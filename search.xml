<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[编程的4门功课]]></title>
    <url>%2Fbook%2F%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91%2F</url>
    <content type="text"><![CDATA[计算机组成原理首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。 操作系统原理综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。 现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！我希望我写过的程序能在任何一台机上运行。我希望我能边听音乐边干活——即同一时间可以运行多个程序。我希望别人写的傻×东西不要影响到我的工作——即多任务控制。我希望计算机里面的各种资源都能得到良好的组织，更快的访问。我希望我的用户界面更好看，使用更方便，功能更强大！我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。 而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。 既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。 至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。 数据结构数据结构的作用, 就是为了提高硬件利用率. 比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。 数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。 计算机网络计算机网络分为3块： 硬件网卡，网线，交换机这些，用来处理数据的。 协议数据在网络中通信如何组织？如何识别？如何保证数据的正确性？这2块我就不多说了。 操作系统这就是如何把计算机网络和操作系统结合起来的问题了。对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。 网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解预处理器]]></title>
    <url>%2Fbook%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译. 预定义符号预处理指令 指令 描述 #include 包含一个源代码 #define 定义宏 #undef 取消已定义的宏 #ifdef 如果宏已经定义,则返回真 #ifndef 如果宏没有定义,则返回真 #if 如果给定条件为真,则编译下面代码 #else #if的替代方案 #elif 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 #endif 结束一个#if…#else 条件编译块 #error 当遇到标准错误时, 输出错误消息 #pragma 使用标准化方法, 向编译器发布特殊的命令道编译器中 typedef c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 . 动态内存分配 当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据. c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需. python对象就是 c语言结构体在堆上申请的一块内存. 在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 c中大量操作字符串的函数 函数 目的 strcpy 复制字符串s2到字符串s1 strcat 连接s2 到字符串s1的末尾 strlen 返回字符串s1的长度 strcmp 如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 strchar 返回一个指针,指向字符串s1中字符ch的第一次出现的位置 strstr 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解restful]]></title>
    <url>%2Fbook%2F%E7%90%86%E8%A7%A3restful%2F</url>
    <content type="text"><![CDATA[Restful API越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件. 这种”互联网软件”采用客户端/服务器模式, 建立在分布式体系上, 通过互联网通信, 具有高延时(high latency) , 高并发等特点. 网站开发, 完全可以采用软件开发的模式, 但是传统上, 软件和网络是两个不同的领域, 很少有交集. 软件开发主要针对单机环境, 网络则主要研究系统之间的通信. RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 resourcesrest的名称”表现层状态转化” 中, 省略了主语, “ 表现层” 其实指的是”资源”(resource) 的”表现层”. 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层(representation)“资源”是一种信息实体, 他可以有多种外在表现形式. 我们把”资源” 具体呈现出来的形式. 叫做它的”表现层”(representation). 比如, 文本可以用txt格式表现, 也可以用html格式, xml格式,JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 注意:资源不能是动词. 在RESTful架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表格名对应.一般来说, 数据库中的表都是同种记录的”集合”, 所以api中的名词也应该使用复数. http方法对于资源的具体操作类型, 由http动词表示. 常用的http动词有下面五个, (括号里对应的sql命令). GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的http动词. HEAD:获取资源的元数据. OPTIONS:获取信息, 关于资源的那些属性是客户端可以改变的. 下面是一些例子: GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息(filtering) 如果记录信息很多, 服务器不可能都将他们返回给用户, API应该提供参数, 过滤返回结果. 下面是一些常见的参数. ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余, 即允许api路径和url参数偶尔有重复.比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 api的身份认证应该使用oauth 2.0框架. 服务器返回的数据格式, 应该尽量使用json, 避免使用xml.]]></content>
      <categories>
        <category>理解restful</category>
      </categories>
      <tags>
        <tag>理解restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统]]></title>
    <url>%2Fbook%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的. 程序结构和执行信息存储大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.一个字节包括8位,在二进制表示法中,0000000011111111 0255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.2进制]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2Fbook%2F%E8%8D%89%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[none 与NUll的区别表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为0,因为0是有意义的,而none是一个特殊的空值判断的时候 均是false属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被调用.如果参数不包含dir(),该方法将最大限度地收集参数信息. 功能性函数返回都为noneNone是一个特殊的常量。None和False不同。None不是0。None不是空字符串。None和任何其他的数据类型比较永远返回False。None有自己的数据类型NoneType。你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。]]></content>
  </entry>
  <entry>
    <title><![CDATA[理解js中的promise]]></title>
    <url>%2Fbook%2F%E7%90%86%E8%A7%A3js%20%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[概念ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示. 简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理. 12345//语法new Promise( /*下面定义的函数是executor*/ function(resolve, reject) &#123;...&#125;); executor是一个带有resolve和reject 两个参数的函数. executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败. 如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略. executor中, resolve或reject只能执行其中一个函数. promise的状态 fulfilled:意味着操作成功完成 pending:初始状态,不是成功或失败状态 rejected: 意味着操作失败. Promise.then(onfilled, onRejected) 参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉. catch(onRejected) 为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象. Promise提供2个方法: Promise.resolve(value)返回 状态为fulfilled的Promise对象 Promise.reject(reason)返回 状态为rejected状态的Promise对象. catch其实是then(undefined, () =&gt; {})的语法糖,如下: 1234let p = Promise.reject('error');p.catch(err =&gt; &#123; console.log('catch' + err);&#125;) Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调. 实例 1234567891011121314151617181920212223242526272829function runAsync()&#123; return new Promise(function(resolve, reject)&#123; setInterval(function()&#123; console.log('do sth ----') resolve('ok----') &#125;, 3000); &#125;);&#125;//调用runAsync().then( value =&gt; &#123; console.log(value); return Promise.reject(value + '*'); &#125;).catch( reason =&gt; &#123; console.log(reason); return Promise.resolve(reason + '*'); &#125;).then( value =&gt; &#123; console.log(value); console.log('Promise end') &#125;)console.log('=========')]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fbook%2F%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊属性 属性 含义 __name__ 类,函数,方法等名字 __module__ 类定义所在的模块名 __class__ 对象或类所属的类 __base__ 类的基类的元组,顺序为他们在基类中出现的顺序 __doc__ 类, 函数的文档字符串, 如果没有定义则为None __mro__ 类的mro, class.mro()返回的结果的保存在__mro__ 中 __dict__ 类或实例的属性, 可写的字典 查看属性__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它. 如果dir()参数obj包括方法_dir__(), 该方法将被调用.如果参数obj不包含\_dir__(), 该方法将最大限度地收集属性信息. dir(obj)对于不同类型的对象obj具有不同的行为: 如果对象是模块对象, 返回的列表包含模块的属性名和变量名 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名 如果是类的实例 有__dir__方法, 返回可迭代对象的返回值 没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名 如果obj不写, 返回列表包含内容不同 在模块中, 返回模块的属性和变量名 在函数中, 返回本地作用域的变量名 在方法中, 返回本地作用域的变量名 123456789# animal.pyclass Animal: x = 123 def __init__(self, name): self._name = name self.__age = 10 self.weight = 20 print('animal Module\ s names = &#123;&#125;'.format(dir()))# 模块的属性 ) 魔术方法*** 分类: 创建, 初始化与销毁 可视化 hash bool 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他杂项 实例化 方法 意义 __new__ 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法 __new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回 可视化 方法 意义 __str__ str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息 __repr__ 内建函数repr()对一个对象获取字符串表达 __bytes__ bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 123456class A: def __init__(self, name, age = 18): self.name = name self.age = age def __repr__(self): return 'repr:&#123;&#125;&#123;&#125;'.format(self.name, self.age) hash 方法 意义 __hash__ 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash __eq__ 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了 bool 方法 意义 __bool__ 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真 上下文管理文件IO操作可以对文件对象使用上下文管理，使用with。。as语法 12with open('test') as f: pass 仿照上例写一个自己的泪，实现上下文管理 1234class Point: passwith Point as p: pass 提示属性错误，没有__exit__，看了需要这个属性 某些版本会显示没有__enter__ 上下文管理对象 当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象 __enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上 __exit__退出与此对象相关的上下文 with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作 注意,with 并不开启一个新的作用域 上下文管理是安全的 上下文应用场景 1.增强功能 在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能 2.资源管理 打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等 3.权限验证 在执行代码之前,做权限验证,在__enter__ contextilb.contextmanager他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法 对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值. 也就是这个装饰器接受一个生成器对象作为参数. 总结 如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便 反射概述 运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候 反射, reflection, 指的是运行时获取类型定义信息 一个对象能够在运行时,像照镜子一样,反射出其类型信息 简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身 具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等 反射相关的函数和方法 getattar 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. setattar object的属性存在,这覆盖, 不存在,新增 hasattat 判断对象是否有这个名字的属性,name必须为字符串 反射相关的魔术方法__getattr__(), __setattr__(), __delattr__(), 三个魔术方法 实例属性会按照继承关系找, 如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出 AttributeError异常表示找不到属性. 查找属性顺序为: instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fbook%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[语言的分类面向机器:抽象成机器指令, 机器容易理解.代表:汇编语言面向过程:做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.问题规模小, 可以步骤化.按部就班处理.代表:c语言面向对象OOP随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.代表:C++, java, python等 面向对象类:class类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.用计算机语言来描述类,是属性和方法的集合.对象:instance, object对象是类的具象, 是一个实体.对于我们每个人这个个体, 都是抽象概念人类不同的实体. 属性:它是对象状态的抽象,用数据结构来描述.操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.哲学:一切皆对象对象是数据和操作的封装.对象是独立的,但是对象之间可以相互作用.目前OOP是最接近人类认知的编程范式. 三要素1.封装组装:将数据和操作组装到一起.隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.2.继承多复用,继承来的就不用了自己写了多继承少修改,OCP,使用继承来改变,来体现个性.3.多态面向对象编程最灵活的地方,动态绑定人类就是封装人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:多态,继承自动物类的人类,猫类的操作’吃’不同. python的类:1.必须使用class关键字2.类名必须使用大驼峰命名3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上. 类对象及类属性类对象,类的定义执行后会生成一个类对象.类的属性,类定义中的变量和类中定义的方法都是类的属性.类变量,self指代当前实例本身. 实例化a = Myclass() # 实例化使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.实例化就真正创建一个该类的对象tom = Person()jerry = Person()每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.python类实例化后, 会调用init方法,这个方法第一个形式参数必须留给self,其他参数随意.init方法 注意:init()方法不能有返回值,也就是只能是return None 实例对象instance类实例化后一定会获得一个类的实例,就是实例对象init方法的第一参数self就是指代某一个实例自身.类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上. 实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法. 总结:是类的,也就是这个类所有实例的,器实例都可以访问到:是实例的,就是这个实例自己的,通过类访问不到.类变量是属于类的变量,这个类的所有实例可以共享这个变量.对象可以动态的给自己增加一个属性.实例属性的查找顺序指的是实例使用,.点号来访问属性.会先找自己的dict,如果没有,然后通过属性class找到自家的类, 再去类的dict中找.注意:如果实例使用dict访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找. 一般来说, 类变量可使用全大写来命名. 类方法和静态方法类方法:1.在类定义中,使用@classmethod装饰器的方法2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改4.通过cls可以直接操作类的属性.静态方法:在类定义中, 使用@staticmethod装饰器的方法2在调用时, 不会隐式的传入参数.静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理. 类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,原因是第一参数必须是类的实例.总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类. 访问控制:私有属性私有属性,使用双下划线开头的属性名就是私有属性. 私有属性的本质:类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了. 保护变量:在变量名前使用一个下划线,称为保护变量这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.私有方法:参照保护变量,私有变量,使用单下划线,双下化线的命名方法, 补丁可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变猴子补丁:在运行时,对属性,方法,函数,等进行动态替换其目的往往是为了通过替换,修改来增强,扩展原有代码的能力 属性装饰器一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性. property装饰器 后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性setter装饰器可以控制是否删除属性,很少用deleter装饰器可以控制是否删除属性,很少用property装饰器必须在前,setter deleter装饰器在后,property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果. 对象的销毁类中可以定义del方法 ,称为析构函数.作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用del方法.由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.封装:将数据和操作组织到类中,即属性和方法.将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python部署]]></title>
    <url>%2Fbook%2F%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Django打包 构建setup.py文件 1234567useradd pythonecho python | passwd python --stdinyum install git python-devel mysql-develyum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-develcurl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 123export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 1234567source .bashrc [global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com python setup.py sdist –formats=gztar ln -sv blog-1.0 web /root/blog/projects/web uwsgi -d –ini blog.ini 后台启动服务, 123456789101112131415161718import &#123; resolve &#125; from &quot;url&quot;;let p = new Promise((resolve, reject) =&gt; &#123; //做一些事情 //然后再某些条件下resolve, 或者reject if(/*条件随便写*/) &#123; resolve() &#125;else&#123; reject() &#125;&#125;)p.then(() =&gt; &#123; //如果p的状态被resolve, 就进入这里&#125;), () =&gt; &#123; //如果p的状态被reject,进入这里&#125; 第一段调用了Promise构造函数, 第二段是调用了promise实例的.then方法 构造实例 构造函数接受一个参数作为参数 调用构造函数得到实例p的同时,作为参数的函数会立即执行. 参数函数接受两个回调函数参数resolve和reject 在参数函数被执行的过程中, 如果在其内部调用resolve, 会被p的状态变为fulfilled, 或者调用reject, 会将p的状态变为rejected. 调用.then 调用.then可以为实例p注册两种状态回调函数 当实例p的状态为fulfilled, 会触发第一个函数执行 当实例p的状态为rejected, 则会触发第二个函数执行. 总结 上面这样构造promise实例, 然后调用.then.then.then的编写代码方式, 就是promise. 其基本模式是: 将异步过程转换成promise对象. 对象有三种状态, 通过.then注册状态的回调. 已完成的状态能触发回调. 采用这种方式来处理编程中的异步任务, 就是在使用promise了. 所以promise就是一种异步编程模式.]]></content>
      <categories>
        <category>项目部署</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2Fbook%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[OSI参考模型 模型 说明 应用层 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. 表示层 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. 会话层 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. 传输层 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). 网络层 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. 链路层 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . 物理层 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. 网络协议 链路层和物理层 描述 ARP(地址解析协议) IP地址——-&gt;MAC地址 RARP MAC地址——&gt;IP地址（逆向的） PPP协议 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 MAC地址 48位全球唯一,网络设备的身份识别 网络层 描述 IP协议 IP:（分为IPV4（168….）和IPV6（16进制用：隔开）） ICMP（Internet控制管理协议） ping命令属于ICMP IGMP（Internet分组管理协议） 广播，组播 传输层 描述 TCP（传输控制协议) 面向连接，可靠,效率低，一对一的可靠数据传输的协议 UDP（用户数据报协议） 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输 SCTP 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 应用层 描述 网页访问协议 HTTP HTTPS(S是安全) 邮件发送接收协议 POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） FTP 文件传输协议 Telnet（明文传输）/SSH（安全） 远程登录 嵌入式 描述 NTP 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） SNMP(开源（SNMP.NET）) 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 RTP/RTSP 用传输音视频传输（监控等） 中继系统中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。 中继系统之集线器光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。 这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。 中继系统之交换机还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：有记忆功能。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？ 交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。 如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。 中继系统之路由器路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。 端口IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。 这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。 socketsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系. arp协议因为ip数据包是在以太网数据包里发送, 所以我们必须同时知道两个地址, 一个是对方的MAC地址, 另一个是对方的IP地址, 通常情况下, 对方的IP地址是已知的, 但是我们不知道它的mac地址.所以, 我们需要一种地址, 能够从ip地址得到mac地址.这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 路由Routing跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络. 路由器上维护着路由表,他知道如何将数据包发往另外的网络. windows使用route print, liunx使用route -n可以查看路由表. 路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置. 静态路由:有管理员手动配置的固定的路由信息 动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与json]]></title>
    <url>%2Fbook%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson%2F</url>
    <content type="text"><![CDATA[序列化与反序列化内存中的字典,列表,集合以及各种对象,如何保存到一个文件中. 如果是自己定义的类的实例, 如何保存到一个文件中. 如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例. 要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化. 定义serialization 序列化 将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制 deserialization 反序列化 将文件的一个个字节恢复成内存中对象 &lt;-二进制 序列化保存到文件就是持久化. 可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化. jsonJSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。 json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。 1、JSON语法规则JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。 （1）简单值 简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。 12345678910111213// 简单值"Hello World!" // 字符串99 // 数值true // 布尔型false // 布尔型null// 在JSON中不能使用的值NaN // 数值不能是NaNInfinity // 数值不能是Infinityundefined // 在JSON也不可以使用JavaScript中的undefined'Hello World!' // 字符串必须使用双引号表示，不能使用单引号0x1 // 数值必须以十进制表示，不能使用十六进制 （2）对象 对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。 123456789101112// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号&#123; "name": "Andy", "age": 18, "isStudent": true, "isLeader": false, "mark": null, "school": &#123; "name": "BIT", "region": "Beijing" // 这个地方不能有逗号，因为是对象的最后一个属性成员 &#125; // 这个地方也不可以有逗号，因为也是对象的最后一个属性成员&#125; （3）数组 数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。 12345678910111213141516// 示例一["Andy", "Ruby", "Danny", "Peter", "Lisa"]// 示例二[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]// 示例三[ &#123;"name": "Andy", "age": 18&#125;, &#123;"name": "Ruby", "age": 18&#125;, &#123;"name": "Danny", "age": 20&#125;]// 示例四[ [0, 1, 2], [3, 4, 5], [6, 7, 8]] 2、JSON字符串和JSON对象（1）JSON字符串 JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。 1234//JSON字符串var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string （2）JSON对象 JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。 12345678// JSON对象var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object （3）JSON字符串和JSON对象互相转换 JavaScript中有一个全局的对象，JSON。JSON中有两个方法 stringify() 和 parse()。 JSON.parse() 把JSON字符串解析为JSON对象 12345//JSON字符串通过parse转化为JSON对象var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';person = JSON.parse(p)console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object JSON.stringify() 用于把JSON对象序列化为JSON字符串。 123456789//JSON对象通过stringify转化为JSON字符串var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;var p = JSON.stringify(person)console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fbook%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式简绍概述:正则表达式正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.正则表达式 Regular Expression,缩写regex, regexp ,RE等.分类1.BRE基本正则表达式,grep,sed,vi等软件支持.vim有扩展.2.ERE扩展正则表达式,egrep, sed -r等.3.PCRE几乎所有高级语言都是PCRE的方言或者变种. 基本语法元字符 metacharacter转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.反斜杠自身,得使用\ \r \n还是转义后代表回车,换行 贪婪与非贪婪默认是贪婪模式,也就是说尽量多匹配更长的字符串,非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了. 单行模式:. 可以匹配所有的字符, 包括换行符.^ 表示整个字符串的开头, &amp;整个字符串的结尾多行模式:. 可以匹配除了换行符之外的字符,多行不影响.点号^ 表示行首, &amp;行尾, 只不过这里的行是每一行 默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n re模块re.M多行模式re.S单行模式re.I忽略大小写re.X忽略表达式中的空白字符使用 | 位或运算开启多种选项方法编译re.compile(pattern, flag=0)设定flags, 编译模式,返回正则表达式对象regexpattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.单次匹配re.match(pattern, string, flags=0)match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象. 全局搜索对整个字符串, 从左至右匹配,返回匹配项的列表.匹配替换使用pattern对字符串string进行匹配,对匹配使用repl替换.replacement可以是string, bytes, function. 分割字符串字符串的分割函数split,太难用, 不能指定多个字符进行分割.分组使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.2.如果使用了命名分组,可以使用group的方式取分组3.也可以使用group返回所有组.4.使用groupdict()返回命名的分组.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python小技巧]]></title>
    <url>%2Fbook%2Fpython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[为多个变量赋值有时，有多个变量需要赋值，这时你会怎么赋值呢？常规方法：常规方法是给变量逐个赋值。123a = 0 b = 1 c = 2 优雅方法：直接按顺序对应一一赋值.a, b, c = 0, 1, 2 序列解包需要取出列表中的元素。常规方法：一般我们知道可以通过下标获取具体元素。1234567info = ['brucepk', 'man', 'python']name = info[0]sex = info[1]tech = info[2]print(name,sex,tech)结果:brucepk man python 优雅方法：给出对应变量接收所有元素。12345info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]name,sex,tech = infoprint(name,sex,tech)结果:brucepk man python 优雅你的判断语句我们用判断语句来定义一个绝对值函数。常规方法：1234567891011121314x = -6if x &lt; 0: y = -xelse: y = xprint(y)结果:6优雅方法：x = -6y = -x if x&lt;0 else xprint(y)结果6 区间判断使用 and 连续两次判断的语句，条件都符合时才执行语句。常规方法：123456score = 82if score &gt;=80 and score &lt; 90: level = 'B'print(level)结果B 优雅方法：使用链式判断。123456score = 82if 80 &lt;= score &lt; 90: level = &apos;B&apos;print(level)结果B 多个值符合条件判断多个值任意一个值符合条件即为 True 的情况。常规方法：123456num = 1if num == 1 or num == 3 or num == 5: type = &apos;奇数&apos;print(type)结果奇数 优雅方法：使用关键字 in，让你的语句更优雅。123456num = 1if num in(1,3,5): type = &apos;奇数&apos;print(type)结果奇数 判断是否为空判断元素是空还是非空。常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;if len(A) &gt; 0: print(&apos;A 为非空&apos;)if len(B) &gt; 0: print(&apos;B 为非空&apos;)if len(C) &gt; 0: print(&apos;C 为非空&apos;)结果A 为非空 优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。 123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos; if A: print(&apos;A 为非空&apos;) if B: print(&apos;B 为非空&apos;) if C: print(&apos;C 为非空&apos;) 结果A 为非空 多条件内容判断至少一个成立常规方法：用 or 连接多个条件。12345math,English,computer =90,80,88if math&lt;60 or English&lt;60 or computer&lt;60: print(&apos;not pass&apos;)结果not pass 优雅方法：使用 any 语句。12345math,English,computer =90,59,88if any([math&lt;60,English&lt;60,computer&lt;60]): print(&apos;not pass&apos;)结果not pass 多条件内容判断全部成立常规方法：使用 and 连接条件做判断。12345math,English,computer =90,80,88if math&gt;60 and English&gt;60 and computer&gt;60: print(&apos;pass&apos;)结果pass 优雅方法：使用 all 方法。12345math,English,computer =90,80,88if all([math&gt;60,English&gt;60,computer&gt;60]): print(&apos;pass&apos;)结果pass 遍历序列的元素和元素下标常规方法：使用 for 循环进行遍历元素和下标。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for i in range(len(L)): print(i, &apos;:&apos;, L[i])结果0 : math1 : English2 : computer3 : Physics 优雅方法：使用 enumerate 函数。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for k,v in enumerate(L): print(k, &apos;:&apos;, v)结果0 : math1 : English2 : computer3 : Physics 循环语句优化之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。常规方法：使用简单的 for 循环可以达到目的。123456L = []for i in range(1, 6): L.append(i*i)print(L) 结果：[1, 4, 9, 16, 25] 优雅方法：使用列表生成式，一行代码搞定。123print([x*x for x in range(1, 6)]) 结果：[1, 4, 9, 16, 25] 将list中的所有元素转为单个字符串12a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]print(&quot; &quot;,join(a)) 字符串倒转方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。方法二：用Python自带reversed()函数，它可被用于list倒转。方法三：第三种是通过倒转数据类型和切片倒转整数. 链式调用在python 中实现链式调用只需在函数返回对象自己就行123456def product(a, b): return a * bdef add(a, b): return a + bb = Trueprint((product if b else add)(5, 7)) 复制list在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：方法一：b=a[:]。方法二：b=list(a)。方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。方法四：使用copy.deepcopy()。 按value排序字典Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：方法一：用sorted函数排序，其中key参数是lamda表达式。方法二：用operator.itemgetter而不是lamda表达式进行排序。方法三：如果只需得到排序后的key，可用.get。 for … else语法合并字典方法一：Python 3.5可以存在重复键值，print({d1 ,d2})。方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。方法三：d1.update()。 从list中删除重复项方法一：把list转成set，去除重复项，再转回list。方法二：调用collections里的OrderedDict，和set差不多。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fbook%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本概念数学定义y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)python函数:是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元完成一定的功能函数的作用结构化编程对代码的最基本的封装, 一般按照功能组织一段代码封装的目的为了复用,减少冗余代码代码更加简洁美观,可读易懂 函数的分类:内建函数,如max()库函数,如math.ceil自定义函数,使用def关键字定义 函数定义def 函数名(参数列表): 函数体(代码块) [return 返回值]函数名就是标识符,命名要求一样语句块必须缩进,约定4个空格函数名就是标识符就是变量python的函数没有return,会返回none定义中的参数列表称为形式参数,只是一种标识符占位置的函数的标识符就是指向函数对象函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参不定义会报nameERREO 传参方式: 位置传参按照参数定义顺序传入实参 关键字使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的参数缺省值缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用 可变位置参数在形参使用* 表示该形参是可变位置参数, 可以接受多个实参它将收集来的实参组织到一个tuple中tuple 有序按位置传参可变关键字参数在形参使用表示该形参是可变关键字参数,可以接受多个关键字参数它将收集来的实参的名称和值,组织到一个dict中可变的关键字传参 kwargs 有可变位置参数和可变关键字参数可变位置参数在形参前使用一个*号可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple可变关键字参数收集形成一个dict混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面要在可变关键字参数之前. keyword-only 参数def fn(args, x, y, **kwargs): print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)fn(3, 5)fn(3, ,5, 7)在python3之后,新增了keyword-only参数keyword-only参数:在形参定义时,在一个星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数keyword-only参数,言下之意就是这个参数必须采取关键字传参可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.星号后所有的普通参数都成了keyword-only参数参数的混合使用参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数代码应该易读易懂, 而不是为难别人请按照书写习惯定义函数参数.参数解构:在给函数提供实参的时候,可以在可迭代对象前使用或者来进行的解构,提取出其中所有元素作为函数的实参.使用*解构成位置参数使用解构成位置 传参提取出来的元素数目要和参数的要求匹配 python函数使用return语句返回”返回值”所有函数都有返回值,如果没有return语句, 隐式调用return Nonereturn语句并不一定是函数的语句块的最后一条语句一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None如果有必要,可以显示调用return None ,可以简写return如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行返回值的作用: 结束函数调用,返回返回值函数不能同时返回多个值. 作用域一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域注意:每一个函数都会开辟一个作用域分类:全局作用域:在整个程序运行环境中都可见全局作用域中的变量称为全局变量局部作用域:在函数 ,类等内部可见局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域函数嵌套在一个函数中定义了另一个函数内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见 global语句使用global关键字的变量,将声明为外部的全局作用域中定义的使用了global 不再是局部变量,它是全局变量global使用原则外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决一句话:不要global,学习他就是深入理解变量作用域 闭包自由变量:未在本地作用域中定义的变量闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript nonlocal语句将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义代码中内层函数引到外部局部作用域中的自由变量,形成闭包 函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期查看default属性,他是个元组 变量名解析原则LEGB***local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡所以一个名词的查找顺序就是LEGB. |]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识框架]]></title>
    <url>%2Fbook%2Fpython%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[python基础python是一种动态的强类型语言,底层是用C语言开发的. 平台：*nix平台系统：线程、进程、Shell编程网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个中间件：消息队列原理和应用，例如8曲bitMQWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一可视化：WEB的前端开发多一些HTML、jS要会数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用 python学习路线:基础：操作系统、网络基础、数据库基础、python语言基础..进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).新前端开发(ES6、React、Antd）…实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..高端：数据清洗、企业数据分析、预测准荐、机器视觉． 数据类型python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none 字符串因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节. 字符串的格式化format函数或 格式符 编码字符串与bytes字符串是字符组成的有序序列，字符可以使用编码来理解bytes是字节组成的有序的不可变序列bytearray是字节组成的有序的可变序列 编码与解码：字符串按照不同的字符集编码encode返回字节序列bytesencode（encoding=‘utf-8’，errors=‘strict’）字节序列按照不同的字符集解码decode返回字符串bytes.decode（encoding=“utf-8”，errors=“strict”）ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统 要熟记31 41 61 的ascii表 字节序：大端模式，big-endian；小端模式，little-endianintel x86cpu使用小端 模式网络传输更多使用大端模式windows，linux 使用小端模式mac os使用大端模式java 虚拟机是大端模式 数字有整数 浮点数 复数等 true false主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。 None：Python里面特殊的空值，不能理解为0。 容器list（列表） tuple（元组） set（集合） dictionary（字典）这些都是可以迭代的 list创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。 tuple元组和列表类似，但是不同的是元组不能修改，元组使用小括号。 dict判断结构ifif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。 elif 语句 elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。 if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。 forfor循环可以遍历任何序列的项目： whilewhile循环，只要条件满足，就不断循环，条件不满足时退出循环： break和continue语句： break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。 continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2Fbook%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[练习 有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。思路排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。查找插入点，使用二分查找完成。假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。直到中点就是 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) - 1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]newlst = sorted(lst) # 升序 print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41): newlst = insert_sort(newlst, x) print(newlst) 看似上面代码不错，请测试插入100。问题来了，100插入的位置不对，为什么？ 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) # 去掉减1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret # 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51] newlst = sorted(lst) # 升序print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41, 100): newlst = insert_sort(newlst, x) print(newlst) high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。 二分二分前提是有序，否则不可以二分。二分查找算法的时间复杂度O(log n) bisect模块bisect模块提供的函数有： bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。 bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。 bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。函数可以分2类： bisect系，用于查找index。Insort系，用于实际插入。默认重复时从右边插入。 应用判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’ 12345678910import bisect def get_grade(score): breakpoints = [60, 70, 80, 90] grades = 'EDCBA' return grades[bisect.bisect(breakpoints, score)] for x in (91, 82, 77, 65, 50, 60, 70, 80, 90): print('&#123;&#125; =&gt; &#123;&#125;'.format(x, get_grade(x)))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web路由]]></title>
    <url>%2Fbook%2Fweb%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[web开发中路由route和路由器router到底是什么 1. 什么是路由在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。 2. router和route的区别route就是一条路由，它将一个URL路径和一个函数进行映射，例如： /users -&gt; getAllUsers() /users/count -&gt; getUsersCount() 这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。 而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route”。 3. 服务器端路由对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。 以Express为例， 12345678app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.sendFile(&apos;index&apos;)&#125;)app.get(&apos;/users&apos;, (req, res) =&gt; &#123; db.queryAllUsers() .then(data =&gt; res.send(data))&#125;) 这里定义了两条路由： 当访问/的时候，会返回index页面 当访问/users的时候，会从数据库中取出所有用户数据并返回 不仅仅是URL 在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。 4. 客户端路由对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案： 基于Hash 基于History API (1) 基于Hash我们知道，URL中#及其后面的部分为hash。例如： 1234const url = require(&apos;url&apos;)var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)console.log(a.hash)// =&gt; #/foo/bar hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。 通过监听window对象的hashChange事件，可以实现简单的路由。例如： 123456789101112131415window.onhashchange = function() &#123; var hash = window.location.hash var path = hash.substring(1) switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; (2) 基于History API通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考： Manipulating the browser historyUsing the HTML5 History API我们可以通过监听window对象的popstate事件，来实现简单的路由： 1234567891011121314window.onpopstate = function() &#123; var path = window.location.pathname switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; 但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如： 1234567var pushState = history.pushStatehistory.pushState = function() &#123; pushState.apply(history, arguments) // emit a event or just run a callback emitEventOrRunCallback()&#125; 不过，最好的方法还是使用实现好的history库。 (3) 两种实现的比较总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。 但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。 假设服务器只有如下文件（script.js被index.html所引用）： 123/- |- index.html |- script.js 基于Hash的路径有： 12http://example.com/http://example.com/#/foobar 基于History API的路径有： 12http://example.com/http://example.com/foobar 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。 当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 5. 动态路由上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。 例如在Express中： 12345678app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123; // ... ...&#125;)在Flask中：@app.route(&apos;/user/&lt;user_id&gt;&apos;)def get_user_info(user_id): pass 6. 严格路由在很多情况下，会遇到/foobar和/foobar/的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。 在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到/foobar/，而反过来则不会。 如果使用的是Express，默认这两者是一样的，也可以通过app.set来设置strict routing，来区别对待这两种情况。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题]]></title>
    <url>%2Fbook%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[重点知识 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理异常]]></title>
    <url>%2Fbook%2F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常处理(Exception)错误Error逻辑错误:算法写错了, 例如加法写成了减法 笔误:例如变量名写错了,语法错误 函数或类使用错误, 其实这也属于逻辑错误 总之,错误是可以避免的 异常Eception本意就是意外情况 这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去. 例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况. 错误和异常在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获. 123with open('tetsabcd') as f: pass# 异常 产生异常产生: raise语句显示的抛出异常 Python解释器自己检测异常并引发它程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行) 异常的捕获1234try: 待捕获异常的代码块except [异常类型] 异常的处理代码块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fbook%2F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[魔术方法 类别 方法名 可视化 __str__, __repr__, __format__, __bytes__ 数值转换 __abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__ 容器模拟 __len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__ 迭代枚举 __iter__, __reversed__, __next__ 可调用模拟 __call__ 上下文管理 __enter__, __exit__ 实例创建和销毁 __new__, __init__, __del__ 属性管理(反射) __dir__, __getattr__, __setattr__, __delattr__, __getattribute__ 属性描述符(描述器) __get__, __set__, __delete__ 特殊属性 __name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__ 比较运算符 __eq__,__lt__, __le__, __gt__, __ge__, __ne__ 算数运算符 __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 增量运算符 __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__ 反向运算符 __radd__, __rsub__ 其他 __slots__ 内置函数 内置函数名 方法名 数学运算 abs, divmod,max,min,pow, round, sum 类型转换 bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex 序列操作 all, any, filter, map,next,reversed, sorted, zip 对象操作 help,dir,id,hash, type,len, ascii,format, vars, 反射操作 __import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable 变量操作 globals, locals, 交互操作 print,input 文件操作 open 编译执行 compile, eval,exec, repr 装饰器 property,classmethod, staticmethod, 数据结构 tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object 标识符: 1234567False await else import passNone break except in raiseTrue class finally is returnand continue for lambda tryas def from nonlocal whileassert del global not withasync elif if or yield 模块常用方法 内置模块 方法名 re compile, search, match, fullmatch,split,findall, sub, string ascii_letters,ascii_lowercase.digits datetime datetime collections nametuple, deque, OrderdDict, defaultdict, bisect bisect_left,bisect_right, math ceil random randint, choice, randrange,shuffle, sample functools reduce, partial,lru_cache pathlib os shutil copyfileobj, copyfile, copymode, copystat,copy,copy2,copytree,rmtree,move, pickle csv reader time threading queue json base64 sys inspect signature(callable)获取签名, ConfigParser argparse heapq hea]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件io]]></title>
    <url>%2Fbook%2Fpython%E6%96%87%E4%BB%B6io%2F</url>
    <content type="text"><![CDATA[文件io常用操作一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络ioopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取seek: 文件指针操作 tell: 指针位置 打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.文件操作中,最常用的操作就是读和写.文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件a: 写入打开,如果文件存在,则追加b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力. open默认是只读模式r打开已经存在的文件. 文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOFbuffering:缓冲区0:只在二进制模式打开,表示关buffer1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush大于1:用于指定buffer的大小. 上下文管理1.异常处理当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.使用finally可以保证打开的文件可以被关闭.2.上下文管理一种特殊的语法, 交给解释器去释放文件对象.使用with … as关键字上下文管理的语句并不会开启新的作用域with语句执行的时候,自动关闭文件对象.1234f1 = open(&apos;text&apos;)with f1: f1.write(&apos;abc&apos;)f1.closed 对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题. StringIO和BytesIOStringIOio模块中的类from io import StringIO内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.当close方法被调用的时候,这个buffer被释放. 好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率. BytesIOio模块中的类from io import BytesIO内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.当close方法被调用的时候, 这个buffer会释放. file-like对象类文件对象,可以像文件一样操作socket对象,输入输出对象都是类文件对象. 路径操作from os import path3.4版本开始建议使用pathlib模块,提供path对象来操作.包括目录和文件Pathlib模块 目录操作初始化路径拼接和分解操作符分解joinpath 通配符glob通配给定的模式rglob通配给定的模式,递归目录都返回一个生成器?代表一个字符*表示任意个字符[abc]或[a-z]表示一个字符 匹配match(pattern)模式匹配,成功返回True 文件操作os模块os.name windows是nt, linux是posixos.uname() *nix支持sys.platform windows显示win32, linux 显示linuxos.listdir返回指定目录内容列表, 不递归os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似. shutil模块文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.python提供了一个方便的shutil(高级文件操作)copy复制copyfileobj(fsrc, fdst[, length]) 文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.12345import shutilwith open (&apos;text&apos;, &apos;r+&apos;) as f: f.write(&apos;abcd&apos;) with open(&apos;text1&apos;, &apos;w+&apos;) as f1: shutil.copyfileobj(f, f1) 复制文件内容,不含元数据,src,dst为文件的路径字符串. rm删除shutil.rmtree(path, ignore_errors=False, oneerror=None)递归删除,如同rm -rf一样危险,慎用.他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.shutil.retree(“text”) 类似rm -rf move移动递归移动文件,目标到目标,返回目标本身使用的是os.rename方法如果不支持rename,如果是目录则copytree再删除源目录.shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz csv文件csv是一个被行分隔符,列分割符划分成行和列的文本文件.csv不指定字符编码.行分割符为\r\n,最后一行可以没有换行符.列分割符常用逗号或者制表符.每一行称为一条记录record.字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.csv模块返回reader对象,是一个行迭代器默认使用excel方言.delimiter列分割符,逗号.lineterminator行分割符\r\n ini文件处理作为配置文件,ini文件格式的很流行. 中括号里面的部分称为section,译作节,区, 段每一个section内, 都是key=value形成的键值对,key称为option选项.注意这里的DEFAULT是缺省section的名字,必须大写.configparserconfigparser模块的configparser类就是用来操作.可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典. 序列化和反序列化为什么要序列化内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.serialization序列化将内存中对象存储下来,把他变为一个个字节.deserialization反序列化将文件的一个个字节恢复成内存中的对象序列化保存到文件就是持久化可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化python提供了pickle库 dumps 对象序列化为bytes对象dump 对象序列化到文件对象,就是存入文件loads 从bytes对象反序列化load 对象反序列化,从文件读取数据 序列化应用一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型jsonjson的数据类型 messagepackmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.他可以像json那样,在许多语言之间交换结构对象.但是他比json更快速也跟轻巧.支持python.ruby,java等众多语言,兼容json 和pickle 安装pip install msgpack 常用方法序列化对象,提供dumps来兼容pickle和jsonunpackb反序列化对象.提供了loads来兼容.pack序列化对象保存到文件对象,提供了dump来兼容.unpack反序列化对象保存到文件对象,提供了load来兼容.messagepack简单易用,高效压缩,支持语言丰富.所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据结构]]></title>
    <url>%2Fbook%2Fpython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要. 常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合. 数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型. 抽象数据类型抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.抽象的意义在于数据类型的数学抽象特性. 内存单元和地址计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,在计算机内存里表示数据元素之间的联系,只有两种技术:利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构. 数据结构是相互之间存在一种或多种特定关系的数据元素的集合.逻辑上分:集合结构, 线性结构, 树形结构, 图形结构物理结构:顺序存储结构, 链式存储结构. 算法算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.函数渐进式增长.判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.用O()来体现时间复杂度的记法, 我们称为大O记法.O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶. 线性表从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来. 线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素.插入删除的时间复杂度为O(n).它比较适合元素个数不太变化,而更多存取数据的应用.优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间. 可以快速地存取表中任意位置的元素.缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量造成存储空间的”碎片”. 线性表链式存储结构线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点. 头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.头指针具有标识作用,所以常用头指针冠以链表的名字.无论链表是否为空,头指针均不为空,头指针是链表的必要元素.由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显. 若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构. 静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法 将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针. 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表.对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表. 在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,栈是限定仅在表尾进行插入和删除操作的线性表.我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶. 栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.栈的删除操作,也叫出栈,或弹栈栈.特别是插入和删除操作,我们改名为push 和pop.两栈共享空间 栈的链式存储结构简称链栈顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些. 对列对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出. 串串是有零个或多个字符组成的有限序列,又名字符串.串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.串的顺序存储结构串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.在计算机中存在一个自由存储区,叫做堆. 模式匹配算法子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.一个字符的ASCII码可以看成是8位的二进制01串. 本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.所谓的回文就是一个字符串的逆转显示reverse的操作. 树树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树. 所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.树的定义其实就是我们在讲解栈提到的递归的方法.树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值. 结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.树中结点的最大层次称为树的深度或高度. 树的存储结构 树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.双亲表示法:我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行. 二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成. 二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,左子树和右子树是有顺序的,次序不能任意颠倒, 顺序存储结构一般只用于完全二叉树.二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.这里有两个关键词:访问和次序二叉树本质上,是对链表和数组的一个折中.每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据. 压缩编码方法:赫夫曼编码 图图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.图是由顶点的有穷非空集合和顶点之间边的集合组成.图不能用简单的顺序结构来表示,而是多重链表. 搜索引擎的工作原理:它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录. 查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素. python 对象特性python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值: 身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.值:对象表示的数据. python基本数据类型python的数据类型:number(数字), string(字符串), bool(布尔), None(空值) python 内建数据结构线性结构字符串在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变. 列表元组bytes非线性结构集合set字典dict]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python特殊函数]]></title>
    <url>%2Fbook%2Fpython%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[匿名函数匿名函数 :隐藏名字,即没有名称匿名函数: 没有名字的函数lambda表达式python中,使用lambda表达式构建匿名函数使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式参数列表不需要小括号,无参就不写参数冒号用来分割参数和表达式部分不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.lambda表达式匿名函数只能写在一行上,也称为单行函数. 匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码. 递归函数函数执行流程:压栈 递归函数recursion函数直接或者间接调用自身就是递归.递归需要有边界条件,递归前进段,递归返回段.递归一定要有边界条件.当边界条件不满足的时候,递归前进当边界条件满足的时候,递归返回. 递归例子:斐波那契数列如果用循环写法:1234567a = 0b = 1n = 10for i in range(n -1): a,b=b, a+belse: print(b) 递归写法:def fib(n): return 1 if n &lt;3 else fib(n-1) +fib(n-2) 递归要求递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.递归调用的深度不宜python 对递归调用的深度做了限制,以保护解释器超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度sys.getrecursionlimit() 循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了. 递归是一种很自然的表达,符合逻辑思维递归相对效率低,每一次调用都要开辟栈帧.递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.绝大多数递归,都可以使用循环实现即使递归代码很简洁,但是能不用则不用递归. 生成器生成器generator生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.生成器对象,是一个可迭代对象,是有个迭代器.生成器对象,是延时计算,惰性求值的. 函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.普通函数调用,函数会立即执行直到执行完毕.生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑. 在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回再执行会执行到下一个yield语句又会暂停执行return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration生成器函数包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.再次调用next函数,和上一条一样的处理过程.继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常. 协程生成器的高级用法他比进程,线程轻量级,是在用户空间调度函数的一种实现.协程调度器实现思路协程是一种非抢占式调度. yield from 语法yield from就是一种简化语法的语法糖. yield 和return的区别带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return 如何生成斐波那契数列:斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数. 12345678def fab(max): a, b = 1, 1 n = 1 while n &lt; max: print(b) a, b = b, a+b n +=1fab(20) 结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.123456789def fab(max): n, a, b = 0, 0, 1 l = [] while n &lt; max: l.append(b) b = b+a a = b-a n = n+1 return l 改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要用list来保存中间结果, 而是通过iterable对象来迭代. 1234567891011121314151617class Fab(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.b = self.a + self.b self.a = self.b - self.a self.n = self.n + 1 return r raise StopIteration() 然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b b = b+a a = b-a n = n + 1 第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果调用第四版的fab和第二版的fab完全一致: 简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法这样我们就可以清楚看到fab的执行流程. 高阶函数函数也是对象, 是可调用对象函数可以作为普通变量,也可以作为函数的参数, 返回值. 在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数接受一个或多个函数作为参数输出一个函数 排序sorted排序函数,可以接受key作为参数进行排序,不改变序列的原有值.排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素. 过滤filter对可迭代对象进行遍历,返回一个迭代器function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值function参数如果是None, 可迭代对象的每一个元素自身等效布尔值. 映射map对多个可迭代对象的元素,按照指定的函数进行映射返回一个迭代器 柯里化指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述器]]></title>
    <url>%2Fbook%2F%E6%8F%8F%E8%BF%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[描述器 Descriptors描述器的表现 用到3个魔术方法: __get__() 、 __set__() 、 __delete__() 方法签名如下 object.__get__(self, instance, owner) object.__set__(self, instance, value) object.__delete__(self, instance) self 指代当前实例，调用者 instance 是owner的实例 owner 是属性的所属的类 请思考下面程序的执行流程是什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041class A: def __init__(self): self.a1 = 'a1' print('A.init')class B: x = A() def __init__(self): print('B.init')print('-'*20)print(B.x.a1)print('='*20)b = B()print(b.x.a1)# 运行结果A.init--------------------a1====================B.inita1 可以看出执行的先后顺序吧？ 类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。 然后实例化并初始化B的实例b。 打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。 描述器定义Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。 仅实现了 __get__ ，就是非数据描述符 non-data descriptor 实现了 __get__ 、 __set__ 就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。 属性的访问顺序为上例中的类B增加实例属性x 12345678910111213141516171819202122232425262728293031323334353637class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return selfclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x)print(b.x.a1) # AttributeError: 'str' object has no attribute 'a1' 类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。 继续修改代码，为类A增加 __set__ 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return self def __set__(self, instance, value): print('A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'.format(self, instance, value)) self.data = valueclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x) # 返回什么print(b.x.a1) # 返回什么print(b.x.data) # 返回什么？ 所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。 属性查找顺序实例的 __dict__ 优先于 非数据描述器 数据描述器 优先于 实例的 __dict__ __delete__ 方法有同样的效果，有了这个方法，也是数据描述器。 尝试着增加下面的2行代码，看看字典的变化 b.x = 500 B.x = 600 b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。 B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。 ### Python中的描述器 描述器在Python中应用非常广泛。 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 12345678910111213141516171819202122232425262728293031323334353637class A: @classmethod def foo(cls): # 非数据描述器 pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300a = A()print(a.__dict__)print(A.__dict__) foo、bar都可以在实例中覆盖，但是z不可以。 新增方法 3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。 12345678910111213141516171819202122class A: def init(self): print('A init') def get(self, instance, owner): print(1, self, instance, owner) return self def set_name(self, owner, name): print(2, self, owner, name) self.name = nameclass B:x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)print(B().x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识框架]]></title>
    <url>%2Fbook%2Flinux%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍操作系统os(operating system),通用目的的软件程序 硬件驱动进程管理内存管理网络管理安全管理文件管理 安装linux linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的manjaro或mint分区和启动:硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tbuefi的GPT分区:逐渐代替MBR标准主分区 一块硬盘最多4个,不能划分更小,最小单位扩展分区:一块硬盘最多一个,不能直接创建文件系统安装过程大同小异 详细步骤需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌./dev/sda 100g/dev/sda1 /boot mountpoint 1g/dev/sda2 / 50g/dev/sda3 /data 20g/dev/sda5 /swap 2g 开发接口标准 ABI:application binary interface ABI描述了程序与os之间的底层接口API:application programming interface开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit 用户和内核空间 username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响内核空间:kernel space linux哲学思想在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的 文件操作文件和目录被组织成单根倒置树结构文件系统从根目录下开始,用”/“表示proc虚拟的,在硬盘上不存在文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)以.开头的文件为隐藏文件元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.数据:data(内容在硬盘上)文件系统分成结构:LSB文件名最长255个字节,文件系统不一样大小不一样包括路径在内文件名称最长4095个字节蓝色—目录 绿色—可执行文件 红色—压缩文件浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递管道文件 p开头(pipe)单工传输 文件系统结构元素/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64：专用于x86_64系统上的辅助共享库文件存放位置/etc：配置文件目录/home/USERNAME：普通用户家目录/root：管理员的家目录/media：便携式移动设备挂载点/mnt：临时文件系统挂载点/dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问/opt：第三方应用程序的安装位置/srv：系统上运行的服务用到的数据/tmp：临时文件存储位置/proc: 用于输出内核与进程信息相关的虚拟文件系统/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文/usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序sbin: lib：32位使用 lib64：只存在64位系统include: C程序的头文件(header files)share：结构化独立的数据，例如doc, man等local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文 /var: variable data files cache: 应用程序缓存数据目录lib: 应用程序状态信息数据local：专用于为/usr/local下的应用程序存储可变数据lock: 锁文件 log: 日志目录及文件opt: 专用于为/opt下的应用程序存储可变数据run: 运行中的进程相关数据,通常用于存储进程pid文件spool: 应用程序数据池tmp: 保存系统两次重启之间产生的临时数据 Linux下的文件类型-：普通文件d: 目录文件b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)c: 字符设备(设备主要以字符为单位,键盘为主)l: 符号链接文件p: 管道文件pipes: 套接字文件socket 显示当前工作目录每个shell和系统进程都有一个当前的工作目录CWD:current work directory显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 更改目录cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -选项：-P相关的环境变量： PWD：当前目录路径 OLDPWD：上一次目录路径 列出目录内容列出当前目录的内容或指定目录用法：ls [options] [ files_or_dirs ]示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R 目录递归通过 ls -ld 目录和符号链接信息 ls -1 文件分行显示 ls –S 按从大到小排序 ls –t 按mtime排序 ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示 ls –X 按文件后缀排序 [root@centos7 sysconfig]# ll /etc/motd-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd[root@centos7 sysconfig]# ll ../motd-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd-a 全部-r 递归ll 是别名 (ls -l) 查看文件状态stat文件：metadata, data三个时间戳: access time：访问时间，atime，读取文件内容modify time: 修改时间,mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变data 时间不会一直更新通配符* 任意字符二进制查看hexdump -C 创建和查看文件touch 命令是个外部命令[]表示其中一个字母[^ ]表示除去其中字符的任意字符两个大于号比 touch安全 文件统配符man 7 glob 复制和转移删除文件cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失原始命令前加\拷贝文件夹 -r(递归)cp 有可能丢失数据不能用rmdir删除 data是个挂载点cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中 基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中cp SRC… DEST SRC…：多个文件DEST必须存在，且为目录，其它情形均会出错；cp SRC DESTSRC是目录：此时使用选项：-r如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；如果DEST存在：如果DEST是文件：报错如果DEST是目录：inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 inode 唯一标识在元数据里删除其实删的元数据.删文件比建文件快多了 软和硬链接硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区语法: ln filename [linkname ]软连接一个符号文件链接指向一个文件ls -s显示链接的名称和应用的文件一个符号链接的内容是他引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数语法:ln -s 文件 链接名 i/0 重定向至文件程序:指令+数据input 和output打开的文件都有一个fd:file descrptor(文件描述符)linux 给程序提供三种i/o设备标准输入(STDIN)-0 默认接受来自键盘的输入标准输出(STDOUT) -1默认输出到终端窗口标准错误(STDERR) -2 默认输出到窗口i/o重定向:改变默认位置语法:命令 操作符号 文件名操作符&gt;把STDOUT重定向到文件2&gt; 把STDERR重定向到文件$&gt; 把所有输出重定向到文件tr 转换和删除字符 管道管道用来连接命令命令1|命令2|命令3将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDINless 一页一页地查看输入重定向到多个目标(tee)把命令1的STDOUT保存在文件中,作为命令2的输入-a追加使用:保存不同阶段的输入复杂管道的故障排除同时查看和记录输出 用户组权限用户user令牌token,identitylinux用户:username/UID管理员:root,0普通用户:1-65535系统用户:1-499,1-999对守护进程获取资源进行权限进行分配登录用户:500+,1000交互式登录nologin 是软件启动没有用户登录 组grouplinux:Groupname/GID管理员:系统 :1-499,1-999普通组:500+,1000+安全上下文:进行中的程序:程序(process)以进程发起者的身份运行:root:/bin/catmage:/bin/cat组的类别用户的主要组:用户必须属于一个且只有一个主组组名同用户名,且包含一个用户,私有组用户和组的配置文件/etc/passwd:用户及其属性信息/etc/group:组及其属性信息/etc/shadow:用户密码及其相关属性/etc/gshadow:组密码及其相关属性passwd文件格式login name:登录用名passwd:密码UID:用户身份编号GID:登录默认所在组编号GECOS:用户全名或注释home diretory:用户主目录shell:用户默认使用shellshadow文件格式useradd usermod userdel组账号维护命令:groupaddgroupmod groupdel 用户创建:useradduseradd [options]LOGIN-u UID-o 配合-u选项,不检查UID的唯一性-g GID:指明用户所属基本组,可谓组名,也可以GID-c “COMMENT”:用户的注释信息默认设置:/etc/default/useradd文件中删除用户:userdel -r删除用户目录 查看用户相关的ID信息id [OPTIONS]…[USER]-u :显示UID-g :显示GID-G :显示用户所属的组的ID-n :显示名称,需配合ugG使用 切换用户或以其他用户身份执行命令su[options] [-] [user[args…]]切换用户的方式ssh root@ipcurl wwservice network restat 设置密码passwd常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 创建组groupadd[option]…group_name-g GID:指明GID号:-r:创建系统组修改和删除组:组属性修改:groupmod组删除:groupdel组密码:gpasswdnewgrp命令:临时切换主组chown设置文件的所有者chgrp设置文件的属组信息修改文件的属主和属组chown修改文件的属组:chgrp 文件权限文件的权限主要针对三类对象进行定义owner: 属主, ugroup: 属组, gother: 其他, o每个文件针对每类访问者都定义了三种权限r: Readablew: Writablex: eXcutable 修改文件权限chmod [OPTION]… OCTAL-MODE FILE… -R: 递归修改权限chmod [OPTION]… MODE[,MODE]… FILE… MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]… –reference=RFILE FILE…参考RFILE文件的权限，将FILE的修改为同RFILE数字权限法:chmod数字 filerwx r-x r– file其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 文本工具基础文件内容:less和cat文件截取:head和tail按列抽取:cut按关键字抽取:grep文件查看:cat tac rev分页查看:more一页一页的查看:lessless 命令是man命令使用的分页器 显示文本前后或后行内容head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行tail[option]…[FILE]看文本尾tail-f 跟踪看日志cut命令取字段past 横着合并文件wc 收集文本 文本排序sort把整理过的文本显示在STDOUT,不改变原始文件sort[opiton]file(s)uniq:从输入中删除前后相接的重复的行,处理日志liunx:文本处理三剑客grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红sed:stream editor, 文本编辑工具awk:liunx上的实现gawk,文本报告生成器grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行 正则表达式匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数位置锚定:定位正则字符特殊 元字符.单个任意字符[abc]表示其中一个字符[^abc]除去abc任意字母[:lower:]小写[:upper:]大写分组方式abc{3}\搜索替代工具grep过滤特定行,sed也可以并且编辑修改文件 vim编辑器vi:visual interface 文本编辑器文本:asscii ,unicode文本编辑种类:行编辑器:sed全屏编辑器:nano,vivim -viimproved其他编辑器gedit 一个简单的图形编辑器gvim 一个vim编辑器的图形版本vi一开始是vim的别名vim有三种模式:normal(普通) insert(插入) extendcommand(命令)normal :默认模式,移动光标,剪切/粘贴文本insert :修改文本extend command:保存,退出 搜索替代/ :从当前光标所在处向文件尾部查找? :从当前光标所在处向文件首部查找n :与命令同方向N :与命令反方向处理文本的工具sedstream editor 行编辑器sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.vim不适合修改大批量文件,sed可以sed 配合管道可以使用awk 语言sed ‘’ passwd‘地址命令’地址不写代表全部文件 命令不写代表输出 软件管理包管理器rpm 打包文件 不需要考虑部署 安装路径都定义好二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件程序包管理器：debian：deb文件, dpkg包管理器redhat: rpm文件, rpm包管理器rpm: Redhat Package Manager RPM Package Manager源代码：name-VERSION.tar.gz|bz2|xz VERSION: major.minor.releaserpm包命名方式:name-VERSION-release.arch.rpm例：bash-4.2.46-19.el7.x86_64.rpm VERSION: major.minor.release release：release.OS常见的arch： x86: i386, i486, i586, i686 x86_64: x64, x86_64, amd64 powerpc: ppc 跟平台无关：noarch 包：分类和拆包Application-VERSION-ARCH.rpm: 主包Application-devel-VERSION-ARCH.rpm 开发子包 Application-utils-VERSION-ARHC.rpm 其它子包 Application-libs-VERSION-ARHC.rpm 其它子包包之间：可能存在依赖关系，甚至循环依赖解决依赖包管理工具:yum：rpm包管理器的前端工具 apt-get：deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具 查看二进制程序所依赖的库文件 ldd /PATH/TO/BINARY_FILE管理及查看本机装载的库文件 ldconfig 加载库文件 /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf 缓存文件：/etc/ld.so.cache 程序包管理器功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.包文件组成 (每个包独有)RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.安装或卸载时运行的脚本数据库(公共)：/var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息管理程序包的方式:使用包管理器：rpm 使用前端工具：yum, dnf获取程序包的途径：(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com(2) 项目官方站点程序包的来源(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/(4) 自己制作 注意：第三方包建议要检查其合法性 来源合法性,程序包的完整性 rpm包管理CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护 安装：rpm {-i|–install} [install-options] PACKAGE_FILE… -v: verbose -h: 以#显示程序包管理执行进度 rpm -ivh PACKAGE_FILE … rpm包安装[install-options]–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs | replacefiles–nosignature: 不检查来源合法性–nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre: 安装前脚本；–nopre %post: 安装后脚本；–nopost %preun: 卸载前脚本；–nopreun %postun: 卸载后脚本； –nopostun rpm包升级升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…rpm {-F|–freshen} [install-options] PACKAGE_FILE…upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装”freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE … rpm -Fvh PACKAGE_FILE …–oldpackage：降级–force: 强制安装 升级注意项注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留 包查询rpm {-q|–query} [select-options] [query-options] [select-options]-a: 所有包-f: 查看指定的文件由哪个程序包安装生成-p rpmfile：针对尚未安装的程序包文件做查询操作–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 常用查询用法： -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, … -qa包卸载： rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME … 包校验rpm {-V|–verify} [select-options] [verify-options] S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ包校验包来源合法性验正及完整性验正完整性验正：SHA256来源合法性验正：RSA 公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人 rpm数据库数据库重建： /var/lib/rpm rpm {–initdb|–rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之 否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 yumCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下） 文件服务器: http:// https:// ftp:// file:// yum配置文件yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义： [repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000 yum仓库yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号 $arch: 平台，i386,i486,i586,x86_64等 $basearch：基础平台；i386, x86_64 $YUM0-$YUM9:自定义变量 实例: http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64 http://server/centos/6/i384yum源阿里云repo文件:http://mirrors.aliyun.com/repo/CentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/EPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 yum命令yum命令的用法： yum [options] [command] [package …]显示仓库列表： yum repolist [all|enabled|disabled]显示程序包： yum list yum list [all | glob_exp1] [glob_exp2] […] yum list {available|installed|updates} [glob_exp1] […] 安装程序包： yum install package1 [package2] […] yum reinstall package1 [package2] […] (重新安装)yum命令升级程序包： yum update [package1] [package2] […] yum downgrade package1 [package2] […] (降级)检查可用升级： yum check-update卸载程序包： yum remove | erase package1 [package2] […]yum命令查看程序包information： yum info […]查看指定的特性(可以是某文件)是由哪个程序包所提供： yum provides | whatprovides feature1 [feature2] […]清理本地缓存： 清除/var/cache/yum/$basearch/$releasever缓存 yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]构建缓存： yum makecacheyum命令搜索：yum search string1 [string2] […] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilities： yum deplist package1 [package2] […]查看yum事务历史： yum history [info|list|packages-list|packages-info| summary|addon-info|redo|undo| rollback|new|sync|stats] yum history yum history info 6 yum history undo 6日志 ：/var/log/yum.log安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] …yum localupdate rpmfile1 [rpmfile2] […] (用update替代)包组管理的相关命令： yum groupinstall group1 [group2] […] groupupdate group1 [group2] […] yum grouplist [hidden] [groupwildcard] […] yum groupremove group1 [group2] […] yum groupinfo group1 […]yum命令yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件系统光盘yum仓库系统安装光盘作为本地yum仓库：(1) 挂载光盘至某目录，例如/mnt/cdrom mount /dev/cdrom /mnt/cdrom(2) 创建配置文件 [CentOS7] name= baseurl= gpgcheck= enabled= 创建yum仓库： createrepo [options] 程序包编译程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 C、C++：make 项目管理器 configure脚本 –&gt; Makefile.in –&gt; Makefile java: maven C语言源代码编译安装三步骤:1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make 根据Makefile文件，构建应用程序3、make install 复制文件到相应路径开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in注意：安装前查看INSTALL，README 开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software Foundation) mariadb.org 代码托管:SourceForge.net Github.com code.google.comc/c++编译器: gcc (GNU C Complier) 编译C源代码： 准备：提供开发工具及开发环境 开发工具：make, gcc等 开发环境：开发库，头文件 glibc：标准库 实现：通过“包组”提供开发组件 Development Tools Server Platform Development 第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项 选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译 Optional Features: 可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包 –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION 第二步：make 第三步：make install 安装后的配置：(1) 二进制程序目录导入至PATH环境变量中 编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH(2) 导入帮助手册 编辑/etc/man.config|man_db.conf文件 添加一个MANPATH shell编程基础程序：指令+数据程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 shell程序：提供了编程能力，解释执行 编程基本概念编程逻辑处理方式：顺序执行循环执行选择执行 shell编程：过程式、解释执行编程语言的基本结构：各种系统命令的组合数据存储：变量、数组表达式: a + b语句:ifshell脚本基础shell脚本:包含一些命令或声明，并符合一定格式的文本文件格式要求:首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perlshell脚本的用途有：自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 添加注释注释以#开头第二步：运行脚本给予执行权限，在命令行上指定脚本的绝对或相对路径直接运行解释器，将脚本作为解释器程序的参数运行 脚本规范脚本代码开头约定1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 脚本调试检测脚本中的语法错误bash -n /path/to/some_script调试执行bash -x /path/to/some_script 变量变量：命名的内存空间数据存储方式：字符：数值：整型，浮点型变量：变量类型作用：1、数据存储格式2、参与的运算3、表示的数据范围类型：字符数值：整型、浮点型变量命名法则：1、不能使程序中的保留字：例如 if, for2、只能使用数字、字母及下划线，且不能以数字开头3、见名知义4、统一命名规则：驼峰命名法，建议大写 bash中变量的种类根据变量的生效范围等标准划分下面变量类型：局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程， 包括当前shell的子shell进程均无效环境（全局）变量：生效范围为当前shell进程及其子进程 本地变量：生效范围为当前shell进程中某代码片断，通常指函数 位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传 递给它的参数特殊变量：$?, $0, $*, $@, $#,$$ 局部变量变量赋值：name=‘value’可以使用引用value:(1) 可以是直接字串; name=“root”(2) 变量引用：name=”$USER”(3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name“”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set删除变量：unset name 环境变量bash内建的环境变量：PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE— 只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量： readonly name declare -r name查看只读变量： readonly –p位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置$0: 命令本身$: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/nullecho $?退出状态码bash自定义退出状态码exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 运算bash中的算术运算:help let+, -, , /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如bash有内建的随机数生成器：RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数赋值 增强型赋值：+=, -=, *=, /=, %=let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1 let var++ let var-=1 let var-- 逻辑运算true, false1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! 0 = 1 短路运算 短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算 短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算 异或：^异或的两个值,相同为假，不同为真 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1 测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符bash的数值测试-v VAR变量VAR是否设置 数值测试：-gt 是否大于-ge 是否大于等于-eq 是否等于-ne 是否不等于-lt 是否小于-le 是否小于等于bash的字符串测试 字符串测试: == 是否等于ascii码是否大于ascii码&lt; 是否小于!= 是否不等于=~ 左侧字符串是否能够被右侧的PATTERN所匹配注意: 此表达式一般用于[[ ]]中；扩展的正则表达式-z “STRING“ 字符串是否为空，空为真，不空为假-n “STRING“ 字符串是否不空，不空为真，空为假注意：用于字符串比较时的用到的操作数都应该使用引号Bash的文件测试 存在性测试 -a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件Bash的文件权限测试 文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限Bash的文件属性测试 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组Bash的文件属性测试 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 使用read命令来接受输入使用read来把输入值分配给一个或多个shell变量-p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE 流程控制过程式编程语言： 顺序执行 选择执行 循环执行条件选择if语句 选择执行: 注意：if语句可嵌套单分支 if 判断条件;then 条件为真的分支代码 fi双分支 if 判断条件; then 条件为真的分支代码 else条件为假的分支代码fi 多分支 if 判断条件1; then 条件为真的分支代码 elif 判断条件2; then 条件为真的分支代码 elif 判断条件3; then 条件为真的分支代码 else 以上条件都为假的分支代码 fi 逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断：case语句 case 变量引用 in PAT1) 分支1 ;; PAT2) 分支2 ;; ... *) 默认分支 ;; esac case支持glob风格的通配符： *: 任意长度任意字符 ?: 任意单个字符 []：指定范围内的任意单个字符 a|b: a或b 循环 循环执行将某代码段重复运行多次重复运行多少次：循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, untilfor循环for 变量名 in 列表;do循环体done执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 for循环列表生成方式：(1) 直接给出列表(2) 整数列表：(a) {start..end}(b) $(seq [start [step]] end)(3) 返回列表的命令$(COMMAND)(4) 使用glob，如：.sh(5) 变量引用；$@, $while循环while CONDITION; do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为falseuntil循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true循环控制语句continue用于循环体中ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thencontinuefiCMDn…done循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thenbreakfiCMDn…done特殊用法双小括号方法，即((…))格式，也可以用于算术运算双小括号方法也可以使bash Shell实现C语言风格的变量操作I=10((I++))for循环的特殊格式：for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))do 循环体done控制变量初始化：仅在运行到循环代码段时执行一次控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于：Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改定义函数函数由两部分组成：函数名和函数体help function语法一：f_name （）{…函数体…} 语法二：function f_name {…函数体…} 语法三：function f_name （） {…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止函数返回值函数有两种返回值：函数的执行结果返回值：(1) 使用echo等命令进行输出(2) 函数体中调用命令的输出结果函数的退出状态码：(1) 默认取决于函数中执行的最后一条命令的退出状态码(2) 自定义退出状态码，其格式为：return 从函数中返回，用最后状态命令决定返回值return 0 无错误返回。return 1-255 有错误返回交互式环境下定义和使用函数 示例:dir() {ls -l}定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir在脚本中定义及使用函数函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用调用函数仅使用其函数名即可示例：cat func1!/bin/bashfunc1hello(){echo “Hello there today’s date is date +%F“}echo “now going to the function hello”helloecho “back from the function”使用函数文件可以将经常使用的函数存入函数文件，然后将函数文件载入shell文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例： cat functions.main #!/bin/bash #functions.mainfindit(){if [ $# -lt 1 ] ; thenecho “Usage:findit file”return 1fifind / -name $1 –print} 载入函数函数文件已创建好后，要将它载入shell定位函数文件并载入shell的格式：. filename 或 source filename注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径 检查载入函数使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 示例：setfindit=( ){if [ $# -lt 1 ]; thenecho “usage :findit file”;return 1fifind / -name $1 -print} 执行shell函数要执行函数，简单地键入函数名即可示例：findit groups/usr/bin/groups/usr/local/backups/groups.bak 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量在函数中定义局部变量的方法local NAME=VALUE函数递归示例 函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)!函数递归示例: 示例：fact.sh fact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi } fact $1 fork炸弹 fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现:(){ :|:&amp; };:bomb() { bomb | bomb &amp; }; bomb 实际上: 代表bomb脚本实现 cat Bomb.sh./$0|./$0&amp;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbook%2Fgit%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[变基rebase rebase, 有垫底的意思, git rebase我们称它为git变基, 即在当前分支外另一结点重新应用当前分支的提交历史, 变基是git整合变更的一种方式, 另一中方式是合并(merge).]]></content>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fbook%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[js基础语法 常量和变量标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写. 声明 123456789var声明一个变量let声明一个块作用域中的局部变量const声明一个常量js中的变量声明和初始化时可以分开的.var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug. 数据类型 序号 名称 说明 1 number 数值型,包括整型和浮点型 2 boolean 布尔型,true和false 3 string 字符串 4 null 只有一个值null 5 undefined 变量声明未赋值的;对象未定义的属性 6 symbol ES6新引入类型 7 object 是以上基本类型的复合类型,是容器 弱类型,不需要强制类型转换, 会隐式类型转换. NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN 总结: 1234567遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换. 三元运算符条件表达式?真值:假值 等价于简单的if…else结构 函数, 匿名函数,函数表达式的差异 函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已. 区别在于, 函数会声明提升, 函数表达式不会 . 高阶函数: 函数作为参数或返回 一个函数. 函数12345678function 函数名(参数列表)&#123; 函数体; return 返回值;&#125;function add(x, y)&#123; return x + y;&#125;console.log(add(3, 5)); 函数, 匿名函数, 函数表达式的差异函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已. 区别在于, 函数会申明提升, 函数表达式不会. 123456789console.log(add(4, 6));// 匿名函数function add(x, y)&#123; return x + y;&#125;const sub = function (x, y)&#123; return x -y;&#125;console.log(sub(5, 6)); 高阶函数 高阶函数: 函数作为参数或返回一个函数 箭头函数箭头函数就是匿名函数,它是一种更加精简的格式. 箭头函数参数 如果一个函数没有参数,使用() 如果只有一个参数,参数列表可以省略小括号() 多个参数不能省略小括号,且使用逗号间隔. 箭头函数返回值. 如果函数体部分有多行,就需要使用{}, 如果有返回值使用return. 如果只有一行语句, 可以同时省略大括号和return. 只有return语句, 就不能省略大括号, 如果只有一条非return语句, 加上大括号, 函数就成了无返回值, 函数参数普通参数一个参数占一个位置,支持默认参数. 可变参数(rest parameters剩余参数) js使用…表示可变参数(python用*手机多个参数) 12345678const sum = function (...args)&#123; let result = 0; for (let x in args)&#123; result += args[x] &#125; return result&#125;;console.log(sum(3, 6, 9)) arguments对象函数的所有参数会被保存在一个arguments的键值对对象中. 参数解构和python类似, js提供了参数解构, 依然使用了…符号来结构. 1234const add = (x, y) =&gt;&#123;console.log(x, y); return x + y&#125;;console.log(add(...[100, 200]))console.log(add(...[100, 200, 300]))console.log(add(...[100])) 函数返回值python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组. 表达式的值 类c的语言,都有一个概念 – 表达式的值 赋值表达式的值: 等号右边的值 逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值. 异常抛出异常 js的异常语法和java相同, 使用throw关键字抛出. 使用throw关键字可以抛出任意对象的异常. 1234throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok'; 捕获异常try…catch语句捕获异常 try …catch…finally 语句捕获异常, finally保证最终一定执行. 问题: null和undefined的异同1.undefined：是所有没有赋值变量的默认值，自动赋值。 2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。 共同点：都是原始类型，保存在栈中变量本地。 不同点： undefined——表示变量声明过但并未赋过值。 它是所有未赋值变量默认值，例如： 1var a; // a 自动被赋值为 undefined null——表示一个变量将来可能指向一个对象。 一般用于主动释放指向对象的引用，例如： 12var emps = [&apos;ss&apos;,&apos;nn&apos;]; emps = null; // 释放指向数组的引用 它是专门释放对象内存的一个程序。 在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期； 总有一个对象不再被任何变量引用时，才释放]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScrript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python pep]]></title>
    <url>%2Fbook%2Fpython%20pep%2F</url>
    <content type="text"><![CDATA[PEPPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0 https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅import thisBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题） PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148 PEP8016Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 三大器]]></title>
    <url>%2Fbook%2Fpython%20%E4%B8%89%E5%A4%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用. 12345678def 炼丹炉(func): def 变身(*args): 火眼金睛 returrn 孙悟空 return 变身@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)def 孙悟空: return 装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper 单层的只需要function 如:注册器 双层的是返回一个全新的函数 如:打印log 迭代器迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代可迭代对象就是,实现了迭代器协议的对象.协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)使用迭代器协议访问对象.举个例子:for n in [1, 2, 3, 4]: print(n) 但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象with open (‘/etc/passwd’) as f: for line in f: print(line) def gensquares(n): for i in range(n): yield i ** 2for item in genquares(s): print(item) 生成器语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.自动实现迭代器协议:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(2)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(2)%2F</url>
    <content type="text"><![CDATA[文档编辑grepLinux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。 语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]参数： -a 或 –text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 –count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 –fixed-regexp : 将样式视为固定字符串的列表。-G 或 –basic-regexp : 将样式视为普通的表示法来使用。-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 –ignore-case : 忽略字符大小写的差别。-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 –only-matching : 只显示匹配PATTERN 部分。-q 或 –quiet或–silent : 不显示任何信息。-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。-s 或 –no-messages : 不显示错误信息。-v 或 –revert-match : 显示不包含匹配文本的所有行。-V 或 –version : 显示版本信息。-w 或 –word-regexp : 只显示全字符合的列。-x –line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定”-i”参数相同。 sortLinux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 语法sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]参数说明： -b 忽略每行前面开始出的空格字符。-c 检查文件是否已经按照顺序排序。-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-f 排序时，将小写字母视为大写字母。-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。-m 将几个排序好的文件进行合并。-M 将前面3个字母依照月份的缩写进行排序。-n 依照数值的大小排序。-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r 以相反的顺序来排序。-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。–help 显示帮助。–version 显示版本信息。 trLinux tr 命令用于转换或删除文件中的字符。 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 语法tr [-cdst][–help][–version][第一字符集][第二字符集]tr [OPTION]…SET1[SET2]参数说明： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息字符集合的范围： \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。[CHAR] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止[CHARREPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)[:alnum:] ：所有字母字符与数字[:alpha:] ：所有字母字符[:blank:] ：所有水平空格[:cntrl:] ：所有控制字符[:digit:] ：所有数字[:graph:] ：所有可打印的字符(不包含空格符)[:lower:] ：所有小写字母[:print:] ：所有可打印的字符(包含空格符)[:punct:] ：所有标点字符[:space:] ：所有水平与垂直空格符[:upper:] ：所有大写字母[:xdigit:] ：所有 16 进位制的数字[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符) uniqLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 语法uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]参数： -c或–count 在每列旁边显示该行重复出现的次数。-d或–repeated 仅显示重复出现的行列。-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。-u或–unique 仅显示出一次的行列。-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。–help 显示帮助。–version 显示版本信息。[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 wcLinux wc命令用于计算字数。 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…]参数： -c或–bytes或–chars 只显示Bytes数。-l或–lines 只显示行数。-w或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 letlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 语法格式let arg [arg …]参数说明：arg：要执行的表达式 sedLinux sed命令是利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法sed [-hnV][-e][-f&lt;script文件&gt;][文本文件]参数说明： -e或–expression= 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或–help 显示帮助。-n或–quiet或–silent 仅显示script处理后的结果。-V或–version 显示版本信息。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门笔记]]></title>
    <url>%2Fbook%2Fpython%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机基础程序是一组让计算机识别和执行的指令电子计算机:能够执行程序的机器计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.即8位 2**8=256种状态 内存 掉电易失 与晶振频率有关 临时数据 mermorycpu与内存速度差几个数量级cpu 只认内存 io设备最慢CPU 缓存 cache bus 总线先写源程序 通过编译程序把源程序转换成机器指令的程序python是跑在虚拟机上的 动态语言 做节点 集群优化编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样 机器语言: 是一定位数组成的0 1序列 称为机器指令 机器指令的集合就是机器语言汇编: 是用助记符替代机器指令静态语言: 是声明变量类型,不能再改变,编译需要检查动态语言: 不用声明类型 随时可以赋值为其他类型强类型: 不同类型之间操作 必须强制类型转换为同一类型弱类型: 不同类型之间操作 自动隐式转换 python基础介绍python 的源代码需要被解释器编译成中间代码,在虚拟机上运行*`程序 = 算法 +数据结构`*数据一切程序的核心数据结构是数据在计算机中的类型和组织方式算法是处理数据的方式,算法有优劣之分.python自带了一个IDLE的程序,全称是交互式开发环境.注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要. import math #对角线的长度i = 4w = 10d = math.sqrt(12 + w2)即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的编写尽量用pep8风格 数据类型:python将数据划分为不同的类别,即数据类型.每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.对象的数据类型是对象所属的数据类别.“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号数据类型为bool的对象被称为布尔值.数据类型为nonetype的对象,其值永远我none 用来表示数据缺失. 系统编程python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展此外很多python的系统工具设计都考虑了其可移植性. python解释器python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行. python变量和内存变量在python是表示内存的地址.可以用id()函数获取内存地址 a=5id(a)id(5)会发现这两个地址一样,都输出140720362218448 即python的编程哲学 :一切皆对象,一切皆指针只有指针,要说变量也是指针变量variable 变量是改变的值.变量由一个或多个字符组成的名称构成并使用赋值符 等号赋予了这个名称一个值变量是记住内存中 0 1数字 开始和结束的一串 指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。对于C和C++这样的没有Garbage Collection 的语言来讲我们主要关注两种类型的内存泄漏： 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 python虚拟机原理python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.pycodeobject保存字节码以及进程上下文信息. 过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象.pyc文件字节码在磁盘上的表现形式pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,从技术上将,他才是所谓python解释器的最后一步.代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式. 开发环境 —-pyenvpython多版本管理工具pip包管理器pip install xxxpip listpip search keyword 或者 pypipip help installpip install redis ipythonpip install jupyterpip -Vpip freeze &gt; requirementpip install-r requirement 原码补码反码原码是给人看的,补码是给计算机用的127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。因为它是用补码的编码方式。正数的补码就是它的原码，也就是单纯的二进制数。负数的话，1111 1111这个二进制串，首先它最高位是1，明确他是个负数。那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001也就是1，再加上符号位。最终结果是-1 补码 从小到大 二进制1000 0000—-0000 0000—-0111 1111首尾相连，刚好连个时钟，最大的加一到最小的 字符串使用单双三引号括起来的序列叫字符串 r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理f前缀:3.6版本开始,新增f前缀,格式化字符串转义序列\ \t \r \n \’ \”缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系约定使用4个空格缩进续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\extend 魔术方法add() 标识符一个名字,用来指代一个值只能是字母,下划线和数字只能以字母或下划线开头不能是python的关键字,例如def,class等python是大小写敏感的约定:不允许使用中文不要使用歧义单词,例如class_在python中不要随便使用下划线开头的标识符 运算符 算术运算符 +-*/%**自然除/结果是浮点数,整除// 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 比较运算符 == != &gt; &lt; &gt;= &lt;=返回一个bool值 逻辑运算符 与或非 and or not短路运算符 赋值运算符0 *? =0短路1+? =1短路运算 可以提高效率 可以提前算完了赋值运算 先算右边 和左边相连(映射) a=min(3,5) 运算符优先级 就记住一句话 a+b&gt;c and 折半思想可以优化程序 程序控制顺序结构:按照先后顺序一条条执行分支结构:根据不同情况判断,条件满足执行某条件下的语句循环结构:条件满足就反复执行,不满足就不执行或不再执行 内置类型内置对象使程序更容易编写内置对象使扩展的组件内置对象往往比定制的数据结构更有效率内置对象使语言的标准的一部分python的核心数据类型模式匹配 循环while 语句whlie condition: block当他成立则进入循环while true: pass #死循环 冒号后要形成语句块 死循环都用这个语法例子: flag = 10while flag: print(flag) flag-= 1 在做循环时,一定要分析边界 边界最容易出错range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包 for i in range(10): print(i+1) i= i+10循环 隐含赋值 原来有什么会被冲掉for相当于遍历 不会重复拿 挨个拿如果要倒着遍历 应当在range函数内加步长-1例子:for i in range(10): if i %2 == 0: print(i) for i in range(10): if not i % 2: print(i)not 经常用for i in range (10): if i &amp;1 == 0: print(i) for i in range(10): if i &amp; 1: continue print(i) 写程序要减少循环提高效率 for i in range(10): if i % 2: continue print(i) 如果循环嵌套 continue 和break也只影响语句所在的那一层循环 迭代器和生成器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： from collections import Iterableisinstance([], Iterable)Trueisinstance({}, Iterable)Trueisinstance(‘abc’, Iterable)Trueisinstance((x for x in range(10)), Iterable)Trueisinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： L = [x x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x x for x in range(10))g &lt;generator object at 0x1022ef630&gt; 函数python 内置了很多有用的函数,我们可以直接调用要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(1)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[1 文档管理cat chgrp chmod chown file find cut in less more mv tee touch which cp read2 文档编辑:grep sed tr sort uniq wc let3 磁盘管理:cd df du mkdir pwd mount stat tree ls4 网络通讯:telnet httpd ifconfig netatat ping tty write5 系统管理:useradd data adduser exit kill ps pstree top reboot sudo uname who whoami whois w id free6 系统设置:reset clear alias enable rpm set passwd time setup7 备份压缩:zip tar8 其他命令: bc tail 文档命令cat全称: concatenate files and print on the standard outputcat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0注： OUTFILE 指输出的镜像文件名. IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用制作开机磁片 chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法:chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法chmod [-cfvR] [–help] [–version] mode file…参数说明mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本实例将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r *此外chmod也可以用数字来表示权限如 : chmod 777 file语法为： chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。chmod a=rwx file和 chmod 777 file效果相同 chmod ug=rwx,o=x file和 chmod 771 file效果相同 若用chmod 4755 filename可使此程序具有root的权限 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。使用权限 : root语法chown [-cfhvR] [–help] [–version] user[:group] file…参数 :user : 新的文件拥有者的使用者 IDgroup : 新的文件拥有者的使用者组(group)-c : 显示更改的部分的信息-f : 忽略错误信息-h :修复符号链接-v : 显示详细的处理信息-R : 处理指定目录以及其子目录下的所有文件–help : 显示辅助说明–version : 显示版本 fileLinux file命令用于辨识文件类型。 通过file指令，我们得以辨识该文件的类型。 语法file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]参数： -b 列出辨识结果时，不显示文件名称。-c 详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 指定魔法数字文件。-v 显示版本信息。-z 尝试去解读压缩文件的内容。[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 findLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法find path -option [ -print ] [ -exec -ok command ] {} \;参数说明 : find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 你可以使用 ( ) 将运算式分隔，并使用下列运算。 exp1 -and exp2 ! expr -not expr exp1 -or exp2 exp1, exp2 cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 语法cut [-bn] [file]cut [-c] [file]cut [-df] [file]使用说明: cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 参数: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符。-f ：与-d一起使用，指定显示哪个区域。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 lnLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 语法 ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] [–help] [–version] [–] 命令功能 :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数必要参数： -b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数： -S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”–help 显示帮助信息–version 显示版本信息 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 语法less [参数] 文件参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 moreLinux more命令Linux 命令大全 Linux 命令大全 Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 语法more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料-s 当遇到有连续两行以上的空白行，就代换为一行的空白行-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示+num 从第 num 行开始显示fileNames 欲显示内容的文档，可为复数个数 mvLinux mv命令Linux 命令大全 Linux 命令大全 Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 语法mv [options] source destmv [options] source… directory参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果 mv 文件名 文件名 将源文件名改为目标文件名mv 文件名 目录名 将文件移动到目标目录mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名mv 目录名 文件名 出错 rmrm命令用于删除一个文件或者目录。 语法rm [options] name…参数： -i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 teeLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。 tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 语法tee [-ai][–help][–version][文件…]参数： -a或–append 附加到既有文件的后面，而非覆盖它．-i或–ignore-interrupts 忽略中断信号。–help 在线帮助。–version 显示版本信息。 touchLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录。 语法touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]参数说明：a 改变档案的读取时间记录。m 改变档案的修改时间记录。c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。f 不使用，是为了与其他 unix 系统的相容性而保留。r 使用参考档的时间记录，与 –file 的效果一样。d 设定时间与日期，可以使用各种不同的格式。t 设定档案的时间记录，格式与 date 指令相同。–no-create 不会建立新档案。–help 列出指令格式。–version 列出版本讯息。 whichLinux which命令用于查找文件。 which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法which [文件…]参数： -n&lt;文件名长度&gt; 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p&lt;文件名长度&gt; 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 cpLinux cp命令主要用于复制文件或目录。 语法cp [options] source dest或 cp [options] source… directory参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。 readLinux read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]参数说明: -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以使用命令补全功能。-n 后跟一个数字，定义输入文本的长度，很实用。-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(3)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(3)%2F</url>
    <content type="text"><![CDATA[磁盘管理cdLinux cd命令用于切换当前工作目录至 dirName(目录参数)。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。 另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。 语法cd [dirName]dirName：要切换的目标目录。 dfLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 语法df [选项]… [FILE]…文件-a, –all 包含所有的具有 0 Blocks 的文件系统文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, –inodes 列出 inode 资讯，不列出已使用 block文件-k, –kilobytes 就像是 –block-size=1024文件-l, –local 限制列出的文件结构文件-m, –megabytes 就像 –block-size=1048576文件–no-sync 取得资讯前不 sync (预设值)文件-P, –portability 使用 POSIX 输出格式文件–sync 在取得资讯前 sync文件-t, –type=TYPE 限制列出文件系统的 TYPE文件-T, –print-type 显示文件系统的形式文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件–help 显示这个帮手并且离开文件–version 输出版本资讯并且离开 duLinux du命令用于显示目录或文件的大小。 du会显示指定的目录或文件所占用的磁盘空间。 语法du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]参数说明： -a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或–dereference-args 显示指定符号连接的源文件大小。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或–kilobytes 以1024 bytes为单位。-l或–count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或–megabytes 以1MB为单位。-s或–summarize 仅显示总计。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。–help 显示帮助。–version 显示版本信息。 mkdirLinux mkdir命令用于建立名称为 dirName 之子目录。 语法mkdir [-p] dirName参数说明： -p 确保目录名称存在，不存在的就建一个。 pwdLinux pwd命令用于显示工作目录。 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。 语法pwd [–help][–version]参数说明: –help 在线帮助。–version 显示版本信息。 mountLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 语法mount [-hV]mount -a [-fFnrsvw] [-t vfstype]mount [-fnrsvw] [-o options [,…]] device | dirmount [-fnrsvw] [-t vfstype] [-o options] device dir参数说明： -V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 lsLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法 ls [-alrtAFR] [name…]参数 : -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出 系统管理useraddLinux useradd命令用于建立用户帐号。 useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 语法useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ]参数说明： -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。-d&lt;登入目录&gt; 指定用户登入时的启始目录。-D 变更预设值．-e&lt;有效期限&gt; 指定帐号的有效期限。-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。-g&lt;群组&gt; 指定用户所属的群组。-G&lt;群组&gt; 指定用户所属的附加群组。-m 自动建立用户的登入目录。-M 不要自动建立用户的登入目录。-n 取消建立以用户名称为名的群组．-r 建立系统帐号。-s 指定用户登入后所使用的shell。-u 指定用户ID dataLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 时间方面： % : 印出 %%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面： %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。 使用权限：所有使用者。 当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。 当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。 语法date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]参数说明： -d datestr : 显示 datestr 中所设定的时间 (非系统时间)–help : 显示辅助讯息-s datestr : 将系统时间设为 datestr 中所设定的时间-u : 显示目前的格林威治时间–version : 显示版本编号 psLinux ps命令用于显示当前进程 (process) 的状态。 语法ps [options] [–help]参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义-A 列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程au(x) 输出格式 :USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDUSER: 行程拥有者PID: pid%CPU: 占用的 CPU 使用率%MEM: 占用的记忆体使用率VSZ: 占用的虚拟记忆体大小RSS: 占用的记忆体大小TTY: 终端的次要装置号码 (minor device number of tty)STAT: 该行程的状态:D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的行程N: 低优先序的行程L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)START: 行程开始时间TIME: 执行的时间COMMAND:所执行的指令 topLinux top命令用于实时显示 process 的动态。 使用权限：所有使用者。 语法top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]参数说明： d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 sq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来s : 安全模式，将交谈式指令取消, 避免潜在的危机i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程n : 更新的次数，完成后将会退出 topb : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 pstreeLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。 使用权限：所有使用者。 语法pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]或 pstree -V参数说明： -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） rebootLinux reboot命令用于用来重新启动计算机。 若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代 语法reboot [-n] [-w] [-d] [-f] [-i]参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 screenLinux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。 语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明： -A 将所有的视窗都调整为目前终端机的大小。-d&lt;作业名称&gt; 将指定的screen作业离线。-h&lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r&lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S&lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 shutdownLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 使用权限：系统管理者。 语法shutdown [-t seconds] [-rkhncfF] time [message]参数说明： -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。 swatchLinux swatch命令用于系统监控程序。 swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。 语法swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]参数说明： -A&lt;分隔字符&gt; 预设配置文件中，动作的分隔字符，预设为逗号。-c&lt;设置文件&gt; 指定配置文件，而不使用预设的配置文件。-f&lt;记录文件&gt; 检查指定的记录文件，检查完毕后不会继续监控该记录文件。-I&lt;分隔字符&gt; 指定输入记录的分隔字符，预设为换行字符。-P&lt;分隔字符&gt; 指定配置文件中，事件的分隔字符，预设为逗号。-r&lt;时间&gt; 在指定的时间重新启动。-t&lt;记录文件&gt; 检查指定的记录文件，并且会监控加入记录文件中的后继记录。 idLinux id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 语法id [-gGnru][–help][–version][用户名称]参数说明： -g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法free [-bkmotV][-s &lt;间隔秒数&gt;]参数说明： -b 以Byte为单位显示内存使用情况。-k 以KB为单位显示内存使用情况。-m 以MB为单位显示内存使用情况。-o 不显示缓冲区调节列。-s&lt;间隔秒数&gt; 持续观察内存使用状况。-t 显示内存总和列。-V 显示版本信息。 系统设置setupLinux setup命令设置公用程序，是一个启动图形设置系统的命令。 setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。 语法setupsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项： １.登陆认证方式２.键盘组态设置３.鼠标组态设置４.开机时所要启动的系统服务５.声卡组态设置６.时区设置７.X Windows组态设置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析]]></title>
    <url>%2Fbook%2FPandas%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Pandas:最流行的Python数据分析库 基于Numpy, 专用于数据预处理和数据分析的Python第三方库, 最适合处理大型结构化表格数据. Pandas两大数据类型 Series: 一维 DataFrame: 二维 Series数据类型 12a = pd.Series([3, 4, 5, 6, 7])a DataFrame数据类型 12b = pd.DataFrame([3, 4, 5], [6, ,7, 8], [9, 10, 11])b 抽象和维度 维度: 观察事物的角度 日常保存数据的数据格式: 0维: 字符串, 单值变量 1维: 列表, 字典(1成括号) 2维: Excel表格, Mysql数据库 3维或以上: JSON, MongoDB, HTML Pandas各个数据类型的关系： 0维单值变量 -&gt; 1维Series -&gt; 2维DataFrame -&gt; 3维层次化DataFrame Series列表创建Series a = pd.Series([2, 3, 5]) 字典创建Series 123# 索引就是字典字典的键d = pd.Series(&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;gander&apos;:True&#125;)d 其他方式 123# 标量创建pd.Series(5)pd.Series(5, index=[1,2, 3, 4, 5]) 12345# Numpy的序列函数创建np.arange(5)np.arange(2, 5)np.arange(9, 5, -1) 查询 1class1 = pd.Series([95, 25, 59, 61], index=[&apos;ming&apos;, &apos;hua&apos;, &apos;hong&apos;,&apos;huang&apos;, &apos;bai&apos;]) 查询数据形状 1维数据的形状就是它的值个数 1class1.shape, class1.shape[0] 查询值(values) 和索引(index) 一个Series数据是由2个ndarray数组组成的 12# 查询值class1.values 查询值 根据索引查询值 索引查询 切片插叙 根据条件反查索引 布尔查询 索引查询 索引和切片都是根据索引查询值 class1 查询单值 123# Series有两套索引：默认索引，自定义索引class1[&apos;hong&apos;] # 自定义索引class1[2] # 默认索引 查询多值 12class1[[&apos;hua&apos;, &apos;bai&apos;]]class1[[1, 4]] 切片查询 1234# 默认索引：包含起始值，不包含结束值class1[:3] class1[2:]class1[1:4] 布尔查询 根据值反查索引 根据条件反查索引 12# 布尔查询class1[[False, True, True, False, False]] 向量化运算矢量运算, 并行运算 123a = pd.Series(x)aa + 5 # 向量化运算, 不需要遍历, 速度快效率高 123# Pandas向量化方式a.sum() # Pandas方法np.sum(class1) # Numpy方法 类Numpy数组操作, 和类Python字典的操作 Pandas数据可以执行全部Numpy数据操作(因为Pandas底层基于Numpy, 所以通用) 也可以执行部分Python原生列表或字典操作(仅限于Pandas实现的操作) 类Numpy数组操作 1np.mean(class1) # Numpy方法 类Python字典操作 in关键字: 判断某索引是否存在 get方法:判断某索引是否存在, 存在则直接输出值, 不存在则输出定义值 DataFrame对象 - 创建DataFrame对象是Pandas最常用的数据类型 DataFrame对象是由多个Series增加一个索引后组成一种表格类型数据结构 DataFrame对象既有行索引, 又有列索引 行索引,表明不同行, 横向索引, 叫index, 0轴, axis=0 列索引, 表名不同列, 纵向索引, 叫colums, 1轴, axis=1 列表创建 ndarry数组创建 字典内嵌套列表：要求内部列表等长 字典内嵌套字典：内部字典不需要等长 字典内嵌套Series：等同嵌套字典 列表创建 12# 默认索引pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]]) 使用Numpy数组创建 Numpy数组类似一个高级版的Python列表 123np.arange(10)np.arange(10).reshape(2, 5) 字典创建 字典内嵌套列表 列表值需要等长, 否则报错 12345678pd.DataFrame( &#123; '姓名': ['张三', '李四', '王五'], '年龄': [18, 28, 38], '性别': [True, True, False], '分数': [85.5, 59, 78], &#125;) 字典嵌套字典字典不要求等长 12345678pd.DataFrame( &#123; 'name': &#123;1: '张三', 2: '李四', 3: '王五'&#125;, 'age': &#123;1: 18, 2: 28, 3: 38&#125;, 'gender': &#123;1: True, 2: True, 3: False&#125;, 'grade': &#123;1: 85.5, 3: 78&#125;, # 不等长也不报错 &#125;,) DataFrame整体查询 123456a.shape # 表格形状，行数 列数a.dtypes # 列数据类型a.index # 行索引a.columns # 列索引a.values # 对象值，二维ndarray数组 整体数据情况 a.info()整体信息, 查看:数据是否异常 有没有缺失值 列数据类型是否正确 a.describe()整体统计指标 a.head() 前5行 a.tail() 后5行 内容查询 类列表/字典/ndarray数组的查询方式 功能简陋, 一般仅用于查询单列 Pandas专用查询方式：经过优化，推荐 三种查询方式： 索引 切片 过滤 索引和切片查询，两种查询方式： a.loc[行,列]，标签索引，自定义索引 a.iloc[行,列]，位置索引，默认索引 参数书写顺序都是都是先行后列 索引查询用于不连续(行列有间隔)行列区块查询 查询单行 1234567# 自定义索引查询a.loc[3] # 简写a.loc[3, :] # 完整写法# 默认索引a.iloc[2]a.iloc[2, :] 查询多行 1234a.loc[[2, 4]] # 选中所有列，省略了列条件a.loc[[2, 4], :] # 完整写法a.iloc[[1, 3]] 索引查询和切片查询的区别 索引查询更适合查询不连续的行列数据 切片查询适合查询连续行和列数据 索引查询可以实现切片查询的所有功能，只是有个书写效率问题 用索引查询查连续数据，需要将每个索引都写上，效率低 切片查询连续数据，只要写起始和结束索引即可。 切片不能查询不连续数据 查询时：优先使用切片查询，无法实现功能时再使用索引查询 专用查询：过滤查询索引查询和切片查询, 都是通过索引查询值 过滤查询(布尔查询) : 通过值查询索引 过滤查询不通过索引, 而是通过值查询 用于结果索引不确定的查询 通过运算所得布尔值对查询结果进行过滤 类list/字典查询方式 专用查询方式的布尔查询 12# 布尔查询a.loc[[False, True, False, True, False], [True, True, False, False, False, True, False]] 12# 查询不及格同学的姓名、年龄和成绩a.loc[a['grade'] &lt; 60, ['name', 'age', 'grade']] where过滤（了解）另一种简洁的布尔查询写法 总结 原生的布尔查询，需要每列单独判断条件，然后用逻辑运算符组合条件，得出最终结果 where过滤过滤：先将所有需要判断条件的列抽出来，整体判断，得出最终结果 优点：写法简洁 缺点：where过滤所有列的判断条件，只能有一个，使用受限 视图模式 将一个对象整体赋值给另一个变量 修改一个变量，另一个变量值也会变 多个变量数据指向同一内存数据 副本模式 将一个对象查询的一部分值赋值给另一个变量 修改一个变量，另一个变量值不会变 当将一个对象整体赋值给另一个变量时，视图模式，两个变量对应的内存地址相同，修改一个变量，另一个变量也会改变。 当使用copy()将一个对象赋值给另一个变量时 或者使用查询赋值，查询数据的一部分并赋值给其他变量 当赋值为原数据查询的一部分时，是副本模式，修改一个变量不会影响另一个变量 变量查询一部分数据理论上是副本模式，但实际上，直接修改赋值变量时会报警告（能修改成功） 1a[['name', 'sex', 'address']] 数据操作 创建：C,Create 查询：R,Read 增加：I,Insert 修改：U,Update 删除：D,Delete pandas数据操作: 其他操作 pandas对象的命名: name pandas对象的遍历 Pandas对象的命名:name Series和Dataframe对象本身, 索引都可以命名 数据的输入和输出是Pandas的基础操作 Pandas可以存取多种介质类型数据：常见的有： 文本类数据 csv JSON 二进制磁盘数据 Excel pkl HDF5 数据库 SQL（略） Web API数据 HTML 其他 内存 12345文本类数据文件读入Pandas时会自动推断每列数据类型（类型推断）和数据编码并转化。二进制类数据文件没有编码问题，且部分文件会在格式中存储数据类型不需转化对Pandas不能直接支持或不方便使用的数据格式，可以使用支持软件将其转为csv或xlsx格式后使用Pandas读写，如SPSS文件]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2Fbook%2FPyUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Pyunit(unittest) 是python 自带的单元测试框架, 用于编写和运行可重复的测试.pyunit是xunit体系的一个成员, xunit是众多测试框架的总称,pyunit主要用于进行白盒测试和回归测试. 通过Pyunit可以让测试具有持久性, 测试与开发同步进行, 测试代码与开发代码一同发布.使用PyUnit具有如下好处: 可以是测试代码与产品代码分离. 针对某一个类的测试代码只需进行较少的改动, 便可以应用于另一个类的测试. PyUnit开放源代码, 可以进行二次开发, 方便对Pyunit的扩展.]]></content>
  </entry>
  <entry>
    <title><![CDATA[ansible]]></title>
    <url>%2Fbook%2Fandible%2F</url>
    <content type="text"><![CDATA[ansible简介安装ansibleyun install -y ansible todoansible 文档https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#foreword]]></content>
      <categories>
        <category>ansible</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2Fbook%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本入门算法有三个经典算法:冒泡,选择和插入算法 1.冒泡排序 冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现： 123456789101112# -*- coding:utf-8 -*-def bubble_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(1,length-index): if raw_list[i-1]&gt;raw_list[i]: raw_list[i],raw_list[i-1]=raw_list[i-1],raw_list[i] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = bubble_sort(data_test)print(sorted_list) 2.选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 12345678910111213# -*- coding:utf-8 -*-def select_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(index,length): if raw_list[index]&gt;raw_list[i]: raw_list[index],raw_list[i]=raw_list[i],raw_list[index] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = select_sort(data_test)print(sorted_list) 3.插入排序 每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 代码实现： 1234567891011121314151617# -*- coding:utf-8 -*-def insert_sort(raw_list): length = len(raw_list) for i in range(1, length): temp = raw_list[i] #j从i-1 到 0倒序 for j in range(i-1,-1,-1): if(raw_list[j]&lt;=temp): break if(raw_list[j]&gt;temp): raw_list[j],raw_list[j+1] = temp,raw_list[j] j -= 1 return raw_list#测试data_test = [10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = insert_sort(data_test)print(sorted_list) 4.希尔排序 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 即所有记录放在同一组中进行直接插入排序为止。 123456789101112131415161718# -*- coding:utf-8 -*-def shell_sort(list): length=len(list) dist=length/2 while dist&gt;0: for i in range(dist,length): temp=list[i] j=i while j&gt;=dist and temp&lt;list[j-dist]: list[j]=list[j-dist] j-=dist list[j]=temp dist/=2 return list#测试list=[10,23,1,53,654,54,16,646,65,3155,546,31]print shell_sort(list) 5.归并排序 归并排序，就是把两个已经排列好的序列合并为一个序列。 代码实现： 1234567891011121314151617181920# -*- coding:utf-8 -*-#算法逻辑比较简单，以第一个list为基准，第二个向第一个插空def merge_sort(list1,list2): length_list1=len(list1) length_list2=len(list2) list3=[] j=0 for i in range(length_list1): while list2[j]&lt;list1[i] and j&lt;length_list2: list3.append(list2[j]) j=j+1 list3.append(list1[i]) if j&lt;(length_list2-1): for k in range(j,length_list2): list3.append(list2[k]) return list3#测试list1=[1,3,5,10]list2=[2,4,6,8,9,11,12,13,14]print merge_sort(list1,list2) 6.快速排序 123456789101112131415161718192021222324随意选择一个数字作为基准，比基准数字大的在右，比基准数字小的在左。# -*- coding:utf-8 -*-def kp(arr,i,j):#快排总函数 #制定从哪开始快排 if i&lt;j: base=kpgc(arr,i,j) kp(arr,i,base) kp(arr,base+1,j)def kpgc(arr,i,j):#快排排序过程 base=arr[i] while i&lt;j: while i&lt;j and arr[j]&gt;=base: j-=1 while i&lt;j and arr[j]&lt;base: arr[i]=arr[j] i+=1 arr[j]=arr[i] arr[i]=base return iww=[3,2,4,1,59,23,13,1,3]print wwkp(ww,0,len(ww)-1)print ww 7.堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤： 创建最大堆:将堆所有数据重新排序，使其成为最大堆 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算 代码实现： 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-def head_sort(list): length_list = len(list) first=int(length_list/2-1) for start in range(first,-1,-1): max_heapify(list,start,length_list-1) for end in range(length_list-1,0,-1): list[end],list[0]=list[0],list[end] max_heapify(list,0,end-1) return listdef max_heapify(ary,start,end): root = start while True: child = root*2 + 1 if child &gt; end: break if child + 1 &lt;= end and ary[child]&lt;ary[child+1]: child = child + 1 if ary[root]&lt;ary[child]: ary[root],ary[child]=ary[child],ary[root] root=child else: break#测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print head_sort(list) 8.计数排序 12345678910111213141516171819202122# -*- coding:utf-8 -*-def count_sort(list): max=min=0 for i in list: if i &lt; min: min = i if i &gt; max: max = i count = [0] * (max - min +1) for j in range(max-min+1): count[j]=0 for index in list: count[index-min]+=1 index=0 for a in range(max-min+1): for c in range(count[a]): list[index]=a+min index+=1 return list #测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print count_sort(list)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml语言]]></title>
    <url>%2Fbook%2FYaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Yaml语言编程Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便. 一、简介YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 它的基本语法规则如下。 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML 支持的数据结构有三种。 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 以下分别介绍这三种数据结构。 二、对象对象的一组键值对，使用冒号结构表示。 12&gt; animal: pets&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: 'pets' &#125;&gt; Yaml 也允许另一种写法，将所有键值对写成一个行内对象。 12&gt; hash: &#123; name: Steve, foo: bar &#125; &gt; 转为 JavaScript 如下。 12&gt; &#123; hash: &#123; name: 'Steve', foo: 'bar' &#125; &#125;&gt; 三、数组一组连词线开头的行，构成一个数组。 1234&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ 'Cat', 'Dog', 'Goldfish' ]&gt; 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 12345&gt; -&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ [ 'Cat', 'Dog', 'Goldfish' ] ]&gt; 数组也可以采用行内表示法。 12&gt; animal: [Cat, Dog]&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: [ 'Cat', 'Dog' ] &#125;&gt; 四、复合结构对象和数组可以结合使用，形成复合结构。 12345678910&gt; languages:&gt; - Ruby&gt; - Perl&gt; - Python &gt; websites:&gt; YAML: yaml.org &gt; Ruby: ruby-lang.org &gt; Python: python.org &gt; Perl: use.perl.org &gt; 转为 JavaScript 如下。 1234567&gt; &#123; languages: [ 'Ruby', 'Perl', 'Python' ],&gt; websites: &gt; &#123; YAML: 'yaml.org',&gt; Ruby: 'ruby-lang.org',&gt; Python: 'python.org',&gt; Perl: 'use.perl.org' &#125; &#125;&gt; 五、纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示。 12&gt; number: 12.30&gt; 转为 JavaScript 如下。 12&gt; &#123; number: 12.30 &#125;&gt; 布尔值用true和false表示。 12&gt; isSet: true&gt; 转为 JavaScript 如下。 12&gt; &#123; isSet: true &#125;&gt; null用~表示。 12&gt; parent: ~ &gt; 转为 JavaScript 如下。 12&gt; &#123; parent: null &#125;&gt; 时间采用 ISO8601 格式。 12&gt; iso8601: 2001-12-14t21:59:43.10-05:00 &gt; 转为 JavaScript 如下。 12&gt; &#123; iso8601: new Date('2001-12-14t21:59:43.10-05:00') &#125;&gt; 日期采用复合 iso8601 格式的年、月、日表示。 12&gt; date: 1976-07-31&gt; 转为 JavaScript 如下。 12&gt; &#123; date: new Date('1976-07-31') &#125;&gt; YAML 允许使用两个感叹号，强制转换数据类型。 123&gt; e: !!str 123&gt; f: !!str true&gt; 转为 JavaScript 如下。 12&gt; &#123; e: '123', f: 'true' &#125;&gt; 六、字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 12&gt; str: 这是一行字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一行字符串' &#125;&gt; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 12&gt; str: '内容： 字符串'&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '内容: 字符串' &#125;&gt; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 123&gt; s1: '内容\n字符串'&gt; s2: "内容\n字符串"&gt; 转为 JavaScript 如下。 12&gt; &#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125;&gt; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 12&gt; str: 'labor''s day' &gt; 转为 JavaScript 如下。 12&gt; &#123; str: 'labor\'s day' &#125;&gt; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 1234&gt; str: 这是一段&gt; 多行&gt; 字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一段 多行 字符串' &#125;&gt; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 1234567&gt; this: |&gt; Foo&gt; Bar&gt; that: &gt;&gt; Foo&gt; Bar&gt; 转为 JavaScript 代码如下。 12&gt; &#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;&gt; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 12345678910&gt; s1: |&gt; Foo&gt; &gt; s2: |+&gt; Foo&gt; &gt; &gt; s3: |-&gt; Foo&gt; 转为 JavaScript 代码如下。 12&gt; &#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125;&gt; 字符串之中可以插入 HTML 标记。 123456&gt; message: |&gt; &gt; &lt;p style="color: red"&gt;&gt; 段落&gt; &lt;/p&gt;&gt; 转为 JavaScript 如下。 12&gt; &#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125;&gt; 七、引用锚点&amp;和别名*，可以用来引用。 123456789101112&gt; defaults: &amp;defaults&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; &lt;&lt;: *defaults&gt; &gt; test:&gt; database: myapp_test&gt; &lt;&lt;: *defaults&gt; 等同于下面的代码。 1234567891011121314&gt; defaults:&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; adapter: postgres&gt; host: localhost&gt; &gt; test:&gt; database: myapp_test&gt; adapter: postgres&gt; host: localhost&gt; &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 123456&gt; - &amp;showell Steve &gt; - Clark &gt; - Brian &gt; - Oren &gt; - *showell &gt; 转为 JavaScript 代码如下。 12&gt; [ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]&gt; 八、函数和正则表达式的转换这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 1234&gt; # example.yml&gt; fn: function () &#123; return 1 &#125;&gt; reg: /test/&gt; 解析上面的 yml 文件的代码如下。 123456789101112&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; try &#123;&gt; var doc = yaml.load(&gt; fs.readFileSync('./example.yml', 'utf8')&gt; );&gt; console.log(doc);&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt; 从 JavaScript 对象还原到 yaml 文件的代码如下。 123456789101112131415161718&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; var obj = &#123;&gt; fn: function () &#123; return 1 &#125;,&gt; reg: /test/&gt; &#125;;&gt; &gt; try &#123;&gt; fs.writeFileSync(&gt; './example.yml',&gt; yaml.dump(obj),&gt; 'utf8'&gt; );&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt;]]></content>
      <categories>
        <category>yaml</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2Fbook%2FRabbitMQ%2F</url>
    <content type="text"></content>
      <categories>
        <category>消息中间件</category>
      </categories>
      <tags>
        <tag>消息中间件</tag>
      </tags>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E7%B1%BB%E5%9E%8B%E6%B3%A8%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[函数定义的弊端 Python是动态语言 ，变量随时可以被赋值，且能赋值为不同的类型 Python不是静态编译语言，变量类型是在运行期决定的 动态语言很灵活，但是这种特性也是弊端函数注解 Python 3.5 引入 对函数的参数进行类型注解 对函数的返回值进行类型注解 只对函数参数做一个辅助的说明，并不对函数参数进行类型检查 提供给第三方工具，做代码分析，发现隐藏的bug 函数注解的信息，保存在annotations属性中123456789def add(x:int , y:int) -&gt; int: ''' :param x: :param y: :return: ''' return x + yprint(help(add))print(add.__annotations__) 打印结果1234567add(x:int, y:int) -&gt; int :param x: :param y: :return:None&#123;'x': &lt;class 'int'&gt;, 'y': &lt;class 'int'&gt;, 'return': &lt;class 'int'&gt;&#125; 变量注解 Python 3.6引入。它也只是一种对变量的说明，非强制 i：int = 3函数参数类型检查思路 函数参数的检查，一定是在函数外，如果把检查代码侵入到函数中 函数应该作为参数，传入到检查函数中 检查函数拿到函数传入的实际参数，与形参声明对比 annotations属性是一个字典，其中包括返回值类型的声明。假设要做位置参数的判断，无法和字典中的声明对应。使用inspect模块inspet模块 提供获取对象信息的函数，可以检查函数的类、类型检查 signature(callable)，获取前面（函数签名包括了一个函数的信息，包括函数、它的参数类型、它所在的类和名称空间及其他信息）1234567891011121314import inspectdef add(x:int, y:int, *args, **kwargs) -&gt; int: return x + ysig = inspect.signature(add)print(sig,type(sig)) # 函数签名print('params:',sig.parameters) #OrderedDict print('return:',sig.return_annotation) print(sig.parameters['y'],type(sig.parameters['y']))print(sig.parameters['x'].annotation)print(sig.parameters['args'])print(sig.parameters['args'].annotation)print(sig.parameters['kwargs'])print(sig.parameters['kwargs'].annotation) 打印结果123456789(x:int, y:int, *args, **kwargs) -&gt; int &lt;class 'inspect.Signature'&gt;params: OrderedDict([('x', &lt;Parameter "x:int"&gt;), ('y', &lt;Parameter "y:int"&gt;), ('args', &lt;Parameter "*args"&gt;), ('kwargs', &lt;Parameter "**kwargs"&gt;)])return: &lt;class 'int'&gt;y:int &lt;class 'inspect.Parameter'&gt;&lt;class 'int'&gt;*args&lt;class 'inspect._empty'&gt;**kwargs&lt;class 'inspect._empty'&gt; inspect用法 inspect.isfunction(add)，是否是函数 inspect.ismethod(add)，是否是类的方法 inspect.isgenerator(add)，是否是生成器对象 inspect.isgeneratorfunction(add)，是否是生成器函数 inspect.isclass(add)，是否是类 inspect.ismodule(inspect)，是否是模块 inspect.isbuiltin(print)，是否是内建对象 还有很多is函数，可通过inspect模块帮助查阅Parameter对象 保存在元组中，是只读的 name，参数的名字 annotation，参数的注解，可能没有定义 default，参数的缺省值，可能没有定义 empty，特殊的类，用来标记default属性或者注释annotation属性的空值 kind，实参如何绑定到形参，就是形参的类型 POSITIONAL_ONLY，值必须是位置参数提供 POSITIONAL_OR_KEYWORD，值必须作为关键字或者位置参数提供 VAR_POSITIONAL，可变位置参数，对应*args KEYWORD_ONLY，keyword-only参数，对应*或者*args之后的出现的非可变关键字参数 VAR_KEYWORD，可变关键字参数，对应**kwargs例：12345678910111213import inspectdef add(x, y:int=7, *rangs, z, t=10, **kwargs) -&gt;int: return x + ysig = inspect.signature(add)print(sig)print('params:', sig.parameters)# 有序字典print('return:', sig.return_annotation)print('~~~~~~~~~~~~~~~~~~~')for i ,item in enumerate(sig.parameters.items()): name, param = item print(i+1, name, param.annotation, param.kind, param.default) print(param.default is param.empty, end='\n\n') 打印结果：123456789101112131415161718192021(x, y:int=7, *rangs, z, t=10, **kwargs) -&gt; intparams: OrderedDict([('x', &lt;Parameter "x"&gt;), ('y', &lt;Parameter "y:int=7"&gt;), ('rangs', &lt;Parameter "*rangs"&gt;), ('z', &lt;Parameter "z"&gt;), ('t', &lt;Parameter "t=10"&gt;), ('kwargs', &lt;Parameter "**kwargs"&gt;)])return: &lt;class 'int'&gt;~~~~~~~~~~~~~~~~~~~1 x &lt;class 'inspect._empty'&gt; POSITIONAL_OR_KEYWORD &lt;class 'inspect._empty'&gt;True2 y &lt;class 'int'&gt; POSITIONAL_OR_KEYWORD 7False3 rangs &lt;class 'inspect._empty'&gt; VAR_POSITIONAL &lt;class 'inspect._empty'&gt;True4 z &lt;class 'inspect._empty'&gt; KEYWORD_ONLY &lt;class 'inspect._empty'&gt;True5 t &lt;class 'inspect._empty'&gt; KEYWORD_ONLY 10False6 kwargs &lt;class 'inspect._empty'&gt; VAR_KEYWORD &lt;class 'inspect._empty'&gt;True 业务应用 有函数如下 12def add(x, y:int=7) -&gt; int: return x + y 检查用户输入是否符合参数注解的要求 思路 调用时，判断用户输入的实参是否符合要求 调用时，用户感觉上还是在调用add函数 对用户输入的数据和声明的类型进行对比，如果不符合，提示用户12345678910111213141516171819202122import inspectdef check(fn): def wrapper(*args,**kwargs): sig = inspect.signature(fn) params = sig.parameters values = list(params.values()) for i,p in enumerate(args): param = values[i] if param.annotation is not param.empty and not isinstance(p, param.annotation): print(p,'!= =',values[i].annotation) for k,v in kwargs.items(): if params[k].annotation is not inspect._empty and not isinstance(v, params[k].annotation): print(k,v,'! = = =',params[k].annotation) return fn(*args, **kwargs) return wrapper@checkdef add(x, y:int=7) -&gt; int: return x + yprint(add(20,0)) # 20]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E7%AE%97%E6%B3%95---%E6%8F%92%E5%85%A5%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[直接插入排序直接插入排序原理 在未排序序列中，构建一个子排序序列，直至全部数据排序完成 将待排序的数，插入到已经排序的序列中合适的位置 增加一个哨兵，放入待比较值，让它和后面已经拍好序的序列比较，找到合适的插入点 12345678910111213141516import randomnum = [i for i in range(10)]random.shuffle(num)# 就地打乱列表中元素顺序print(num)nums = [0] + num# 增加一个哨兵位length = len(nums)for i in range(2,length):# 跳过哨兵和第一个数，从索引2开始 nums[0] = nums[i]# 设置哨兵 j = i - 1# 往左 if nums[j] &gt; nums[0]: while nums[j] &gt; nums[0]:# 一旦有进入if，说明一定有挪动 nums[j+1] = nums[j]# 右移 j -= 1 nums[j+1] = nums[0]print(nums[1:])#利用切片将哨兵位置剔除 解析：增加一个哨兵位，每趟将戴比较数放入哨兵依次和待比较数的前一个数据比较，大数靠右移动，找到哨兵中值的插入位置每一轮结束后，得到一个开始到待比较数位置的一个有序序列 总结 最好情况，正好是升序排序，比较迭代n-1次 最差情况，正好是降序排序，比较迭代1,2,…n-1即n(n-1)/2，数据移动非常多 使用两层嵌套循环，时间复杂度O(n^2) 稳定排序算法如果待排序序列R中两元素相等，即Ri等于Rj，且i&lt;j，那么排序后这个先后顺序不变，这种排序算法就称为稳定排序 使用在小规模数据比较 优化如果比较操作耗时大的话，可以采用二分查找来提交效率，即二分查找插入排序]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E7%9A%84%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[Python的对象模型在Python中，任何对象多有类型，可以使用type()或者__class__查看但是类型也是对象即类对象，它也有自己的类型所有新类型的缺省类型是type(可以使用元类来改变) 特殊类型type是所有对象的缺省类型，也包括type自己。但它又是一个对象，因此从object继承 特殊类型object是继承树的顶层，它是python所有类型的最终基类 也就是说，继承都来自object，类型都看type。type也是对象继承自object，object也有类型是type。这俩又特殊，type类型是它自己，obkect没有基类]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E7%94%9F%E6%88%90%E5%99%A8%E5%87%BD%E6%95%B0---yield%E3%80%81%E5%8D%8F%E7%A8%8B%E5%BA%94%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC 生成器generator 生成器指的是生成器对象，可以由生成器表达式得到，也可以使用yield关键字得到一个生成器函数，调用这个函数得到一个生成器对象 生成器对象，是一个可迭代对象，是一个迭代器 生成器对象，是延迟计算、惰性求值的生成器函数 函数体中包含yield语句的函数，就是生成器函数，调用后返回生成器对象 在生成器函数中，可以多次yield 12345678910111213141516171819m = (i for i in range(5))print(type(m)) # 打印结果(类型) &lt;class 'generator'&gt; 生成器print(next(m)) # 打印结果 0def inc(): for i in range(5): yield iprint(type(inc)) # 打印结果(类型) &lt;class 'function'&gt; 函数print(type(inc())) `` # 打印结果(类型) &lt;class 'generator'&gt; 生成器g = inc()print(type(g)) # 打印结果(类型) &lt;class 'generator'&gt; 生成器print(next(g)) # 0for x in g: print(x) # 1 2 3 4print('-----------') for y in g: print(y) # 未打印 普通函数调用，函数会立即执行直到执行完毕 生成器函数调用，并不会立即执行函数体，而是需要使用next函数来驱动生成器函数执行后获得的生成器对象 生成器表达式和生成器函数都可以得到生成器对象，只不过生成器函数可以写出更加复杂的逻辑 生成器的执行12345678910111213141516def gen(): print('line 1') yield 1 print('line 2') yield 2 print('line 3') return 3 yield 4next(gen()) # line1next(gen()) # line1g = gen() #用变量记住gen函数,这样在此进行使用时就可以延续上一次未完成的print(next(g)) # line 1 1print(next(g)) # line 2 2print(next(g)) # StopIterationprint(next(g,'end')) # 没有元素给个缺省值 在生成器函数中，可以多次yield，每执行一次yield后会暂定执行，把yield表达式的值返回 再次执行会执行到下一个yield语句又会暂停执行 return语句依然可以种植函数运行，但return语句的返回值不能被获取到 return会导致当前函数返回，无法继续执行，也无法继续获取下一个值，抛出Stoplteration异常 如果函数没有显式的return语句，当生成器函数执行到结尾（相当于执行了return None），一样会抛出StopIteration异常生成器函数 包含yield语句的生成器函数调用后，生成生成器对象的时候，生成器函数的函数体不会立即执行 next(generator)会从函数的当前位置向后执行到之后碰到的第一个yield语句，会弹出值，并暂停函数执行 再次调用next函数，和上一条一样的处理过程 继续调用next函数，生成器函数如果结果执行了（显式或隐式调用了return语句），会抛出StopIteration异常生成器应用无限循环12345678910def counter(): i = 0 while True: i += 1 yield ic = counter()print(next(c)) # 打印 1print(next(c)) # 打印 2print(next(c)) # 打印 3 计数器1234567891011121314151617def inc(): def counter(): i = 0 while True: i += 1 yield i c = counter() # def inner(): # return next(c) # return inner return lambda :next(c)g = inc()print(g()) # 打印 1print(g()) # 打印 2print(g()) # 打印 3 斐波那契数列12345678910def fib(): x = 0 y = 1 while True: yield y x, y = y, x + yfoo = fib()for i in range(10): # 前10项 print(next(foo)) 生成器交互12345678910111213141516171819def inc(): def counter(): i = 0 while True: i += 1 response = yield i if response is not None: i = response c = counter() return lambda x=False: next(c) if not x else c.send(0)foo = inc()print(foo())print(foo())print(foo())print(foo(True))print(foo())print(foo())print(foo()) 协程Coroutine 生成器的高级用法 它比进程、线程轻量级，是在用户空间调度函数的一种实现 Python3 asyncio就是协程实现，已经加入到标准库 Python3.5使用async、await关键字直接原生态支持协程 协程调度器实现思路有2个生成器A、Bnext(A)，A执行到了yied语句暂停，然后去执行next(B)，B执行到yieid语句也暂停，然后再次调用next(A)，在调用next(B)，周而复始，就实现了调度的效果可以引入调度的策略来实现切换的方式 协程是一种非抢占式调度yield from 语法 从Python3.3开始增加了yield from语法，使得yield from iterable 等价于 for i in iterable: yield i yield from 就是一种简化语法的语法糖1234567891011def foo(): for x in range(5): yield x#等价于def foo(): yield from range(5)add = foo()print(next(add)) # 打印结果 0print(next(add)) # 打印结果 1print(next(add)) # 打印结果 2 本事上yield from 的意思就是，从from 后面的可迭代对象中拿元素一个个yield出去]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2Fpython%E5%90%84%E7%A7%8D%E6%A8%A1%E5%9D%97%E4%BD%BF%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@TOC random 随机数模块 random.randint(a, b) 返回 [a, b] 之间的整数 random.choice(seq)从非空序列的元素中随机挑选一个元素比如random.choice(range(10))，从0到9中 随机挑选一个整数random.choice([1,3,5,7]) random.randrange([start,] stop [,step])从指定范围内，按指定基数递增的集合中获取一个随机数，基数缺省值为1random.randrange(1,7,2) -&gt; [1,3,5,7] random.shuffle(list) -&gt; None 就地打乱列表元素 random.sample(population, k)从样本空间或总体（序列或者集合类型）中随机取出k个不同的元素，返回一个新的列表标准库datetime 模块对日期、时间、时间戳的处理datetime类方法 datetime.datetime.today()返回本地时区当前时间的datetime对象 datetime.datetime.now(tz=None)返回当前时间的datetime对象，时间到微秒，如果tz为None，返回和today()一样 datetime.datetime.utcnow()没有时区的当前时间 datetime.datetime.fromtimestamp(timestamp, tz=None)从一个时间戳返回一个datetime对象1234import datetimedt = datetime.datetime.timestamp(datetime.datetime.today())print(datetime.datetime.fromtimestamp(dt))# 2019-07-06 15:24:05.455759 datetime对象 datetime.datetime.timestamp()返回一个到微秒的时间戳时间戳：格林威治时间1970年1月1日0点到现在的秒数123import datetimeprint(datetime.datetime.timestamp(datetime.datetime.today()))# 1562397786.469274 datetime对象构造方法 datetime.datetime(2016, 12, 6, 16, 29, 43, 79043)year、month、day、hour、minute、second、microsecond，取datetime对象的年月日时分秒及微秒以下方法都需传入一个datetime对象 weekday() 返回星期的天，周一0，周日6 isoweekday() 返回星期的天，周一1，周日7 date() 返回日期date对象 time() 返回时间time对象 replace() 修改并返回新的时间 isocalendar() 返回一个三元组(年，周数，周的天) 日期格式化 类方法 strptime(date_string, format) ，返回datetime对象 对象方法 strftime(format) ，返回字符串 字符串format函数格式化 12345678910import datetimedt = datetime.datetime.strptime("21/11/06 16:30", "%d/%m/%y %H:%M")print(dt.strftime("%Y-%m-%d %H:%M:%S"))print("&#123;0:%Y&#125;/&#123;0:%m&#125;/&#123;0:%d&#125; &#123;0:%H&#125;::&#123;0:%M&#125;::&#123;0:%S&#125;".format(dt))print('&#123;:%Y-%m-%d %H:%M:%S&#125;'.format(dt))# 执行结果2006-11-21 16:30:002006/11/21 16::30::002006-11-21 16:30:00 datetime.timedelta(days=0, seconds=0, microseconds=0, milliseconds=0, minutes=0, hours=0, weeks=0)year = datetime.timedelta(days=365) total_seconds() 返回时间差的总秒数标准库time模块 time.sleep(secs) 将调用线程挂起指定的秒数]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E5%8C%BF%E5%90%8D%E5%87%BD%E6%95%B0lambda%2F</url>
    <content type="text"><![CDATA[匿名函数Lambda表达式Python中，使用Lambda表达式构建匿名函数12345678lambda x: x ** 2 #定义(lambda x: x ** 2)(4) #调用foo = lambda x,y:(x+y) ** 2 #定义函数,不推荐,不如直接定义foo(1,2)#等价于def foo(x,y): return (x+y) ** 2 使用lambda关键字定义匿名函数,格式为 lambda [参数列表]: 表达式 参数列表不需要小括号。无参就不写参数 冒号用来分割参数列表和表达式部分 不需要使用rrturn。表达式的值，就是匿名函数的返回值。表达式中不能出现等号 lambda表达式（匿名函数）只能写在一行上，也称为单行函数匿名函数往往用在未高阶函数传参时，使用lambda表达式，往往能简化代码 将函数对象加入列表中,通过索引访问 1[lambda x : x + 1][0](1) # 调用 #返回值 2 比较整数和字符串大小 123l1 = [1, 2, 'a', '1']sorted(l1, key=lambda x: ord(x) if isinstance(x, str) else x)#返回值 [1, 2, '1', 'a'] 返回常量的函数 1print((lambda :0)()) # 加法匿名函数，带缺省值 12print((lambda x,y=3:x + y)(5)) # 打印结果 8print((lambda x,y=3:x + y)(5,6)) # 打印结果 11 keyword-only参数 12print((lambda x,*,y=3:x + y)(5)) # 打印结果 8print((lambda x,*,y=3:x + y)(5,y=6)) # 打印结果 11 可变参数 123print((lambda *args:[x for x in args])(*range(5))) # 打印结果 [0, 1, 2, 3, 4]print((lambda *args:&#123;x for x in args&#125;)(*range(5))) # 打印结果 &#123;0, 1, 2, 3, 4&#125;print((lambda *args:(x for x in args))(*range(5))) # 打印结果 &lt;generator object &lt;lambda&gt;.&lt;locals&gt;.&lt;genexpr&gt; at 0x0000000001DF5E60&gt; 注:print((lambda args:(x for x in args))(range(5)))的打印结果为生成器表达式，因为(x for x in args)使用了小括号，而这种表达方式为生成一个惰性的生成器表达式]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E5%87%BD%E6%95%B0%E8%BF%94%E5%9B%9E%E5%80%BC%E4%BD%9C%E7%94%A8%E5%9F%9F%EF%BC%88%E9%97%AD%E5%8C%85%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC 函数返回值 例 return语句之后可以执行吗? 12345678910def showplus(x): print(x) return x + 1 print('-'*30) # return语句之后会执行吗showplus(5) # 5，输出结果# return之后print('-'*30)并没有执行5 # 输出结果,return之后print('-'*30)并没有执行 多条return语句都会执行吗 123456789def showplus(x): print(x) return x + 1 return x + 2showplus(5) #， 输出结果 # return之后return x + 2并没有执行 下例多个return可以执行吗? 12345678def guess(x): if x &gt; 3: return "&gt; 3" else: return "&lt;= 3"print(guess(4)) # &gt;3, 输出结果print(guess(2)) # &lt;=3,输出结果 观察下例函数执行的结果 123456789def fn(x): for i in range(x): if i &gt; 3: return i else: print("&#123;&#125; is not greater than 3".format(x))print(fn(5)) #4 输出结果print(fn(2)) # 2 is not greater than 3 ；None 输出结果 总结 Python函数使用return语句返回“返回值” 所有函数都有返回值，如果没有return语句，隐式调用retuen None return语句并不一定是函数的语句块的最后一条语句 一个函数可以存在多个return语句，但是只有一条可以被执行。如果没有一条return语句被执行到，隐式调用return None 如果有必要，可以显示调用return None，可以简写为return 如果函数执行了return语句，函数就会返回，当前被执行的reutrn语句之后的其他语句就不会被执行了 返回值的作用：结束函数调用、返回“返回值” 1234def showvalues(): return 1, 3, 5print(showvalues()) #输出结果(1, 3, 5) 函数不能同时返回多个值 return 1, 3, 5看似返回多个值，隐式的被python封装成了一个元祖 x, ,y, z =showlist() 使用结构提取返回值更为方便函数作用域作用域 一个标识符的课件范围，这就是标识符的作用域。一般常说的是变量的作用域 1234def foo(): x = 100print(x) # 可以访问到吗 上例中x不可以访问，会抛出异常（NameError:name ‘x’ is not defined）,原因在于函数是一个封装，它会开辟一个作用域，x变量被限制在这个作用域中，所以在函数外部x变量不可见 注意：每一个函数都会开辟一个作用域作用域分类 全局作用域在整个程序运行环境中都可见全局作用域中的变量称为全局变量 局部作用域在函数、类等内部课件局部作用域中的变量称为局部变量，其使用范围不能超过其所在局部作用域 局部变量 1234567def fn1(): x = 1 #局部作用域,x为局部变量,使用范围在fn1内def fn2(): print(x) # x 能打印吗? 可见吗? 为什么?print(x) #x能打印吗?可见吗?为什么? 全局变量 12345x = 5 # 全局变量，也在函数外定义def foo(): print(x) #可见吗？为什么？ foo() 一般来讲外部作用域变量在函数内部可见，可以使用 反过来，函数内部的局部变量，不能在函数外部看到函数嵌套 在一个函数中定义了另外一个函数 12345678def outer(): def inner(): print("inner") print("outer") inner() outer() # 可以调用吗inner() # 可以调用吗 内部函数inner不能在外部直接使用，会抛出NameError异常，因为它在函数外部不可见 其实，inner不过就是一个标识符，就是一个函数outer内部定义的变量而已嵌套结构的作用域对比下面嵌套结构，代码执行的效果12345678910def outer(): o = 65 def inner(): print("inner &#123;&#125;".format(o)) print(chr(0)) inner() print("outer &#123;&#125;".format(o))outer() #输出结果 inner 65 ； outer 65 1234567891011def outer2(): o = 65 def inner(): o = 97 print("inner &#123;&#125;".format(o)) print(chr(0)) inner() print("outer &#123;&#125;".format(o))outer2() #输出结果 inner 97 ； outer 65 从执行的结果来看：外层变量在内部作用域课件内部作用域inner中，如果定义了 o = 97，相当于在当前函数inner作用域中重新定义了一个新的变量o，但是，这个o并不能覆盖掉外部作用域outer2中的变量o，只不过对于inner函数来说，其只能可见自己作用域中定义的变量o 一个赋值语句的问题12345x = 5def foo(): x += 1foo() #报错如下# UnboundLocalError: local variable 'x' referenced before assignment 原因分析：x += 1其实是 x = x+1相当于在foo内部定义一个局部变量 x，那么foo内部所有x都是这个局部变量x了x = x +1 相当于使用了局部变量x，但是这个x还没有完成赋值，就被右边拿来做加1操作了 如果解决这个常见问题？ global语句123456x = 5def foo(): global x #全局变量 x +=1 print(x)foo() 使用global关键字的变量，将foo内的x声明为使用外部的全局作用域中定义的x 全局作用域中必须有x的定义使用了global，foo中的x不再是局部变量，它是全局变量总结 x += 1 这种是特殊形式产生的错误的原因？先引用后赋值，而python动态语言是赋值才算定义，才能被引用。解决办法，在这条与语句前增加x=0之类的赋值语句，或者使用global告诉内部作用域，去全局作用域查找变量定义 内部作用域使用 x= 10 之类的赋值语句会重新定义局部作用域使用的变量x，但是，一旦这个作用域中使用global声明x为全局的，那么x=5相当于在未全局作用域的变量x赋值global使用原则 外部作用域变量会在内部作用域可见，但也不要在这个内部的局部作用域中直接使用，因为函数的目的就是为了封装，列表玉外界隔离 如果函数需要使用外部全局变量，请尽量使用函数的形参定义，并在调用传实参解决 闭包 自由变量：未在本地作用域中定义的变量。例如定义在内层函数外的外层函数的作用域中的变量 闭包：就是一个概念，出现在嵌套函数中，指的是内层函数引用到了外层函数的自由变量，就形成了闭包。很多语言都有这个概念，最熟悉就是JaveSceipt 12345678910def counter(): c = [0] def inc(): c[0] += 1 return c[0] return incfoo = counter()print(foo(), foo())c = 100print(foo()) 代码分析第7行会执行counter函数并返回inc对应的函数对象，注意这个函数对象并不释放，因为有foo记着第4行不会报错，c已经在counter函数中定义过了。而且inc中的使用方式是为c的元素修改值，而不是重新定义c变量第8行打印 1 2第10行打印 3第9行的c和counter中的不一样，而inc引用的是自变量真是counter中的变量c 这就是Python2中实现闭包的方式，Python3还可以使用nonlocal关键字nonlocal语句nonlocal：将变量标记为不在本地作用域定义，而是在上级的某一级局部作用域中定义，但不能是全局作用域中定义。12345678910def counter(): count =0 def inc(): nonlocal count #声明变量count不是本地变量 count += 1 return count return incfoo = counter()print(foo(),foo()) # 打印结果 1 2 count 是外层函数的局部变量，被内部函数引用内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义代码中内层函数引用外部局部作用域中的自由变量，形成闭包 默认值的作用域123456def foo(xyz=1): print(xyz)foo() #打印 1foo() #打印 1print(xyz) #错误传参 xyz是foo函数的本地变量，不可再函数范围外直接调用 1234567def foo (xyz=[]): xyz.append(1) print(xyz)foo() #打印 [1]foo() #打印[1, 1]print(xyz) #同上 第二次调用foo函数打印的是[1, 1]因为函数也是对象，每个函数定义被执行后，就生成了一个函数对象和函数名这个标识符关联python把函数的默认值放在了函数对象的属性中，这个属性就伴随着这个函数对象的整个生命周期通过查看foo.defaults属性,它是个元祖123456789def foo (xyz=[], m=123, n='abc'): xyz.append(1) print(xyz)print(id(foo),foo.__defaults__) # 打印结果 35535864 ([], 123, 'abc')foo() # 打印结果 [1]print(id(foo),foo.__defaults__) #打印结果 35535864 ([1], 123, 'abc')foo() #打印结果[1, 1]print(id(foo),foo.__defaults__) #打印结果 35535864 ([1, 1], 123, 'abc') 函数地址并没有变，就是说foo这个函数对象没有变过，调用它，它的属性defaults中使用元祖保存默认值xyz默认值是引用类型，引用类型的元素变动，并不是元祖的变化 非引用类型缺省值12345678def foo (xyz, m=123, n='abc'): m = 456 n = 'def' print(xyz)print(foo.__defaults__) #结果 (123, 'abc')foo('hello') #结果 helloprint(foo.__defaults__) #结果 (123, 'abc') 属性defaults中使用元祖保存所有位置参数默认值，它不会因为在函数体内改变了局部变量（形参）的值而发生改变 keyword-only参数的缺省值123456789def foo(xyz, m=123, *,n='abc',t =[1, 2]): m = 456 n = 'def' t.append(30) print(xyz, m, n, t)print(foo.__defaults__,foo.__kwdefaults__) # 结果 (123,) &#123;'n': 'abc', 't': [1, 2]&#125;foo('hello') # 结果 hello 456 def [1, 2, 30]print(foo.__defaults__,foo.__kwdefaults__) # 结果 &#123;'n': 'abc', 't': [1, 2, 30]&#125; 属性defaults中使用元祖保存所有位置参数默认值 属性kwdefaults中使用字典保存所有keyword-only参数的默认值 +和+=的区别：+表示两个列表合并并返回一个全新的列表+=表示，就地修改前一个列表，在其后追加一个列表。就是extend方法变量名解析原则LEGB Local，本地作用域、局部作用域的local命名空间。函数调用时穿件，调用结束消亡 Enclosing，Python2.2时引入了嵌套函数，实现了闭包，这个就是嵌套函数的外部函数的命名空间 Global，全局作用域，即一个模块的命名空间。模块被import时创建，解释器退出时消亡 Build-in，内置模块的命名空间，生命周期从python解释器启动时创建到解释器退出时消亡。例如print(open)，print和open都是内置的变量函数的销毁 定义一个函数就是生产一个函数对象，函数名指向的就是函数对象 可以使用del语句删除函数，使用引用计数减1 可以使用同名标识符覆盖原有定义，本质上也是使其应用计数减1 Python程序结束时，所有对象销毁 函数也是对象，也不例外，是否销毁，还是看引用计数是否减为0]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%E5%87%BD%E6%95%B0%E3%80%81%E5%8F%82%E6%95%B0%E3%80%81%E5%8F%82%E6%95%B0%E8%A7%A3%E6%9E%84%2F</url>
    <content type="text"><![CDATA[@TOC Python函数函数数学定义 y=f(x)，y是x的函数，x是自变量。y=f(x0,x1,…xn)Python函数 由若干语句组成的语句块、函数名称、参数列表构成，它是组织代码的最小单元 完成一定的功能函数的作用 结构化变成对代码的最基本的封装，一般按照功能组织一段代码 封装的目的为了复用，减少冗余代码 代码更加简介美观、可读易懂函数的分类 内建函数，如max()、reversed()等 库函数，如math、ceil()等 自定义函数，使用def关键字定义 函数定义123def 函数名(参数列表): 函数体(代码块) [return 返回值] 函数名就是标识符，命名要求一样 语句块必须缩进，约定4个空格 Python的函数若没有return语句，会隐式返回一个None值 定义中的参数列表称为形式参数，只是一种符号表达（标识符），简称形参函数调用 函数定义，只是声明了一个函数，它不能被执行，需要调用执行 调用的方式，就是函数名后加上小括号，如有必要在括号内填上参数 调用时写的参数是实际参数，是实实在在传入的值，简称实参123456def add(x, y): # 函数定义 result = x + y # 函数体 return result # 返回值out = add(4, 5) # 函数调用，可能有返回值，使用变量接收这个返回值print(out) # print函数加上括号也是调用 上面代码解释： 定义一个函数add，及函数名是add，接受2个参数 该函数计算的结果，通过返回值返回，需要return语句 调用时，通过函数名add后加2个参数，返回值可使用变量接受。 函数名也是标识符，返回值也是值 定义需要在调用前 函数是可调用的对象，如callable()函数参数 函数在定义是要约定好形式参数，调用时也提供足够的十级参数，一般来说，形参和实参个数要一致（可变参数除外）传参方式位置传参 定义时def f(x,y,z)，调用使用f(1,3,5)，按照参数定义顺序传入实参关键字传参 定义时def f(x,y,z)，调用使用f(x=1, y=3, z= 5)，使用形参的名字来传入实参的方式，如果使用了形参名字，那么传参顺序就可和定义顺序不同 要求位置参数必须在关键字参数之前传入，位置参数是按位置对应的123456def f(x, y, z): passf(z=None, y=10, x=[1])f((1,), z=6, y=4.1)f(y=5, z=6, 2) #错误传参 参数缺省值缺省值也称为默认值，可以在函数定义时，为形参增加一个缺省值。其作用： 参数的默认值可以在未传入足够的实参的时候，对没有给定的参数赋值为默认值 参数非常多的时候，并不需要用户每次都输入所有的参数，简化函数调用 可在定义缺省值时，将不常修改的缺省值放在其他缺省值后12def add(x=4, y=5): return x+y 测试调用:1234567891011#用print()测一下输出结果是多少add() 9add(x=5) 10add(y=7) 11add(6, 10) 16(add(6, y=7) 13add(x=5, y=6) 11add(y=5, x=6) 11add(x=5, 6) #SyntaxErroradd(y=8, 4) #SyntaxErroradd(8, x=4) #TypeError def add(x, y=5)，这样可以定义def add(x=4, y)，这样定义会报错SyntaxError 123456789# 定义一个函数login，参数名称为lost、port、username、passworddef login(host='192.168.1.1', port='8080', username='luqx',password='luqx'): print('&#123;&#125;:&#123;&#125;@&#123;&#125;/&#123;&#125;'.format(host, port, username, password))login()login('127,0,0,1', 80, 'tom', 'tom')login('127.0.0.1', port=80, password='com')login('localhost', port=80, password='com')login(port=80, password='magedu', host='www') 输出结果12345192.168.1.1:8080@luqx/luqx127,0,0,1:80@tom/tom127.0.0.1:80@luqx/comlocalhost:80@luqx/comwww:80@luqx/magedu 可变参数 需求：写一个函数，可以对多个数累加求和12345678def sum(iterable): sum = 0 for x in iterable: sum += x return sumprint(sum([1,2,5]))print(sum(range(4))) 输出结果1286 上例，传入可迭代对象，并累加每一个元素 也可以使用可变参数完成上面的参数12345def sum(*nums): sum = 0 for x in nums: sum += x return sum 1296 可变位置参数 在形参前使用 * 表示该形参是可变位置参数，可以接受多个实参 它将收集来的实参组织到一个tuple中可变关键字参数 在形参前使用 ** 表示该形参是可变关键字参数，可以接受多个关键字参数 它将收集来的实参的名称和值，组织到一个dict中12345def showconfig(**kwargs): for k, v in kwargs.items(): print("&#123;&#125;=&#123;&#125;".format(k,v), end=',')showconfig(host='192.168.1.1', port=8080, username='tom', password='tom') 输出结果1host=192.168.1.1,port=8080,username=tom,password=tom, 总结 有可变位置参数和可变关键字参数 可变位置参数在形参前使用一个星号 * 可变关键字参数在形参前使用两个星号 ** 可变位置参数和可变关键字参数都可以收集若干个实参,可变位置参数收集形成一个tuple，可变关键字参数收集形成一个dict 混合使用参数的时候，普通参数需要放到参数列表前面，可变参数要放到参数列表的后面，可变位置参数需要在可变关键字参数之前 例:123456789def fn(x, y, *args, **kwargs): print(x, y, args, kwargs, sep='\n', end='\n\n')fn(3, 5, 7, 9, 10, a=1, b='abc')fn(3, 5)fn(3, 5, 7)fn(3, 5, a=1, b='abc')fn(x=3, y=8, 97, a=1, b='abc') # 错误传参，位置传参必须在关键字传参之前fn(7, 9, y=5, x=3, a=1, b='abc') # 错误传参，7、9已按位置传参，y=5，x=3有重复传参 keywoed-only 参数 在Python3之后，新增了keyword-only参数 keywoed-only参数：在形参定义时，在一个*星号之后，或一个可变位置参数之后，出现的普通参数，就已经不是普通的参数了，称为keyword-only参数 123456def fn(*args,x): print(x, args, sep='\n', end'\n\n')fn(3, 5) # 传参有误fn(3, 5, 7) # 传参有误fn(3, 5, x=7) keyword-only参数，言下之意就是这个参数必须采用关键字传参 可以认为，上例中，args可变位置参数已经获取了所有位置参数，其后的变量x不可能通过位置传参传入了 思考：def fn(**kwargs, x) 可以吗? 12def fn(**kwargs, x): print(x, kwargs, sep='\m', end='\n\n') 这样传参会直接报语法错误 可以认为，kwargs会截取所有关键字传参，就算写了x=5，x也没有机会得到这个值，所以这种语法不存在 keyword-only参数另一种形式 星号后所有的普通参数都称为了keyword-only参数12345def fn(*, x, y): print(x, y)fn(x=6, y=7)fn(y=8, x=9) 参数的混合使用 可变位置参数、keyword-only参数、缺省值 12345678def fn(*args, x=5): print(x) print(args)fn() # 等价于fn(x=5) # 返回值 5 ()fn(5) # 返回值 5 (5,)fn(x=6) # 6 ()fn(1, 2, 3, x=10) 10 (1, 2, 3) 普通参数、可变位置参数、keyword-only参数、缺省值 12345678910def fn(y, *args, x=5): print("x=&#123;&#125;, y=&#123;&#125;".format(x, y)) print(args)fn() # 错误传参 y未传参fn(5) fn(5, 8)fn(x=6) # 错误传参fn(1, 2, 3, x=10) fn(y=17, 2, 3, x= 10) # 错误传参，关键字传参不允许在位置传参前fn(1, 2, y=3, x=10) # 错误传参，y已经有赋值1，y=3重复传参 普通参数、缺省值、可变位置参数 123456789def fn(x=5, **kwargs ): print("x=&#123;&#125;".format(x)) print(kwargs)fn() x=5 &#123;&#125;fn(5) x=5 &#123;&#125;fn(x=6) x=6 &#123;&#125;fn(y=3, x=10) x=10 &#123;'y': 3&#125;fn(3, y=10) x=3 &#123;'y': 10&#125;fn(y=3, z=20) x=5 &#123;'y': 3, 'z': 20&#125; 参数规则 参数列表参数一般顺序是：普通参数、缺省参数、可变位置参数、keyword-only参数（可带缺省值）、可变关键字参数 注意：代码应该易读易懂，而不是为难别人请按照书写习惯定义函数参数123456789101112def fn(x, y, z=3, *args, m=4, n, **kwargs): print(x, y, z, m ,n) print(args) print(kwargs)def connect(host='localhost', port='3306', user='tom',password='tom',**kwargs): print(host, port) print(user, password) print(kwargs)connect(db='cmdb')connect(host='192.168.1.123', db='cmdb')connect(host='192.168.1.123', db='cmdb',password='mysql') 输出结果:123456789localhost 3306tom tom&#123;'db': 'cmdb'&#125;192.168.1.123 3306tom tom&#123;'db': 'cmdb'&#125;192.168.1.123 3306tom mysql&#123;'db': 'cmdb'&#125; 定义最常用参数为普通参数，可不提供缺省值，必须由用户提供，注意这些参数的顺序，最常用的先定义 必须使用名称的才能使用的参数，定义为keyword-only，要求必须使用关键字传参 如果函数有很多参数，无法逐一定义，可使用可变参数。如果需要知道这些参数的意义，则使用可变关键字参数收集 参数结构1234567891011121314def add(x, y): print(x, y) return x +yadd(4, 5)add((4, 5)) # 传参错误,只传了一个参数(4, 5)t = 4, 5add(t[0], t[1])# 将参数结构，分为两个参数add(*t)add(*(4, 5))add(*[4, 5])add(*&#123;4, 5&#125;)add(*range(4, 6)) 结果都为4, 5123add(*&#123;'a':100, 'b':11&#125;) #结果为 a b 等价于 a,badd(**&#123;'a':10, 'b':11&#125;) # 错误，**为结构成关键字传参，定义的函数中形参并没有a，badd(**&#123;'x':10, 'y':11&#125;) 结果为10 11 等价于,x=10,y=11 在给函数提供实参的时候，可以在可迭代对象前使用* 或者 ** 来进行结构的解构，提取出其中所有元素作为函数的实参 使用 * 解构成位置传参 使用 ** 解构成关键字传参 提取出来的元素数目要和参数的要求匹配123456789def add(*iterable): result = 0 for x in iterable: result += x print(result)add(1, 2, 3) # 6add(*[1, 3, 5]) # 9add(*range(5)) #10 练习1、编写一个函数，能够接受至少2个参数，返回最小值和最大值2、完成一个函数，可以接受输入的多个数，每一次都能返回到目前为止的最大值、最小值 答案 第一题答案123456def select(x,y,*args): print(x, y, args) return max(x, y, *args), min(x, y, *args)import randomprint(*select(*[random.randint(10,20) for i in range(random.randint(2, 10))])) 解析：利用max与min函数求极值， 利用random.randint生成随机数， 利用 * 结构可迭代对象 第二题答案1234567891011121314def double_values(): max_ = min_ = None while True: x = input('&gt;&gt;&gt;') nums = [int(c) for c in x.replace(',', ' ').split()] if not nums: continue if max_ is None: max_ = min_ = nums[0] max_ = max(max_, *nums) min_ = min(min_, *nums) print(max_, min_)double_values()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E8%A3%85%E9%A5%B0%E5%99%A8%E7%9A%84%E5%BA%94%E7%94%A8%EF%BC%88%E5%91%BD%E4%BB%A4%E5%88%86%E5%8F%91%E5%99%A8%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC 写一个命令分发器 程序员可以方便的注册函数到某一个命令，用户输入命令时，路由到注册的函数 如果此命令没有对应的注册函数，执行默认函数 用户输入用input(“&gt;&gt;”) 分析 输入命令映射到一个函数，并执行这个函数。应该是cmd_tbl[cmd] = fn的形式，字典正好合适 如果输入了某一个cmd命令后，没有找到函数，就要调用缺省的函数执行，这正好是字典缺省参数 cmd是字符串 1234567891011121314151617181920212223242526272829303132# 构建全局字典cmd_table = &#123;&#125;# 注册函数def reg(cmd, fn): cmd_table[cmd] = fn# 缺省函数def default_func(): print('Unknown command')# 分发器，调度def dispatcher(): while True: cmd = input("&gt;&gt;") # 退出条件 if cmd.strip() == '': return cmd_table.get(cmd, default_func)() # get，当cmd不存在时,使用缺省值defaul_func# 自定义函数def foo1(): print('hello')def foo2(): print('python') # 注册reg('hi', foo1)reg('py', foo2)# 循环dispatcher() 分析： 代码函数的注册不好看 所有的函数和字典都在全局中定义，不好 改进办法封装 将reg函数封装成装饰器，并用它来注册函数123456789101112131415161718192021222324252627282930313233343536373839def command_dispatcher(): # 构建全局字典 cmd_table = &#123;&#125; # 注册函数 def reg(cmd): def _reg(fn): cmd_table[cmd] = fn return fn return _reg # 缺省函数 def default_func(): print('Unknown command') # 分发器，调度 def dispatcher(): while True: cmd = input("&gt;&gt;") # 退出条件 if cmd.strip() == '': return cmd_table.get(cmd, default_func)() # get,当cmd不存在时,使用缺省值defaul_func return reg,dispatcher # 把两个函数标识符(分别对应函数)封装到元组中reg, dispatcher = command_dispatcher() # 将两个函数解构# 自定义函数@reg('hi')def foo1(): print('hello')@reg('py')def foo2(): print('python') # 循环dispatcher() 完善命令分发器 完善命令分发器，实现函数可以带任意参数（可变参数除外），解析参数并要求用户输入 即解决下面的问题12345678# 自定义函数@reg('hi')def foo1(x,y): print('hello', x, y)@reg('py')def foo2(a,=100): print('python', a, b) 思路 可以有2中方式 注册的时候，固定死，@reg(‘py’,200,100)可以认为@reg(‘py’,200,100)和@reg(‘py’,300,100)是不同的函数，可以用partial函数 运行时，在输入cmd的时候，逗号或空格分割，获取参数 一般用户都喜欢使用单纯一个命令如hi，然后直接显示想要的结构，就采用方式一实现方式一实现12345678910111213141516171819202122232425262728293031323334353637383940414243444546# 自定义函数可以有任意参数,可变参数、keyword-only除外def command_dispatcher(): # 构建全局字典 cmd_tbl = &#123;&#125; # 注册函数 def reg(cmd, *args, **kwargs): def _reg(fn): cmd_tbl[cmd] = fn, args, kwargs return fn return _reg # 缺省函数 def default_func(): print('Uknown command') # 调度器 def dispatcher(): while True: cmd = input('please input cmd&gt;&gt;') # 退出条件 if cmd.strip() == '': return fn, args, kwargs = cmd_tbl.get(cmd, (default_func, (), &#123;&#125;)) # get,当cmd不存在时,使用缺省值(defaul_func, (), &#123;&#125;) ，并将其解构，fn对应default_func... fn(*args,**kwargs) # 调用cmd[0]或default_func函数 return reg,dispatcherreg, dispatcher = command_dispatcher()# 自定义函数@reg('hi', z=200, y=300, x=100)@reg('hi1', z=300, y=300, x=300)@reg('hi2', 1, 2, 3)def foo1(x, y, z): print('hello',x, y, z)@reg('py', 300, b=400)def foo2(a, b=100): print('python', a, b)# 调度循环dispatcher()```python## 方法二实现 自定义函数可以有任意参数,可变参数、keyword-only除外def command_dispatcher(): # 构建全局字典 commands = {} 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950# 注册函数def reg(cmd): def _reg(fn): commands[cmd] = fn return fn return _reg# 缺省函数def default_fn(*args,**kwargs): print('Uknown command')# 调度器def dispatcher(): while True: cmd = input('&gt;&gt;') # 退出条件 if cmd.strip() == '': break else: fname, *params = cmd.replace(',', ' ').split() #list #print(params) # ['1', 'y=5'] args = [] kwargs = &#123;&#125; for param in params: x = param.split('=', maxsplit=1) # 按'='切,最大切一刀 if len(x) == 1: # 顺序传参 args.append(int(x[0])) elif len(x) == 2: # a=1 [a,1] kwargs[x[0]] = int(x[1]) #print(args, kwargs) commands.get(fname, default_fn)(*args, **kwargs) return reg, dispatcherreg, dispatcher = command_dispatcher()# 自定义函数@reg('hi')def foo1(x, y): print('hello', x, y, x+y)@reg('py')def foo2(a, b=100): print('python', a, b, a+b)# 调度循环dispatcher()# &gt;&gt; py 200 300# &gt;&gt; py 200# &gt;&gt; py 200,y=200]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%EF%BC%88re%E6%A8%A1%E5%9D%97%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOCPython使用re模块提供了正则表达式处理的能力 常量 多重选项 使用 | 位或 运算开启多重选项 如果单独存在，设计为1-9 如果多个存在，设置为1,2,4,8,16..123impoet rere.M | re.S 方法编译1re.compile(pattern, flags=0) 设定flags，编译模式，返回正则表达式对象regex pattern就是正则表达式字符串，flags是选项，指代当前工作模式。正则表达式需要被编译，为了提高效率，这些编译后的结果被保存，下次使用同样的pattern的时候，就不需要再次编译 re的其他方法为了提高效率都调用了编译方法，就是为了提速12345678# 先编译在操作import res = 'apple\nbig'regex = re.compile('^a', re.M)r = regex.match(s)print(s) 单次匹配match12re.match(pattern, string, flags=0)regex.match(string[, pos[, endpos]]) match 匹配，只从开头匹配 regex对象match方法可以重设定开始位置和结束位置。返回match对象 search12re.search(pattern, string, flags=0)regex.search(string[, pos[, endpos]]) 从头搜索直到第一个匹配 regex对象search方法可以重设定开始位置和结束位置，返回match对象 fullmatch12re.fullmatch(pattern, string, flags=0)regex.fullmatch(string[, pos[, endpos]]) 全长完全匹配，整个字符串和正则表达式匹配 match举例12345678import res = """python\nhello\nwho"""r = re.match('p', s)print(type(r), r) # match 对象，出一个结果# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(0, 1), match='p'&gt; 1234567891011# 设置模式import res = """python\nhello\nwho"""r = re.match('^h', s, re.M)print(type(r), r) # match 对象，出一个结果# 打印结果 &lt;class 'NoneType'&gt; None# None原因：虽然re.M为多行模式，但是match只从头开始找 1234567891011# 先编译，在匹配，设置开始位置import res = """python\nhello\nwho"""regex = re.compile('t', re.M)r = regex.match(s, 2) # 把索引2作为开始找print(type(r), r)#打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(2, 3), match='t'&gt;# 只有先编译，在match，才可以调整开始位置 总结：mauch不管单行多行，只从头或指定开始索引找 search举例123456789import res = """python\nhello\nwho"""#regex = re.compile('h', re.M)r = re.search('h',s) # 找到python的h就停止匹配了print(type(r), r)# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(3, 4), match='h'&gt; 1234567891011# 设置模式import res = """python\nhello\nwho"""#regex = re.compile('h', re.M)r = re.search('e',s, re.M)print(type(r), r)# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(8, 9), match='e'&gt; 1234567891011# 先编译在匹配，设置开始位置import res = """python\nhello\nwho"""regex = re.compile('h', re.M) # 设置为多行模式r = regex.search(s,4,9) # 从索引4开始，到索引8结束，[4,9)print(type(r), r)# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(7, 8), match='h'&gt; 总结： search不管是不是多行，找到就返回fullmatch举例123456789import res = """python\nhello\nwho"""regex = re.compile('.+', re.S) # .+ 在单行模式下, . 点可匹配到换行符r = regex.search(s)print(type(r), r) # match='python\nhello\nwho'# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(0, 16), match='python\nhello\nwho'&gt; 123456789import res = """python\nhello\nwho"""regex = re.compile('\w+') # 先编译r = regex.search(s, 1, 3) # 匹配 [1,3)print(type(r), r) # match =yt# 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(1, 3), match='yt'&gt; 总结：fullmatch不管单行多行模式情况下整个字符串（或指定区间）需与正则表达式匹配 全文搜索findall12re.findall(pattern,string,flags=0)regex.findall(string[, pos[, endpos]]) 对整个字符串，从左至右匹配，返回所有匹配项的列表，里面是str finditer12re.finditer(pattern,string,flags=0)regex.finditer(string[, pos[, endpos]]) 对整个字符串，从左至右匹配，返回所有匹配项，返回迭代器 注意每次迭代返回的是match对象findall举例12345678import res = """python\nhello\nwho"""r= re.findall('h',s)print(r)# 打印结果['h', 'h', 'h'] 1234567891011# 按区间匹配，需先编译import res = """python\nhello\nwho"""regex = re.compile('h')r= regex.findall(s, 3,10) # 匹配 [3,10)print(r)# 打印结果['h', 'h'] finditer举例123456789101112import res = """python\nhello\nwho"""r= re.finditer('h',s)print(r) # &lt;callable_iterator object at 0x00000000021E09B0&gt;for i in r: print(type(i),i,s[i.start():i.end()]) # s[i.start():i.end()] 切片拿到match值 # 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(3, 4), match='h'&gt; h&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(7, 8), match='h'&gt; h&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(14, 15), match='h'&gt; h 匹配替换sub12re.sub(pattern, replacement, string, count=0, flags=0)regex.sub(replacement, string, count=0) 使用pattern对字符串string进行匹配，对匹配项使用replacement替换，返回的是str replacement可是是string、bytes、function subn12re.subn(pattern, replacement, string, count=0, flags=0)regex.subn(replacement, string, count=0) 同sub返回一个元祖(new_string, number_of_subs_made) sub举例 12345678910import res = """python\nhello\nwho"""r= re.sub('h', 'ab', s)print(type(r), r)# 打印结果&lt;class 'str'&gt; pytabonabellowabo 1234567891011# 指定替换次数import res = """python\nhello\nwho"""r= re.sub('h', 'ab', s, 1) # 替换1次print(type(r), r)# 打印结果 # 仅python被替换为pytabon&lt;class 'str'&gt; pytabonhellowho 123456789101112# 先编译后替换，指定替换次数import res = """python\nhello\nwho"""regex = re.compile('h')r= regex.sub('ab', s, 2) # 替换2次print(type(r), r)# 打印结果 # 仅python和hello被替换&lt;class 'str'&gt; pytabonabellowho 引用分组，添加后缀或前缀1234567891011121314151617181920# 添加前缀import res = """honey\nhello\nhi"""r= re.sub('(h\w+)', r'python-----\1', s)print(r)# 打印结果python-----honeypython-----hellopython-----hi# 添加后缀r= re.sub('(h\w+)', r'\1------python', s)print(r)# 打印结果honey------pythonhello------pythonhi------python sunb举例1234567891011121314151617import res = """honey\nhello\nhi"""r= re.subn('h', 'p', s)print(type(r), r)# 打印结果&lt;class 'tuple'&gt; ('poney\npello\npi', 3)for i in r: print(i) # 打印结果poneypellopi3 分割字符串1re.split(pattern, string, maxsplit=0, flags=0) re.split 分割字符串1234567891011121314import res = """os.path.abspath(path)normpath(join(os.getcwd(), path))"""# 把每行单词提取出来print(s.split()) # 做不到# 打印结果['os.path.abspath(path)', 'normpath(join(os.getcwd(),', 'path))']print(re.split('[\.()\s,]+', s))# 打印结果['', 'os', 'path', 'abspath', 'path', 'normpath', 'join', 'os', 'getcwd', 'path', ''] 分组 使用小括号的pattern捕获的数据被放到了组group中 match、search函数可以返回match对象 findall返回字符穿列表；finditer返回一个个match对象group() 如果pattern中使用了分组，如果有匹配的结果，会在match对象中 使用group(N)方式返回对应分组，1到N是对应的分组，0返回整个匹配的字符串，N不写缺省为0 如果使用了命名分组，可以使用group(‘name’)的方式取分组 也可以使用groups()返回所有组 使用groupdict()返回所有命名的分组分组12345678import res = '''bottle\nbag\nbig\napple'''regex = re.compile('(b\w+)') # 先编译result = regex.match(s) # 从头开始匹配一次print(type(result)) # &lt;class '_sre.SRE_Match'&gt;print(result.group()) # bottle 命名分组 分组命名从1开始，0代表整个match对象 123456789101112131415161718192021222324import res = '''bottle\nbag\nbig\napple'''regex = re.compile('(b\w+)\n(?P&lt;name2&gt;b\w+)\n(?P&lt;name3&gt;b\w+)')result = regex.match(s)print(result) # type(result)返回的是 &lt;class '_sre.SRE_Match'&gt;# 打印结果 &lt;_sre.SRE_Match object; span=(0, 14), match='bottle\nbag\nbig'&gt;print(result.group(1),result.group(2),result.group(3)) # 通过分组索引取对应分组值# 打印结果 bottle bag bigprint(result.group('name2'),result.group('name3')) # 通过命名分组名称取对应分组值# 打印结果 bag bigprint(result.groupdict()) # 将命名分组组成kv对放入字典# 打印结果 &#123;'name2': 'bag', 'name3': 'big'&#125;print(result.group(0)) # 等效result.group() # 打印结果bottlebagbig findall用法 1234567891011import res = '''bottle\nbag\nbig\napple'''regex = re.compile('(b\w+)\n(?P&lt;name2&gt;b\w+)\n(?P&lt;name3&gt;b\w+)')result = regex.findall(s)for x in result: print(type(x),x) # 打印结果 &lt;class 'tuple'&gt; ('bottle', 'bag', 'big') finditer用法 12345678910111213import res = '''bottle\nbag\nbig\napple'''regex = re.compile('(?P&lt;head&gt;b\w+)')result = regex.finditer(s)for x in result: print(type(x), x, x.group(), x.group('head')) # 打印结果&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(0, 6), match='bottle'&gt; bottle bottle&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(7, 10), match='bag'&gt; bag bag&lt;class '_sre.SRE_Match'&gt; &lt;_sre.SRE_Match object; span=(11, 14), match='big'&gt; big big]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[@TOC 概述 正则表达式，Regular Expression，缩写为regex、regexp、RE等。 正则表达式是文本处理极为重要的技术，用它可以对字符串按照某种规则进行检索、替换。 1970年代，Unix之父Ken Thompson将正则表达式引入到Unix中文本编辑器ed和grep命令中，由此正则表达式普及开来。 1980年后，perl语言对Henry Spencer编写的库，扩展了很多新的特性。1997年开始，Philip Hazel开发出了PCRE(Perl Compatible Regular Expressions)，它被PHP和HTTPD等工具采用。 正则表达式应用极其广泛，shell中处理文本的命令、各种高级编程语言都支持正则表达式。 参考：https://www.w3cschool.cn/regex_rmjc/分类BRE 基本正则表达式，grep、sed、vi等软件支持。vim有扩展ERE 扩展正则表达式，egrep（gerp -E）、sed -r等PCRE 几乎所有高级语言都是PCRE的方言或者变种，Python从1.6开始就使用SRE正则表达式引擎，可以认为是PCRE的子集，见模块re基本语法元字符 metacharacter转义 凡是在正则表达式中有特殊意义的符号，如果想使用它的本意，需使用\转义 反斜杠自身,得使用\ \r，\n代表回车、换行重复练习 1、匹配手机号码字符串为“手机号码13899879021” 2、匹配中国坐骑字符串为“号码027-65666837、0543-5837291” 代码实现 1、\d{11} 2、\d{3,5}-\d{7,8}or匹配与分组 注意：分组和捕获是同一个意思使用正则表达式，能用简单表达式，就不要复杂的表达式零宽度断言 注意：断言不占分组号。断言如同条件，只是要求匹配必须满足断言的条件注释 贪婪与非贪婪 默认是贪婪模式，也就是说尽量多匹配更长的字符串 非贪婪很简单，在重复的符号后面加上一个？问号，就尽量的少匹配了引擎选项工作模式单行模式 . 点号可以匹配所有字符，包括换行符 ^ 表示整个字符串的开头 $ 表示整个字符串的结尾多行模式 . 点号可以匹配除了换行符之外的字符，多行不影响 . 点号 ^ 表示行首，$ 表示行尾，不过这里的行是每一行默认模式 可以看做待匹配的文本是一行，不能看做多行 . 点号不能匹配换行符 ^ 和 $ 表示行首和行尾，而行首行尾就是整个字符串的开头和结尾总结 简单讲，单行模式只影响 . 点号行为，多行模式重新定义行影响了 ^ 和 $ 字符串看不见的换行符，\r\n会影响e\$的测试，e\$ 只能匹配e\n 举例very very happyharry key 上面2行happy之后，有可能是\r\n结尾 y$ 单行匹配key的y，多行匹配happy和key的y（这里的匹配是全局匹配） .$ 指的是此行的结尾，而默认模式和单行模式都是一行，指的是这个大字符串的最后一个字符，就是key的y]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E6%A0%91Tree%2F</url>
    <content type="text"><![CDATA[@TOC 树 非线性结构 树是n(n≥0)个元素的集合n = 0时,称为空树树自由一个特殊的没有前驱的元素，称为树的根Root树中除了根节点外，其余所有元素只能有一个前驱，可以有零个或多个后继 递归定义树T是n(n≥0)个元素的集合，n = 0时，称为孔数有且自由一个特殊元素根，剩余元素都可以被划分为m个互不相交的集合T1、T2、T3、…、Tm，而每一个集合都是树，称为T的子树Subtree子树也有自己的根树的概念 结点：树中的数据元素 结点的度degree：结点拥有的子树的数目称为度，记作d(v) 叶子结点：结点的度为0，称为叶子结点leaf、终端结点、末端节点 分支结点：结点的度不为0，称为非终端结点或分支结点 分支：结点之间的关系 内部结点：除根结点外的分支结点，当然也不包括叶子特点 树的度是树内各结点的度的最大值。D结点度最大为3，树的度数就是3 孩子（儿子Child）结点：结点的子树的根结点成为该结点的孩子 双亲（父Parent）结点：一个结点是它各子树的根结点的双亲 兄弟（Sibling）结点：具有相同双亲结点的结点 祖先结点：从根结点到该结点所经分支上所有的结点。A、B、D都是G的祖先结点 子孙结点：结点的所有子树上的结点都称为该结点的子孙。B的子孙是D、G、H、I 结点的层次（Level）：根节点为第一层，根的孩子为第二层，以此类推，记作L(v) 树的深度（高度Depth）：树的层次的最大值。上图的树深度为4 堂兄弟：双亲在同一层的结点# 有序树：结点的子树是有顺序的（兄弟有大小，有先后次序），不能交换。 无序树：结点的子树是有无序的，可以交换。 路径：树中的k个结点n1、n2、…、nk，满足ni是n(i+1)的双亲，称为n1到nk的一条路径。就是一条线串下来的，前一个都是后一个的父（前驱）结点。 路径长度=路径上结点数-1，也是分支数 森林：m(m≥0)棵不相交的树的集合 对于结点而言，其子树的集合就是森林。A结点的2棵子树的集合就是森林 树的特点 唯一的根 子树不相交 除了根以外，每个元素只能有一个前驱，可以有零个或多个后继 根结点没有双亲结点（前驱），叶子结点没有孩子结点（后继） vi是vj的双亲，则L(vi) = L(vj)-1，也就是说双亲比孩子结点的层次小1 堂兄弟的双亲是兄弟关系吗？堂兄弟定义是，双亲结点是同一层的节点下图G和J是堂兄弟，因为它们的双亲结点D和E在第三层，依然是堂兄弟因此，堂兄弟的双亲不一定是兄弟关系二叉树 每个结点最多2棵子树二叉树不存在度数大于2的结点 它是有序树，左子树、右子树是顺序的，不能交换次序 即使某个结点只有一棵子树，也要确定它是左子树还是右子树二叉树的五种基本形态 空二叉树 只有一个根结点 根结点只有左子树 根结点只有右子树 根结点有左子树和右子树斜树 左斜树，所有结点都只有左子树 右斜树，所有节点都只有右子树满二叉树 一棵二叉树的所有分支结点都存在左子树和右子树，并且所有叶子结点只存在在最下面一层。 同样深度二叉树中，满二叉树结点最多。 k为深度（1≤k≤n），则结点总数为2^k-1 一个深度为4的15个结点的满二叉树完全二叉树Complete Binary Tree 若二叉树的深度为k，二叉树的层数从1到k-1层的结点数都达到了最大个数，在第k层的所有结点都集中在最左边，这就是完全二叉树 完全二叉树由满二叉树引出 满二叉树一定是完全二叉树，但完全二叉树不一定是满二叉树 k为深度（1≤k≤n），则结点总数最大值为2^k-1，当达到最大值的时候就是满二叉树二叉树性质性质1 在二叉树的第i层上至多有2^(i-1)个结点(i≥1)性质2 深度为k的二叉树，至多有2^k-1个节点(k≥1) 一层2-1=1 二层4-1=1+2=3 三层8-1=1+2+4=7性质3 对任何一棵二叉树T，如果其终端节点数为n0，度数为2的结点为n2，则有n0=n2+1 换句话说，就是叶子结点数-1就等于度数为2的结点数。-证明：总结点数为n=n0+n1+n2，n1为度数为1的结点总数。一棵树的分支数为n-1，因为除了根结点外，其余结点都有一个分支，即n0+n1+n2-1。分支数还等于n00+n11+n22，n2是2分支结点所以乘以2，2n2+n1。可得2*n2+n1=n0+n1+n2-1 =&gt; n2=n0-1其他性质 高度为k的二叉树，至少有k个结点。 含有n（n≥1）的结点的二叉树高度至多为n。和上句一个意思 含有n（n≥1）的结点的二叉树的高度至多为n，最小为math.ceil(log2 (n+1))，不小于对数值的最小整数，向上取整。 假设高度为h，2^h-1=n =&gt; h = log2 (n+1)，层次数是取整。如果是8个节点，3.1699就要向上取整为4，为4层性质4 具有n个结点的完全二叉树的深度为int(log2n)+1或者math.ceil(log2(n+1))性质5 如果有一棵n个结点的完全二叉树（深度为性质4），结点按照层序编号，如下图 如果i=1，则结点i是二叉树的根，无双亲；如果i&gt;1，则其双亲是int(i/2)，向下取整。就是子节点的编号整除2得到的就是父结点的编号。父结点如果是i，那么左孩子结点就是2i，右孩子结点就是2i+1。 如果2i&gt;n，则结点i无左孩子，即结点i为叶子结点；否则其左孩子结点存在编号为2i。 如果2i+1&gt;n，则结点i无右孩子，注意这里并不能说明结点i没有左孩子；否则右孩子结点存在编号为2i+1。]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOC 文件操作冯诺依曼体系架构 CPU由运算器和控制器组成 运算器，完成各种算数运算、逻辑运算、数据传输等数据加工处理 控制器，控制计算机各部件协调运行 存储器，用于记忆程序和数据，例如内存 输入设备，将数据或者程序输入到计算机中，例如键盘、鼠标 输出设备，将数据或程序的处理结果展示给用户，例如显示器、打印机等一般说IO操作，指的是文件IO，如果指的是网络IO，都会直接说网络IO文件IO常用操作打开操作open(file, mode=’r’, buffering=-1, encoding=None, errors=None, newline=None, closefd= True, opener=None) 打开一个文件，返回一个文件对象（流对象）和文件描述符。打开文件失败，则返回异常 基本使用：创建一个文件test，然后打开它，用完关闭 12345f = open("tese") # file对象# windows &lt;_io.TextIOWrapper name='tese' mode='r' encoding='cp936'&gt;# linux &lt;_io.TextIOWrapper name='tese' mode='r' encoding='UTF-8'&gt;print(f.read()) # 读取文件f.close() # 关闭文件 文件操作中，最常用的操作就是 “读” 和 “写” 文件访问的模式有两种： 文本模式和二进制模式。不同模式下，操作函数不相同，表现的结果也不一样注： windows中使用codepage代码页，可以认为每一个代码页就是一张编码表。cp936等同于GBKopen的参数 file 打开或者要创建的文件名。如果不指定路径，默认是当前路径 mode模式在上面的例子中，可以看到默认是文本打开模式，且是只读的r 模式 只读打开文件，如果使用write方法，会抛异常 如果文件不存在，抛出FileNotFoundError异常 open模式是只读模式r打开已存在的文件w 模式 表示只写打开方式，如果读取则抛出异常 如果文件不存在，则直接创建文件 如果文件存在，则清空文件内容 x 模式 文件不存在，创建文件，并只写方式打开 文件存在，抛出FileExistsError异常a 模式 文件存在，只写打开，追加内容 文件不存在，则创建后，只写打开，追加内容总结 r 是只读，wxa 都是只写 wxa 模式都可以产生新文件w 不管文件存在与否，都会生成全新内容的文件a 不管文件是否存在，都能在打开的文件尾部追加x 必须要求文件事先不存在，自己创建一个新文件文本模式 t 字符流，将文件的字节按照某种字符编码理解，按照字符操作。open的默认mode就是 rt二进制模式 b 字节流，将文件就按照字节理解，与字符编码无关。二进制模式操作时，字节操作使用bytes类型12345678910f = open("test3",'rb') # 二进制只读s = f.read()print(type(s)) # bytesprint(s)f.close() # 关闭文件f = open("tese3",'wb') # IO对象s = f.write("你好".encode()) # encode默认使用UTF-8编码，一个中文3个字节print(s) # 6f.ckose() + 模式 为r、w、a、x提供缺失的读或写功能，但是获取文件对象依旧按照r、w、a、x自己的特征 +模式不能单独使用，可以认为它是为前面的模式字符做增强功能的文件指针 文件指针，指向当前字节位置 mode=r，指针起始在0 mode=a，指针起始在EOF tell()显示指针当前位置 seek(offset[,whence]) 移动文件指针位置。offest偏移多少字节，whence从哪里开始文本模式下whence 0 缺省值，表示从头开始，offest只能正整数whence 1 表示从当前位置，offest只接受0whence 2 表示从EOF开始，offest只接受0 文本模式支持从开头向后偏移的方式 whence为1表示从当前位置开始偏移，但是只支持偏移0，相当于原地不动，所以没什么用 whence为2表示从EOF开始，只支持偏移0，相当于移动文件指针到EOF seek是按照字节偏移的 read在文本模式是按照字符读取的 二进制模式下whence 0 缺省值，表示从头开始，offest只能正整数whence 1 表示从当前位置，offest可正可负whence 2 表示从EOF开始，offest可正可负二进制模式支持任意起点的便宜，从头、从尾、从中间位置开始向后seek可以超界，但是向前seek的时候，不能超界，否则抛异常 buffering：缓冲区 -1表示使用缺省大小的buffer。如果是二进制模式，使用价格io.DEFAULT_BUFFER_SIZE值，默认是4096或者8192。如果是文本模式，如果是终端设备，实行缓存方式，如果不是，则使用二进制模式的策略 0，只在二进制模式使用，表示关buffer 1，只在文本模式使用，表示使用行缓冲。意思就是见到换行符就flush 大于1，用于指定buffer的大小buffer缓冲区 缓冲区一个内存空间，一般来说是一个FIFO队列，到缓冲区满了或者达到阈值，数据才会flush到磁盘。fluch() 将缓冲区数据写入磁盘chlose() 关闭前会调用flush() io.DEFAULT_BUFFER_SIZE 缺省缓冲区大小，字节二进制模式12345678910111213141516171819import iof = open('test','w+b')print(io.DEFAULT_BUFFER_SIZE) # 8192f.write("hello".encode())# cat testf.seek(0) # 指针回0# cat testf.write('python'.encode())f.flush()f.close()f = open('test','w+b',4) # 缓冲区大小f.write(b'hello')# cat testf.write(b'python')# cat testf.close() 文本模式12345678910111213141516171819import io# buffering=1，使用行缓冲f = open('test','w+',1)f.write('hello') # cat testf.write('python'*4) # cat testf.write('\n') # cat testf.write('hi\nPython') # cat testf.close()#buffering&gt;1，使用指定大小的缓冲区f = open('test','w+',15)f.write('hello') # cat testf.write('python') # cat testf.write('hi\n') # cat testf.write('\nPython') # cat testf.write('a' * (io.DEFAULT_BUFFER_SIZE - 20)) # 设置为大于1没什么用f.write('\nhelloPython')f.close() buffering=0 这是一种特殊的二进制模式，不需要内存的buffer，可以看作是一个FIFO的文件123456f = open('test','wb+',0)f.write('hello') # cat testf.write('python'*4) # cat testf.write('\n') # cat testf.write('hi\nPython') # cat testf.close() 文本模式，一般都用默认缓冲区大小 二进制模式，是一个个字节的操作，可以指定buffer的大小 一般来说，默认缓冲区大小是个比较好的选择，除非明确知道，否则不调整它 一般编程中，明确知道需要写磁盘了，都会手动调用一次flush，而不是等到自动flush或者close的时候encoding：编码，仅文本模式使用 None表示使用缺省编码，依赖操作系统。windows、linux下测试如下代码123f = open('test','w')f.write('啊')f.close() windows下缺省GBK(0xB0A1)，linux下缺省UTF-8(0xE5 95 8A) 其他参数errors 什么样的编码错误将被捕获 None和strict表示有编码错误将抛出ValueError异常；ignore表示忽略newline 文本模式中，换行的转换。可以用None、“空串、’\r’、’\n’、’\r\n’ 读时，None表示’\r’、’\n’、’\r\n’都被转换为’\n’；’’空串表示不会自动转换通用换行符；其它合法字符表示换行符就是指定字符，就会按照指定字符分行 写时，None表示’\n’都会被替换为系统缺省行分割符os.linesep；’\n’或’’空串表示’\n’不替换；其它合法字符表示’\n’会被替换为指定的字符123456789101112131415161718192021f = open('/etc/test', 'w')# newline缺省为None，windows下会把\n替换为\r\nf.write('python\rwww.python.org\nwww.baidu.com\r\npython3')# 真正写入的是# 'python\rwww.python.org\rwww.baidu.com\r\rpython3'f.close()newlines = [None, '', '\n', '\r\n']for nl in newlines: f = open('/etc/test', newline=nl) # 缺省替换所有换行符 print(f.readlines()) f.close()# 运行结果如下# ['python\n', 'www.python.org\n', 'www.baidu.con\n', '\n', 'python3']# 常见换行符都替换为\n# ['python\r', 'www.python.org\r\n', 'www.baidu.con\r', '\r\n', 'python3']# ''表示什么都不做# ['python\rwww.python.org\r\n', 'www.baidu.con\r\r\n', 'python3']# \n做作为换行符# ['python\rwww.python.org\r\n', 'www.baidu.con\r\r\n', 'python3']# \r\n作为换行符 closefd 表示文件描述符，True表示关闭它。False会在文件关闭后保持这个描述符。fileobj.fileno()查看read read(size=-1) size表示读取的多少个字符或字节；负数或者None表示读取到EOF123456789101112f = open('/etc/test', 'r+')f.write("hello")f.write('\n')f.write('你好')f.seek(0)f.read(7)f.close()# 二进制f = open('/etc/test', 'rb+')f.read(7)f.read(1)f.close() 行读取readline(size=1) 一行行读取文件内容。size设置一次能读取行内几个字符或字节readlines(hint=-1) 读取所有行的列表。指定hint则返回指定的行数1234567# 按行迭代f = open('test') # 返回可迭代对象for line in f: print(line.encode())f.close() write write(s)，把字符串s写入到文件中并返回字符的个数 writelines(lines)，将字符串列表写入文件12345678f = open('test', 'w+'）line = ['abc', '123\n', 'hello'] # 提供换行符f.writelines(lines)f.seek(0)print(f.read())f.close() close flush并关闭文件对象 文件已经关闭，再次关闭没有任何效果其他上下文管理 在Linux中，执行123456lst = []for _ in range(2000): lst.append(open('test'))# OSError: [Errno 24] Too many open files: 'test'print(len(lst)) lsof：列出打开的文件没有就# yum install lsof123$ ps aux | grep python$ lsof -p 9255 | grep test |wc -1$ ulimit -a ps命令返回进程，grep处python进程ID lsof -p 进程号，列出该进程的所有文件描述符，grep出test文件的文件描述符，wc统计 ulimit -a 查看所有限制。其中open files就是打开问价数的限制，默认102412for x in lst: x.close() 将文件一次关闭，然后就可以继续打开了。再看一次lsof1、异常处理 当出现异常的时候，拦截异常。但是，因为很多代码都可能出现OSError异常，还不好判断异常就是因为资源限制产生的 12345f = open('test')try: f.writs("abc") # 文件只读，写入失败finally: f.close() # 这样才行 使用finally可以保证打开的文件可以被关闭2、上下文管理一种的特殊语法，交给解释器去释放文件对象 上下文管理123456del fwith open('test') as f: f.write('abc') # 文件只读，写入失败#测试f是否关闭f1.closed 对于类似文件对象的IO对象，一般来说都需要在不使用的时候关闭、注销，以释放资源 IO被打开的时候，会获得一个文件描述符。计算机资源是有限的，所以操作系统都会做限制。就是为了保护计算机的资源不要被完全耗尽，计算资源是共享的，不是独占的 一般情况下，除非特别明确的知道资源情况，否则不要提高资源的限制值来解决问题]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython-%E5%8F%8D%E5%B0%84%2F</url>
    <content type="text"><![CDATA[概述运行时，区别于编译时，指的是程序被加载到内存中执行的时候反射，reflection，指的是运行时获取类型定义信息一个对象能够在运行时，像照镜子一样，反射处其类型信息简单说，在python中，能够通过一个对象，找出其type、class、attribute或method的能力，称为反射或者自省具有反射能力的函数有type()、isinstance()、callable()、dir()、getattr()等反射相关的函数和方法需求有一个Point类，查看它实例的属性，并修改它。动态为实例增加属性1234567891011121314151617181920class Point: def __init__(self, x, y): self.x = x self.y = y def __str__(self): return "Point(&#123;&#125;, &#123;&#125;)".format(self.x, self.y) def show(self): print(self.x, self.y)p = Point(4, 5)print(p) # Point(4, 5)print(p.__dict__) # &#123;'x': 4, 'y': 5&#125;p.__dict__['y'] = 16 # &#123;'x': 4, 'y': 16&#125;print(p.__dict__) # &#123;'x': 4, 'y': 16, 'z': 10&#125;p.z = 10print(p.__dict__)print(dir(p))print(p.__dir__()) 上例通过属性字典__dict__来访问对象的属性，本质上也是利用的反射的能力。Python提供了内置的函数|内建函数|意义||:–|:–||getattr(object,name[,default])|通过name返回object的属性值。当属性不存在，将使用default返回，如果没有default，则抛出AttributeError。name必须为字符串||setattr(object,name,value)|object的属性存在，则覆盖，不存在，新增||hasattr(object,name)|判断对象是否有这个名字的属性，name必须为字符串|12345678910111213141516171819202122232425262728293031323334353637383940414243444546class Point: def __init__(self, x, y): self.x = x self.y = y def __str__(self): return "Point(&#123;&#125;, &#123;&#125;)".format(self.x, self.y) def show(self): print(self)p1 = Point(4, 5)p2 = Point(10, 10)print(repr(p1), repr(p2))print(p1.__dict__) # &#123;'x': 4, 'y': 5&#125;setattr(p1, 'y', 16)setattr(p1, 'z', 16)print(getattr(p1, '__dict__')) # &#123;'x': 4, 'y': 16, 'z': 16&#125;# 动态调用方法if hasattr(p1, 'show'): getattr(p1, 'show')() # Point(4, 16)# 动态增加方法# 为类增加方法if not hasattr(Point, 'add'): setattr(Point, 'add', lambda self,other: Point(self.x +other.x, self.y + other.y))print(Point.add) # &lt;function &lt;lambda&gt; at 0x000002018E6E51E0&gt;print(p1.add) # &lt;bound method &lt;lambda&gt; of &lt;__main__.Point object at 0x000001EC6C2A86A0&gt;&gt;print(p1.add(p2)) # 绑定 # Point(14, 26)# 为实例增加方法，未绑定if not hasattr(p1, 'sub'): setattr(p1, 'sub', lambda self, other: Point(self.x - other.x, self.y - other.y))print(p1.sub(p1, p1)) # Point(0, 0)print(p1.sub) # &lt;function &lt;lambda&gt; at 0x0000018C324E5620&gt;# add在谁里面， sub在谁里面print(p1.__dict__) # &#123;'x': 4, 'y': 16, 'z': 16, 'sub': &lt;function &lt;lambda&gt; at 0x00000180472D5620&gt;&#125;print(Point.__dict__)# &#123;'__module__': '__main__', '__init__': &lt;function Point.__init__ at 0x00000180472D5158&gt;,\# '__str__': &lt;function Point.__str__ at 0x00000180472D5268&gt;, 'show': &lt;function Point.show at 0x00000180472D5598&gt;, \# '__dict__': &lt;attribute '__dict__' of 'Point' objects&gt;, '__weakref__': &lt;attribute '__weakref__' of 'Point' objects&gt;,\# '__doc__': None, 'add': &lt;function &lt;lambda&gt; at 0x00000180472D51E0&gt;&#125; 思考 这种动态增加属性的方式和装饰器修饰一个类、Mixin方式的差异在哪里 这种动态增删属性的方式是运行时改变类或者实例的方式，但是装饰器或Mixin都是定义时就决定了，因此反射能力具有更大的灵活性 练习 命令分发器，通过名称找到对应的函数执行 思路：名称找对象的方法12345678910111213141516171819class Dispatcher: def __init__(self): pass def reg(self, name, fn): setattr(self, name, fn) def run(self): while True: cmd = input('&gt;&gt;&gt;').strip() if cmd == 'quit': break getattr(self, cmd, lambda :print('Unknowm Cmd &#123;&#125;'.format(cmd)))()dis = Dispatcher()dis.reg('ls', lambda :print('ls'))dis.run() 上例中使用getattr方法找到对象的属性的方式，比自己维护一个字典来建立名词和函数之间的关系的方式好多了 反射相关的魔术方法__getattr__()、__setattrr__()、__delattr__() __getattr__()123456789101112131415161718192021class Base: n = 0class Point(Base): z = 6 def __init__(self, x, y): self.x = x self.y = y def show(self): print(self.x, self.y) def __getattr__(self, item): return "missing &#123;&#125;".format(item)p1 = Point(4,5)print(p1.x) # 4print(p1.z) # 6print(p1.n) # 0print(p1.y) # 5 实例属性会按照继承关系找，如果找不到，就会执行__getattr__()方法，如果没有这个方法，就会抛出AttrbuteError异常表示找不到属性 查找属性的顺序：instance.__dict__ –&gt; instance.__class__.__dict__ –&gt; 继承的祖先类(直到object)的__dict –&gt; 找不到调用__getattr__()__setattrr__()12345678910111213141516171819202122232425262728293031323334353637383940414243class Base: n = 0class Point(Base): z = 6 def __init__(self, x, y): self.x = x self.y = y def show(self): print(self.x, self.y) def __getattr__(self, item): return "missing &#123;&#125;".format(item) def __setattr__(self, key, value): print("setattr &#123;&#125;=&#123;&#125;".format(key,value))p1 = Point(4,5)print(1, p1.x)print(2, p1.z) print(3, p1.n)print(4, p1.t)p1.x = 50print(5, p1.x)print(6, p1.__dict__)p1.__dict__['x'] = 60print(7, p1.__dict__)print(8, p1.x)执行结果setattr x=4setattr y=51 missing x2 63 04 missing tsetattr x=505 missing x6 &#123;&#125;7 &#123;'x': 60&#125;8 60 实例通过.点号设置属性，例如self.x = x属性赋值，就会调用__setattr_-()，属性要加到实例的__dict__中，就需要自己完成12345678910111213141516class Point(Base): z = 6 def __init__(self, x, y): self.x = x self.y = y def show(self): print(self.x, self.y) def __getattr__(self, item): return "missing &#123;&#125;".format(item) def __setattr__(self, key, value): print("setattr &#123;&#125;=&#123;&#125;".format(key,value)) self.__dict__[key] = value # 操作字典 __setattr__()方法，可以拦截对实例属性的增加、修改操作，如果要设置生效，需要自己操作实例的__dict__ 例子__getattr__和__setattr__综合使用123456789101112131415161718192021222324252627282930313233343536373839404142434445class B: b = 200class A(B): z = 100 d = &#123;&#125; def __init__(self, x, y): self.x = x setattr(self, 'y', y) self.__dict__['a'] = 5 def __getattr__(self, item): print('------', item) return self.d[item] def __setattr__(self, key, value): print('setattr key ', key) print('setattr key ', value) self.d[key] = value def __delattr__(self, item): print('can not del &#123;&#125;'.format(item))a = A(4, 5)print(a.__dict__)print(A.__dict__)print(a.x , a.y)print(a.a)# 执行结果setattr key xsetattr key 4setattr key ysetattr key 5&#123;'a': 5&#125;&#123;'__module__': '__main__', 'z': 100, 'd': &#123;'x': 4, 'y': 5&#125;,\ '__init__': &lt;function A.__init__ at 0x000001062E6C5158&gt;,\ '__getattr__': &lt;function A.__getattr__ at 0x000001062E6C5268&gt;, \ '__setattr__': &lt;function A.__setattr__ at 0x000001062E6C5598&gt;, \ '__delattr__': &lt;function A.__delattr__ at 0x000001062E6C5620&gt;, \ '__doc__': None&#125;------ x------ y4 55 __delattr__()123456789101112131415161718class Point: Z = 5 def __init__(self, x, y): self.x = x self.y = y def __delattr__(self, item): print('Can not del &#123;&#125;'.format(item))p = Point(4, 5)del p.xp.z = 15del p.zdel p.Zprint(Point.__dict__)print(p.__dict__)del Point.Zprint(Point.__dict__) 执行结果12345678910Can not del xCan not del zCan not del Z&#123;'__module__': '__main__', 'Z': 5, '__init__': &lt;function Point.__init__ at 0x0000029FBF8B5158&gt;, \'__delattr__': &lt;function Point.__delattr__ at 0x0000029FBF8B5268&gt;, '__dict__': &lt;attribute '__dict__' of 'Point' objects&gt;, \'__weakref__': &lt;attribute '__weakref__' of 'Point' objects&gt;, '__doc__': None&#125;&#123;'x': 4, 'y': 5, 'z': 15&#125;&#123;'__module__': '__main__', '__init__': &lt;function Point.__init__ at 0x0000029FBF8B5158&gt;, \'__delattr__': &lt;function Point.__delattr__ at 0x0000029FBF8B5268&gt;, '__dict__': &lt;attribute '__dict__' of 'Point' objects&gt;,\ '__weakref__': &lt;attribute '__weakref__' of 'Point' objects&gt;, '__doc__': None&#125; 可以阻止通过实例来删除属性的操作。但是通过类依然可以删除属性 __getattribute__()123456789101112131415161718192021222324252627class Base: n = 0class Point(Base): z = 6 def __init__(self, x , y): self.x = x self.y = y def __getattr__(self, item): return "missing &#123;&#125;".format(item) def __getattribute__(self, item): return itemp1 = Point(4, 5)print(p1.__dict__) # __dict__print(p1.x) # xprint(p1.z) # zprint(p1.n) # nprint(p1.t) # tprint(Point.__dict__)# &#123;'__module__': '__main__', 'z': 6, '__init__': &lt;function Point.__init__ at 0x0000016930285158&gt;,\ '__getattr__': &lt;function Point.__getattr__ at 0x0000016930285268&gt;, \ '__getattribute__': &lt;function Point.__getattribute__ at 0x0000016930285598&gt;, '__doc__': None&#125;print(Point.z) # 6 实例的所有的属性访问，第一个都会调用__getattribute__方法，它阻止了属性的查找，该方法应该返回（计算后的）值或者抛出一个AttributeError异常 它的return值将作为属性查找的结果 如果抛出AttributeError异常，则会直接调用__getattr__方法，表示属性没有找到 1234567891011121314151617181920212223242526272829class Base: n = 0class Point(Base): z = 6 def __init__(self, x , y): self.x = x self.y = y def __getattr__(self, item): return "missing &#123;&#125;".format(item) def __getattribute__(self, item): # raise AttributeError("Not Found") # pass # return self.__dict__[item] # RecursionError return object.__getattribute__(self, item)p1 = Point(4, 5)print(p1.__dict__) # &#123;'x': 4, 'y': 5&#125;print(p1.x) # 4print(p1.z) # 6print(p1.n) # 0print(p1.t) # missing tprint(Point.__dict__)# &#123;'__module__': '__main__', 'z': 6, '__init__': &lt;function Point.__init__ at 0x0000029AF7765158&gt;, \'__getattr__': &lt;function Point.__getattr__ at 0x0000029AF7765268&gt;, \'__getattribute__': &lt;function Point.__getattribute__ at 0x0000029AF7765598&gt;, '__doc__': None&#125;print(Point.z) # 6 __getattribute__方法中为了避免在该方法中无限的递归，它的实现应该永远调用基类的同名方法打以访问需要的任何属性，例如object.__getattribute__(self, item) 除非明确地知道__getattribute__方法用来做什么，否则不要使用它总结|魔术方法|意义||:–|:–||__getattr__()|当通过搜索实例、实例的类及祖先类查不到属性，就会调用此方法||__setattr__()|通过.点访问实例属性，进行增加、修改都要调用它||__delattr__()|当通过实例来删除属性时调用此方法||__getattribute__()|实例所有的属性调用都从这个方法开始| 属性查找顺序：实例调用__getattribute__() –&gt; instance.__dict__ –&gt; instance.__class__.__dict__ –&gt; 继承的祖先类(直到object)的__dict__–&gt;调用__getattr__()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95--%E4%B8%8A%E4%B8%8B%E6%96%87%E7%AE%A1%E7%90%86%2F</url>
    <content type="text"><![CDATA[@TOC 上下文管理文件IO操作可以对文件对象使用上下文管理，使用with..as语法12with open('test') as f: pass 仿照上例写一个自己的类，实现上下文管理12345class Point： passwith Point() as p: # AttributeError: __exit__ pass 提示属性错误，没有__exit__，看了需要这个属性某些版本会显示没有__enter__ 上下文管理对象当一个对象同时实现了__enter()__和__exit__()方法，它就属于上席文管理的对象|方法|意义||:–|:–||__enter__|进入与此对象相关的上下文。如果存在该方法，with语法会把该方法的返回值作为绑定到as子句中指定的变量上||__exit__|退出与此对象相关的上下文|1234567891011121314151617181920212223242526272829import timeclass Point(): def __init__(self): print('init =========') time.sleep(1) print('init over =====') def __enter__(self): print('enter ========') def __exit__(self, exc_type, exc_val, exc_tb): print('exit =========')with Point() as p: print('in with =========') time.sleep(2) print('with over ========')print('======end======')# 执行结果init =========init over =====enter ========in with =========with over ========exit ===============end====== 实例化对象的时候，并不会调用enter，进入with语句块调用__enter__方法，然后执行语句体，最后离开with语句块的时候，调用__exit__方法 with可以开启一个上下文运行环境，在执行前做一些准备工作，执行后做一些首位工作。 注意，with并不开启一个新的作用域上下文管理的安全性 异常对上下文的影响123456789101112131415161718192021import timeclass Point(): def __init__(self): print('init =========') time.sleep(1) print('init over =====') def __enter__(self): print('enter ========') def __exit__(self, exc_type, exc_val, exc_tb): print('exit =========')with Point() as p: print('in with =========') raise Exception('error') time.sleep(2) print('with over ========')print('======end======') 执行结果虽然有异常弹出，但是enter和exit照样执行，上下文管理是安全的 极端的例子调用sys.exit()，它会退出当前解释器打开python解释器，在里面输入 sys.exit()，窗口直接关闭，也就是说碰到这一句，Python运行环境直接退出12345678910111213141516171819202122import timeclass Point(): def __init__(self): print('init =========') time.sleep(1) print('init over =====') def __enter__(self): print('enter ========') def __exit__(self, exc_type, exc_val, exc_tb): print('exit =========')with Point() as p: print('in with =========') import sys sys.exit(1) time.sleep(2) print('with over ========')print('======end======') 执行结果1234567init =========init over =====enter ========in with =========exit =========Process finished with exit code 1 从执行结果来看，依然执行了__exit__函数，哪怕是退出Python运行环境说明上下文管理很安全 with语句123456789101112131415161718192021222324class Point(): def __init__(self): print('init') def __enter__(self): print('enter') def __exit__(self, exc_type, exc_val, exc_tb): print('exit')f = open('t3.py')with f as p: print(f) print(p) print(1,f is p) # 打印什么 print(2,f == p) # 打印什么p = Point()with p as f: print('in with-----') print(3,p == f) print('with over')print('======end======') 执行结果1234567891011&lt;_io.TextIOWrapper name='t3.py' mode='r' encoding='cp936'&gt;&lt;_io.TextIOWrapper name='t3.py' mode='r' encoding='cp936'&gt;1 True2 Trueinitenterin with-----3 Falsewith overexit======end====== 问题在于__enter__方法上，它将自己的返回值赋给f。修改上例123456789101112131415161718class Point(): def __init__(self): print('init') def __enter__(self): print('enter') return self # 增加返回值 def __exit__(self, exc_type, exc_val, exc_tb): print('exit')p = Point()with p as f: print('in with-----') print(p == f) print('with over')print('======end======') 执行结果1234567initenterin with-----Truewith overexit======end====== with语句，会调用with后的对象的__enter__方法，如果有as，则将该方法的返回值赋给as子句的变量上例，可以等价为f = p.__enter__() 方法的参数__enter__方法 没有其他参数__exit__方法有3个参数__exit__(self, exc_type, exc_value, traceback) 这三个参数都与异常有关。 如果该上下文退出时没有异常，这3个参数都为None 如果有异常，参数意义如下：exc_type，异常类型exc_value，异常的值traceback，异常的追踪信息 __exit__方法返回一个等效True的值，则压制异常；否则，继续抛出异常1234567891011121314151617181920212223class Point(): def __init__(self): print('init') def __enter__(self): print('enter') return self # 增加返回值 def __exit__(self, exc_type, exc_val, exc_tb): print(1, exc_type) print(2, exc_val) print(3, exc_tb) print('exit') return 'abc' # return 值恒等为True，压制报错 # return None # 0 # []p = Point()with p as f: print('in with-----') raise Exception('Error') print('with over')print('======end======') 执行结果12345678initenterin with-----1 &lt;class 'Exception'&gt;2 Error3 &lt;traceback object at 0x00000259B3BFDB88&gt;exit======end====== 练习为加法函数计时方法1、使用装饰器显示该函数的执行市场方法2、使用上下文管理方法来显示该函数的执行时长12345import timedef add(x, y): time.sleep(2) return x + y 装饰器实现12345678910111213141516171819202122232425262728import timeimport datetimefrom functools import wrapsdef timeit(fn): @wraps(fn) def wrapper(*args, **kwargs): start = datetime.datetime.now() ret = fn(*args, **kwargs) delta = (datetime.datetime.now() - start).total_seconds() print('&#123;&#125; took &#123;&#125;s'.format(fn.__name__,delta)) return ret return wrapper@timeitdef add(x, y): time.sleep(2) return x + yprint(add(4,5))def add(x, y): time.sleep(2) return x + y# 执行结果add took 2.000913s9 上下文实现1234567891011121314151617181920212223242526272829303132333435363738import timeimport datetimefrom functools import wrapsdef timeit(fn): @wraps(fn) def wrapper(*args, **kwargs): start = datetime.datetime.now() ret = fn(*args, **kwargs) delta = (datetime.datetime.now() - start).total_seconds() print('&#123;&#125; took &#123;&#125;s'.format(fn.__name__,delta)) return ret return wrapper@timeitdef add(x, y): time.sleep(2) return x + yclass TimeIt: def __init__(self, fn): self.fn = fn def __enter__(self): self.start = datetime.datetime.now() return self.fn def __exit__(self, exc_type, exc_val, exc_tb): delta = (datetime.datetime.now() - self.start).total_seconds() print("&#123;&#125; took &#123;&#125;s".format(self.fn.__name__,delta))with TimeIt(add) as fn: print(add(4, 7)) # 执行结果add took 2.000563s11add took 2.000563s 可调用对象实现123456789101112131415161718192021222324252627282930313233343536373839404142import timeimport datetimefrom functools import wrapsdef timeit(fn): @wraps(fn) def wrapper(*args, **kwargs): start = datetime.datetime.now() ret = fn(*args, **kwargs) delta = (datetime.datetime.now() - start).total_seconds() print('&#123;&#125; took &#123;&#125;s'.format(fn.__name__,delta)) return ret return wrapper@timeitdef add(x, y): time.sleep(2) return x + yclass TimeIt: def __init__(self, fn): self.fn = fn def __enter__(self): self.start = datetime.datetime.now() return self.fn def __exit__(self, exc_type, exc_val, exc_tb): delta = (datetime.datetime.now() - self.start).total_seconds() print("&#123;&#125; took &#123;&#125;s".format(self.fn.__name__,delta)) def __call__(self, x, y): print(x, y) return self.fn(x, y)with TimeIt(add) as timeitobj: print(timeitobj(4, 7))# 执行结果add took 2.000302s11add took 2.000302s 将上面代码的类当装饰器使用12345678910111213141516171819202122232425262728293031323334353637import timeimport datetimefrom functools import wrapsclass TimeIt: def __init__(self, fn): self.fn = fn def __enter__(self): self.start = datetime.datetime.now() return self.fn def __exit__(self, exc_type, exc_val, exc_tb): delta = (datetime.datetime.now() - self.start).total_seconds() print("&#123;&#125; took &#123;&#125;s".format(self.fn.__name__,delta)) pass def __call__(self, *args, **kwargs): self.start = datetime.datetime.now() ret = self.fn(*args, **kwargs) self.delta = (datetime.datetime.now() - self.start).total_seconds() print('&#123;&#125; took &#123;&#125;s'.format(self.fn.__name__, self.delta)) return ret@TimeItdef add(x, y): """This is add function.""" time.sleep(2) return x + yadd(4, 5)print(add.__doc__)# print(add.__name__) # 异常，没有此属性# 执行结果add took 2.000581sNone 解决文档字符串的问题 方法一直接修改__doc__ 12345class TimeIt: def __init__(self, fn=None): self.fn = fn # 把函数对象的文档字符串赋给类 self.__doc__ = fn.__foc__ 方法2使用functools.wraps函数 12345678910111213141516171819202122232425262728293031323334353637383940414243import timeimport datetimefrom functools import wrapsclass TimeIt: """This is A Class""" def __init__(self, fn): self.fn = fn # 把函数对象的文档字符串赋给类 # self.__doc__ = fn.__doc__ # update_wrapper(self, fn) wraps(fn)(self) def __enter__(self): self.start = datetime.datetime.now() return self.fn def __exit__(self, exc_type, exc_val, exc_tb): delta = (datetime.datetime.now() - self.start).total_seconds() print("&#123;&#125; took &#123;&#125;s".format(self.fn.__name__,delta)) def __call__(self, *args, **kwargs): self.start = datetime.datetime.now() ret = self.fn(*args, **kwargs) self.delta = (datetime.datetime.now() - self.start).total_seconds() print('&#123;&#125; took &#123;&#125;s'.format(self.fn.__name__, self.delta)) return ret@TimeItdef add(x, y): """This is add function.""" time.sleep(2) return x + yprint(add(4, 5))print(add.__doc__)print(TimeIt(add).__doc__)# 执行结果add took 2.000641s9This is add function.This is add function. 上面的类即可以用在上下文管理，又可以用作装饰器 上下文应用场景 增强功能在代码执行的前后增加代码，以增强其功能。类似装饰器的功能 资源管理打开了资源需要关闭，例如文件对象、网络连接、数据库连接等 权限验证在执行代码之前，做权限的验证，在__enter__中处理contextlib.contextmanager 它是一个装饰器实现上下文管理，装饰一个函数，而不用像类一样实现__enter__和__exit__方法 对下面的函数有要求，必须有yield，也就是这个函数必须返回一个生成器，且只有yield一个值 这个装饰器接受一个生成器对象作为参数12345678910111213141516import contextlib@contextlib.contextmanagerdef foo(): print('enter') # 相当于__enter__() yield # yield 5, yield的值只能有一个，作为__enter__方法的返回值 print('exit') # 相当于 __exit__()with foo() as f: # raise Exception() print(f)# 执行结果enterNoneexit as后的f接受yield语句的返回值 上面程序如果打开 raise Exception()语句，则print(&#39;exit&#39;)不会执行 解决办法：增加try finally 12345678910111213import contextlib@contextlib.contextmanagerdef foo(): print('enter') # 相当于__enter__() try: yield # yield 5, yield的值只能有一个，作为__enter__方法的返回值 finally: print('exit') # 相当于 __exit__()with foo() as f: raise Exception() print(f) 执行结果上例当yield发生处为生成器函数增加了上下文管理。这就是为函数增加上下文机制的方式 把yield之前的当做__enter__方法执行 把yield之后的当做__exit__方法执行 把yield的值作为__enter__的返回值123456789101112131415161718192021import contextlibimport datetimeimport time@contextlib.contextmanagerdef foo(x, y): # 为生成器函数增加了上下文管理 start = datetime.datetime.now() try: time.sleep(2) yield x + y #yield的值只能有一个，__enter__方法的返回值 finally: delta = (datetime.datetime.now() - start).total_seconds() print(delta) # 相当于 __exit__()with foo(4, 5) as f: # raise Exception() print(f)# 执行结果92.000907 总结如果业务逻辑加单可以使用函数加contextlib.contextmanager装饰器方式，如果业务复杂，用类的方式加__enter__和__exit__方法方便]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1--%E7%B1%BB%E7%9A%84%E7%BB%A7%E6%89%BF%2F</url>
    <content type="text"><![CDATA[@TOC 基本概念面向对象三要素之一，继承Inheritance在面向对象的世界中，从父类继承，就可以直接拥有父类的属性和方法，这样可以减少代码、多复用。子类可以定义自己的属性和方法 定义格式如下12class 子类名(基类1[,基类2,...]): 语句块 如果类定义时，没有基类列表，等同于继承自object。在Python3中，object类是所有对象的根基类12345class A: pass# 等价于class A(object): pass 注意，上例在Python2中，两种写法是不同的Python支持多继承，继承也可以多级 继承class Son(Father) 这种形式就是父类继承，括号中写上继承的类的列表继承可以让子类从父类获取特征（属性和方法） 父类Father就是Son的父类，也称为基类、超类 子类Son就是Father的子类，也称为派生类单一继承(括号类写一个)1234567891011class Animal: def shout(self): print('Animal shouts')class Cat(Animal): passa = Animal()a.shout() # Animal shoutsc = Cat()c.shout() # Animal shouts 取当前实例类型的名称1234567891011class Animal: def shout(self): print('&#123;&#125; shouts'.format(type(self).__name__))class Cat(Animal): passa = Animal()a.shout() # Animal shoutsc = Cat()c.shout() # Cat shouts 继承的特殊属性和方法123456789101112131415161718192021222324252627class Animal: def shout(self): print('&#123;&#125; shouts'.format(type(self).__name__))class Cat(Animal): passclass Dog(Animal): passprint(Cat.__base__) # 类的基类 print(Dog.__bases__) # 类的基类元祖 print(Animal.__bases__) # 类的基类元祖 # mro：方法解析顺序，可看清楚继承路线print(Cat.mro() # 显示方法查找顺序，基类的列表print(Cat.__mro__) #显示方法查找顺序，基类的元组print(Animal.__subclasses__()) # 类的子类列表# 打印结果&lt;class '__main__.Animal'&gt;(&lt;class '__main__.Animal'&gt;,)(&lt;class 'object'&gt;,)[&lt;class '__main__.Cat'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class 'object'&gt;](&lt;class '__main__.Cat'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class 'object'&gt;)[&lt;class '__main__.Cat'&gt;, &lt;class '__main__.Dog'&gt;] int的子类1print(int.__subclasses__()) # [&lt;class 'bool'&gt;] 继承中的访问控制1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465class Animal: __COUNT = 100 HEIGHT = 0 def __init__(self,age, weight, height): self.__COUNT += 1 self.age = age self.__weight = weight self.HGIGHT = height def eat(self): print('&#123;&#125; eat'.format(self.__class__.__name__)) def __getweight(self): print(self.__weight) @classmethod def showcount1(cls): print(cls) print(cls.__dict__) print(cls.__COUNT) @classmethod def __showcount2(cls): print(cls.__COUNT) def showcount3(self): print(self.__COUNT)class Cat(Animal): NAME = 'CAT' __COUNT = 200# c = Cat() # __init__ 函数参数错误c = Cat(3, 5, 15)c.eat() # Cat eatprint(c.HEIGHT) # 0# print(c.__COUNT)# AttributeError, 可通过c._Animal__COUNT访问 # 101# c.__getweight()# AttributeError, 可通过c._Animal__getweight()访问 # 5c.showcount1()# 打印结果# &lt;class '__main__.Cat'&gt;# &#123;'__module__': '__main__', 'NAME': 'CAT', '_Cat__COUNT': 200, '__doc__': None&#125;# 100# c.__showcount2# AttributeError # 可通过c._Animal__showcount2访问c.showcount3() # 101print(c.NAME) # CATprint("&#123;&#125;".format(Animal.__dict__))print("&#123;&#125;".format(Cat.__dict__))# &#123;'__module__': '__main__', 'NAME': 'CAT', '_Cat__COUNT': 200, '__doc__': None&#125;print(c.__dict__) # &#123;'_Animal__COUNT': 101, 'age': 3, '_Animal__weight': 5, 'HGIGHT': 15&#125;print(c.__class__.mro()) # [&lt;class '__main__.Cat'&gt;, &lt;class '__main__.Animal'&gt;, &lt;class 'object'&gt;] 方法的重写、覆盖override123456789101112131415161718class Animal: def shout(self): print('Animal shouts')class Cat(Animal): # 覆盖了父类方法 def shout(self): print('miao')a = Animal()a.shout()c = Cat() # Animal shoutsc.shout() # miaoprint(a.__dict__)print(c.__dict__)print(Animal.__dict__)print(Cat.__dict__) Cat中能够有覆盖自己的方法?1234567891011121314151617181920212223242526272829class Animal: def shout(self): print('Animal shouts')class Cat(Animal): # 覆盖了父类的方法 def shout(self): print('miao') # 覆盖了自身的方法，显示调用了父类的方法 def shout(self): print(super()) # &lt;super: &lt;class 'Cat'&gt;, &lt;Cat object&gt;&gt; print(super(Cat, self)) # &lt;super: &lt;class 'Cat'&gt;, &lt;Cat object&gt;&gt; print(super(self.__class__, self)) # &lt;super: &lt;class 'Cat'&gt;, &lt;Cat object&gt;&gt; super().shout() # Animal shouts super(Cat, self).shout() # 等价于super() # Animal shouts self.__class__.__base__.shout(self) # 不推荐 # Animal shoutsa = Animal()a.shout() # Animal shoutsc = Cat() c.shout() # miaoprint(a.__dict__)print(c.__dict__)print(Animal.__dict__)print(Cat.__dict__) super() 可以访问到父类的类属性 类方法和静态方法123456789101112131415161718192021222324252627class Animal: @classmethod def class_method(cls): print('class_method_animal') @staticmethod def static_method(): print('static_method_animal')class Cat(Animal): @classmethod def class_method(cls): print('class_method_cat') @staticmethod def static_method(): print('static_method_cat')c = Cat()c.class_method() # class_method_catc.static_method() # static_method_catprint(Cat.__dict__)print(Animal.__dict__)Cat.static_method() # static_method_catAnimal.static_method() # static_method_animal 这些方法都可以覆盖，原理都一样，属性字典的搜索顺序 继承时使用初始化 初始化只跟实例字典相关 12345678910111213141516171819class A: def __init__(self,a, d=10): self.a = a self.d = dclass B(A): def __init__(self, b, c): A.__init__(self, b + c, b - c) self.b = b self.c = c def printv(self): print(self.b) # 200 print(self.a) # 500f = B(200, 300)print(f.__dict__) # &#123;'a': 500, 'd': -100, 'b': 200, 'c': 300&#125;print(f.__class__.__bases__) # (&lt;class '__main__.A'&gt;,)f.printv() 如果父类定义了__init__方法，应该在子类的init中调用它 那么，子类什么时候自动调用父类的init方法呢？示例11234567891011class A: def __init__(self): self.a1 = 'a1' self.a2 = 'a2' print('init in A')class B(A): passb = B() # init in Aprint(b.__dict__) # &#123;'a1': 'a1', 'a2': 'a2'&#125; B实例的初始化会自动调用基类A的__init__方法，所以print(&#39;init in A&#39;)会打印出来 示例212345678910111213class A: def __init__(self): self.a1 = 'a1' self.a2 = 'a2' print('init in A')class B(A): def __init__(self): self.b1 = 'b1' print('init in B')b = B() # init in Bprint(b.__dict__) # &#123;'b1': 'b1'&#125; B实例一旦定义了初始化__init__方法，就不会自动调用父类的初始化__init__方法，需要手动调用1234567891011121314151617class A: def __init__(self): self.a1 = 'a1' self.a2 = 'a2' print('init in A')class B(A): def __init__(self): self.b1 = 'b1' print('init in B') A.__init__(self)b = B() # init in Bprint(b.__dict__) # 注意看__a2# init in A# &#123;'b1': 'b1', 'a1': 'a1', '_A__a2': 'a2'&#125; 正确初始化1234567891011121314151617181920212223class Animal: def __init__(self, age): print('init in Animal') self.age = age def show(self): print(self.age)class Cat(Animal): def __init__(self, age, weight): # 调用父类的__init__方法的顺序有时决定着show方法的结果 super().__init__(age) print('init in Cat') self.age = age + 1 self.weight = weight super().__init__(age)c = Cat(10, 5)# 打印结果# init in Animal# init in Cat# init in Animalc.show() #10 注意，调用父类的__init__方法，出现在不同的位置，可能导致出现不同的结果 将上例中所有的实例属性改成私有变量 12345678910111213141516171819202122232425class Animal: def __init__(self, age): print('init in Animal') self.__age = age def show(self): print(self.__age)class Cat(Animal): def __init__(self, age, weight): # 调用父类的__init__方法的顺序有时决定着show方法的结果 super().__init__(age) print('init in Cat') self.__age = age + 1 self.__weight = weight super().__init__(age)c = Cat(10, 5)# 打印结果# init in Animal# init in Cat# init in Animalc.show() # 10print(c.__dict__) # &#123;'_Animal__age': 10, '_Cat__age': 11, '_Cat__weight': 5&#125; 上例中打印10，原因看__dict__就知道了。因为父类Animal的show方法中_age会被解释为_Animal__age，因此显示的是10，而不是11 这样的设计不好，Cat的实例c应该显示自己的属性值更好 解决的办法： 一个原则，自己的私有属性，就该自己的方法读取和修改，不要借助其他类的方法，即使是父类或者派生类的方法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E9%80%92%E5%BD%92%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[@TOC 函数执行流程 全局帧中生成foo1、foo2、foo3、main函数对象 main函数调用 main中查找内建函数print压栈，将常量字符串压栈，调用函数，弹出栈顶 main中全局查找函数foo1压栈，将常量100、101压栈，调用函数foo1，创建栈帧。print函数压栈，字符串和变量b、b1压栈，调用函数，弹出栈顶，返回值。 main中全局查找foo2函数压栈，将常量200压栈，调用foo2，创建栈帧。foo3函数压栈，变量c引用压栈，调用foo3，创建栈帧。foo3完成print函数调用后返回。foo2恢复调用，执行print后，返回值。main中foo2调用结束弹出栈顶。main继续执行print函数调用，弹出栈顶，main函数返回 递归Recursion 函数直接或者间接调用自身就是 递归 递归需要有边界条件、递归前进段（计算的过程）、递归返回段（拿到返回值的过程） 递归一定要有边界条件 当边界条件不满足的时候，递归前进 当边界条件满足的时候，递归返回递归要求 递归一定要有退出条件，递归调用一定要执行到这个退出条件。没有退出条件的递归调用，就是无限调用 递归调用的深度不宜过深 Python对递归条用的深度做了限制，以保护解释器 超过递归深度限制，抛出RecursionReeor：maxinum recursion depth exceeded 超出最大深度 使用sys.getrecursionlimit()可查看递归层次限制，CPython 限制1000123import sysprint(sys.getrecursionlimit()) #输出结果 1000 递归的性能fib 35项比较 for循环 123456789101112import datetimestart = datetime.datetime.now()a = 0b = 1n = 35#循环实现for i in range(n-1): a, b = b, a + belse: pass # print(b) 9227465delte 循环稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果 fib函数代码极简易懂，但是只能获取取到最外层的函数调用，内部递归结果都是中间结果。而且给定一个n都要进行近2n次递归，深度越深递归总结 递归是一种很自然的表达，符合逻辑思维 递归相对运行效率低，每一次调用函数都要开辟栈帧 递归有深度限制，如果递归层次太深，函数反复压栈，栈内存很快就溢出了 如果是有限次数的递归，可以使用递归调用，或者使用循环代替，循环代码稍微复杂一些，但是只要不是死循环，可以多次迭代直至算出结果 绝大多数递归，都可以使用循环实现 即使递归代码很简洁，但是能不用则不用递归]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E6%A0%91%E7%9A%84%E9%81%8D%E5%8E%86%E5%92%8C%E5%A0%86%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 二叉树的遍历遍历 迭代所有元素一遍树的遍历对树中所有元素不重复地访问一遍，也称作扫描广度优先遍历 层序遍历深度优先遍历 前序遍历 中序遍历 后序遍历遍历序列 将树中所有元素遍历一遍后，得到的元素的序列。将层次结构转换成了线性结构 层序遍历 按照树的层次，从第一层开始，自左向右遍历元素 遍历序列 ABCDEFGHI深度优先遍历 设树的根结点为D，左子树为L，右子树为R，且要求L一定在R之前，则有下面几种遍历方式： 前序遍历，也叫先序遍历、也叫先根遍历，DLR 中序遍历，也叫中根遍历，LDR 后序遍历，也叫后根遍历，LRD 前序遍历DLR 从根结点开始，先左子树后右子树 每个子树内部依然是先根结点，再左子树后右子树。递归遍历 遍历序列 A BDGH CEIF中序遍历LDR 从根结点的左子树开始遍历，然后是根结点，再右子树 每个子树内部，也是先左子树，后根结点，再右子树。对遍历 遍历序列 左图：GDHB A IECF 右图：GDHB A EICF后序遍历LRD 先左子树，后右子树，再根结点 每个子树内部依然是先左子树，后右子树，再根结点。递归遍历 遍历序列GHDB IEFC A堆排序Heap Sort堆Heap 堆是一个完全二叉树 每个非叶子结点都要大于或者等于其左右孩子结点的值称为大顶堆 每个非叶子结点都要小鱼或者等于其左右孩子结点的值称为小顶堆 根结点一定是大顶堆中的最大值，一定是小顶堆中的最小值大顶堆 完全二叉树的每个非叶子结点都要大于或者等于其左右孩子结点的值称为大顶堆 根结点一定是大顶堆中的最大值小顶堆 完全二叉树的每个非叶子结点都要小于或者等于其左右孩子结点的值称为小顶堆 根结点一定是小顶堆中的最小值1. 构建完全二叉树 待排序数字为 30，20，80，40，50，10，60，70，90 构建一个完全二叉树存放数据，并根绝性质5对元素编号，放入顺序的数据结构中 构造一个列表为[0,30,20,80,40,50,10,60,70,90]2. 构建大顶堆核心算法 度数为2的结点A，如果它的左右孩子结点的最大值比它大的，将这个最大值和该结点交换 度数为1的结点A，如果它的左孩子的值大于它，则交换 如果结点A被交换到新的位置，还需要和其孩子结点重复上面的过程起点结点的选择 从完全二叉树的最后一个结点的双亲结点开始，即最后一层的最右边叶子结点的父结点开始 结点数为n，则起始结点的编号为n//2(性质5) 下一个结点的选择 从起始结点开始向左找其同层结点，到头后再从上一层的最右边结点开始继续向左逐个查找，直至根结点3. 大顶堆的目标 确保每个非叶子结点的都比其左右孩子结点的值大4. 排序 将大顶堆根结点逐个最大值和最后一个叶子结点交换，那么最后一个叶子结点就是最大值，将这个叶子结点排除在待排序结点之外 从根结点开始（新的根结点），重新调整为大顶堆后，重复上一步 堆顶和最后一个结点交换，并排序最后一个结点算法实现123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384import mathdef print_tree(array,unit_width=2): ''' i 前空格 元素间 1 3 7=2**3-1 0 2*7+1 2*前空格+1 2 2 3=2**2-1 7=2**3+1 3 1 1=2**1-1 3=2**1+1 4 0 0=2**0-1 1=2*0+1 ''' length = len(array) index = 1 # 因为使用时前面补0了,不然应该是math.ceil(math.log2(len(array)+1) depth = math.ceil(math.log2(length)) # 4 # print(depth) space = ' ' * unit_width for i in range(depth-1, -1, -1): pre = 2 ** i - 1 print(pre * space, end="") # 前置空格 offset = 2 ** (depth - i - 1) line = array[index:index+offset] # 取数字 interval = (2 * pre + 1) * space # 间隔的空格 print(interval.join(map(lambda x:"&#123;:2&#125;".format(x), line))) index += offset# Heap Sort 堆排序# 为了和编码对应，增加一个无用的0在首位origin = [0, 30, 20, 80, 40, 50, 10, 60, 70, 90]total = len(origin) - 1 # 初始待排序元素个数，即nprint_tree(origin)print("="*50)def heap_adjust(n ,i, array:list): ''' 调整当前节点(核心算法) 调整的结点的起点在n//2，保证所有调整的结点都有孩子结点 :param n: 待比较数个数 :param i: 当前结点的下标 :param array: 待排序数据 :return: None ''' while 2 * i &lt;= n: # 孩子结点判断 2i为左孩子, 2i+1为右孩子 lchile_index = 2 * i max_child_index = lchile_index # n=2i if n &gt; lchile_index and array[lchile_index +1] &gt; array[lchile_index] :# n&gt;2i说明还有右孩子 max_child_index = lchile_index + 1 # n=2i+1 # 和子树的根结点比较 if array[max_child_index] &gt; array[i]: array[i], array[max_child_index] = array[max_child_index], array[i] i = max_child_index # 被交换后，需要判断是否还需要调整 else: break # print_tree(array)# 构建大顶堆、大根堆def max_heap(total, array:list): for i in range(total // 2, 0, -1): heap_adjust(total, i, array) return arrayprint_tree(max_heap(total, origin))print("=" * 50)# 排序def sort(total, array:list): while total &gt; 1: array[1], array[total] = array[total], array[1] # 堆顶和最后一个结点交换 total -= 1 if total == 2 and array[total] &gt;= array[total - 1]: break heap_adjust(total, 1, array) return arrayprint_tree(sort(total, origin))print("="*50)print(origin[1:]) 打印结果12345678910111213141516 30 20 80 40 50 10 6070 90================================================== 90 70 80 40 50 10 6020 30================================================== 10 20 30 40 50 60 7080 90==================================================[10, 20, 30, 40, 50, 60, 70, 80, 90] 总结 是利用堆性质的一种选择排序，在堆顶选出最大值或者最小值 时间复杂度堆排序的时间复杂度为O(nlogn)由于堆排序对原始记录的排序状态并不敏感，因此它无论是最好、最坏和平均时间复杂度均为O(nlogn)空间复杂度 只是使用了一个交换用的空间，空间复杂度就是O(1)稳定性 不稳定的排序算法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%92%8C%E6%9C%AA%E5%AE%9E%E7%8E%B0%E5%BC%82%E5%B8%B8%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E9%87%8D%E8%BD%BD%E5%8F%8D%E5%90%91%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[未实现和未实现异常12345678print(type(NotImplemented))print(type(NotImplementedError))# &lt;class 'NotImplementedType'&gt;# &lt;class 'type'&gt;# raise NotImplemented # TypeError: exceptions must derive from BaseExceptionraise NotImplementedError # NotImplementedError NotImplemented是个值，单值，是NotImplementedType的实例NotImplementedError是类型，是异常类，返回type 运算符重载中的反响方法1234567891011121314151617class A: def __init__(self, x): self.x = x def __add__(self, other): print(self, 'add') return self.x + other.x def __iadd__(self, other): print(self, 'iadd') return A(self.x + other.x) def __radd__(self, other): print(self, 'radd') return self.x + other.xa = A(4)a + 1 运行结果出现了AttributeError，因为1是int类型，没有x这个属性，A类的__add__被执行了 测试1 + a ，运行结果如下这次执行的是实例a的__radd__方法1 + a等价于1.__add__(a)，也就是int.__add__(1, a)，而int类型实现了__add__方法，没有抛出异常，而是执行了实例a的__radd__方法 分析下面例子代码 1234567891011121314151617181920212223242526272829class A: def __init__(self, x): self.x = x def __add__(self, other): print(self, 'add') return self.x + other.x def __iadd__(self, other): print(self, 'iadd') return A(self.x + other.x) def __radd__(self, other): print(self, 'radd') return self.x + other.xclass B: # 未实现__add__ def __init__(self, x ): self.x = xa = A(4)b = B(10)print(a + b)print(b + a)# 执行结果&lt;__main__.A object at 0x0000021577038400&gt; add14&lt;__main__.A object at 0x0000021577038400&gt; radd14 b + a 等价于b.__add__(a)，但是类B没有实现__add__方法，反而去找a的__radd__方法1 + a等价于1.__add__(a)，而int类型实现了__add__方法，不过这个方法对于这种加法的返回值是==NotImplemented==，解释器发现是这个值，就会发起对第二操作对象的__radd__方法的调用 B类也等价于下面的实现 123456789class B: def __init__(self, x ): self.x = x def __add__(self, other): if isinstance(other, type(self)): return self.x + other.x else: return NotImplemented 1 + a 用如下方法解决 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A: def __init__(self, x): self.x = x def __add__(self, other): print(self, 'add') if hasattr(other, 'x'): return self.x + other.x else: try: x = int(other) except: x = 0 return self.x + x def __iadd__(self, other): print(self, 'iadd') return A(self.x + other.x) def __radd__(self, other): print(self, 'radd') return self + otherclass B: def __init__(self, x): self.x = xa = A(4)b = B(20)print(a + b)print(b + a)print(a + 2)print(2 + a)# 执行结果&lt;__main__.A object at 0x000001C4AA548400&gt; add24&lt;__main__.A object at 0x000001C4AA548400&gt; radd&lt;__main__.A object at 0x000001C4AA548400&gt; add24&lt;__main__.A object at 0x000001C4AA548400&gt; add6&lt;__main__.A object at 0x000001C4AA548400&gt; radd&lt;__main__.A object at 0x000001C4AA548400&gt; add6 &#39;abc&#39; + a ， 字符串也实现了__add__方法，不过默认是处理不了和其他类型的加法，就返回NotImplemented]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E6%97%A5%E5%BF%97%E5%88%86%E6%9E%90%E3%80%81%E5%88%86%E5%8F%91(queue%E6%A8%A1%E5%9D%97%E3%80%81threading%E6%A8%A1%E5%9D%97)%E3%80%81%E5%88%86%E6%9E%90%E5%99%A8%EF%BC%88IP%E3%80%81PV%E3%80%81useragent%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC 概述生成中会生产大量的系统日志、应用程序日志、安全日志等，通过对日志的分析可以了解服务器的负载、健康状况，可以分析客户的分布情况、客户行为，甚至基于这些分析可以做出预测 一般采集流程日资产处 -&gt; 采集(Logstash、Flume、Scribe) -&gt; 存储 -&gt; 分析 -&gt; 存储（数据库、NoSQL） -&gt; 可视化 开源实时日志分析ELK平台Logstash收集日志，并存放到ElasticSearch集群中，Kibana则从ES集群中查询数据生成图表，返回浏览器端数据提取半结构化数据 日志是半结构化数据，是有组织的、有格式的数据。可以分割成行和咧，就可以当做表理解和处理了，当然也可以分析里面的数据文本分析 日志是文本文件，需要依赖文件IO、字符串操作、正则表达式等技术 通过这些技术就能够把日志中需要的数据提取出来 这是最常见的日志，nginx、tomcat等WEB Server都会产生这样的日志。如何提取出数据？这里面每一段有效的数据对后期的分析都是必须的提取数据代码实现1234567891011121314151617181920212223# 使用正则表达式import reline = '''183.60.212.153 - - [19/Feb/2013:10:23:29 +0800] \"GET /o2o/media.html?menu=3 HTTP/1.1" 200 16691 "-" \"Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)"'''pattern = '([\d.]&#123;7,&#125;) - - \[(.+)\] \"(.+) (.+) (.+)" (\d&#123;3&#125;) (\d+) "[^"]+" "([^"]+)"'regex = re.compile(pattern)def extract(logline:str): m = regex.match(logline) if m : print(m.groups())extract(line)# 输出结果('183.60.212.153', '19/Feb/2013:10:23:29 +0800', 'GET',\ '/o2o/media.html?menu=3', 'HTTP/1.1', '200', '16691', \ 'Mozilla/5.0 (compatible; EasouSpider; \ +http://www.easou.com/search/spider.html)') 使用上面的分组就可以提取到所有想要数据的分组 类型转换fields中的数据是有类型的，例如时间、状态码等。对不同的field要做不同的类型转换，甚至是自定义的转换 19/Feb/2013:10:23:29 +0800 对应格式 %d/%b/%Y:%H:%M:%S %Z 使用datetime类的strptime方法1234import datatimedef convert_time(timestr): return datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S %z') 可以得到1lambda timestr:datetime.datetime.strptime(timestr, '%d/%b/%Y:%H:%M:%S %z') 状态码和字节数都是整型，使用int函数转换映射对每一个字段命名，然后与值和类型转换的方法对应最简单的方式，就是使用正则表达式分组123456789101112131415161718192021222324252627282930import reimport datetimeline = '''183.60.212.153 - - [19/Feb/2013:10:23:29 +0800] \"GET /o2o/media.html?menu=3 HTTP/1.1" 200 16691 "-" \"Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)"'''pattern = '(?P&lt;remote&gt;[\d.]&#123;7,&#125;) - - \[(?P&lt;datetime&gt;.+)\] \"(?P&lt;method&gt;.+) (?P&lt;url&gt;.+) (?P&lt;protocol&gt;.+)" \(?P&lt;status&gt;\d&#123;3&#125;) (?P&lt;size&gt;\d+) "[^"]+" "(?P&lt;useragent&gt;[^"]+)"'regex = re.compile(pattern)conversion = &#123; 'datetime': lambda timestr:datetime.datetime.strptime(timestr,'%d/%b/%Y:%H:%M:%S %z'), 'status':int, 'size':int&#125;def extract(logline:str): m = regex.match(logline) if m : return &#123;k:conversion.get(k, lambda x:x)(v) for k,v in m.groupdict().items()&#125;print(extract(line))# 打印结果&#123;'remote': '183.60.212.153', \'datetime': datetime.datetime(2013, 2, 19, 10, 23, 29, tzinfo=datetime.timezone(datetime.timedelta(0, 28800))),\ 'method': 'GET', 'url': '/o2o/media.html?menu=3', \ 'protocol': 'HTTP/1.1', 'status': 200, 'size': 16691,\ 'useragent': 'Mozilla/5.0 (compatible; EasouSpider; +http://www.easou.com/search/spider.html)'&#125; 异常处理日志中不免会出现一些不匹配的行，需要处理这里使用re.match方法，有可能匹配不上。所以要增加一个判断采用抛出异常的方式，让调用者获得异常并自行处理1234567def extract(logline:str): """返回字段的字典,抛出异常说明匹配失败""" m = regex.match(logline) if m : return &#123;k:conversion.get(k, lambda x:x)(v) for k,v in m.groupdict().items()&#125; else: raise Exception('No match. &#123;&#125;'.format(line)) # 或输出日志记录 也可以采用返回一个特殊值的方式，告知调用者没有匹配 1234567def extract(logline:str): """返回字段的字典,抛出异常说明匹配失败""" m = regex.match(logline) if m : return &#123;k:conversion.get(k, lambda x:x)(v) for k,v in m.groupdict().items()&#125; else: return None # 或输出日志记录 通过返回值,在函数外部获取了None，同样也可以才去一些措施。本次采用返回None的实现 数据载入 对于本项目来说，数据就是日志的一行行记录，载入数据就是文件IO的读取。将获取数据的方法封装成函数123456789def load(path): """装载日志文件""" with open(path) as f: for line in f: fields = extract(line) if fields: yield fields else: continue # TODO 以后处理,丢弃数据或记录在日志中 日志文件的加载 目前实现的代码中，只能接受一个路径，修改为接受一批路径 可以约定一下路径下文件的存放方式：如果送来的是一批路径，就迭代其中路径如果路径是一个普通文件，就直接加载这个文件如果路径是一个目录，就遍历路径下所有指定类型的文件，每一个文件按照行处理可以提供参数处理是否递归子目录完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748from pathlib import Pathimport reimport datetimepattern = '(?P&lt;remote&gt;[\d.]&#123;7,&#125;) - - \[(?P&lt;datetime&gt;.+)\] \"(?P&lt;method&gt;.+) (?P&lt;url&gt;.+) (?P&lt;protocol&gt;.+)" \(?P&lt;status&gt;\d&#123;3&#125;) (?P&lt;size&gt;\d+) "[^"]+" "(?P&lt;useragent&gt;[^"]+)"'regex = re.compile(pattern)conversion = &#123; 'datetime': lambda datestr:datetime.datetime.strptime(datestr,'%d/%b/%Y:%H:%M:%S %z'), 'status':int, 'size':int&#125;def extract(logline:str) -&gt; dict: """返回字段的字典,抛出异常说明匹配失败""" m = regex.match(logline) if m : return &#123;k:conversion.get(k, lambda x:x)(v) for k,v in m.groupdict().items()&#125; else: raise Exception('No match. &#123;&#125;'.format(line)) # 或输出日志记录def loadfile(filename:str,encoding='utf-8'): """装载日志文件""" with open(filename,encoding=encoding) as f: for line in f: fields = extract(line) if fields: yield fields else: continue # TODO 以后处理,丢弃数据或记录在日志中def load(*paths, encoding='utf-8', ext='*.log', recursive=False): """装载日志文件""" for x in paths: print(x) p = Path(x) if p.is_dir(): # 处理目录 if isinstance(ext, str): ext = [ext] else: ext = list(ext) for e in ext: files = p.rglob(e) if recursive else p.glob(e) # 是否递归 for file in files: yield from loadfile(str(file.absolute()), encoding=encoding) #file.absolute() 取文件绝对路径 elif p.is_file(): # 处理文件 yield from loadfile(str(p.absolute()), encoding=encoding) 分发生产者消费者模型 一个系统的健康运行，需要监控并处理很多数据，包括日志 对其中已有数据进行采集、分析 被监控对象就是数据的生产者producer，数据的处理程序就是数据的消费者consumer生产者消费者传统模型 最不容易解决的就是生产者和消费者速度要匹配的问题 但是，真实情况下往往生产和消费的速度就不能够很好的匹配解决办法 队列queue作用 解耦、缓冲日志生产者往往会部署好几个程序，日志产生的也很多，而消费者也会有多个程序，去提取日志分析处理 数据的生产是最不稳定的。可能会造成短时间数据的“潮涌”，需要缓冲 消费者消费能力不一样，有快有慢，消费者可以自己决定消费缓冲区中的数据 单机时，可以使用标准库queue模块的类来构建进程内的队列，满足多个线程间的生产消费需求 大型系统可以使用第三方消息中间件– RabbitMQ、RocketMQ、Kafka等数据处理所需模块queue模块 – 队列 Queue先进先出,LifoQueue后进先出queue模块提供了一个先进先出的队列Queuequeue.Queue(maxsize=0) 创建FIFO队列，返回Queue对象 maxsize 小于等于0，队列长度没有限制queue.get(block=True, timeout=None) 从队列中移除元素并返回这个元素 block为阻塞，timeout为超时block为True，是阻塞。timeout为None就是一直阻塞block为True但是timeout有值，就阻塞到一定秒数抛出Empty异常block为False，是非阻塞。timeout将被忽略，要么成功返回一个元素，要么抛出empty异常queue.put(item, block=True, timeout=None) 把一个元素加入到队列中去block=True，timeout=None，一直阻塞直至有空位放元素block=True，timeout=5，阻塞5秒就抛出Full异常block=False，timeout失效，立即返回，能塞进去就塞，不能则返回抛出Full异常Queue.put_nowait(item) 等价于put(item,False)，也就是能塞进去就塞，不能则返回抛出Full异常 1234567891011121314# Queue测试from queue import Queueimport randomq = Queue()q.put(random.randint(1,100)q.put(random.randint(1,100)print(q.get())print(q.get())# print(q.get()) # 阻塞# print(q.get(timeout-3)) # 阻塞，但超时抛异常print(q.get_nowait()) # 不阻塞，没数据立即抛异常 注意： Queue的数据一旦被get后，就会从队列中消失 threading模块–线程123456789101112import threadingdef handle(a, b): print(a, b) print('-' * 30)# 定义线程# target线程中运行的函数; args这个函数运行时需要的实参的元组t = threading.Thread(target=handle, args=(4, 5))# 启动线程t.start() 上面的代码执行一次就退出了线程，如果想让线程不退出，修改handel函数如下 123456789101112131415import threadingimport timedef handle(a, b): while True: print(a, b) print('-' * 30) time.sleep(1)# 定义线程# target线程中运行的函数; args这个函数运行时需要的实参的元组t = threading.Thread(target=handle, args=(4, 5))# 启动线程t.start() 为了让生产者的生产数据和消费者的消费数据同时进行，可以使用不同的线程 数据处理流程 生产者（数据源）生产数据，缓冲到消息队列中 数据处理流程：分发器的实现 数据分析的程序有很多，例如PV分析、IP分析、UserAgent分析等 同一套数据可能要被多个分析程序并行处理：需要使用多线程来并行处理多个分许程序又需要同一份数据，这就是一份变多分 数据处理流程： 这是一个典型的分发器注册统计分析函数，并为其提供一个单独的数据队列收集日志数据将一份日志数据发送到多个已注册的分析函数的队列中去为了并行，每一个分析函数都在一个独立的线程中执行1234567891011121314151617181920212223242526from queue import Queueimport threading# 消息队列, 分发def dispatcher(src): handlers = [] queues = [] def reg(handle): q = Queue() queues.append(q) t = threading.Thread(target=handle, args=(q,)) handlers.append(t) def run(): for t in handlers: t.start() # 启动线程,运行所有的处理函数 for item in src: for q in queues: q.put(item) return reg, runreg, run = dispatcher(load('/logs')) 分析器IP分析分析一段时间内，不同IP字出现的次数。基于IP可以分析出用户的地理分布1234567891011# IP分析@regdef ip_handle(q:Queue): ips = &#123;&#125; while True: data = q.get() # 阻塞读取 ip = data.get('remote') if ip: ips[ip] = ips.get(ip, 0) + 1 print(len(ips), ips.keys()) print(sorted(ips.itmes(), key=lambda x:x[1], reverse=True)) 这段程序可以得到对于所有文档一个IP的统计 PV分析PV指的是Page view，也就是页面浏览量或页面点击量PV分析，就是按照URL分析 不同URL被不同的用户访问了几次？ 两种计算：1.同一个用户不管刷新多少下同一个页面，就算1次2.同意用户刷新同一个页面也算1次url分析12345678910111213141516171819from urllib.parse import urlparseurls = [ 'http://www.python.org' '/index.html' '/index.html?id=5&amp;age=20']for i, url in enumerate(urls, 1): t = urlparse(url) print(i, url) print(i, t, t.path)# 打印结果1 http://www.python.org/index.html/index.html?id=5&amp;age=201 ParseResult(scheme='http', netloc='www.python.org',\ path='/index.html/index.html', params='', query='id=5&amp;age=20',\ fragment='') /index.html/index.html pv分析12345678910111213@regdef pv_handle(q:Queue): pvs = &#123;&#125; while True: data = q.get() ip = data.get('remote') url = data.get('url') if ip and url: path = urlparse(url).path if path not in pvs: pvs[path] = &#123;&#125; pvs[path][ip] = pvs[path].get(ip, 0) + 1 print(pvs) useragent分析 useragent指的是，软件按照一定的格式向远端的服务器提供一个表示自己的字符串 在HTTP协议中，使用user-agent字段传送这个字符串 注意：这个值可以被修改 格式现在浏览器的user-agent值格式一般如下： 信息提取pyyaml、ua-parser、user-agents模块 安装$ pip install pyyaml ua-parser user-agents 使用123456789101112131415161718192021from user_agents import parseuseragents = [ "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko)\ chrome/57.0.2987.133 Safari/537.36", "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:56.0) Gecko/20100101 Firefox/56.0", "Mozilla/5.0 (X11; Ubuntu; Linux x86_64; rv:52.0) Gecko/20100101 Firefox/52.0", "Mozilla/5.0 (compatible; MSIE 10.0; Windows NT 6.1; WOW64; Trident/6.0; SLCC2;\ .NET CLR 2.0.50727; .NET CLR 3.5.30729; NET CLR 3.0.30729; Media Center PC 6.0; .NET4.0C; .NET4.0E)"]for uastring in useragents: ua = parse(uastring) print(ua.browser, ua.browser.family, ua.browser.version, ua.browser.version_string)# 运行结果Browser(family='Safari', version=(), version_string='') Safari () Browser(family='Firefox', version=(56, 0), version_string='56.0') Firefox (56, 0) 56.0Browser(family='Firefox', version=(52, 0), version_string='52.0') Firefox (52, 0) 52.0Browser(family='IE', version=(10, 0), version_string='10.0') IE (10, 0) 10.0 ua.browser.famliy和ua.browser.version_string分别返回浏览器名称、版本号 数据分析 conversion 增加对useragent的处理 12345678from user_agents import parseconversion = &#123; 'datetime': lambda datestr:datetime.datetime.strptime(datestr,'%d/%b/%Y:%H:%M:%S %z'), 'status':int, 'length':int 'useragent':lambda ua:parse(ua)&#125; 增加浏览器分析函数 12345678910111213# UserAgent分析@regdef ua_handle(q:Queue): browsers = &#123;&#125; while True: data = q.get() ua = data.get('uaeragent') if ua: key = ua.browser.family, ua.browser.version_string browsers[key] = browsers.get(key, 0) + 1 print(browsers) 完整代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123from user_agents import parsefrom pathlib import Pathimport datetimeimport repattern = '(?P&lt;remote&gt;[\d.]&#123;7,&#125;) - - \[(?P&lt;datetime&gt;.+)\] \"(?P&lt;method&gt;.+) (?P&lt;url&gt;.+) (?P&lt;protocol&gt;.+)" \(?P&lt;status&gt;\d&#123;3&#125;) (?P&lt;size&gt;\d+) "[^"]+" "(?P&lt;useragent&gt;[^"]+)"'regex = re.compile(pattern)conversion = &#123; 'datetime': lambda datestr:datetime.datetime.strptime(datestr,'%d/%b/%Y:%H:%M:%S %z'), 'status':int, 'length':int 'useragent':lambda ua:parse(ua)&#125;def extract(logline:str) -&gt; dict: """返回字段的字典，如果返回None说明匹配失败""" m = regex.match(logline) if m: return &#123;k:conversion.get(k, lambda x:x)(v) for k, v in m.groupdict().items()&#125; else: return None # 或输出日志记录 def loadfile(filename:str, encoding='utf-8'): """装载日志文件""" with open(filename, encoding=encoding) as f: for line in f: fields = extract(line) if fields: yield fields else: continue # TODO 以后处理，丢弃数据或记录在日志中 def load(*paths, encoding='utf-8', ext='*.log', recursive=False): """装载日志文件""" for x in paths: print(x) p = Path(x) if p.is_dir(): # 处理目录 if isinstance(ext, str): ext = [ext] else: ext = list(ext) for e in ext: files = p.rglob(e) if recursive else p.glob(e) # 是否递归 for file in files: yield from loadfile(str(file.absolute()), encoding=encoding) elif p.is_file(): yield from loadfile(str(p.absolute()), encoding=encoding)from queue import Queueimport threading# 消息队列，分发def dispatcher(src): handlers = [] queues = [] def reg(handle): q = Queue() queues.append(q) t = threading.Thread(target=handle, args=(q,)) handlers.append(t) def run(): for t in handlers: t.start() # 启动线程，运行所有的处理函数 for item in src: # 将数据源取到的数据分发到所有队列中 for q in queues: q.put(item) return reg,runreg, run = dispatcher(load('.'))# IP分析@regdef ip_handle(q:Queue): ips = &#123;&#125; while True: data = q.get() # 阻塞读取 ip = data.get('remote') if ip: ips[ip] = ips.get(ip, 0) + 1 # print(len(ips), ips.key()) # print（sorted(ips.items(), key=lambda x:x[1], reverse=True)) from urllib.parse import urlparse# PV分析@regdef pv_handle(q:Queue): pvs = &#123;&#125; while True: data = q.get() ip = data.get('remote') url = data.get('url') if ip and url: path = urlparse(url).path if path not in pvs: pvs[path] = &#123;&#125; pvs[path][ip] = pvs[path].get(ip, 0) + 1 # print(pvs) # UserAgent分析@regdef ua_handle(q:Queue): browsers = &#123;&#125; while True: data = q.get() ua = data.get('useragent') if ua: key = ua.browser.family, ua.browser.version_string browsers[key] = browsers.get(key, 0) + 1 print(browsers)run()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86%2F</url>
    <content type="text"><![CDATA[@TOC 异常 Exception错误 Error 逻辑错误：算法写错了，例如加法写成了减法 笔误：例如变量名写错了，语法错误 函数或类使用错误，其实这也属于逻辑错误 总之，错误是可以避免的异常 Exception 本意就是意外情况 这有个前提，没有出现上面说的错误，也就是说程序写的没有问题，但是在某些情况下，会出现一些意外，导致程序无法正常的执行下去 例如open函数操作一个文件，文件不存在，或者创建一个文件时已经存在了，或者访问一个网络文件，突然断网了，这就是异常，是个意外的情况 异常不可能避免错误和异常在高级编程语言中，一般都有错误和异常的概念，异常是可以捕获，并被处理的，但是错误是不能被捕获的对比异常和错误123print( 1/ 0) # 除0异常def 1a(): pass # 语法错误 一个健壮的程序，应尽可能避免错误，尽可能捕获、处理各种异常 产生异常 产生：raise 语句显式的抛出异常Python解释器自己检测到异常并引发它1234567891011121314def foo(): print('before') print(1/0) # 除零异常 print('after')foo()# 打印结果beforeTraceback (most recent call last): File "C:/Users/Administrator/PycharmProjects/test/Task/Temporary.py", line 6, in &lt;module&gt; foo() File "C:/Users/Administrator/PycharmProjects/test/Task/Temporary.py", line 3, in foo print(1/0) # 除零异常ZeroDivisionError: division by zero 12345678910111213141516def bar(): print('before') raise Exception('my exception') # raise 主动抛出异常 print('after') bar()# 打印结果beforeTraceback (most recent call last): File "C:/Users/Administrator/PycharmProjects/test/Task/Temporary.py", line 6, in &lt;module&gt; bar() File "C:/Users/Administrator/PycharmProjects/test/Task/Temporary.py", line 4, in bar raise Exception('my exception') # raise 主动抛出异常Exception: my exceptionProcess finished with exit code 1 程序会在异常抛出的地方中断执行，如果不捕获，就会提前结束程序（其实是终止当前线程的执行） 异常的捕获1234try: 待捕获异常的代码块except [异常类型]: 异常的处理代码块 123456789101112131415161718def foo(): try: print('before') c = 1/0 print('after') except: print('error') print('catch the exception')foo()print("=====end=====")# 打印结果beforeerrorcatch the exception=====end===== 上例执行到c = 1/0 时产生异常并抛出，由于使用了try…except语句块则捕捉到了这个异常，异常生成位置之后语句将不再执行，转而执行对应的except部分的语句，最后执行try...except语句块之外的语句 捕获指定类型的异常1234567891011def foo(): try: print('before') print(1/0) print('after') except ArithmeticError: # 指定捕获的类型 print('error') print('catch the exception') foo()print('======= end =========') 异常类及集成层次12345678910111213141516171819202122232425262728293031323334353637# Python异常的继承BaseException +-- SystemExit # 系统推出 +-- KeyboardInterrupt # 键盘打断 +-- GeneratorExit +-- Exception # 自己写的所有异常类，从这里开始继承 +-- RuntimeError # 运行时异常 | +-- RecursionError # 递归异常 +-- MemoryError # 内存异常 +-- NameError # 名称不存在 +-- StopIteration # 迭代次数超出 +-- StopAsyncIteration +-- ArithmeticError # 算数异常 | +-- FloatingPointError # 浮点数异常 | +-- OverflowError | +-- ZeroDivisionError # 除0异常 +-- LookupError # 找位置找不着 | +-- IndexError # 超界 | +-- KeyError +-- SyntaxError # 语法错误 +-- OSError # 操作系统里的错误 | +-- BlockingIOError | +-- ChildProcessError # 子进程错误 | +-- ConnectionError | | +-- BrokenPipeError | | +-- ConnectionAbortedError | | +-- ConnectionRefusedError | | +-- ConnectionResetError | +-- FileExistsError # 文件已存在 | +-- FileNotFoundError # 文件不存在 | +-- InterruptedError | +-- IsADirectoryError | +-- NotADirectoryError | +-- PermissionError | +-- ProcessLookupError | +-- TimeoutError BasaException及子类BasaException所有内建异常类的基类是BasaException SystemExitsys.exit()函数引发的异常，异常不捕获处理，就直接交给Python解释器，解释器推出123456import sysprint('before')sys.exit(1)print('SysExit')print('outer') # 不会执行 捕获异常123456789101112# 捕获异常import systry: sys.exit(1)except SystemExit: # 换成Exception无法捕获 print('SysExit')print('outer')# 打印结果SysExitouter 如果except语句捕获了异常，则继续向后面执行，如果没有捕获住该异常SystemExit，解释器直接退出程序 KeyboardInterrupt对应的捕获用户终端行为Ctrl + C12345678try: import time while True: time.sleep(1) print('~~~')except KeyboardInterrupt: print('ctrl + c')print('=== end ===') Exception及子类Exception是所有内建的、非系统退出的异常的基类，自定义异常应该继承自它 SyntaxError 语法错误Python将这种错误也归到异常类下面的Exception下的子类，但是这种错误是不可捕获的1234567891011def a(): try: 0a = 5 except: pass# 错误File "test2.py", line 3 0a = 5 ^SyntaxError：invalid syntax ArithmeticError所有算术计算引发的异常，其子类有除零异常等 LookupError使用映射的键或序列的索引无效时引发的异常的基类：IndexError，KeyError 自定义异常类从Exception继承的类1234567class MyException(Exception): passtry: raise MyException()except MyException: # 捕获自定义异常 print('catch the exception') 多种捕获except可以指定捕获的类型，捕获多种异常1234567891011121314151617181920import sysclass MyException(Exception): passtry: a = 1/0 raise MyException open('t1') sys.exit(1)except ZeroDivisionError: print('zero')except ArithmeticError: print('ari')except MyException: print('catch my exception')except Exception: print('excption')except: print('sysexit') 捕获规则捕获是从上到下依次比较，如果匹配，则执行匹配的except语句块如果被一个except语句捕获，其他except语句就不会再次捕获了如果没有任何一个except语句捕获到这个异常，则该异常向外抛出 捕获的原则从小到大，从具体到宽泛as字句1234567891011class A:passtry: # 1/0 raise 1 # raise 'abc' # raise &#123;&#125; # raise A # raise A()except: print('catch the exception') 被抛出的异常，应该是异常类的实例，可以使用as子句获得这个对象123456789101112131415class MyException(Exception): def __init__(self, code, message): self.code = code self.message = messagetry: raise MyExceptionexcept MyException as e: print('catch my exception: &#123;&#125; &#123;&#125;')except Exception as e: print('catch')# 运行结果catch 修改代码如下123456789101112131415class MyException(Exception): def __init__(self, code, message): self.code = code self.message = messagetry: raise MyExceptionexcept MyException as e: print('catch my exception: &#123;&#125; &#123;&#125;')except Exception as e: print('&#123;&#125;'.format(e)) # 运行结果__init__() missing 2 required positional arguments: 'code' and 'message' raise后跟类名是无参构造实例，因此需要2个参数123456789101112131415class MyException(Exception): def __init__(self, code, message): self.code = code self.message = messagetry: raise MyException(200, 'OK')except MyException as e: print('catch my exception: &#123;&#125; &#123;&#125;'.format(e.code, e.message))except Exception as e: print('&#123;&#125;'.format(e))# 执行结果catch my exception: 200 OK raise子句 raise后要求应该是BaseException类的子类或实例，如果是类，将被无参实例化 raise后什么都没有，表示抛出最近一个被激活的异常，如果没有被激活的异常，则抛类型异常。这种方式很少用finally子句 finally最终，即最后一定要执行的，try...finally语句块中，不管是否发生了异常，都要执行finally的部分1234567891011try: f = open('test.txt')except FileNotFoundError as e: print('&#123;&#125; &#123;&#125; &#123;&#125;'.format(e.__class__, e.errno, e.strerror))finally: print('清理工作') # f.close()# 执行结果&lt;class 'FileNotFoundError'&gt; 2 No such file or directory清理工作 注意上例中的f的作用域，解决的办法是在外部定义ffinally中一般放置资源的清理、释放工作的语句123456789f = Nonetry: f = open('test.txt')except FileNotFoundError as e: print('&#123;&#125; &#123;&#125; &#123;&#125;'.format(e.__class__, e.errno, e.strerror))finally: print('清理工作') if f: f.close() 也可以在finally中再次捕获异常123456789101112131415try: f = open('test.txt')except FileNotFoundError as e: print('&#123;&#125;'.format(e))finally: print('清理工作') try: f.close() except Exception as e: print(e)# 执行结果[Errno 2] No such file or directory: 'test.txt'清理工作name 'f' is not defined finally 执行时机try后如果有finally，保证finally一定可以执行12345678910111213141516171819202122# 测试def foo(): return 1 try: return 3 finally: return 5 print('finally') print('==')print(foo())# 执行结果# 1# 关闭return 1 return 5# 执行结果# finally# 3# 关闭return 1 打开return 5# 执行结果# 5 # 说明return 3 返回值被覆盖 当打开return 1 时，后面语句将不再执行 当关闭return 1 ，进入try，执行return 3 ，虽然函数要返回，但是finally一定还要执行，所有执行return 5，函数返回。5被压在栈顶，所以返回5。简单说，函数的返回值取决于最后一个执行的return语句，而finally则是try...finally中最后执行的语句块异常的传递123456789def foo1(): return 1/0def foo2(): print('foo2 start') foo1() print('foo2 stop')foo2() foo2调用了foo1，foo1产生的异常，传递到了foo2中异常总是向外层抛出，如过外层没有处理这个异常，就会继续向外抛出如果内层捕获并处理了异常，外部就不能捕获到了如果到了最外层还是没有被处理，就会中断异常所在的线程的执行。注意整个程序结束的状态返回值123456789101112131415161718import threadingimport timedef foo1(): return 1/0def foo2(): time.sleep(3) # 3秒后抛出异常 # print('foo2 start') foo1() # print('foo2 stop')t = threading.Thread(target=foo2)t.start()while True: time.sleep(1) # print('Everything OK') print(threading.enumerate()) # 打印当前所有线程 执行结果虽然线程报错了，但是主线程还在执行异常会向外抛出，到线程以及，如果线程以及没人管，则会结束此线程 try嵌套12345678910111213141516try: try: ret = 1 / 0 except KeyError as e: print(e) finally: print('inner fin')except: print('outer catch')finally: print('outer fin')# 执行结果inner finouter catchouter fin 内层捕获不到异常，会向外层传递异常但是如果内层有finally且其中有return、break语句，则异常就不会继续向外抛出123456789101112131415161718def foo(): try: ret = 1 / 0 except KeyError as e: print(e) finally: print('inner fin') return # 异常被丢弃try: foo()except: print('outer catch')finally: print('outer fin')# 执行结果inner finouter fin 异常的捕获时机立即捕获 需要立即返回一个明确的结果12345678910def parse_int(s): try: return int(s) except: return 0print(parse_int('s'))# 执行结果0 边界捕获 封装产生了边界例如，写了一个模块，用户调用这个模块的时候捕获异常，模块内部不需要捕获、处理异常，一旦内部处理了，外部调用者就无法感知例如，open函数，出现的异常交给调用者处理，文件存在了，就不用再创建了，看是否修改还是删除例如，自己写了一个类，使用了open函数，但是出现了异常不知道如何处理，就继续向外层抛出，一般来说最外层也是边界，必须处理这个异常，否则线程退出else子句在except之后，finally之前没有异常的时候会执行else语句12345678try: ret = 1 * 0except ArithmeticError as e: print(e)else: print('ok')finally: print('fin') esle子句没有任何异常发生，则执行 总结]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8C%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%EF%BC%9BJson%E4%B8%8EMessagePack%2F</url>
    <content type="text"><![CDATA[@TOC 为什么要序列化 内存中的字典、列表、集合以及各种对象，如何保存到一个文件中？ 如果是自己定义的类的实例，如何保存到一个文件中？ 如何从文件中读取数据，并让他们在内存中再次恢复成自己对应的类的实例？ 要设一套协议，就按照某种规则，把内存中数据保存到文件中。文件是一个字节序列，所以必须把数据转换成字节序列，输出到文件。这就是序列化。反之，把文件的字节序列恢复到内存并且还是原来的类型，就是反序列化定义serialization 序列化 将内存中对象存储下来，把它变成一个个字节 -&gt;二进制deserialization 反序列化 将文件的一个个字节恢复成内存中对象 -&gt; 二进制 序列化保存到文件就是持久化 可以将数据序列化后持久化，或者网络传输；也可以将文件中或者网络接收到的字节序列反序列化 Python提供了pickle库pickle库 Python中的序列化、反序列化模块 12345678910111213141516171819202122import picklefilename = 'o:/ser'i = 99c = 'c'l = list('123')d = &#123;'a':1, 'b':'abc', 'c':[1,2,3]&#125;# 序列化with open(filename, 'wb') as f: pickle.dump(i, f) pickle.dump(c, f) pickle.dump(l, f) pickle.dump(d, f)# 反序列化with open(filename, 'rb') as f: print(f.read(), f.seek(0)) for i in range(4) x =pickle.load(f) print(x, type(x)) 对象序列化 1234567891011121314151617import pickleclass AAA: tttt = 'ABC' def show(self): print('abc') a1 = AAA() # 创建AAA类的对象# 序列化ser = pickle.dumps(a1)print('ser=&#123;&#125;'.format(ser)) # AAA# 反序列化a2 = pickle.loads(ser)print(a2.tttt)a2.show() 上面的例子中，故意使用了连续的AAA、ABC、abc等字符串，就是为了在二进制文件中能容易的发现它们 上例中，其实就保存了一个类名，因为所有的其他东西都是类定义的东西，是不变的，所以只序列化一个AAA类名。反序列化的时候找到类就可以恢复一个对象 123456789101112131415161718import pickle# 对象序列化class AAA: def__int__(self): self.aaaa = 'abc'a1 = AAA() # 创建AAA类的对象# 序列化ser = pickle.dumps(a1)print('ser=&#123;&#125;.format(ser)) # AAA aaaa abc# 反序列化a2 = pickle.loads(ser)print(a2, type(a2))print(a2.aaaa)print(id(a1), id(a2)) 可以看出这回除了必须保存的AAA，还序列化了aaaa和abc，因为这是每一个对象自己的属性，每一个对象不一样的，所以这些数据需要序列化 序列化、反序列化实验 定义类AAA，并序列化到文件 12345678910111213141516171819import pickle# 实验# 对象序列化class AAA: def __init__(self): self.aaaa = 'abc'a1 = AAA() # 创建AAA类的对象# 序列化ser = pick.dumps(a1)print('ser=&#123;&#125;'.format(ser)) # AAA aaaa abcprint(len(ser))filename = 'o:/ser'with open(filename, 'wb') as f: pickle.dump(a1, f) 将产生的序列化文件ser发送到其他节点上 增加一个x.py文件，内容如下。最后执行这个脚本 $ python x.py 1234import picklewith open('ser', 'rb') as f: a = pickle.load(f） # 异常 会抛出异常**AttributeError: Can’t get attribute ‘AAA’ on 这个异常实际上是找不到类AAA的定义，增加类定义即可解决 反序列化的时候找到AAA类的定义，才能成功。否则就会抛出异常 可以这样理解：反序列化的时候，类是模子，二进制序列就是铁水 1234567891011import pickleclass AAA: def show(self): print('xyz') with open('ser', 'rb') as f: a = pickle.load(f) print(a) a.show() print(a.aaaa) 这里定义了类AAA，并且上面的代码也能成功的执行 注意：这里的AAA定义和原来完全不同了因此，序列化、反序列化必须保证使用同一套类的定义，否则会带来不可预料的结果 序列化应用一般来说，本地序列化的情况，应用较少。大多数场景都应用在网络传输中。将数据序列化后通过网络传输到远程节点，远程服务器上的服务将接受到的数据反序列化后，就可以使用了但是需要注意，远程接受端，反序列化时必须有对应的数据类型，否则就会报错。尤其是自定义类，必须远程得有一致的定义现在，大多数项目，都不是单机的，也不是单服务的，需要多个程序之间配合。需要通过网络将数据传送到其他节点上去，这就需要大量的序列化、反序列化过程但是，问题是，Python程序之间还可以都用pickle解决序列化、反序列化，如果是跨平台、跨语言、跨协议。pickle就不太适合，需要公共的协议。例如XML、Json、Protocol Buffer等不同的协议，效率不同，适用不同的场景，根据不同的情况分析选型 JsonJson(JavaScript Object Notation,JS 对象标记)是一种轻量级的数据交换格式。它基于 ECMAScript(w3c组织制定的JS规范)的一个子集，采用完全独立于变成语言的文本格式来存储和表示数据Json官网：http://json.org/ Json是数据类型值 双引号引起来的字符串，数值，true和false，null，对象，数组。这些都是值 字符串：由双引号包围起来的任意字符的组合，可以有转义字符 数值：有正负，有整数、浮点数 对象：无序的键值对的集合格式：{key1:value1,…,keyn:valuen}key必须是一个字符串，需要双引号包围这个字符串value可以是任意合法的值 数组：有序的值的集合格式：[val1,…,valn] 实例12345678910111213&#123; "person":[ &#123; "name": "tom", "age": 18 &#125;, &#123; "name": "jerry", "age": 16 &#125; ], "total": 2&#125; Json 模块Python 与 Json Python支持少量内建数据类型到Json类型的转换 常用方法12345678import jsond = &#123;'name':'Tom', 'age':20, 'interest':('music', 'movie'), 'class':['python']&#125;j = json.dumps(d)print(j, type(j)) # 注意引号、括号的变化，注意数据类型的变化d1 = json.loads(j)print(d1)print(id(d), id(d1)) 一般json编码的数据很少落地，数据都是通过网络传输。传输的时候，要考虑压缩它本质上来说它就是个文本，就是个字符串json很简单，几乎编程语言都支持json，所以应用范围十分广泛 MessagePack官网：https://msgpack.org/MessagePack是一个基于二进制高效的对象序列化类库，可用于跨语言通信它可以像Json那样，在许多语言之间交换结构对象但是它比Json更快速也更轻巧支持Python、Ruby、Java、C/C++等众多语言。兼容json和pickle12345# Json：27 bytes&#123;"person":[&#123;"name":"tom","age":18&#125;,&#123;"name":"jerry",."age":16&#125;],"total":2&#125;# MessagePack：18 bytes# 82 a7 63 6f 6d 70 61 63 74 c3 a6 73 63 68 65 6d 61 00 可以看出，大大的节约了空间 安装1$ pip install msgpack 常用方法 packb 序列化对象。提供了dumps来兼容pickle和json unpackb 反序列化对象。提供了loads来兼容 pack 序列化对象保存到文件对象。提供了dump来兼容 unpack 反序列化对象保存到文件对象。提供了load来兼容 12345678910111213141516171819202122232425262728import pickleimport msgpackimport jsond = &#123;'person': [&#123;'name': 'tom', 'age': 18&#125;, &#123;'name': 'jerry', 'age': 16&#125;], 'total':2&#125;# jsondata = json.dumps(d)print(type(data), len(data), data)print(data.replace(' ', '')print(len(data.replace(' ', ''))) # 72 bytes 注意这样替换的压缩是不对的# pickledata = pickle.dumps(d)print(type(data), len(data), data) # 101 bytes# msgpackdata = msgpack.dumps(d)print(type(data), len(data), data) # 48 bytesprint('-' * 30)u = msgpack.umpackb(data)print(typr(u), u)print(msgpack.loads(data))u = msgpack.loads(data, encoding='utf-8')print(type(u), u) MessagePack简单易用，高效压缩，支持语言丰富 所以，用它序列化也是一种很好的选择。Python很多大名鼎鼎的库都是用了msgpack]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E5%AE%9E%E7%8E%B0%E7%B1%BBproperty%E8%A3%85%E9%A5%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[实现类property装饰器，类名称为Property123456789101112131415161718192021222324252627282930313233343536373839class Property: def __init__(self, fget, fset=None): self.fget = fget # 实例的属性保存一个函数,不会有绑定 self.fset = fset def __get__(self, instance, owner): if instance: return self.fget(instance) # data(self:A) # self.fget 相当于调用data,没有绑定,缺第一参数,将instance注入 raise AttributeError() def __set__(self, instance, value): if self.fset is None: raise AttributeError("can't set attribute") # 只读属性,不允许修改 self.fset(instance, value) def setter(self, fn): self.fset = fn return selfclass A: def __init__(self, data): self._data = data @Property # data = Property(data) -&gt; data是Property类的实例 def data(self): return self._data @data.setter # data = data.setter(data) -&gt; data是Property类的实例，同一个 def data(self, value): self._data = valuea = A(10)print(a.data)a.data = 1000print(a.data)# 执行结果101000]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E5%A4%9A%E7%BB%A7%E6%89%BF%EF%BC%88Mixin%E7%B1%BB%EF%BC%89%2F</url>
    <content type="text"><![CDATA[Python不同版本的类 Python2.2之前类是没有共同的祖先的，之后，引入object类，它是所有类的共同祖先类object。 Python2中为了兼容，分为古典类（旧式类）和新式类。 Python3中全部都是新式类。 新式类都是继承自object的，新式类可以使用super。123456789101112131415161718192021# 以下代码在Python2.x中运行# 古典类（旧式类）class A: pass# 新式类class B(object): passprint(dir(A))print(dir(B))print(A.__bases__)print(B.__bases__)# 古典类a = A()print(a.__class__)print(type(a)) # &lt;type 'instance'&gt;# 新式类b = B()print(b.__class__)print(type(b)) 多继承 OCP原则：多用“继承”、少修改 继承的用途：在子类上实现对基类的增强、实现多态 多态 在面向对象中，父类、子类通过继承联系在一起，如果可以通过一套方法，就可以实现不同表现，就是多态。 一个类继承自多个类就是多继承，它将具有多个类的特征。多继承弊端 多继承很好的模拟了世界，因为事物很少是单一继承，但是舍弃简单，必然引入复杂性，带来了冲突。 多继承的实现会导致编译器设计的复杂度增加，所以有些高级编程语言舍弃了类的多继承。 C++支持多继承；Java舍弃了多继承。 Java中，一个类可以实现多个接口，一个接口也可以继承多个接口。Java的接口很纯粹，只是方法的声明，继承者必须实现这些方法，就具有了这些能力，就能干什么。 多继承可能会带来二义性，实现多继承的语言，要解决二义性，深度优先或者广度优先。Python多继承实现 左图是多继承（菱形继承），右图是单一继承 多继承带来路径选择问题 Python使用MRO（method resolution order方法解析顺序）解决基类搜索顺序问题。 历史原因，MRO有三个搜索算法： 经典算法，按照定义从左到右，深度优先策略。2.2版本之前左图的MRO是MyClass,D,B,A,C,A 新式类算法，是经典算法的升级，深度优先，重复的只保留最后一个。2.2版本左图的MRO是MyClass,D,B,C,A,object C3算法，在类被创建出来的时候，就计算出一个MRO有序列表。2.3之后，Python3唯一支持的算法左图中的MRO是MyClass,D,B,C,A,object的列表 C3算法解决多继承的二义性C3算法，解决了继承的单调性，它阻止创建之前版本产生二义性的代码。求得的MRO本质是为了线性化，且确定了顺序。单调性：假设有A、B、C三个类，C的mro是[C, A, B]，那么C的子类的mro中，A、B的顺序一致就是单调的。 Mixin类 Mixin本质上就是多继承实现的 Mixin体现的是一种组合的设计模式 在面向对象的设计中，一个复杂的类，往往需要很多功能，而这些功能有来自不同的类提供，这就需要很多的类组合在一起 从设计模式的角度来说，多组合，少继承Mixin类的使用原则 Mixin类中不应该显式的出现init初始化方法 Mixin类通常不能独立工作，因为它是准备混入别的类中的部分功能实现 Mixin类的祖先类也应是Mixin类 使用时，Mixin类通常在继承列表的第一个位置 父类只做方法的定义 抽象类，抽象方法 其他语言抽象类不可实例化 抽象类一般不实例化，作为基类用123456789101112131415161718192021222324252627282930313233343536373839class Document: # 第三方库，不允许修改 def __init__(self, content): self.content = contentclass Word(Document): pass # 第三方库，不允许修改class Pdf(Document): pass # 第三方库，不允许修改class PrintableMixin: def print(self): print(self.content, 'Mixin') class PrintableWord(PrintableMixin, Word): passprint(PrintableWord.__dict__) # &#123;'__module__': '__main__', '__doc__': None&#125;print(PrintableWord.mro())# [&lt;class '__main__.PrintableWord'&gt;, &lt;class '__main__.PrintableMixin'&gt;, &lt;class '__main__.Word'&gt;, &lt;class '__main__.Document'&gt;, &lt;class 'object'&gt;]pw = PrintableWord('test string')pw.print() # test string Mixinclass SuperPrintableMixin(PrintableMixin): def print(self): print('-' * 20) # 打印增强 super().print() print('-' * 20) # 打印增强# PrintableMixin类的继承class SuperprintablePdf(SuperPrintableMixin, Pdf): passprint(SuperprintablePdf.__dict__) # &#123;'__module__': '__main__', '__doc__': None&#125;print(SuperprintablePdf.mro())# [&lt;class '__main__.SuperprintablePdf'&gt;, &lt;class '__main__.SuperPrintableMixin'&gt;,\# &lt;class '__main__.PrintableMixin'&gt;, &lt;class '__main__.Pdf'&gt;, \# &lt;class '__main__.Document'&gt;, &lt;class 'object'&gt;]spp = SuperprintablePdf('super print pdf')spp.print()# --------------------# super print pdf Mixin# --------------------]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[二分二分前提是有序，否则不可以二分二分查找算法的是时间复杂度O(log n) bisect模块 bisect 模块提供的函数 bisect.bisect_left(a,x, lo=0, hi=len(a))查找再有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使整个列表。如果x已经存在，在其左边插入。返回值为index bisect.bisect_right(a,x, lo=0, hi=len(a))或bisect.bisect(a,x, lo=0, hi=len(a))和bisect_left类似，但如果x已经存在，在其右边插入 bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x,lo,hi), x) bisect.insort_right(a,x, lo=0, hi=len(a))或者 bisect.insort(a,x, lo=0, hi=len(a))和insort_left函数类似，但如果已经存在，在其右边插入 函数可以分2类：bisect系，用于查找indexinsort系，用于实际插入默认重复时从右边插入1234567891011121314151617181920212223242526import bisectlst = [37, 88, 20, 50, 30, 65, 41, 50]newlst = sorted(lst) # 升序print(newlst) # [20, 30, 37, 41, 50, 50, 65, 88]print(list(enumerate(newlst)))# [(0, 20), (1, 30), (2, 37), (3, 41), (4, 50), (5, 50), (6, 65), (7, 88)]print(bisect.bisect(newlst, 20)) # 1print(bisect.bisect(newlst, 30)) # 2print(bisect.bisect(newlst, 40)) # 3print(bisect.bisect_left(newlst, 20)) # 0print(bisect.bisect_left(newlst, 30)) # 1print(bisect.bisect_left(newlst, 40)) # 3for x in (20, 30, 40, 100): bisect.insort_left(newlst, x) print(newlst) # print(newlst) 打印结果[20, 20, 30, 37, 41, 50, 50, 65, 88][20, 20, 30, 30, 37, 41, 50, 50, 65, 88][20, 20, 30, 30, 37, 40, 41, 50, 50, 65, 88][20, 20, 30, 30, 37, 40, 41, 50, 50, 65, 88, 100] 应用判断学生成绩，成绩等级A-E。其中，90分以上为’A‘，80-89分为’B‘，70-79分为’C’，60-69分为’D’，60分以下为’E‘12345678910import bisectdef get_grade(score): breakpoints = [60, 70, 80, 90] grades = 'EDCBA' return grades[bisect.bisect(breakpoints, score)]for x in (91, 82, 77, 65, 50, 60, 70, 80, 90): print('&#123;&#125; =&gt; &#123;&#125;'.format(x, get_grade(x))) 执行结果12345678991 =&gt; A82 =&gt; B77 =&gt; C65 =&gt; D50 =&gt; E60 =&gt; D70 =&gt; C80 =&gt; B90 =&gt; A]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--tracemalloc%E5%BA%93(%E7%BB%9F%E8%AE%A1%E5%86%85%E5%AD%98%E4%BD%BF%E7%94%A8%E6%83%85%E5%86%B5)%2F</url>
    <content type="text"><![CDATA[@[toc] trancemalloc标准库trancemalloc，可以统计内存使用情况filename：统计整个文件内存lineno：分开统计123456789101112import tracemalloc # from 3.4tracemalloc.start() # 开始跟踪内存分配d = [dict(zip('xy',(5, 6))) for i in range(1000000)]t = [tuple(zip('xy',(5, 6))) for i in range(1000000)]snapshot = tracemalloc.take_snapshot() # 快照，当前内存分配top_stats = snapshot.statistics('lineno') # 快照对象的统计for stat in top_stats: print(stat) 从上例中可以看出，d的内存消耗为237M，t的内存消耗为191M所以可以得知内存使用上字典还是较为占用空间的 __slots__字典为了提升查询效率，必须用空间换时间一般来说一个实例，属性多一点，都存储在字典中便于查询，问题不大但是如果数百万个实例，那么字典占的总空间就有点大Python提供了__slots__可以把属性字典__dict__省略1234567891011121314151617181920class A: x = 1 __slots__ = ('y', 'z') # 元组 # __slots__ = ['y', 'z'] # 等同上面 # __slots__ = 'y', 'z' # 等同上面 # __slots__ = 'y' def __init__(self): self.y = 5 self.z = 6 def show(self): print(self.x, self.y)a = A()a.show() # 1 5print(A.__dict__) # print(a.__dict__) # AttributeError: 'A' object has no attribute '__dict__'print(a.__slots__) # ('y', 'z') __slots__告诉解释器，实例的属性都叫什么，一般来说，既然要节约内存，最好还是使用元组比较好一旦类提供了__slots__，就阻止实例产生__dict__来保存实例的属性 动态增加属性12345# 为实例动态增加属性a.newx = 5 # AttributeError: 'A' object has no attribute 'newx'# 为类动态增加属性A.newx = 5 # 不报错，因为是类属性 说明实例不可以动态增加属性，而类可以 继承使用继承，看看__slots__是否会继承12345678910111213141516class A: x = 1 __slots__ = ('y', 'z') # 元组 def __init__(self): self.y = 5 self.z = 6 def show(self): print(self.x, self.y)class B(A): passprint(B().__dict__) 结果表明，__slots__不影响子类实例，不会继承下去，除非子类里面自己也定义了__slots__ 应用场景使用需要构建在数百万以上众多对象，且内存容量较为紧张，实例的属性简单、固定且不用动态增加的场景可以使用tracemalloc看看内存使用的差异。建议使用stats = snapshot.statistics(&#39;filename&#39;)查看总内存使用]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--StrinIO%E5%92%8CBytesIO%2F</url>
    <content type="text"><![CDATA[StringIO io模块中的类from io impoet StringIO 内存中，开辟的一个文本模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放 getvalue() 获取全部内容。跟文件指针没有关系12345678910from io impoer StringIO# 内存中构建sio = StringIO() # 像文件对象一样操作print(sio.readable(), sio.writable(), sio.seekable())sio.write("hello\nPython)sio.seek(0)print(sio.readline())print(sio.getvalue()) # 无视指针，输出全部内容sio.close() 好处 一般来说，磁盘的操作比内存的操作要慢的多，内存足够的情况下，一般的优化思想是少落地，减少磁盘IO的过程，可以大大提高程序的运行效率BytesIO io模块中的类from io impoet BytesIO 内存中，开辟的一个二进制模式的buffer，可以像文件对象一样操作它 当close方法被调用的时候，这个buffer会被释放12345678from io import BytesIO # 内存中构建bio = BytesIO()print(bio.readable(), bio.writable(), bio.seekable())bio.write(b'hello\nPython')bio.seek(0)print(bio.readline())print(bio.getvalue()) # 无视指针，输出全部内容bio.close() file-like对象 类文件对象、可以像文件对象一样操作 socket对象、输入输出对象（stdin、stdout）都是类文件对象12345from sys import stdout, stderrf = stdoutprint(type(f))f.write('hello')f.close()]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--shutil%E6%A8%A1%E5%9D%97(%E7%9B%AE%E5%BD%95%E5%A4%8D%E5%88%B6)%2F</url>
    <content type="text"><![CDATA[shutil模块 文件拷贝：使用打开2个文件对象，源文件读取内容，写入目标文件中来完成拷贝过程。但是这样丢失stat数据信息（权限等），因为根本没有复制这些信息过去 如何目录复制，Python提供了一个方便的库shutil（高级文件操作）copy复制copyfileobj(fsrc, fdst[, length]) 文件对象的复制，fsrc和fdst是open打开的文件对象，复制内容。fdst要求可写，length指定了表示buffer的大小12345678import shutilwith open('/etc/test', 'r+') as f1: f1.write('abcd\n1234') f1.flush() f1.seek(0) # 指针回0 with open('/etc/test1', 'w+') as f2: shutil.copyfileobj(f1,f2) copyfileobj源码1234567def copygileobj(fsrc, fdst, length=16*1024): """copy data from file-like object fsrc to file-like object fdst""" while 1: buf = fsrc.read(length) if not buf: # 如果为空则退出循环 break fdst.write(buf) copyfile(src, dst, *, follow_symlinks=True) 复制文件内容，不含元数据。src, dst为文件的路径字符串 本质上调用的就是copyfileobj，所以不带元数据二进制内容复制copymode(src, dst, *, follow_symlinks=True) 仅仅复制权限copystat(src, dst, *, follow_symlinks=True) 复制元数据，stat包含权限copy(src, dst, *, follow_symlinks=True) 复制文件内容、权限和部分元数据，不包括创建时间和修改时间 本质上调用的是copyfile(src, dst, follow_symlinks=follow_symlinks)copymode(src, dst, follow_symlinks=follow_symlinks)copy2 比copy多了复制全部元数据，但需要平台支持 本质上调用的是copyfile(src, dst, follow_symlinks=follow_symlinks)copystat(src, dst, follow_symlinks=follow_symlinks)copytree(src, dst, symlinks=False, ignore=None, copy_function=copy2， ignore_dangling_symlinks=False) 递归复制目录。默认使用copy2，也就是带更多的元数据复制 src、dst必须是目录，src必须存在，dst必须不存在 ignore = func，提供一个callable(src, names) -&gt; ignored_names。提供一个函数，它会被调用。src是源目录，names是os.listdir(src)的结果，就是列出src中的文件名，返回值是要被过滤的文件名的set类型数据123456# /etc/temp下有a、b目录def ignore(src, names): ig = filter(lambda x: x.startswith('a'), names) # 忽略a开头的 return set(ig)shutil.copytree('/etc/temp', '/etc/python/o', ignore=ignore) rm 删除shutil.rmtree(path, ignore_errors=False, onerror=None) 递归删除。如同rm -rf一样危险，慎用 它不是原子操作，有可能删除错误，就会中断，已经删除的就删除了 ignore_errors为True，忽略错误。当为False或者omitted时onerror生效 onerror为callable，接受函数function、path和execinfo1shutil.rmtree('/etc/bin') # 类似 rm -rf move 移动move(src, dst, copy_function=copy2) 递归移动文件、目录到目标，返回目标 本身使用的是 os.rename方法 如果不支持rename，如果是目录则copytree再删除源目录 默认使用copy2方法 12os.rename('/etc/bin/t.txt', '/etc/temp/t')os.rename('test3', '/etc/temp/test300') shutil还有打包功能。生成tar并亚索。支持zip、gz、bz、xz]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--GIT%2F</url>
    <content type="text"><![CDATA[@toc 由来 Linux内核代码需要版本管理工具管理代码，2002年开始，使用的是BitMover公司的BitKeeper这个商用软件。但是Linux社区崇尚的是自由软件相悖。 2005年，Andrew Tridgell对BitKeeper的协议进行逆向工程，BitKeeper作者决定收回无偿使用授权。磋商无果，Linus又找不到合适的版本管理工具，决定自行开发分布式版本管理工具，一个月后，Linux内核代码被Git接管。 2008年，基于WEB使用Git进行版本控制的软件托管服务的网站GitHub上线。 2016年5月9日，11年后，BitKeeper开源，发布在了GitHub上。 2018年6月4日，微软宣布，通过75亿美元的股票交易收购代码托管平台GitHub。安装https://git-scm.com/downloads下载对应操作系统的Git客户端版本Linux从RHEL上安装非常简单1# yum install git windows下载对应的32位或者64版本，点击安装即可1$ git --version 查看版本号 概念|名称| ||:–|:–||Repository 仓库、版本库|git初始化后，会在当前目录生成一个.git目录，这就是版本库||Workspace工作空间、工作区|.git文件所在的目录就是工作区，一般是项目的根目录||index索引|介于工作区和版本库之间，暂存修改的||remote 远程版本库|网络上的另一个版本库，暂存修改的| 使用初始化一个版本库$ git init 在当前目录中增加了一个.git目录,不要自行修改这个目录里面的文件 当前目录一般是项目的根目录添加文件 创建一个html文件 $ echo &#39;&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My Website&lt;/body&gt;&lt;/html&gt;&#39; &gt; index.html查看状态 git status -s, -short短格式输出，git status -s可看到当前有一个刚创建的文件为红色，需将跟踪文件使用add命令添加到暂存区index，给git管理 添加 add 单个文件添加 git add file这一步是把文件的==当前变化==添加到索引中，也就是以后这个文件需要版本库来跟踪管理，注意这不是提交。此时，文件还可以继续修改，还可以添加新的被跟踪文件，一定要add才能把这些改变加入到索引中 批量添加 git add ..点号，代表当前目录,这条命令将==递归==添加当前目录及其子目录所有文件只要是目录，就会递归添加改目录下的文件和子目录提交代码 git commit 命令行方式提交 git commit -m &quot;explain&quot; 可视化界面提交 git commit file操作如同Linux，i为输出，wq为保存退出在红色区域输出提交时的说明，需描述本次提交改动了什么文件，什么内容。修改后再次提交12345678910111213141516171819$ sed -i -r 's@(&lt;body&gt;)(.*)(&lt;/body&gt;)@\1Welcome to \2\3@' index.htm$ git status# On branch master# Changed but not updated:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: index.htm#no changes added to commit (use "git add" and/or "git commit -a")$ git commit -m "Second Commit"# On branch master# Changed but not updated:# (use "git add &lt;file&gt;..." to update what will be committed)# (use "git checkout -- &lt;file&gt;..." to discard changes in working directory)## modified: index.htmno changes added to commit (use "git add" and/or "git commit -a") 看上面的信息，commit之后发现，变动的文件index.htm并没有提交1234567891011121314151617$ git add index.htm$ git commit -m "Second Commit"[master b22f4a1] Second CommitCommitter: python &lt;python@nodex.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly:git config --global user.name "Your Name"git config --global user.email you@example.comIf the identity used for this commit is wrong, you can fix it with:git commit --amend --author='Your Name &lt;you@example.com&gt;'1 files changed, 1 insertions(+), 1 deletions(-) 提交成功 Git的文件分类 追踪的Tracked，已经加入版本库的文件 未追踪的Untracked，未加入到版本库的未被管理的文件 忽略的Ignored，git不再关注的文件，例如一些临时文件 .gitignore文件中，目录以/结尾，行起始的!的是取反 .gitignore内容如下123*.ipynb__pycache__/.python-version 忽略文件不需要自己写Python的已经有写好的https://github.com/github/gitignore/blob/master/Python.gitignore$ wget -O .gitignore https://raw.githubusercontent.com/github/gitignore/master/Python.gitignore其他语言的在这里找https://github.com/github/gitignore12345678910$ git status# On branch master## Initial commit## Changes to be committed:# (use "git rm --cached &lt;file&gt;..." to unstage)## new file: index.htm# 文件的生命周期 文件add后，就成为可跟踪文件的未修改状态unmodified，修改后，文件就变成modified状态。 再次add后，将变化提交到索引，状态变为staged，这才能提交。提交成功，文件状态从staged变回unmodified。git的提交 git的提交分为两个步骤： 暂存变更：add作用是把新文件或者文件新的改动添加到一个暂存区stage，也就是加入到index中 提交变更：commit提交的是暂存区中的改动，而不是物理文件目前的改动，提交到当前分支，默认是master分支也可以使用下面命令，将两步合成一步$ git commit index.htm 如果改动了一批文件，一个个写名字很麻烦，使用下面的命令$ git commit -a-a，–all 会把所有跟踪的文件的改动自动暂存，然后commit。上面命令未提交message，会出现一个类似vi命令的操作界面，需要编写message之后，才行。也可以使用下面的命令，把message信息一并填写了。$ git commit -a -m &quot;message&quot; 补增第二次提交后，忘记加入一个文件about.htm123456789101112131415161718$ touch about.htm$ git add about.htm$ git commit --amend[master 40dcd33] Second Commit amend Committer: python &lt;python@nodex.(none)&gt;Your name and email address were configured automatically basedon your username and hostname. Please check that they are accurate.You can suppress this message by setting them explicitly: git config --global user.name "Your Name" git config --global user.email you@example.comIf the identity used for this commit is wrong, you can fix it with: git commit --amend --author='Your Name &lt;you@example.com&gt;'1 files changed, 1 insertions(+), 1 deletions(-)create mode 100644 about.htm --amend 修改，通过创建一个新的commit来replace当前分支的顶部。也可以在命令中继续使用-m选项直接提交message。 git log 查看一下版本库里面提交的历史记录diff 比较git diff 查看被跟踪文件未暂存的修改，比较暂存区和工作区git diff --cached 查看被跟踪文件暂存的修改，比较暂存区和上一次commit的差异git diff HEAD ，查看被跟踪文件，比较工作区和上一次commit的差异。HEAD指代最后一次commit1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253$ echo "welcome about" &gt; about.htm# modified状态$ git diffdiff --git a/about.htm b/about.htmindex e69de29..621ec3a 100644--- a/about.htm+++ b/about.htm@@ -0,0 +1 @@+welcome about$ git add about.htm# staged状态$ git diff$ git diff --cacheddiff --git a/about.htm b/about.htmindex e69de29..621ec3a 100644--- a/about.htm+++ b/about.htm@@ -0,0 +1 @@+welcome about# 修改about.htm为如下内容$ cat about.htm&lt;html&gt; welcome about&lt;/html&gt;$ git diffdiff --git a/about.htm b/about.htmindex 621ec3a..5a99d50 100644--- a/about.htm+++ b/about.htm@@ -1 +1,3 @@+&lt;html&gt;welcome about+&lt;/html&gt;$ git diff --cacheddiff --git a/about.htm b/about.htmindex e69de29..621ec3a 100644--- a/about.htm+++ b/about.htm@@ -0,0 +1 @@+welcome about$ git diff HEADdiff --git a/about.htm b/about.htmindex e69de29..5a99d50 100644--- a/about.htm+++ b/about.htm@@ -0,0 +1,3 @@+&lt;html&gt;+welcome about+&lt;/html&gt; HEAD HEAD可以看做是一个游标，一般是指向当前分支最后一次提交。 HEAD的值存储在.git/HEAD中。 HEAD，指代最后一次commit HEAD^，指代上一次提交 HEAD^^，指代上上一次提交 上n次提交，表示为HEAD~n检查和重置 checkout 用于切换分支，或恢复工作区文件。==注意==：checkout会重写工作区，这个命令还是较为危险的 命令 说明 git checkout 列出暂存区可以被检出的文件 git checkout file 从暂存区检出文件到工作区，就是覆盖工作区文件，可指定检出的文件。但是不清除stage git checkout commit file 检出某个commit的指定文件到暂存区和工作区 git checkout . 检出暂存区的所有文件到工作区 1234567$ echo &gt; about.htm # 清除工作区文件内容$ git checkout about.htm # 从暂存区检出到工作区，工作区文件有了内容$ git checkout HEAD about.htm # 使用当前分支的最后一次commit检出覆盖暂存区和工作区# 下面3条命令结果一致了$ git diff$ git diff --cached$ git diff HEAD 命令 说明 git reset 列出将被reset的文件 git reset file 重置文件的暂存区，和上一次commit一致，工作区不影响 git reset --hard 重置暂存区与工作区，与上一次commit保持一致 1234567$ echo "&lt;html&gt;Welcome about&lt;/html&gt;" &gt; about.htm$ git add about.htm # 添加到暂存区$ git reset about.htm # 使用最后一次提交覆盖暂存区$ cat about.htm # 工作区文件有内容$ git add about.htm # 添加到暂存区$ git reset --hard # 重置暂存区与工作区为上一次commit$ cat about.htm # 工作区文件无内容 命令 说明 git reflog 显示commit的信息，只要HEAD发生变化，就可以在这里看到 git reset commit 重置当前分支的HEAD为指定commit，同时重置暂存区，但工作区不变 git reset --hard [commit] 重置当前分支的HEAD为指定commit，同时重置暂存区和工作区，与指定commit一致 git reset --keep [commit] 重置当前HEAD为指定commit，但保持暂存区和工作区不变 1234567891011121314151617181920212223# 修改并提交2个文件$ echo "&lt;html&gt;Welcom about&lt;/html&gt;" &gt; about.htm$ sed -i -r 's@(&lt;body&gt;)(.*)(&lt;/body&gt;)@\1\2&lt;br&gt;www.magedu.com\3@' index.htm$ git commit -a -m "Third Commit"[master cf914d1] Third Commit2 files changed, 2 insertions(+), 1 deletions(-)# 重置，使用hash值只要能唯一确定一个commit就行$ git reset --hard feccd8843HEAD is now at feccd88 First Commit$ cat index.htm&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;My Website&lt;/body&gt;&lt;/html&gt;$ git reflogfeccd88 HEAD@&#123;0&#125;: feccd8843: updating HEADcf914d1 HEAD@&#123;1&#125;: commit: Third Commit3f330fb HEAD@&#123;2&#125;: commit (amend): Second commit amend7f238b5 HEAD@&#123;3&#125;: commit: Second commit# 再次重置$ git reset --hard cf914d1$ cat index.htm&lt;html&gt;&lt;head&gt;&lt;title&gt;test&lt;/title&gt;&lt;/head&gt;&lt;body&gt;Welcome to My Website&lt;br&gt;www.magedu.com&lt;/body&gt;&lt;/html&gt; ==reset操作，要慎重== 移动和删除 git mv src dest 改名，直接把改名的改动放入暂存区 git rm file 会同时在版本库和工作目录中删除文件，真删除 git rm --cached file 将文件从暂存转成未暂存，从版本库中删除，但不删除工作目录的该文件，即文件恢复成不追踪的状态 以上都算是改动，必须commit才算真改动12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182$ echo "Python" &gt; python.htm$ git add python.htm$ git commit -m "add python"[master d2bc7d4] add python Committer: python &lt;python@nodex.(none)&gt; 1 files changed, 1 insertions(+), 0 deletions(-) create mode 100644 python.htm# MV$ git mv python.htm python.py$ git commit -m "mv python"[master 62c16ae] mv python Committer: python &lt;python@nodex.(none)&gt; 1 files changed, 0 insertions(+), 0 deletions(-) rename python.htm =&gt; python.py (100%)# 删除 git rm --cached file$ echo "print('Hello Python')" &gt; python.py$ git add python.py$ git diff --cacheddiff --git a/python.py b/python.pyindex 46c5d2c..f80df4f 100644--- a/python.py+++ b/python.py@@ -1 +1 @@-Python+print('Hello Python')$ git rm --cached python.pyrm 'python.py'$ git diff --cacheddiff --git a/python.py b/python.pydeleted file mode 100644index 46c5d2c..0000000--- a/python.py+++ /dev/null@@ -1 +0,0 @@-Python$ git commit -m 'delete python'[master 891c9a9] delete python Committer: python &lt;python@nodex.(none)&gt; 1 files changed, 0 insertions(+), 1 deletions(-) delete mode 100644 python.py# ls 看到文件还在，文件没有删除$ lsabout.htm __pycache__ Untitled1.ipynbindex.htm python.py Untitled.ipynb# 但是文件已经变成了未跟踪的状态$ git status# On branch master# Untracked files:# (use "git add &lt;file&gt;..." to include in what will be committed)## python.pynothing added to commit but untracked files present (use "git add" to track)# 文件还在，内容依然是最后修改的$ cat python.pyprint('Hello Python')# 删除 git rm file$ git add python.py$ git commit -m 'add python again'[master 5a09fe9] add python again Committer: python &lt;python@nodex.(none)&gt; 1 files changed, 1 insertions(+), 0 deletions(-) create mode 100644 python.py$ git rm python.pyrm 'python.py'$ git commit -m "delete python again"[master 3a0be16] delete python again Committer: python &lt;python@nodex.(none)&gt; 1 files changed, 0 insertions(+), 1 deletions(-) delete mode 100644 python.py# 工作区文件没有了，真删除了$ ls python.pyls: cannot access python.py: No such file or directory 配置本地用户名和邮箱 这是个好习惯，建议这时候一定要加上123456789101112$ git config --global user.name "my"$ git config --global user.email "my@163.com"# 这些内容对应~/.gitconfig文件，是 用户级别 的配置文件$ cat ~/.gitconfig[user] name = my email = my@163.com# 命令显示$ git config --global user.name$ git config --global user.email push到服务器本地搭建了一个github私服，模拟GitHubhttp://192.168.112.135:3000/my/test.git 关联远程版本库git remote 列出所有远程仓库git remote -v 详细列出所有远程仓库git remote add [shortname] [url] 指定一个名称指向远程仓库12345678910$ git remote add origin http://my@192.168.142.135:3000/my/test.git$ cat .git/config[core] repositoryformatversion = 0 filemode = true bare = false logallrefupdates = true[remote "origin"] url = http://my@192.168.142.135:3000/my/test.git fetch = +refs/heads/*:refs/remotes/origin/* 远程版本库名origin，这是个习惯用法，将建立origin和后面url的映射，这些信息保存在.git/config文件的新的段[remote “origin”] 中注意： http://my@192.168.112.135:3000/my/test.git 加上用户名，否则push会报401 git config --system 在/etc/gitconfig 文件中读写配置 git config --global 在 ~/.gitconfig 文件中读写配置 .git/config 这个文件是 版本库级别 设置文件，这里的设置具有最高优先级 推送数据12345678910$ git push -u origin master Password: Counting objects: 7, done. Delta compression using up to 2 threads. Compressing objects: 100% (5/5), done. Writing objects: 100% (7/7), 583 bytes, done. Total 7 (delta 0), reused 0 (delta 0) To http://my@192.168.142.135:3000/my/test.git * [new branch] master -&gt; master * Branch master set up to track remote branch master from origin. 输入密码就可以连接到远程仓库了。私有的仓库，必须登录，只能用户自己看，为了方便，修改为公有的。1234$ git push origin master # 指定推送到的远程主机和分支$ git push origin # 指定当前分支推送到的主机和对应分支 $ git push -u origin master # 指定远程默认主机和分支 $ git push # simple方式，默认只推送当前分支到默认关联的远程仓库 -u 第一次远程推送的时候加上，以后就可以不使用-u参数，可以git push origin master，也可以git push都使用默认。123456789101112131415161718192021$ echo "welcome about" &gt; about.htm $ git commit -a Aborting commit due to empty commit message. $ git commit -a -m "修改了about.htm" [master 6c20f48] 修改了about.htm Committer: python &lt;python@nodex.(none)&gt; Your name and email address were configured automatically based on your username and hostname. Please check that they are accurate. You can suppress this message by setting them explicitly: git config --global user.name "Your Name" git config --global user.email you@example.com If the identity used for this commit is wrong, you can fix it with: git commit --amend --author='Your Name &lt;you@example.com&gt;' 1 files changed, 1 insertions(+), 0 deletions(-) $ git push origin master # 或者git push 从远程库克隆 这一次使用git协议连接远程库。 为了演示跨平台，这里使用windows系统。 建议使用Git的windows客户端的 git bash ，它含有常用ssh命令 配置本地用户名、邮箱 123456$ git config --global user.name "jack" $ git config --global user.email "jack@163.com" $ cat ~/.gitconfig [user] name = jack email = jack@163.com 删除windows当前用户.ssh文件夹 $ ssh-keygen -t rsa -C &quot;jack@163.com&quot;-t 加密算法类型-C comment 描述信息 1234567891011121314151617181920212223242526$ ssh-keygen -t rsa -C "jack@163.com"Generating public/private rsa key pair. Enter file in which to save the key (/c/Users/Administrator/.ssh/id_rsa): # 直接回车 Enter passphrase (empty for no passphrase): # 直接回车 Enter same passphrase again: # 直接回车 Your identification has been saved in /c/Users/Administrator/.ssh/id_rsa. # 私钥Your public key has been saved in /c/Users/Administrator/.ssh/id_rsa.pub. # 公钥 The key fingerprint is:SHA256:ZxALWxgiq1UUw6TpS+p/hBeTeYOmAbIRVQNUZZ0fUxs jack@163.com The key's randomart image is: +---[RSA 2048]----+ 0|.+=B@o=+o. .E | |o. *.=.+ooo o | |.o* = o. o. | |.+ . B o .. | |. o = + S o | | o + o o | |. . o | |. . | | .... | +----[SHA256]-----+$ cd $ ls .ssh id_rsa id_rsa.pub $ pwd /c/Users/Administrator 打开gogs的用户设置 -&gt; ssh密钥 打开公钥文件-/.ssh/id_rsa.pub，将内容贴入“密钥内容”框中，点击“增加密钥”，密钥名称自己填写 那么SSH登录的用户使用的链接如下图 SSH链接远程库在windows上找一个空目录，执行下面的克隆命令注意，第一次使用ssh连接有提示，敲入yes123456$ git clone git@192.168.142.135:my/test.git Cloning into 'test'... remote: Counting objects: 28, done. remote: Compressing objects: 100% (20/20), done. remote: Total 28 (delta 0), reused 0 (delta 0)Receiving objects: 100% (28/28), done. 克隆成功 下面就可以使用这个初始的项目文件开发了 注：Linux和windows下交替演示，是想说明，git客户端无所谓在什么操作系统]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--functools%E6%A8%A1%E5%9D%97%2F</url>
    <content type="text"><![CDATA[@TOC functools模块reduce方法 reduce方法，顾名思义就是减少 ruduce(function, sequence,[, initial]) -&gt; value 可迭代对象不能为空；初始值没提供就在可迭代对象中取一个元素reduce方法举例12345from functools import reducenums = [6, 5, 8, 5, 10, 6, 9, 4]print(sum(nums)) # 53print(reduce(lambda val, x: val + x,nums)) # 53 partial方法 偏函数，把函数部分的参数固定下来，相当于为部分的参数添加了一个固定的默认值，形成一个新的函数并返回 从partial生成的新函数，是对原函数的封装partial方法举例11234567891011 import functoolsimport inspectdef add(x,y) -&gt; int: return x + ynewadd = functools.partial(add, y=5)print(newadd(7)) # 12print(newadd(7,y=6)) # 13print(newadd(y=9, x =5)) # 14print(inspect.signature(newadd)) # (x, *, y=5) -&gt; int 获取函数签名 partial方法举例212345678910111213 import functoolsimport inspectdef add(x, y, *args) -&gt; int: # print(args) # 返回值为元组 (6, 5, 7) ；(6, 5, 7, 10)；(6, 5) return x + ynewadd = functools.partial(add, 1,3,6,5)print(newadd(7)) # 4print(newadd(7, 10)) # 4print(newadd(9, 10, y=20,x=26)) # 错误传参print(newadd()) #4print(inspect.signature(newadd)) # (*args) -&gt; int partial函数本质123456789101112131415def parial(func, *args, **keywords): def newfunc(*fargs, **fkeywords): # 包装函数 newkeywords = keywords.copy() newkeywords.update(fkeywords) return func(*(args + fargs), **newkeywords) newfunc.func = func # 保留原函数 newfunc.args = args # 保留原函数的位置参数 newfunc.keywords = keywords #保留原函数的关键字参数 return newfuncdef add(x,y): return x + yfoo = parial(add,4)print(foo(5)) # 9 lre_cache方法 @functools.lru_cache(maxsize=128,typed=False) Least-recently-used装饰器。lru，最近最少使用。cache缓存 如果maxsize设置为None，则禁用LRU功能，并且缓存可以无限制增长。当maxsize是二的幂时，LRU功能执行得最好 如果typed设置为True，则不同类型的函数参数将单独缓存。例如，f(3)和f(3.0)将被视为具有不同结果的不同调用 举例123456789101112131415import functoolsimport time@functools.lru_cache()def add(x,y,z=3): time.sleep(z) # 停止z秒 return x + yprint(add(4, 5))print(add(4.0, 5))print(add(4, 6 ))print(add(4, 6, 3))print(add(4, y=6))print(add(x=4, y=6))print(add(y=6, x=4)) lru_cache装饰器 通过一个字典缓存被装饰函数的调用和返回值 斐波那契数列递归方法的改造 1234567import functools@functools.lru_cache() # maxsize=Nonedef fib(n): return 1 if n&lt;3 else fib(n-1) + fib(n-2)print([fib(i+1) for i in range(5)]) # [1, 1, 2, 3, 5] lru_cache装饰器应用 使用提前同样的函数参数一定得到同样的结果函数执行时间很长，且要多次执行 本质是函数调用的参数 =&gt; 返回值 缺点不支持缓存过期，key无法过期、失效不支持清除操作不支持分布式，是一个单机的缓存 适用场景，单机上需要空间换时间的地方，可以用缓存来将计算变成快速的查询]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--csv%E4%B8%8Eini%E6%96%87%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[csv文件csv文件简介 参看 RFC 4180http://www.ietf.org/rfc/rfc4180.txt 逗号分隔值Comma-Separated Values CSV 是一个被行分隔符、列分隔符划分成行和列的文本文件 CSV不指定字符编码 行分隔符为\r\n，最后一行可以没有换行符 列分隔符常为逗号或者制表符 每一行成为一条记录record 字段可以使用双引号括起来，也可以不使用。如果字段中出现了双引号、逗号、换行符必须使用双引号括起来。如果字段的值是双引号，使用两个双引号表示一个转义 表头可选，和字段列对齐就行手动生成csv文件1234567891011121314151617from path impoet Pathp = Path('/etc/python/test.csv')parent = p.parentif not parent.exists(): parent.mkdir(parents=True)csv_body = '''\id,name,age,comment1,zs,18,:I'm 18"2,ls,20,"this is a ""test"" string."3,ww,23,"你好计算机"'''p.write_text(csv_body) csv 模块reader(csvfile, dialect=’excel’, **fmtparams) 返回reader 对象，是一个行迭代器 默认使用excel方言，如下： delimiter 列分隔符，逗号 lineterminator 行分隔符\r\n quotechar 字段的引用符号，缺省为 “ 双引号 双引号的处理 doublequote 双引号的处理，默认为True。如果碰到数据中有双引号，而quotechar也是双引号，True则使用2个双引号表示，False表示使用转义字符将作为双引号的前缀 escapechar 一个转义字符，默认为None writer = csv.writer(f, doublequote=False, escapechar=‘@’)遇到双引号，则必须提供转义字符 quoting 指定双引号的规则 QUOTE_ALL 所有字段 QUOTE_MINIMAL 特殊字符字段，Excel方言使用该规则 QUOTE_NONNUMERIC 非数字字段 QUOTE_NONE 都不使用引号writet(csvfile, dialect=’excel’, **fmtparams) 返回DictWriter的实例 主要方法有writerow、writerows writerow(iterable)123456789101112131415161718192021222324import csvfrom pathlib import Pathp = Path('c:/tmp/mycsv/test.csv')with open(str(p)) as f: reader = csv.reaber(f) print(next(reader)) print(next(reader)) for line in reader: print(line)rows = [ [4,'tom',22,'tom'], (5,'jerry',24,'jerry'), (6,'justin',22,'just\t"in'), "abcdefgh", ((1,),(2,))]row = rows[0]with open(str(p), 'a') as f: writer = csv.writer(f) writer.writerow(row) writer.writerows(rows) 说明row行，需要一个可迭代就可以，可迭代的每一个元素，将作为csv行的每一个元素 windows下回再每行末尾多出一个/r，结果办法 open(‘test.csv’, ‘w’, newline=’’)ini文件处理 作为配置文件，ini文件的格式很流畅 中括号里面的部分称为section，译作节、区、段 每一个section内，都是key=value形成的键值对，key称为option选项 注意这里的DEFAULT是缺省section的名字，必须大写configparser configparser模块的ConfigParser类就是用来操作 可以将section当做key，section存储着键值对组成的字典，可以把ini配置文件当做一个嵌套的字典。默认使用的是有序字典read(filenames, encoding=None) 读取ini文件，可以是单个文件，也可以是文件列表。可以指定文件编码sections() 返回section列表。缺省section不包括在内add_section(section_name) 增加一个sectionhas_section(section, option) 判断seciton是否存在options(section) 返回section的所有option，会追加缺省section的optionhas_option(section, option) 判断section是否存在这个optionget(section, option, *, raw=False, vars=None[, fallback]) 从指定的段的选项上取值，如果找到返回，如果没有找到就去找DEFAULT段有没有getint(section, option, *, raw=False, vars=None[, fallback])getfloat(section, option, *, raw=False,vars=None[, fallback])getboolean(section, option, *, raw=False,vars=None[, fallback])上面3个方法和get一样，返回指定类型数据items(raw=False, vars=None)items(section, raw=Fale, vars=None) 没有section，则返回所有section名字及其对象；如果指定section，则返回这个指定的seciton的键值对组成而元组set(section, option, value) section存在的情况下，写入option=value，要求option、value必须是字符串remove_section(section) 移除seciton及其所有optionremove_option(section, option) 移除section下的optionwrite(fileobject, space_aroud_delimiters=True) 将当前config的所有内容写入fileobject中，一般open函数使用w模式123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869from configparser import ConfigParserfilename = 'test.ini'newfilename = 'mysql.ini'cfg = ConfigParser()read_ok = cfg.read(filename)print(read_ok)# print(cfg.sections())print(cfg.has_section('client'))for k,v in cfg.items(): # 未指定section print(k, type(k)) print(v, type(v)) print(cfg.items(k)) print()print('-'*30)for k,v in cfg.items("mysqld"): # 指定section print(k, type(k)) print(v, type(v)) print('~~~~~~~')print('-'*30)# 取值tmp = cfg.get('mysqld', 'port')print(type(tmp), tmp)tmp = cfg.get('mysqld', 'a')print(type(tmp), tmp)print(cfg.get('mysqld', 'hello', fallback='python')) # 缺省值# 按照类型tmp = cfg.getint('mysqld', 'port')print(type(tmp), tmp)if cfg.has_section('test'): cfg.remove_section('test')cfg.add_section('test')cfg.set('test', 'test1', '1')cfg.set('test', 'test2', '2')with open(newfilename, 'w') as f: cfg.write(f)print(cfg.getint('test', 'test2'))cfg.remove_option('test', 'test2')# 字典操作更简单cfg['test']['x'] = '1000' # key不存在cfg['test2'] = &#123;'test2':'1000'&#125; # section不存在print('x' in cfg['test'])print('x' in cfg['test2'])# 其他内容方式print(cfg._dict) # 返回默认的字典类型，默认使用有序字典&lt;&lt;class 'collections.OrderedDict&gt;&gt;for k,v in cfg._sections.items(): print(k,v) for k,v in cfg._sections['mysqld'].items(): print(k,v)# 修改后需再次写入with open(newfilename, 'w') as f: cfg.write(f)]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython---%E9%AB%98%E9%98%B6%E5%87%BD%E6%95%B0%E4%B8%8E%E6%9F%AF%E9%87%8C%E5%8C%96(sorted%2Cfilter%2Cmap)%2F</url>
    <content type="text"><![CDATA[@TOC 高阶函数一等公民 函数在Python是一等公民(First-Class Object) 函数也是对象，是可调用对象 函数可以作为普通变量，也可以作为函数的参数、返回值高阶函数高阶函数（High-order Function) 数学概念 y = f(g(x)) 在数学和计算机科学中，高阶函数应当是至少满足下面一个条件的函数 接受一个或多个函数作为参数 输出一个函数练习：自定义sort函数仿照内建函数sorted，请自行实现一个sort函数（不用使用内建函数），能够为列表元素排序思考：通过练习，思考sorted函数的实现原理，map、filter函数的实现原理思路： 内建函数sorted函数，它返回一个新的列表，可以设置升序或者降序，可以设置一个用于比较的函数（自定义函数也要实现这些功能） 新建一个列表，遍历原列表，和新列表中的当前值依次比较，决定带插入数插入到新列表的什么位置实现12345678910111213def sort(iterable, *, key=None, reverse=False): # key指定类型 newlist = [] for x in iterable: cx = key(x) if key else x # cs 只参与比较，如果有key，则key(x)，如果为None，则 x for i, y in enumerate(newlist): cy = key(y) if key else y # 同理cx comp = cx &gt; cy if reverse else cx &lt; cy # 实现reverse参数 if comp: newlist.insert(i, x) break #找到了合适的插入位置并插入成功 else: # 不大于，尾部追加 newlist.append(x) return newlist 内建高阶函数排序sorted 定义：sortediterable, , key=None, reverse=False) -&gt;list12sorted(lst, key=lambda x: 6 -x) # 返回新列表list.sort(key=lambda x: 6-x) # 就地修改 过滤filter 定义：filter(function, iterable） 过滤惰性对象，把元素一个个拿来判断是否需要输出，元素只是个数有变化，本身没有变化 对可迭代对象进行遍历，返回一个迭代器 function参数是一个参数的函数，且返回值应当是bool类型，或其返回值等效布尔值。 function参数如果是None，可迭代对象的每一个元素自身等效布尔值 123print(list(filter(lambda x: x%3==0, [1, 9, 55, 150, -2, 3, 123 ]))) # [9, 150, 3, 123]print(list(filter(None, range(5)))) # [1, 2, 3, 4]，None拿元素本身等效,判断是否为Trueprint(list(filter(None, range(-5, 5)))) # [-5, -4, -3, -2, -1, 1, 2, 3, 4] 恒定为True 恒定为Falsemap 定义：map(function, *iterables) -&gt; map ibject 对多个可迭代对象的元素，按照指定的函数进行映射 返回一个迭代器 map实现字典 木桶原理 dict会将[x, y]这个二元结构拆分为kv 如果是传入set,无序的,kv会随机排序 dict在3.6中按输入顺序排序,{x:1, y:2}相当于吧keys拿出来构造字典柯里化 指的是将原来就接受两个参数的函数变成新的接受一个参数的函数的过程。新的函数返回一个以原有第二个参数为参数的函数 z = f(x, y) 转换成 z = f(x)(y)的形式 例如：12def add(x, y): return x + y 柯里化后：1234def add(x): def _add(y): return x + y return _add 通过嵌套函数就可以把函数转换成柯里化函数 三层柯里化12345678910111213141516171819202122def add(x): def _add(y,z): return x + y + z return _addprint(add(4)(5,6)) #15def add1(x,y): def _add1(z): return x + y + z return _add1print(add1(4, 5)(6)) #15def add2(x): def _add2(y): def _add3(z): return x + y + z return _add3 return _add2print(add2(4)(5)(6)) #15]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2Fpython---%E8%BF%9B%E5%88%B6%E8%BD%AC%E6%8D%A2%E3%80%81%E8%BF%90%E7%AE%97%E7%AC%A6%E5%92%8C%E4%BC%98%E5%85%88%E7%BA%A7%E3%80%81%E5%8E%9F%E7%A0%81%E3%80%81%E8%A1%A5%E7%A0%81%2F</url>
    <content type="text"><![CDATA[进制常见进制有：二进制（0b），八进制（0o），十进制（0d），十六进制（0x） 十进制逢十进一；十六进制逢十六进一；二进制逢二进一 转为十进制：按位乘以权累加求和例：二进制（0b）：8 4 2 1 原则；即0b1111转换为十进制：8+4+2+1=15 也可以理解为 1 2 **3 + 1 2 2 + 1 * 2 1 + 1 2 0=15 十六进制（0x）**：0x7F转换为十进制计算为 7 16 + 151 =127八进制（0o）：0o111=1 8 2 + 8 1 + 1=73 转换为二进制例：十六进制（0x）：按位展开即可0x7F转换为二进制为：7即为0111，F即为1111；所以0x7F=01111110111111等于1 bytes即1个字节=8位，1个位只能表示0、11十进制：除以基数2，直到商为0为止，反向提取余数即：127=1111111十六进制（0x）：除以基数16，直到商为0为止，反向提取余数即 127 = 0x7F运算符 算数运算符 ： + - * / % ** // // 整除；5 // 2 = 2； % 模：5 % 2 = 1 ；与2模，可以用来判断奇偶数，如果结果为1则为奇数，为0则为偶数 扩展：divmod(5, 3) = (1, 2)；返回的数据类型为元祖，指1代表5，3的商，2代表5，3的余数 平方； 5 2 = 25；即5的平方；开方：5 ** 0.5 位运算符： &amp; | ~ ^ &lt;&lt; &gt;&gt;&amp; 位与，按位相与；转换成二进制，对位相乘。 9 &amp; 1 = 1，可以用来判断奇偶数，如果结果为1则为奇数，为0，则为偶数| 位或，按位相或；转换成二进制，对位相加。 9 | 8 = 9，二进制状态下相加，1+0=1；0+0=0；1+1=1 &lt;&lt; &gt;&gt;移位运算 8 &gt;&gt; 2 = 2；二进制状态下向右移三次。右移在做除法 1 &lt;&lt; 2 = 4；二进制状态下向左移三次。左移在做乘法^ 异或9 ^ 8 = 1 ；二进制状态下，相异除1，相同除0。~ 按位取反~12 = - 131 == 2 ；1是否等于2，返回值为bool型，即True，False。1 != 2 ；1是否不等于2，返回值为bool型，即True，False。假设b =510 &gt; b and b &gt; 3 当乘法看 1 * 1 = 1 ，短路原则，如果第一位False，则后面不计算。b &gt; 10 or b &gt; 3 当加法看 0 + 1 = 1not b &gt; 10 取反，等价于 b =&lt; 10b += 1 #b = b + 1 ；赋值语句，赋值及重新定义a = min(3,5) 返回值为3；即取最小值a = max(3,5) 返回值为5；即取最大值原码、反码、补码 正数的原码、补码、反码相同负数的反码，以原码的符号位不变，其余为按位取反补码以原码的符号位不变，其余为按位取反后+1补码在补码就是负数的原码例：10 ^ -900001010 10的原、补10001001 -9的原 11110111 -9的补00001010 10的补11111101 异或的补 10000011 异或的原 -3 运算符优先级 算数运算符 &gt; 位运算符 &gt; 身份运算符 &gt; 成员运算符 &gt; 逻辑运算符 单目 &gt; 双目 记不住，用括号 长表达式，多用括号，易懂，易读]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython--%20%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%80%E5%8F%91(pymysql)%2F</url>
    <content type="text"><![CDATA[@toc 驱动MySQL基于TCP协议之上开发，但是网络连接后，传输的数据必须遵循MySQL的协议封装好MySQL协议的包，就是驱动程序 MySQL的驱动 MySQLdb最有名的库。对MySQL的C Client封装实现，支持Python 2，不更新了，不支持Python3 MySQL官方ConnectorMysql官网 https://dev.mysql.com/downloads/connector/ pymysql语法兼容MySQLdb，使用Python写的库，支持Python 3pymysql使用安装$ pip install pymysql创建数据库和表12345678910CREATE DATABASE IF NOT EXISTS school;SHOW DATABASES;USE school;CREATE TABLE `student` ( `id` int(11) NOT NULL AUTO_INCREMENT, `name` varchar(30) NOT NULL, `age` int(11) DEFAULT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 123456789101112131415161718192021222324252627282930313233import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() # sql = "select * from reg" sql = "CREATE TABLE `student` (" \ "`id` int(11) NOT NULL AUTO_INCREMENT," \ "`name` varchar(30) NOT NULL," \ "`age` int(11) DEFAULT NULL," \ "PRIMARY KEY (`id`)" \ ") ENGINE=InnoDB DEFAULT CHARSET=utf8;" r = currsor.execute(sql) print(r) conn.commit()except: conn.rollback() print('roll back')finally: if currsor: currsor.close() if conn: conn.close() 连接Connect首先，必须建立一个传输数据通加粗样式道——连接。 pymysql.connect()方法返回的是Connections模块下的Connection类实例 connect方法传参就是给Connection类的 __init__ 提供参数 Connection初始化常用参数 说明 host 主机 user 用户名 password 密码 database 数据库 port 端口 Connection.ping()方法，测试数据库服务器是否活着。有一个参数reconnect表示断开与服务器连接是否重连。连接关闭抛出异常12345678910111213141516171819import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonetry: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) conn.ping(False) # ping不通则抛异常 print(conn)finally: if conn: conn.close()# 执行结果&lt;pymysql.connections.Connection object at 0x000002370C8996D8&gt; 游标Cursor操作数据库，必须使用游标，需要先获取一个游标对象Connection.cursor(cursor=None) 方法返回一个新的游标对。连接没有关闭前，游标对象可以反复使用 cursor参数，可以指定一个Cursor类。如果为None，则使用默认Cursor类 操作数据库数据库操作需要使用Cursor类的实例，提供execute() 方法，执行SQL语句，成功返回影响的行数 新增记录使用insert into语句插入数据123456789101112131415161718192021222324252627import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() sql = "insert into student (name,age) values('tom', 20)" r = currsor.execute(sql) print(r) conn.commit()except: conn.rollback() print('roll back')finally: if currsor: currsor.close() if conn: conn.close() 提交时需提供commit()方法，原因在于，在Connection类的 __init__方法的注释中有这么一句话autocommit: Autocommit mode. None means use server default. (default: False)一般不用开启自动提交功能，使用手动管理事务 事务管理Connection类有三个方法： begin 开始事务 commit 将变更提交 rollback 回滚事务 批量增加数据123456789101112131415161718192021222324252627import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() for i in range(5): sql = "insert into student (name,age) values('ben&#123;&#125;', &#123;&#125;)".format(i,20+i) r = currsor.execute(sql) conn.commit() # 提交except: conn.rollback() # 回滚 print('roll back')finally: if currsor: currsor.close() if conn: conn.close() 一般流程 建立连接 获取游标 执行SQL 提交事务 释放资源查询 Cursor类的获取查询结果集的方法有fetchone()、fetchmany(size=None)、fetchall() 查询会根据Cursor游标移动 12345678910111213141516171819202122232425262728293031323334353637383940import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() sql = 'select * from student' rows = currsor.execute(sql) # 返回影响的行数 print(currsor.fetchone()) print(currsor.fetchone()) print(currsor.rownumber, currsor.rowcount) print('1 ~~~~~~~~~~~~') print(currsor.fetchmany(2)) print(currsor.rownumber, currsor.rowcount) print('2 ~~~~~~~~~~~~~') print(currsor.fetchall()) print(currsor.rownumber, currsor.rowcount) for x in currsor.fetchall(): print(x, '~~~') currsor.rownumber = 0 for x in currsor.fetchall(): print(x, '===') finally: if currsor: currsor.close() if conn: conn.close() 执行结果 1234567891011121314151617(1, 'tom', 20)(2, 'ben0', 20)2 61 ~~~~~~~~~~~~((3, 'ben1', 21), (4, 'ben2', 22))4 62 ~~~~~~~~~~~~~((5, 'ben3', 23), (6, 'ben4', 24))6 6(1, 'tom', 20) ===(2, 'ben0', 20) ===(3, 'ben1', 21) ===(4, 'ben2', 22) ===(5, 'ben3', 23) ===(6, 'ben4', 24) ===Process finished with exit code 0 名称 说明 fetchone() 获取结果集的下一行 fetchmany(size=None) size指定返回的行数的行，None则返回空元组 fetchall() 返回剩余所有行，如果走到末尾，就返回空元组，否则返回一个元组，其元素是每一行的记录封装的一个元组 cursor.rownumber 返回当前行号。可以修改，支持负数。负向超界，拉到起始位置；正向超界，拉到末位位置 cursor.rowcount 返回的总行数 注意：fetch操作的是结果集，结果集是保存在客户端的，也就是说fetch的时候，查询已经结束了 先查后改123456789101112131415161718192021222324252627282930import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() sql = 'select * from student' rows = currsor.execute(sql) # 返回影响的行数 userid = currsor.fetchone()[0] print(userid) sql = "update student set name='jerry' where id='&#123;&#125;'".format(userid) currsor.execute(sql) conn.commit()except: conn.rollback()finally: if currsor: currsor.close() if conn: conn.close() 带列名查询 Cursor类有一个Mixin的子类DictCursor 只需要 导入from pymysql.cursors import DictCursor库 cursor = conn.cursor(DictCursor) 就可以了 具体实现1234567891011121314151617181920212223242526272829import pymysqlfrom pymysql.cursors import DictCursorIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor(DictCursor) sql = 'select * from student where id=&#123;&#125;'.format('2') currsor.execute(sql) print(currsor.fetchall())except: conn.rollback()finally: if currsor: currsor.close() if conn: conn.close()# 执行结果[&#123;'id': 2, 'name': 'ben0', 'age': 20&#125;] 返回一行，是一个字典返回多行，放在列表中，元素是字典，代表一行 SQL注入攻击 找出用户id为3的用户信息的SQL语句如下 1SELECT * from student WHERE id = 3 现在，要求可以找出某个id对应用户的信息，代码如下 12userid = 5 # 用户id可以变sql = 'SELECT * from student WHERE id = &#123;&#125;'.format(userid) userid可以变，例如从客户端request请求中获取，直接拼接到查询字符串中如果userid = &#39;5 or 1=1&#39; 1sql = 'SELECT * from student WHERE id = &#123;&#125;'.format('5 or 1=1') 运行的结果竟然是返回了全部数据 SQL注入攻击 猜测后台数据库的查询语句使用拼接字符串等方式，从而经过设计为服务端传参，令其拼接出特殊字符串的SQL语句，返回攻击者想要的结果 永远不要相信客户端传来的数据是规范及安全的！！！ 如何解决注入攻击 参数化查询 可以有效防止注入攻击，并提高查询的效率 Cursor.execute(query, args=None) args，必须是元组、列表或字典。 如果查询字符串使用%(name)s，就必须使用字典1234567891011121314151617181920212223242526272829import pymysqlfrom pymysql.cursors import DictCursorIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor(DictCursor) userid = '5 or 1=1' sql = 'SELECT * from student WHERE id = %s' currsor.execute(sql, (2,)) # 参数化查询 print(currsor.fetchall()) currsor.execute(sql, (userid,)) print(currsor.fetchall())finally: if currsor: currsor.close() if conn: conn.close() 参数化查询为什么提高效率？原因就是——SQL语句缓存 数据库服务器一般会对SQL语句编译和缓存，编译只对SQL语句部分，所以参数中就算有SQL指令也不会被当做指令执行 编译过程，需要词法分析、语法分析、生成AST、优化、生成执行计划等过程，比较耗费资源 服务端会先查找是否对同一条查询语句进行了缓存，如果缓存未失效，则不需要再次编译，从而降低了编译的成本，降低了内存消耗 可以认为SQL语句字符串就是一个key，如果使用拼接方案，每次发过去的SQL语句都不一样，都需要编译并缓存 大量查询的时候，首选使用参数化查询，以节省资源开发时，应该使用参数化查询注意：这里说的是查询字符串的缓存，不是查询结果的缓存 批量执行executemany()1234567891011121314151617181920212223242526272829import pymysqlfrom pymysql.cursors import DictCursorIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = Nonecurrsor = None # 对结果集的操作try: conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT) currsor = conn.cursor() sql = "insert into student (name,age) values(%s, %s)" currsor.executemany(sql, ( ('ben&#123;&#125;'.format(i), 20+i) for i in range(5) )) conn.commit()except Exception as e: print(e) conn.rollback()finally: if currsor: currsor.close() if conn: conn.close() 上下文支持 查看连接类和游标类的源码 123456789101112131415161718192021# 连接类class Connection(object): def __enter__(self): """Context manager that returns a Cursor""" return self.cursor() def __exit__(self, exc, value, traceback): """On successful exit, commit. On exception, rollback""" if exc: self.rollback() else: self.commit()# 游标类class Cursor(object): def __enter__(self): return self def __exit__(self, *exc_info): del exc_info self.close() 连接类进入上下文的时候会返回一个游标对象，退出时如果没有异常会提交更改 游标类也使用上下文，在退出时关闭游标对象123456789101112131415161718192021222324import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT)try: with conn.cursor() as cursor: sql = "insert into student (name,age) values('tom'%s, %s)" r = cursor.executemany(sql, (("&#123;&#125;".format(i), 20+i) for i in range(2))) print(r) # 插入行数 with conn as cursor: cursor.execute('select * from student') print(cursor.fetchall())except Exception as e: print(e)finally: if conn: conn.close() 执行结果1234562((1, 'jerry', 20), (2, 'ben0', 20), (3, 'ben1', 21),\ (4, 'ben2', 22), (5, 'ben3', 23), (6, 'ben4', 24),\ (50, "tom'0", 20), (51, "tom'1", 21))Process finished with exit code 0 换一种写法，使用连接的上下文1234567891011121314151617181920import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT)with conn as cursor: for i in range(2): sql = "insert into student (name,age) values('tom&#123;0&#125;', 20+&#123;0&#125;)".format(i) rows = cursor.execute(sql)cursor.execute('select * from student')print(cursor.fetchall())cursor.close()conn.close() conn的with进入是返回一个新的cursor对象，退出时，只是提交或者回滚了事务。并没有关闭cursor和conn。不关闭cursor就可以接着用，省的反复创建它 如果想关闭cursor对象，这样写123456789101112131415161718import pymysqlIP = '192.168.1.6'USERNAME = 'lqx'PASSWORD = 'lqx'DBNAME ='test'PORT = 3306conn = pymysql.connect(IP, USERNAME, PASSWORD, DBNAME, PORT)with conn as cursor: with cursor: sql = "select * from student" cursor.execute(sql) print(cursor.fetchall())# 关闭conn.close() 通过上面的实验，我们应该知道，连接应该不需要反反复复创建销毁，应该是多个cursor共享一个conn]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20%E4%B8%AD%20IO%E5%A4%9A%E8%B7%AF%E5%A4%8D%E7%94%A8%2F</url>
    <content type="text"><![CDATA[@toc IO多路复用 大多数操作系统都支持select和poll Linux 2.5+ 支持epoll BSD、Mac支持kqueue Solaris实现了/dev/poll Windows的IOCP Python的select库实现了select、poll系统调用，这个基本上操作系统都支持。部分实现了epoll。它是底层的IO多路复用模块 开发中的选择 完全跨平台，使用select、poll。但是性能较差 针对不同操作系统自行选择支持的技术，这样做会提高IO处理的性能 select维护一个文件描述符数据结构，单个进程使用有上限，通常是1024，线性扫描这个数据结构。效率低。pool和select的区别是内部数据结构使用链表，没有这个最大限制，但是依然是线性遍历才知道哪个设备就绪了epool使用事件通知机制，使用回调机制提高效率。 select/pool还要从内核空间复制消息到用户空间，而epoll通过内核空间和用户空间共享一块内存来减少复制 selectors库3.4版本提供selectors库，高级IO复用库1234567类层次结构︰BaseSelector+-- SelectSelector 实现select+-- PollSelector 实现poll+-- EpollSelector 实现epoll+-- DevpollSelector 实现devpoll+-- KqueueSelector 实现kqueue selectors.DefaultSelector返回当前平台最有效、性能最高的实现。但是，由于没有实现Windows下的IOCP，所以，Windows下只能退化为select 在selects模块源码最下面有如下代码 12345678910111213# Choose the best implementation, roughly:# epoll|kqueue|devpoll &gt; poll &gt; select.# select() also can't accept a FD &gt; FD_SETSIZE (usually around 1024)if 'KqueueSelector' in globals(): DefaultSelector = KqueueSelectorelif 'EpollSelector' in globals(): DefaultSelector = EpollSelectorelif 'DevpollSelector' in globals(): DefaultSelector = DevpollSelectorelif 'PollSelector' in globals(): DefaultSelector = PollSelectorelse: DefaultSelector = SelectSelector 事件注册 123class SelectSelector(_BaseSelectorImpl): """Select-based selector.""" def register(fileobj, events, data=None) -&gt; SelectorKey: pass 为selector注册一个文件对象，监视它的IO事件。返回SelectKey对象。 fileobj 被监视文件对象，例如socket对象 events 事件，该文件对象必须等待的事件 data 可选的与此文件对象相关联的不透明数据，例如，关联用来存储每个客户端的会话ID，关联方法。通过这个参数在关注的事件产生后让selector干什么事 Event常量 含义 EVENT_READ 可读 0b01，内核已经准备好输入输出设备，可以开始读了 EVENT_WRITE 可写 0b10，内核准备好了，可以往里写了 selectors.SelectorKey 有4个属性： fileobj 注册的文件对象 fd 文件描述符 events 等待上面的文件描述符的文件对象的事件 data 注册时关联的数据练习：IO多路复用TCP Server完成一个TCP Server，能够接受客户端请求并回应客户端消息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748import selectorsimport socket# 构建本系统最优Selectors = selectors.DefaultSelector() # 拿到selector# 准备类文件对象server = socket.socket()server.bind(('127.0.0.1', 9999))server.listen()# 官方建议采用非阻塞IDserver.setblocking(False)# 回调函数，sock的读事件# 形参自定义def accept(sock:socket.socket, mask:int): """mask:事件的掩码""" conn, raddr = sock.accept() conn.setblocking(False) # 非阻塞 key = s.register(conn, selectors.EVENT_READ, recv) # 读和写可同时监控, selectors.EVENT_READ | selectors.EVENT_WRITE print(key) # 回调函数def recv(conn:socket.socket, mast:int): data = conn.recv(1024) print(data) msg = 'Your msg = &#123;&#125; from &#123;&#125;'.format(data.decode(), conn.getpeername()).encode() conn.send(msg)# 注册关注的类文件对象和其事件们 'fileobj', 'fd', 'events', 'data'# 返回SelectorKey对象key = s.register(server, selectors.EVENT_READ, accept) #socket fileobjectprint(key)print(key.__class__.mro())while True: # 监听注册的对象的事件，发生被关注事件则返回events events = s.select() # epoll select, 默认是阻塞的 # 当你注册的文件对象们, 这其中的至少一个对象关注的时间就绪了,就不阻塞了 print(events) # [(key, mask)] for key, mask in events: # key.data =&gt; accept; key.fileobj =&gt; sock # 每一个event都是某一个被观察的就绪的对象 print(type(key), type(mask)) print(key.data) key.data(key.fileobj, mask) 实战：IO多路复用群聊软件将ChatServer改写成IO多路复用的方式不需要启动多线程来执行socket的accept、recv方法了12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import socketimport threadingimport selectorsimport loggingFORMAT = "%(asctime)s %(threadName)s %(thread)d %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): self.sock = socket.socket() self.addr = ip, port self.event = threading.Event() # 构建本系统最优Selector self.selector = selectors.DefaultSelector() def start(self): self.sock.bind(self.addr) self.sock.listen() self.sock.setblocking(False) # 注册sock的被关注事件，返回SelectorKey对象 # key记录了fileobj, fileobj的fd, events, data key = self.selector.register(self.sock, selectors.EVENT_READ, self.accept) logging.info(key) # 只有一个 # self.acceptkey = key # select用的 threading.Thread(target=self.select, name='select', daemon=True).start() def select(self): while not self.event.is_set(): # 监听注册的对象的事件，发生被关注事件则返回events events = self.selector.select() # 阻塞 print(events) # [(key, mask)] for key, mask in events: # key.data =&gt; accept; key.fileobj =&gt; sock key.data(key.fileobj, mask) # select线程 # 回调函数，sock的读事件 # 形参自定义 def accept(self, sock:socket.socket, mask): """mask:事件的掩码""" conn, raddr = self.sock.accept() conn.setblocking(False) # 非阻塞 key = self.selector.register(conn, selectors.EVENT_READ, self.recv) logging.info(key) #n个 # 回调函数 def recv(self, conn:socket.socket, mask): data = conn.recv(1024) if data.strip() == b'quit' or data.strip() == b'': # bye self.selector.unregister(conn) conn.close() return for key in self.selector.get_map().values(): # if key.fileobj is self.sock :continue # print(self.recv is key.data) # False # print(self.recv == key.data) if key.data == self.recv: # key.data 注册时注入的绑定的对象 s = key.fileobj msg = 'Your msg = &#123;&#125; from &#123;&#125;'.format(data.decode(), conn.getpeername()).encode() s.send(msg) def stop(self): self.event.set() fs = [] for key in self.selector.get_map().values(): fs.append(key.fileobj) for f in fs: self.selector.unregister(f) f.close() self.selector.close()if __name__ == '__main__': cc = ChatServer() cc.start() while True: cmd= input('&gt;&gt;').strip() if cmd == 'quit': cc.stop() break logging.info(threading.enumerate()) 本例只完成基本功能，其他功能如有需要，请自行完成。注意使用IO多路复用，使用了几个线程？特别注意key.data == self.recv 总结使用 IO多路复用 +（select、epoll） 并不一定比 多线程 + 同步阻塞IO 性能好，其最大优势可以处理更多的连接 多线程 + 同步阻塞IO模式开辟太多线程，线程开辟、销毁开销还是较大，倒是可以使用线程池；线程多，线程自己使用的内存也很可观；多线程切换时要保护现场和恢复现场，线程过多，切换会占用大量的时间 连接较少，多线程 + 同步阻塞IO模式比较适合，效率也不低 如果连接非常多，对服务端程序来说，IO并发还是比较高的，这时候，开辟太多线程其实也不是很划算，这时候IO多路复用或许是更好的选择，使用epoll]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20-%E8%B7%AF%E5%BE%84%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOC 路径操作模块3.4版本之前os.path模块123456789101112131415161718from os import pathp = path.join('/etc', 'sysconfig', 'network') # 拼接pring(type(p), p)print（path.exists(p）) # 存在print(path.split(p)) # 分割print(path.dirname(p), path.basename(p)) #路径和基名print(path.abspath(''),path.abspath('.')) # 绝对路径print(path.spltdrive('d:/temp/test')) # windows方法p1 = path.abspath(__file__)print(p1)while p1 !=path.dirname(p1): dirname = path.ditname(p1) print(ditname) p1 = dirname 3.4版本开始 建议使用pathlib模块，提供Path对象来操作。包括目录和文件pathlib模块 from pathlib import Path目录操作初始化123p = Path() # 当前目录， Path()、Path('.')、Path('')p = Path('a', 'b', 'c/d') # 当前目录下的a/b/c/dp = Path('/etc') # 根下的etc目录 路径拼接和分解 操作符 /Path对象 / Path对象Path对象 / 字符串 或者 字符串 / Path对象 分解parts属性，可以返回路径中的每一个部分 joinpathjoinpath(*other)连接多个字符串到Path对象中12345678910from pathlib import Pathp = Path()p = p / 'a'p1 = 'b' / p p2 = Path('c')p3 = p2 / p1print(p3.parts) # ('c', 'b', 'a')p4 = p3.joinpath('etc', 'init.d', Path('httpd')) # c\b\a\etc\init.d\httpdprint(p4) 获取路径 str 获取路径字符串 bytes 获取路径字符串的bytes12345from pathlib import Pathp = Path('/etc')print(str(p)) # \etcprint(bytes(p)) # b'\\etc' 父目录 parent目录的逻辑父目录 parents父目录序列，可迭代对象，索引0是直接的父123456789101112from pathlib import Pathp = Path('a/b/c/d')print(p.parent) # a\b\cprint(p.parent.parent) # a\bfor x in p.parents: print(x)# print(x)执行结果# a\b\c# a\b# a# . 目录组成部分 name、stem、suffix、suffixes、with_suffix(suffix)、whit_name(name)name 目录的最后一个部分suffix 目录中最后一个部分的扩展名stem 目录最后一个部分，没有后缀name = stem + suffixsuffixes 返回多个扩展名列表with_suffix(suffix) 有扩展名则替换，无则补充扩展名whit_name(name) 替换目录最后一个部分并返回一个新的路径1234567891011from pathlib import Pathp = Path('/etc/python/mysql.tar.gz')print(p.name) # mysql.tar.gzprint(p.suffix) # .gzprint(p.suffixes) # ['.tar', '.gz']print(p.stem) # mysql.tarprint(p.with_name('python-5.tgz')) # \etc\python\python-5.tgzprint(p.with_suffix('.png')) # \etc\python\mysql.tar.pngp = Path('README')print(p.with_suffix('.txt')) # README.txt 全局方法 cwd() 返回当前工作目录 home()返回当前家目录判断方法 exists() 目录或者文件是否存在 is_dir() 是否是目录，目录存在返回True is_file() 是否是普通文件，文件存在返回True is_symlink() 是否是软链接 is_socket() 是否是socket文件 is_block_device() 是否是块设备 is_char_device() 是否是字符设备 is_absolute() 是否是绝对路径绝对路径 resolve() 非Windows，返回一个新的路径，这个新路径就是当前Path对象的绝对路径，如果是软链接则直接被解析 absolute() 获取绝对路径 rmdir() 删除空目录。没有提供判断目录为空的方法 touch(mode=0o666, exist_ok=True) 创建一个文件 as_uri() 将路径返回成URI，例如’file:///etc/passwd’ mkdir(mode=0o777, parents=False, exist_ok=False) parents，是否创建父目录，True等同于mkdie -p。False时，父目录不存在，则抛出FileNotFoundError exist_ok参数，在3.5版本加入，False时，路径存在。抛出FileExistsError；True时，FileExistsError被忽略 iterdir()迭代当前目录，不递归12345678910111213141516171819202122232425262728293031from pathlib import Pathp = Path()p /= 'a/b/c/d'p.exists() # True#创建目录p.mkdir() # FileNotFoundErrorp.mkdir(parents=True)p.exists() # Truep.mkdir(parents=True)p.mkdir(parents=True,exist_ok=True)p /= 'readme.txt'p.parent.exists() # False 'a/b/c'p.mkdir() # FileNotFoundErrorp.mkdir(parents=True) # 成功# 遍历，判断文件类型，如果是目录是否可以判断其是否为空目录？for x in p.parents[len(p.parents) - 1].iterdir(): print(x, end='\t') if x.is_dir(): flag = False for _ in x.iterdir(): flag = True break print('dir', 'Not Empty' if flag else 'Empyt',sep='\t') elif x.is_file(): print('file') else: print('other file') 通配符 glob(pattern) 通配给定的模式 rglob(pattern) 通配给定的模式，递归目录 都返回一个生成器 ? 代表一个字符 * 表示任意一个字符 [abc]或[a-z]表示一个字符12345678list(p.glob('test*') # 返回当前目录对象下的test开头的文件list(p.glob('**/*.py') # 递归所有目录，等同rgloblist(p.glob('**/*'))g = p.rglob('*.py') # 生成器，递归next(g)list(p.rglob('*.???')) # 匹配扩展名为3个字符的文件list(p1.rglob('[a-z]*.???')) # 匹配字母开头的且扩展名是3个字符的文件 匹配 match(pattern) 模式匹配，成功返回True 12345678from pathlib import PathPath('a/b.py').match('*.py') # TruePath('/a/b/c.py').match('b/*.py') # TruePath('/a/b/c.py').match('a/*.py') # FalsePath('/a/b/c.py').match('a/*/*.py') # TruePath('/a/b/c.py').match('a/**/*.py') # TruePath('/a/b/c.py').match('**/*.py') # True stat()相当于stat命令 lstat()同stat()，但如果是符号链接，则显示符号链接本身的文件信息12345678# ln -s test tfrom pathlib import Pathp = Path('test')p.stat()p1 = Path('t')p1.stat()p1.lstat() 文件操作1Path.open(mode='r', buffering=-1, encoding=None, errors=None, newline=None) 使用方法类似内建函数open。返回一个文件对象 3.5增加的新函数1Path.read_bytes() 以’rb’读取路径对应文件，并返回二进制流。看源码1Path.read_test(encoding=None, errors=None) 以’rt’方式读取路径对应文件，返回文本1Path.write_bytes(data) 以’wb’方式写入数据到路径对应文件1Path.write_text(data, encoding=None, errors=None) 以’wt’方式写入字符串到路径对应文件123456789101112from pathlib import Pathp = Path('my_binary_file')p.write_bytes(b'Binary file contents')p.read_bytes() # b'Binary file contents'p = Path('my_text_file')p.write_text('Text file contents')p.read_text() # 'Text file contents'with p.open() ad f: print(f.read(5)) os 模块 操作系统平台 os.listdie(‘o:/temp’)返回指定目录内容列表，不递归os也有open、read、write等方法，但是太底层，建议使用内建函数open、read、write，使用方法相似 12# 建立一个软链接$ ln -s test t1 os.stat(path, *, dir_fd=None,follow_symlinks=True) 本质上调用Linux系统的stat path：路径的string或者bytes，或者fd文件描述符 follow_symlinks True返回文件本身信息，False且如果是软链接则显示软链接本身。可以使用os.lstat方法 12345os.stat('o:/test.txt')os.stat_result(st_mode=33206, st_ino=281474976710698, st_dev=389224164, st_nlink=1, st_uid=0, st_gid=0, st_size=0, st_atime=1508808249, st_mtime=1508808249, st_crtime=1508808249)st_mode=33206 =&gt; 100666os.stat('test')os.stat_result(st_mode=33204, st_ino=3407875, st_dev=64768, st_nlink=1, st_uid=500, st_gid=500, st_size=3, st_atime=1508690220, st_mtime=1508690177, st_crtime=1508690177) os.chmod(path, mode, *, dit_fd=None, follow_symlinks=True) os.chmod(‘test’,0o777) os.chown(path,uid,gid)改变文件的属主、属组，但需要足够的权限]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20--%E7%AE%80%E5%8D%95%E9%80%89%E6%8B%A9%E6%8E%92%E5%BA%8F%2F</url>
    <content type="text"><![CDATA[@TOC 简单选择排序 属于选择排序 两两比较大小；找出极值（极大值或极小值）被放置在固定的位置，这个位置一般指的是某一端 结果分为升序和降序排序 降序n个数从左至右，索引从0开始到n-1，两两一次比较，记录最大值索引，此轮所有数比较完毕，将最大数和索引0数交换，如果大数就是索引1，不交换。第二轮，从1开始比较，找到最大值，将它和索引1位置交换，如果它就在索引1位置则不交换。以此类推，每次左右都会固定下一个大数。 升序和降序相反简单选择排序代码实现(一) 将1-9随机打乱后,从大到小排序 12345678910111213141516171819#解析版nums = list(range(10))# 生成0~9的十个数import random #导入模块random.shuffle(nums) # 导入shuffle随机生成树模块,将该列表随机打乱print(nums) #打印出随机打乱列表后的效果length = len(nums) #计算长度count_iter = 0 #计算迭代次数count_swap = 0 #计算交换次数#选择排序for i in range(length): # 迭代从0开始 maxindex = i # 默认迭代第一次是数就是最大值,即索引为0为最大值 for j in range(i+1, length): # 迭代从1开始 count_iter += 1 if nums[j] &gt; nums[maxindex]: #当maxindex即i=0,j=1~9, maxindex = j #,如果索引为j大于索引为maxindex,则最大值即maxindex=j,变为索引为j if i != maxindex: #如果上述if语句有成立,则证明maxindex有变过,即i != maxindex nums[i], nums[maxindex] = nums[maxindex], nums[i] #两个索引位置的元素交换 count_swap +=1print(nums, count_iter, count_swap) #打印打印出排好序的列表,迭代和交换过的次数 1234567891011121314#纯净版nums = list(range(10))import random random.shuffle(nums) print(nums) length = len(nums) for i in range(length): maxindex = i for j in range(i+1, length): if nums[j] &gt; nums[maxindex]: maxindex = j if i != maxindex: nums[i], nums[maxindex] = nums[maxindex], nums[i] print(nums) 简单选择排序代码实现(二)优化实现 二元选择排序同时固定左边最大值和右边最小值优点:减少迭代元素的次数1234567891011121314151617181920212223242526272829#解析版nums = list(range(10))# 生成0~9的十个数import random #导入模块random.shuffle(nums) # 导入shuffle随机生成树模块,将该列表随机打乱print(nums) #打印出随机打乱列表后的效果length = len(nums) #计算长度count_iter = 0 #计算迭代次数count_swap = 0 #计算交换次数for i in range(length // 2): #length // 2 整除,因为一轮循环同时确定了左右两个极值,所以i=[0,1,2,3] maxindex = i # 默认迭代第一次是数就是最大值,即索引为0为最大值 minindex = -i - 1 # 默认迭代第一次是数就是最小值,即索引为-1为最小值 minorigin = length + minindex # 将负索引转换为正索引 for j in range(i+1, length-i): #当i=0,j=[1~9);当i=1,j=[2~8),当i=3,j=[4,6) count_iter += 1 if nums[j] &gt; nums[maxindex]: #第一次当i=0,j取[1~8) maxindex = j #如果索引为j大于索引为maxindex,则最大值即maxindex=j,变为索引为j if nums[-j -1] &lt; nums[minindex]: #第一次当i=0,j取[1~8),-j -1 = -2,即索引[-2]与[-1]比较 minindex = -j - 1 # 如果有发现比索引[minindex]还小的,则进行交换. if nums[maxindex] == nums[minindex]: braek #元素都相同 if i != maxindex: #如果上述if nums[j] &gt; nums[maxindex] 语句有成立,则证明maxindex有变过,即i != maxindex nums[i], nums[maxindex] = nums[maxindex], nums[i] #两个索引位置的元素交换 count_swap += 1 if i == minindex: minindex = maxindex #修正索引, if minindex != minorigin and nums[minorigin] != nums[minindex]: # 索引不同,但是值相同,没有必要交换 nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin] #两个索引位置的元素交换 #count_swap += 1print(nums, count_iter, count_swap) 1234567891011121314151617181920212223# 纯净版nums = list(range(10))import randomrandom.shuffle(nums)print(nums)length = len(nums) for i in range(length // 2): maxindex = i minindex = -i - 1 minorigin = length + minindex for j in range(i+1, length-i): if nums[j] &gt; nums[maxindex]: maxindex = j if nums[-j -1] &lt; nums[minindex]: minindex = -j - 1 if nums[maxindex] == nums[minindex]: braek if i != maxindex: nums[i], nums[maxindex] = nums[maxindex], nums[i] if i == minindex: minindex = maxindex if minindex != minorigin and nums[minorigin] != nums[minindex]: nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]print(nums) 总结 简单选择排序需要数据一轮轮比较，并在每一轮中发现极值 没有办法知道当前轮是否已经达到排序要求，但是可以知道极值是否在目标索引位置上 遍历次数1,…,n-1之和n(n-1)/2 时间复杂度O(n²) 减少了交换次数，提高了效率，性能略好于冒泡法]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20--%20%E9%AB%98%E5%B9%B6%E5%8F%91%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88%2F</url>
    <content type="text"><![CDATA[@toc 基本概念并发和并行区别并行，parallel 同时做某些事，可以互不干扰的同一个时刻做几件事并发，concurrency 也是同时做某些事，但是强调，一个时段内有事情要处理。举例 高速公路的车道，双向4车道，所有车辆（数据）可以互不干扰的在自己的车道上奔跑（传输） 在同一个时刻，每条车道上可能同时有车辆在跑，是同时发生的概念，这是并行 在一段时间内，有这么多车要通过，这是并发并发的解决某个时间段内，数据涌来，这就是并发。如果数据量很大，就是高并发1、队列、缓冲区 假设只有一个窗口，陆续涌入食堂的人，排队打菜是比较好的方式 所以，排队（队列）是一种天然解决并发的办法 排队就是把人排成 队列，先进先出，解决了资源使用的问题 排成的队列，其实就是一个缓冲地带，就是 缓冲区 假设女生优先，每次都从这个队伍中优先选出女生出来先打饭，这就是 优先队列 例如queue模块的类Queue、LifoQueue、PriorityQueue（小顶堆实现）2、争抢 只开一个窗口，有可能没有秩序，也就是谁挤进去就给谁打饭 挤到窗口的人占据窗口，直到打到饭菜离开 其他人继续争抢，会有一个人占据着窗口，可以视为锁定窗口，窗口就不能为其他人提供服务了。这是一种锁机制 谁抢到资源就上锁，排他性的锁，其他人只能等候 争抢也是一种高并发解决方案，但是，这样可能不好，因为有可能有人很长时间抢不到3、预处理 如果排长队的原因，是由于每个人打菜等候时间长，因为要吃的菜没有，需要现做，没打着饭不走开，锁定着窗口 食堂可以提前统计大多数人最爱吃的菜品，将最爱吃的80%的热门菜，提前做好，保证供应，20%的冷门菜，现做 这样大多数人，就算锁定窗口，也很快打到饭菜走了，快速释放窗口 一种提前加载用户需要的数据的思路，预处理 思想，缓存常用4、并行 成百上千人同时来吃饭，一个队伍搞不定的，多开打饭窗口形成多个队列，如同开多个车道一样，并行打菜 开窗口就得扩大食堂，得多雇人在每一个窗口提供服务，造成 成本上升 日常可以通过购买更多服务器，或多开进程、线程实现并行处理，来解决并发问题 注意这些都是 水平扩展 思想 注：如果线程在单CPU上处理，就不是真并行了但是多数服务器都是多CPU的，服务的部署往往是多机的、分布式的，这都是并行处理5、提速 提高单个窗口的打饭速度，也是解决并发的方式 打饭人员提高工作技能，或为单个窗口配备更多的服务人员，都是提速的办法 提高单个CPU性能，或单个服务器安装更多的CPU 这是一种 垂直扩展 思想6、消息中间件 上地、西二旗地铁 站外 的九曲回肠的走廊，缓冲人流，进去之后再多口安检进站 常见的消息中间件有RabbitMQ、ActiveMQ（Apache）、RocketMQ（阿里Apache）、kafka（Apache）等 当然还有其他手段解决并发问题，但是已经列举除了最常用的解决方案，一般来说不同的并发场景用不同的策略，而策略可能是多种方式的优化组合 例如多开食堂（多地），也可以把食堂建设到宿舍生活区（就近），所以说，技术来源于生活]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20--%20%E8%AE%A1%E7%AE%971000%E4%BB%A5%E5%86%85%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%E8%A2%AB7%E6%95%B4%E9%99%A4%E7%9A%84%E5%89%8D20%E4%B8%AA%E6%95%B0%EF%BC%88for%E5%BE%AA%E7%8E%AF%EF%BC%89%2F</url>
    <content type="text"><![CDATA[写法1：123456count = 1for i in range(7, 1000, 7): print(i) if count == 20: berak # 终止当前循环体的执行 count += 1 写法2：123456count = 0for i in range(7, 1000, 7): print(i) count += 1 if count == 20: berak # 终止当前循环体的执行 写法3：1234num = 7for i in range(20): print(num) num += 7]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2Fpython%20--%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(UDP%E7%BC%96%E7%A8%8B)%2F</url>
    <content type="text"><![CDATA[@TOC测试命令123456windows 查找udp是否启动端口&gt; netstat -anp udp | find "9999"&gt; net stat -anbp udp | findstr 9999linux下发给服务端数据$ echo "123abc" | nc -u 127.0.0.1 9999 UDP服务端编程UDP服务端编程流程 创建socket对象。type=socket.Sock_DGRAM 绑定IP和Port，bing()方法 传输数据 接受数据，socket.recvform(bufsize[flags]),获得一个二元组(string,address) 发送数据，socket.sendto(string, address)发给某地址某信息 释放资源12345678910import socketserver = socket.socket(type=socket.SOCK_DGRAM)server.bing(('0.0.0.0', 9999)) # 立即绑定一个udp端口data = server.recv(1024) # 阻塞等待数据data = server.recvfrom(1024) # 阻塞等待数据(value, (ip, port))server.sendto(b'hello', ('192.168.142.1', 10000))server.close() UDP客户端编程流程 创建socket对象。type=socket.Sock_DGRAM 发送数据，socket.sendto(string, address)发给某地址某信息 接受数据，socket.recvform(bufsize[flags]),获得一个二元组(string,address) 释放资源 1234567891011import socketclient = socket.socket(type=socket.SOCK_DGRAM)raddr = ('192.168.142.1', 9999)client.connect(raddr)client.sendto(b'hello', raddr)client.send(b'hello')data = client.recvfrom(1024) # 阻塞等待数据(value, (ip, port))data = client.recv(1024) # 阻塞等待数据client.close() 注意：UDP是无连接协议，所以可以只有任何一端例如客户端数据发往服务端，服务端存在与否无所谓 UDP编程中bind、connect、send、sendto、recv、recvfrom方法使用 UDP的socket对象创建后，是没有占用本地地址和端口的 方法 说明 bind方法 可以指定本地地址和端口laddr，会立即占用 connect方法 可以立即占用本地地址和端口laddr，填充远程地址和端口raddr sendto方法 可以立即占用本地地址和端口laddr，并把数据发往指定远端。只有有了本地绑定端口，sendto就可以向任何远端发送数据 send方法 需要和connect方法配合， 可以使用已经从本地端口把数据发往raddr指定的远端 recv方法 要求一定要在占用了本地端口后，返回接受的数据 recvfrom方法 要求一定要占用了本地端口后，返回接受的数据和对端地址的二元祖 练习 –UDP版群聊UDP版群聊服务端代码 服务端类的基本架构 1234567891011class ChatUDPServer: def __init__(self, ip='127.0.0.1', port=9999): self.addr = (ip, port) self.sock = socket.socket(type=socket.SOCK_DGRAM) def start(self): self.sock.bind(self.addr) # 立即绑定 self.sock.recvfrom(1024) # 阻塞接受数据 def stop(self): self.sock.close() 完整版版代码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import socketimport threadingimport datetimeimport loggingFORMAT = "%(asctime)s %(threadName) %(thread) %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatUDPServer: def __init__(self, ip='127.0.0.1', port=9999): self.addr = (ip, port) self.sock = socket.socket(type=socket.SOCK_DGRAM) self.clients = set() # 记录客户端 self.event = threading.Event() def start(self): self.sock.bind(self.addr) # 立即绑定 # 启动线程 threading.Thread(target=self.recv, name='recv').start() def recv(self): while not self.event.is_set(): data , raddr = self.sock.recvfrom(1024) # 阻塞接受数据 if data.strip() == b'quit': # 有可能发来的数据不在clients中 if raddr in self.clients: self.clients.remove(raddr) logging.info('&#123;&#125; leaving'.format(raddr)) continue self.clients.add(raddr) msg = '&#123;&#125;. from &#123;&#125;:&#123;&#125;'.format(data.decode(), *raddr) logging.info(msg) msg = msg.encode() for c in self.clients: self.sock.sendto(msg, c) # 不保证对方能够收到 def stop(self): for c in self.clients: self.sock.sendto(b'bye', c) self.sock.close() self.event.set()def main(): cs = ChatUDPServer() cs.start() while True: cmd = input('&gt;&gt;&gt;') if cmd.strip() == 'quit': cs.stop() break logging.info(threading.enumerate()) logging.info(cs.clients)if __name__ == '__main__': main() UDP版群聊客户端代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import socketimport threadingimport datetimeimport loggingFORMAT = "%(asctime)s %(threadName) %(thread) %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatUdpClient: def __init__(self, rip='127.0.0.1', rport=9999): self.sock = socket.socket(type=socket.SOCK_DGRAM) self.raddr = (rip, rport) self.event = threading.Event() def start(self): self.sock.connect(self.raddr) # 占用本地地址和端口，设置远端地址和端口 threading.Thread(target=self.recv, name='recv').start() def recv(self): while not self.event.is_set(): data , raddr = self.sock.recvfrom(1024) msg = '&#123;&#125;. from &#123;&#125;:&#123;&#125;'.format(data.decode(), *raddr) logging.info(msg) def send(self, msg:str): self.sock.sendto(msg.encode(), self.raddr) def stop(self): self.event.set() self.send('quit') # 通知服务端退出 self.sock.close() def main(): cc1 = ChatUdpClient() cc2 = ChatUdpClient() cc1.start() cc2.start() print(cc1.sock) print(cc2.sock) while True: cmd = input('Input your words &gt;&gt;') if cmd.strip() == 'quit': cc1.stop() cc2.stop() break cc1.send(cmd) cc2.send(cmd)if __name__ == '__main__': main() 上面的例子并不完善，如果客户端断开了，服务端不知道。每一个服务端还需要对所有客户端发送数据，包括已经断开的客户端。问题：服务端如何知道客户端断开了呢？ 代码改进服务端代码改进 增加心跳heartbeat机制或ack机制。这些机制同样可以用在TCP通信的时候 心跳，就是一端定时发往另一端的信息，一般每次数据越少越好。心跳时间间隔约定好就行 ack即响应，一端收到另一端的消息后返回的确认信息心跳机制 一般来说是客户端定时发往服务端的，服务端并不需要ack回复客户端，只需要记录该客户端还活着就行了 如果是服务端定时发往客户端的，一般需要客户端ack响应来表示活着，如果没有收到ack的客户端，服务端移除其信息。这种实现较为复杂，用的较少 也可以双向都发心跳的，用的更少 在服务器端代码中使用第一种心跳机制改进123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172import socketimport threadingimport datetimeimport loggingFORMAT = "%(asctime)s %(threadName) %(thread) %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatUDPServer: def __init__(self, ip='127.0.0.1', port=9999, intreval=10): self.addr = (ip, port) self.sock = socket.socket(type=socket.SOCK_DGRAM) self.clients = &#123;&#125; # 记录客户端, 改为字典 self.event = threading.Event() self.interval = intreval # 默认10秒，超时就要移除对应的客户端 def start(self): self.sock.bind(self.addr) # 立即绑定 # 启动线程 threading.Thread(target=self.recv, name='recv').start() def recv(self): while not self.event.is_set(): localset = set() # 清理超市 data , raddr = self.sock.recvfrom(1024) # 阻塞接受数据 current = datetime.datetime.now().timestamp() # float if data.strip() == b'^hb^': # 心跳信息 self.clients[raddr] = current continue elif data.strip() == b'quit': # 有可能发来的数据不在clients中 self.clients.pop(raddr, None) logging.info('&#123;&#125; leaving'.format(raddr)) continue self.clients[raddr] = current msg = '&#123;&#125;. from &#123;&#125;:&#123;&#125;'.format(data.decode(), *raddr) logging.info(msg) msg = msg.encode() for c , stamp in self.clients.items(): if current - stamp &gt; self.interval: localset.add(c) else: self.sock.sendto(msg, c) # 不保证对方能够收到 for c in localset: self.clients.pop(c) def stop(self): self.event.set() self.clients.clear() self.sock.close()def main(): cs = ChatUDPServer() cs.start() while True: cmd = input('&gt;&gt;&gt;') if cmd.strip() == 'quit': cs.stop() break logging.info(threading.enumerate()) logging.info(cs.clients)if __name__ == '__main__': main() 客户端代码改进增加定时发送心跳代码12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import socketimport threadingimport datetimeimport loggingFORMAT = "%(asctime)s %(threadName) %(thread) %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatUdpClient: def __init__(self, rip='127.0.0.1', rport=9999): self.sock = socket.socket(type=socket.SOCK_DGRAM) self.raddr = (rip, rport) self.event = threading.Event() def start(self): self.sock.connect(self.raddr) # 占用本地地址和端口，设置远端地址和端口 threading.Thread(target=self._sendhb, name='heartbeat', daemon=True).start() threading.Thread(target=self.recv, name='recv').start() def _sendhb(self): # 心跳 while not self.event.wait(5): self.send('^hb^') def recv(self): while not self.event.is_set(): data, raddr = self.sock.recvfrom(1024) msg = '&#123;&#125;. from &#123;&#125;:&#123;&#125;'.format(data.decode(), *raddr) logging.info(msg) def send(self, msg: str): self.sock.sendto(msg.encode(), self.raddr) def stop(self): self.event.set() self.send('quit') # 通知服务端退出 self.sock.close()def main(): cc1 = ChatUdpClient() cc2 = ChatUdpClient() cc1.start() cc2.start() print(cc1.sock) print(cc2.sock) while True: cmd = input('Input your words &gt;&gt;') if cmd.strip() == 'quit': cc1.stop() cc2.stop() break cc1.send(cmd) cc2.send(cmd)if __name__ == '__main__': main() UDP协议应用UDP是无连接协议，它基于以下假设： 网络足够好 消息不会丢包 包不会乱序 但是，即使再局域网，也不能保证不丢包，而且包的达到不一定有序 应用场景 视频、音频传输，一般来说，丢些包，问题不大，最多丢些图像、听不清话语，可以重新发话语来解决 海量采集数据，例如传感器发来的数据，丢几十、几百条数据也没有关系 DNS协议，数据内容小，一个包就能查询到结果，不存在乱序，丢包，重新请求解析 一般来说，UDP性能优于TCP，但是可靠性要求高的场合的还是要选择TCP协议]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2Fpython%20--%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(TCP%E7%BC%96%E7%A8%8B)%2F</url>
    <content type="text"><![CDATA[@TOC TCP编程 Socket编程，需要两端，一般来说需要一个服务端、一个客户端，服务端称为Server，客户端称为Client 这种编程模式也称为 CS编程TCP服务端编程服务端编程步骤 创建Socket对象 绑定IP地址Address和端口Port。使用bind()方法IPv4地址为一个二元组(‘IP地址字符串‘， Port) 开始监听，将再指定的IP端口上监听。使用listen()方法 获取用于传送数据的socket对象socket.accrpt() -&gt; (socket object, address info)accept方法阻塞等待客户端创立连接，返回一个新的Socket对象和客户端地址的二元组地址是远程客户端的地址，IPv4中它是一个二元组(clientaddr, port)接受数据 recv(bufsize[, flags]) 使用缓冲区接受数据 发送数据 send(bytes) 发送数据，必须传入一个bytes 问题两次绑定同一个监听端口会怎么样？1234567891011121314151617181920212223242526import sockets = socket.socket() # 创建socket对象，TCP连接 IPv4ip = '127.0.0.1' # 本机回环地址port = 9999 # TCP 65536s.bind((ip, port)) # 一个地址和端口二元组s.listen() # 开始监听，等待客户端连接到来# 接入一个到来的连接s1, info = s.accept() # 阻塞直到和客户端成功建立连接，返回一个新的socket对象和客户端地址print(s1, info)# 使用缓冲区获取诗句data = s1.recv(1024) # 阻塞print(info, data)s1.send(b'hello world')s1.close()# 接入另一个连接s2, info = s.accept()data = s2.recv(1024)print(info, data)s2.send(b'hello python')s2.close()s.close() 上例accept和recv是阻塞的，主线程经常被阻塞住而不能工作 客户端操作使用测试工具模拟客户端进行测试 灰色，需点连接才可成功连接查看监听端口 windoes 命令-anp tcp | findstr 9999```12- linux 命令```netstat -tanl | grep 9999 或-tanl | grep 9999```123456789101112131415161718192021222324252627282930ss命令没有可使用`pip install ss`自行安装### 注意- IP `127.0.0.1` 指本机回环地址，永远指向本机- `port 端口` linux 用**1000以上**，这是一个两字节数，范围`[0,65535]` ，共65536种状态，当前此协议的此端口不能被别人占用- `server.bild()` 绑定一个二元组，不可多次绑定同一个端口- `listen()` 监听，不可多次监听，真正的显示出端口- 打开的资源必须关闭，**会占用**文件描述符 `fd `### 实现服务端主动断开连接 收发各一次```python# TCP Server 端开发import socketserver = socket.socket() # TCP 连接 IPv4ip = &apos;127.0.0.1&apos;port = 9999 # TCP 65536server.bind((ip, port)) # addressserver.listen() # 真正的显示出端口print(server)newsock, clientinfo = server.accept() # 默认阻塞data = newsock.recv(1024) # 阻塞，buffer空print(data)newsock.send(&apos;server acl. data=&#123;&#125;&apos;.format(data).encode()) # buffer 满newsock.close()server.close() 执行结果 服务端控制台结果 1234&lt;socket.socket fd=508, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 9999)&gt;b'hello world'Process finished with exit code 0 客户端结果 服务端循环接受客户端信息123456789101112131415161718192021# TCP Server 端开发import socketserver = socket.socket() # TCP 连接 IPv4ip = '127.0.0.1'port = 9999 # TCP 65536server.bind((ip, port)) # addressserver.listen() # 真正的显示出端口print(server)newsock, clientinfo = server.accept() # 默认阻塞print(newsock)print('new1', clientinfo)while True: data = newsock.recv(1024) # 阻塞，buffer空 print(data) newsock.send('server acl. data=&#123;&#125;'.format(data).encode()) # buffer 满newsock.close()server.close() 执行结果 服务端控制台结果 123456789101112&lt;socket.socket fd=552, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 9999)&gt;&lt;socket.socket fd=556, family=AddressFamily.AF_INET, type=SocketKind.SOCK_STREAM, proto=0, laddr=('127.0.0.1', 9999), raddr=('127.0.0.1', 54481)&gt;new1 ('127.0.0.1', 54481)b'hello world'b'hello python'b''Traceback (most recent call last): File "C:/Users/mayn/PycharmProjects/mypython/m/t1.py", line 16, in &lt;module&gt; data = newsock.recv(1024) # 阻塞，buffer空ConnectionAbortedError: [WinError 10053] 你的主机中的软件中止了一个已建立的连接。Process finished with exit code 1 客户端结果 因上例代码中未设置循环退出条件，故手动中断连接会抛异常 实战 – 写一个群聊程序需求分析聊天工具是CS程序，C是每一个客户端client，S是服务器端server。服务器应该具有的功能： 启动服务，包括绑定地址和端口，并监听 建立连接，能和多个客户端建立连接 接收不同用户的信息 分发，将接收的某个用户的信息转发到已连接的所有客户端 停止服务 记录连接的客户端代码实现 服务端应该对应一个类 12345678910111213141516class ChatServer: def __init__(self, ip, port): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) def start(self): # 启动监听 pass def accept(self): # 多人连接 pass def recv(self): # 接受客户端数据 pass def stop(self): # 停止服务 pass 在此基础上，扩展完成 1234567891011121314151617181920212223242526272829303132333435363738394041424344import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept会阻塞主线程，所以开一个新的线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while True: sock, client = self.sock.accept() # 阻塞 self.clients[client] = sock # 添加到客户端字典 # 准备接受数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(sock, client)).start() def recv(self, sock:socket.socket, client): # 接受客户端数据 while True: data = sock.recv(1024) # 阻塞到数据到来 msg = "&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n".format( datetime.datetime.now(), *client, data.decode()) logging.info(msg) msg = msg.encode() for s in self.clients.values(): s.send(msg) def stop(self): # 停止服务 for s in self.clients.values(): s.close() self.sock.close()cs = ChatServer()cs.start() 基本功能完成，但是有问题。使用Event改进 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept会阻塞主线程，所以开一个新的线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 self.clients[client] = sock # 添加到客户端字典 # 准备接受数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(sock, client)).start() def recv(self, sock:socket.socket, client): # 接受客户端数据 while not self.event.is_set(): data = sock.recv(1024) # 阻塞到数据到来 msg = "&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n".format( datetime.datetime.now(), *client, data.decode()) logging.info(msg) msg = msg.encode() for s in self.clients.values(): s.send(msg) def stop(self): # 停止服务 self.event.set() for s in self.clients.values(): s.close() self.sock.close()cs = ChatServer()cs.start()while True: cmd = input('&gt;&gt;').strip() if cmd =='quit': cs.stop() threading.Event().wait(3) break 这一版基本能用了，测试通过。但是还有要完善的地方例如各种异常的判断，客户端断开连接后字典中的移除客户端数据等 客户端主动断开带来的问题 服务端知道自己何时断开，如果客户端断开，服务器不知道。（客户端主动断开，服务端recv会得到一个空串） 所以，好的做法是，客户端断开发出特殊消息通知服务器端断开连接。但是，如果客户端主动断开，服务端主动发送一个空消息，超时返回异常，捕获异常并清理连接 即使为客户端提供了断开命令，也不能保证客户端会使用它断开连接。但是还是要增加这个退出功能 增加客户端退出命令 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept会阻塞主线程，所以开一个新的线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 self.clients[client] = sock # 添加到客户端字典 # 准备接受数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(sock, client)).start() def recv(self, sock:socket.socket, client): # 接受客户端数据 while not self.event.is_set(): data = sock.recv(1024) # 阻塞到数据到来 msg = data.decode().strip() # 客户端退出命令 if msg == 'quit' or msg == '': # 主动断开得到空串 self.clients.pop(client) sock.close() logging.info('&#123;&#125; quits'.format(client)) break msg = "&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n".format( datetime.datetime.now(), *client, data.decode()) logging.info(msg) msg = msg.encode() for s in self.clients.values(): s.send(msg) def stop(self): # 停止服务 self.event.set() for s in self.clients.values(): s.close() self.sock.close()cs = ChatServer()cs.start()while True: cmd = input('&gt;&gt;').strip() if cmd =='quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化 程序还是有瑕疵，但是业务基本功能完成了注意： 由于GIL和内置数据结构的读写原子性，单独操作字典的某一项item是安全的。但是遍历过程是线程不安全的，遍历中有可能被打断，其他线程如果对字典元素进行增加、弹出，都会影响字典的size，就会抛出异常。所以还是要加锁Lock 加锁后代码如下123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() self.lock = threading.Lock() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept会阻塞主线程，所以开一个新的线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 with self.lock: self.clients[client] = sock # 添加到客户端字典 # 准备接受数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(sock, client)).start() def recv(self, sock:socket.socket, client): # 接受客户端数据 while not self.event.is_set(): data = sock.recv(1024) # 阻塞到数据到来 msg = data.decode().strip() # 客户端退出命令 if msg == 'quit' or msg == '': # 主动断开得到空串 with self.lock: self.clients.pop(client) sock.close() logging.info('&#123;&#125; quits'.format(client)) break msg = "&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n".format( datetime.datetime.now(), *client, data.decode()) logging.info(msg) msg = msg.encode() with self.lock: for s in self.clients.values(): s.send(msg) def stop(self): # 停止服务 self.event.set() with self.lock: for s in self.clients.values(): s.close() self.sock.close()cs = ChatServer()cs.start()while True: cmd = input('&gt;&gt;').strip() if cmd =='quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化 logging.info(cs.clients) socket常用方法 名称 含义 socket.recv(bufsize[, flags]) 获取数据。默认是阻塞的方式 socket.recvfrom(bufsize[, flags]) 获取数据，返回一个二元组(bytes, address) socket.recv_into(buffer[, nbytes[, flags]]) 获取到nbytes的数据后，存储到buffer中。如果nbytes没有指定或0，将buffer大小的数据存入buffer中。返回接收的字节数 socket.recvfrom_into(buffer[, nbytes[, flags]]) 获取数据，返回一个二元组(bytes, address)到buffer中 socket.send(bytes[, flags]) TCP发送数据 socket.sendall(bytes[, flags]) TCP发送全部数据，成功返回None socket.sendto(string[,flag],address) UDP发送数据 socket.sendfile(file, offset=0, count=None) 发送一个文件直到EOF，使用高性能的os.sendfile机制，返回发送的字节数。如果win下不支持sendfile，或者不是普通文件，使用send()发送文件。offset告诉起始位置。3.5版本开始 名称 含义 socket.getpeername() 返回连接套接字的远程地址。返回值通常是元组(ipaddr,port) socket.getsockname() 返回套接字自己的地址。通常是一个元组(ipaddr,port) socket.setblocking(flag) 如果flag为0，则将套接字设为非阻塞模式，否则将套接字设为阻塞模式（默认值)非阻塞模式下，如果调用recv()没有发现任何数据，或send()调用无法立即发送数据，那么将引起socket.error异常 socket.settimeout(value) 设置套接字操作的超时期，timeout是一个浮点数，单位是秒值为None表示没有超时期。一般，超时期应该在刚创建套接字时设置，因为它们可能用于连接的操作（如connect() socket.setsockopt(level,optname,value) 设置套接字选项的值。比如缓冲区大小。太多了，去看文档不同系统，不同版本都不尽相同 MakeFile1234567891011121314151617181920212223242526创建一个与该套接字相关连的文件对象，将recv方法看做读方法，将send方法看做写方法```pythonimport socketserver = socket.socket()server.bind((&apos;127.0.0.1&apos;, 9999))server.listen()s, _ =server.accept()f = s.makefile(mode=&apos;rw&apos;)print(s.getpeername())print(s.getsockname())f = s.makefile(&apos;rw&apos;)data = f.read(10) # 按行读取要使用readline方法print(data)f.write(&apos;return your msg: &#123;&#125;&apos;.format(data))f.flush()f.close()print(f.closed, s._closed)s.close()print(f.closed, s._closed)server.close() 服务端控制台执行结果 1234567('127.0.0.1', 62161)('127.0.0.1', 9999)1234567890True FalseTrue TrueProcess finished with exit code 0 客户端执行结果 makefile练习 使用makefile改写群聊类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() self.lock = threading.Lock() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept会阻塞主线程，开一个新线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 f = sock.makefile('rw') # 支持读写 with self.lock: self.clients[client] = f, socket # 添加到客户端字典 # 准备接受数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(f, client)).start() def recv(self, f, client): # 接受客户端数据 while not self.event.is_set(): data = f.readline() # 阻塞等一行来，即换行符 msg = data.strip() print(msg, '~~~~~~~~~~~') # 客户端退出命令 if msg == 'quit' or msg == '': # 主动断开得到空串 with self.lock: _, sock = self.clients.pop(client) f.close() sock.close() logging.info('&#123;&#125; quits'.format(client)) break msg = "&#123;:%Y/%m/%d %H:%M:%S &#123;&#125;:&#123;&#125;\n&#123;&#125;\n&#125;".format( datetime.datetime.now(), *client, data) logging.info(msg) with self.lock: for ff,_ in self.clients.values(): ff.write(msg) ff.flush() def stop(self): # 停止服务 self.event.set() with self.lock: for f, s in self.clients.values(): f.close() s.close() self.sock.close()cs = ChatServer()cs.start()while True: cmd = input('&gt;&gt;').strip() if cmd == 'quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化 logging.info(cs.clients) 上例完成了基本功能，但是，如果客户端主动断开，或者readline出现异常，就不会从clients中移除作废的socket。可以使用异常处理解决这个问题 ChatServer实验用完整代码注意，这个代码为实验用，代码中瑕疵还有很多。Socket太底层了，实际开发中很少使用这么底层的接口。增加一些异常处理。1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import loggingimport socketimport threadingimport datetimelogging.basicConfig(level=logging.INFO, format="%(asctime)s %(thread)d %(message)s")class ChatServer: def __init__(self, ip='127.0.0.1', port=9999): # 启动服务 self.sock = socket.socket() self.addr = (ip, port) self.clients = &#123;&#125; # 客户端 self.event = threading.Event() self.lock = threading.Lock() def start(self): # 启动监听 self.sock.bind(self.addr) # 绑定 self.sock.listen() # 监听 # accept 会阻塞主线程，所以开一个新线程 threading.Thread(target=self.accept).start() def accept(self): # 多人连接 while not self.event.is_set(): sock, client = self.sock.accept() # 阻塞 f = sock.makefile('rw') # 支持读写 with self.lock: self.clients[client] = f, sock # 添加到客户端字典 # 准备接收收据， recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, args=(f, client)).start() def recv(self, f, client): # 接收客户端数据 while not self.event.is_set(): try: # 异常处理 data = f.readline() # 阻塞等一行来，换行符 except Exception as e: logging.error(e) data = 'quit' msg = data.strip() # 客户端命令退出 if msg == 'quit' or msg == '': # 主动断开得到空船 with self.lock: _, sock = self.clients.pop(client) f.close() sock.close() logging.info('&#123;&#125; quits'.format(client)) break msg = '&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n'.format( datetime.datetime.now(), *client, data) logging.info(msg) with self.lock: for ff,_ in self.clients.values(): ff.write(msg) ff.flush() def stop(self): # 停止服务 self.event.set() with self.lock: for f, s in self.clients.values(): f.close() s.close() self.sock.close()def main(): cs = ChatServer() cs.start() while True: cmd = input('&gt;&gt;').strip() if cmd == 'quit': cs.stop() threading.Event().wait(3) break logging.info(threading.enumerate()) # 用来观察断开后线程的变化 logging.info(cs.clients)if __name__ == '__main__': main() TCP客户端编程客户端编程步骤 创建Socket对象 连接到远端服务端的ip和port，connect()方法 传输数据使用send、recv方法发送、接收数据 关闭连接，释放资源 123456789101112import socketclient = socket.socket()ipaddr = ('127.0.0.1', 9999)client.connect(ipaddr) # 直接连接服务器client.send(b'abcd\n')data = client.recv(1024) # 阻塞等待print(data)client.close() 开始编写客户端类 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import socketimport threadingimport datetimeimport loggingFORMAT = "%(asctime)s %(threadName)s %(thread)d %(message)s"logging.basicConfig(format=FORMAT, level=logging.INFO)class ChatClient: def __init__(self, ip='127.0.0.1', port=9999): self.sock = socket.socket() self.addr = (ip, port) self.event = threading.Event() def start(self): # 启动对远端服务器的链接 self.sock.connect(self.addr) self.send("I'm ready.") # 准备接收数据，recv是阻塞的，开启新的线程 threading.Thread(target=self.recv, name="recv").start() def recv(self): # 接收客户端的数据 while not self.event.is_set(): try: data = self.sock.recv(1024) # 阻塞 except Exception as e: logging.error(e) break msg = "&#123;:%Y/%m/%d %H:%M:%S&#125; &#123;&#125;:&#123;&#125;\n&#123;&#125;\n".format( datetime.datetime.now(), *self.addr, data.strip()) logging.info(msg) def send(self, msg:str): data = "&#123;&#125;\n".format(msg.strip().encode()) # 服务器需要一个换行符 self.sock.send(data) def stop(self): self.sock.close() self.event.wait(3) self.event.set() logging.info('Client stops.')def main(): cc = ChatClient() cc.start() while True: cmd = input('&gt;&gt;') if cmd.strip() == 'quit': cc.stop() break cc.send(cmd) # 发送消息if __name__ == '__main__': main() 同样，这样的客户端还是有些问题的，仅用于测试]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20--%20%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B(Socket%E4%BB%8B%E7%BB%8D)%2F</url>
    <content type="text"><![CDATA[@toc Socket介绍Socket套接字 Python中提供socket.py标准库，非常底层的接口库 Socket是一种通用的网络编程接口，和网络层次没有一一对应的关系协议族 AF表示Address Family，用于socket()第一个参数 名称 含义 AF_INET IPV4 AF_INET6 IPV6 AF_UNIX Unix Domain Socket, windows没有 Socket类型 名称 含义 SOCK_STREAM 面向连接的流套接字。默认值，TCP协议 SOCK_DGRAM 无连接的数据文套戒子。UDP协议]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E5%90%8E%E7%AB%AF%2Fpython%2F%E5%9F%BA%E7%A1%80%2FPython%20--%20%E7%BB%99%E5%AE%9A%E4%B8%80%E4%B8%AA%E4%B8%8D%E8%B6%85%E8%BF%875%E4%BD%8D%E6%95%B0%E7%9A%84%E6%AD%A3%E6%95%B4%E6%95%B0%EF%BC%8C%E5%88%A4%E6%96%AD%E8%AF%A5%E6%95%B0%E7%9A%84%E4%BD%8D%E6%95%B0%EF%BC%8C%E4%BE%9D%E6%AC%A1%E4%BB%8E%E4%B8%87%E4%BD%8D%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%AA%E4%BD%8D%E6%88%96%E4%B8%AA%E4%BD%8D%E6%89%93%E5%8D%B0%E5%88%B0%E4%B8%87%E4%BD%8D%E7%9A%84%E6%95%B0%E5%AD%97%2F</url>
    <content type="text"><![CDATA[万位打印到个位：123456num=int(input("please input a number") w =10000 for i in range(5): print (num // w) num %= w w //= 10 个位打印到万位：方法1：1234num=int(input("please input a number") for i in range(5): print (num % 10) num = num // 10 方法2：12345num=int(input("please input a number") for i in range(5): c = num // 10 print (num -c *10) num = c]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2Flinux%2Flinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%883%EF%BC%89---%E5%90%AB%E6%96%87%E4%BB%B6%E9%80%9A%E9%85%8D%E7%AC%A6%E7%94%A8%E6%B3%95%2F</url>
    <content type="text"><![CDATA[文件通配符用于匹配文件名，不是匹配文件内容 *匹配零个或多个字符 ? 匹配任何单个字符 1234567[root@CentOS7 ~]# ls /dataaa file10.txt file2.txt file4.txt file6.txt file8.txtasnd file1.txt file3.txt file5.txt file7.txt file9.txt[root@CentOS7 ~]# ls /data/a*/data/aa /data/asnd[root@CentOS7 ~]# ls /data/a?/data/aa ~ 当前用户家目录 ~+ 当前工作目录 ~- 前一个工作目录 1234[root@CentOS7 ~]# cd /data/[root@CentOS7 data]# cd /boot[root@CentOS7 boot]# ls ~-/aa/data/aa [0-9] 匹配数字范围 [a-z]：字母 [A-Z]：字母 123456[root@CentOS7 data]# ll f[a-c].txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fa.txt-rw-r--r--. 1 root root 0 Mar 23 10:13 fA.txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fb.txt-rw-r--r--. 1 root root 0 Mar 23 10:13 fB.txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fc.txt &ensp;&ensp;&ensp;&ensp; 注：a-c里包含a.A.b.B.c，但不包含C [wang] 匹配列表中的任何的一个字符 [^wang] 匹配列表中的所有字符以外的字符123456789[root@CentOS7 data]# ll f[ab].txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fa.txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fb.txt[root@CentOS7 data]# ll f[^ab].txt-rw-r--r--. 1 root root 0 Mar 23 10:13 fA.txt-rw-r--r--. 1 root root 0 Mar 23 10:13 fB.txt-rw-r--r--. 1 root root 0 Mar 23 10:12 fc.txt-rw-r--r--. 1 root root 0 Mar 23 10:13 fC.txt··· 预定义的字符类：man 7 glob [:digit:]：任意数字，相当于0-9 [:lower:]：任意小写字母 [:upper:]: 任意大写字母 [:alpha:]: 任意大小写字母 [:alnum:]：任意数字或字母 [:blank:]：水平空白字符 [:space:]：水平或垂直空白字符 [:punct:]：标点符号 [:print:]：可打印字符 [:cntrl:]：控制（非打印）字符 [:graph:]：图形字符 [:xdigit:]：十六进制字符 touch 的用法 touch用于创建空文件，如果文件夹里存在相同的文件名的文件，不会将其覆盖，但会修改其创建时间。 使用 &gt; 创建文件，会将其文件内容覆盖。 使用 &gt;&gt; 创建文件，如果文件夹里存在相同的文件名的文件，既不会覆盖文件内容，也不会修改文件时间，更为安全。1234567891011121314[root@CentOS7 data]# cp /etc/pnm2ppa.conf new2.txt[root@CentOS7 data]# ll new2.txt -rw-r--r--. 1 root root 6300 Mar 23 10:27 new2.txt[root@CentOS7 data]# touch new2.txt[root@CentOS7 data]# ll new2.txt-rw-r--r--. 1 root root 6300 Mar 23 10:28 new2.txt[root@CentOS7 data]# &gt; new2.txt[root@CentOS7 data]# ll new2.txt -rw-r--r--. 1 root root 0 Mar 23 10:28 new2.txt[root@CentOS7 data]# ll new2.txt -rw-r--r--. 1 root root 0 Mar 23 10:28 new2.txt[root@CentOS7 data]# &gt;&gt; new2.txt[root@CentOS7 data]# ll new2.txt-rw-r--r--. 1 root root 0 Mar 23 10:28 new2.txt cp的用法 cp主要用于拷贝文件 cp在系统中定义的别名为cp -i，拷贝文件夹中如果存在同名文件，会询问是否覆盖 \cp 会使用原始cp命令，不进行询问，直接覆盖 cp -a 会保存原来文件的属性；cp -av 可查看到拷贝过程。 cp默认不允许拷贝文件夹，cp-r 可以拷贝文件夹注：拷贝A文件夹时，会将拷贝的A文件夹修改为指定的文件夹B名称，如果A拷贝的文件夹里已存在需修改的B名称，会默认在拷贝到的B文件夹里创建一个文件夹，名称为拷贝原文件夹A名称 123456789101112[root@CentOS7 data]# cp -r /boot /data/bootbak[root@CentOS7 data]# lltotal 4dr-xr-xr-x. 5 root root 4096 Mar 23 10:48 bootbak[root@CentOS7 data]# cp -r /boot /data/bootbak[root@CentOS7 data]# ls bootbak/bootconfig-3.10.0-957.el7.x86_64efigrubgrub2··· cp –backup=numbered 目标存在，覆盖前先备份加数字后缀 1234567891011121314151617[root@CentOS7 data]# cp /etc/f1 f2.txt[root@CentOS7 data]# lltotal 0-rw-r--r--. 1 root root 0 Mar 23 11:17 f2.txt[root@CentOS7 data]# cp --backup=numbered /etc/f1 f2.txtcp: overwrite ‘f2.txt’? y[root@CentOS7 data]# lltotal 0-rw-r--r--. 1 root root 0 Mar 23 11:20 f2.txt-rw-r--r--. 1 root root 0 Mar 23 11:18 f2.txt.~1~[root@CentOS7 data]# cp --backup=numbered /etc/f1 f2.txtcp: overwrite ‘f2.txt’? y[root@CentOS7 data]# lltotal 0-rw-r--r--. 1 root root 0 Mar 23 11:20 f2.txt-rw-r--r--. 1 root root 0 Mar 23 11:18 f2.txt.~1~-rw-r--r--. 1 root root 0 Mar 23 11:20 f2.txt.~2~ mv的用法 移动或重命名文件12345678[root@CentOS7 data]# lsf2.txt f2.txt.~1~ f2.txt.~2~[root@CentOS7 data]# mv f2.txt /etc/[root@CentOS7 data]# lsf2.txt.~1~ f2.txt.~2~[root@CentOS7 data]# mv f2.txt.~1~ f5[root@CentOS7 data]# lsf2.txt.~2~ f5 terr的用法 显示目录树 tree 显示目录树 -d: 只显示目录 -L level：指定显示的层级数目 -P pattern: 只显示由指定pattern匹配到的路径 mkdir 创建目录 -p: 存在于不报错，且可自动创建所需的各目录 -v: 显示详细信息 -m MODE: 创建目录时直接指定权限 rmdir 删除空目录 -p: 递归删除父空目录 -v: 显示详细信息 rm -r 递归删除目录树 硬链接的与软连接用法 ln 硬链接，给一个文件取多个名称，但是节点编号一致，不能跨分区。12345678910111213[root@CentOS7 data]# ll -i f167 -rw-r--r--. 1 root root 0 Mar 23 11:48 f1[root@CentOS7 data]# cp -a f1 f2[root@CentOS7 data]# ll -itotal 067 -rw-r--r--. 1 root root 0 Mar 23 11:48 f168 -rw-r--r--. 1 root root 0 Mar 23 11:48 f2[root@CentOS7 data]# ln f1 f1.ink[root@CentOS7 data]# ll -itotal 067 -rw-r--r--. 2 root root 0 Mar 23 11:48 f167 -rw-r--r--. 2 root root 0 Mar 23 11:48 f1.ink68 -rw-r--r--. 1 root root 0 Mar 23 11:48 f2 67 -rw-r–r–. 2 root root 0 Mar 23 11:48 f1，其中67为节点编号，2指有链接数，通俗讲就是一个文件有几个名称，磁盘的空间还是占一份。 注：f1与f1.ink为同一个文件，只是名字不一样，修改其中某个文件，其关联文件都会被修改。但是删除f1，f1.ink仍存在。 ln -s 软链接，又称符号链接。创建出的文件，节点编号不一致，类似于Windows的快捷方式，可以跨分区。1234567[root@CentOS7 data]# ln -s f2 f22[root@CentOS7 data]# ll -itotal 067 -rw-r--r--. 2 root root 0 Mar 23 11:48 f167 -rw-r--r--. 2 root root 0 Mar 23 11:48 f1.ink68 -rw-r--r--. 1 root root 0 Mar 23 11:48 f269 lrwxrwxrwx. 1 root root 2 Mar 23 12:02 f22 -&gt; f2 注：如果原始文件被删除，软链接的文件不可使用；但是，重新拷贝一个与原始文件一样名称的文件，刚才创建的软链接仍可使用。 file 判断文件内容&ensp;&ensp;&ensp;&ensp;以上内容仅供参考，如有不足，欢迎批评指正。 附件linux环境下常用的命令（1）linux环境下常用的命令（2）]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2Flinux%2Flinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%882%EF%BC%89%2F</url>
    <content type="text"><![CDATA[shutdown 关机或重启shutdown+选项+ITME的用法 shutdown -r +3 3分钟后重启 shutdown -h +3 3分钟后关机 shutdown -c 取消shutdown执行的命令1234567891011121314[root@CentOS7 ~]# shutdown -r +3Shutdown scheduled for Thu 2019-03-21 15:24:09 CST, use 'shutdown -c' to cancel.[root@CentOS7 ~]# Broadcast message from root@CentOS7.localdomain (Thu 2019-03-21 15:21:09 CST):The system is going down for reboot at Thu 2019-03-21 15:24:09 CST!dateThu Mar 21 15:21:11 CST 2019[root@CentOS7 ~]# shutdown -cBroadcast message from root@CentOS7.localdomain (Thu 2019-03-21 15:21:21 CST):The system shutdown has been cancelled at Thu 2019-03-21 15:22:21 CST! 用户登录信息查看命令： whoami 显示当前登录有效用户 who 系统当前所有的登录会话 w 系统当前所有的登录会话及所有操作123456789101112[root@CentOS7 ~]# whoamiroot[root@CentOS7 ~]# wholqx :0 2019-03-21 14:54 (:0)lqx pts/0 2019-03-21 15:11 (:0)root pts/1 2019-03-21 15:13 (192.168.152.1)[root@CentOS7 ~]# w 15:24:55 up 31 min, 3 users, load average: 0.07, 0.03, 0.11USER TTY FROM LOGIN@ IDLE JCPU PCPU WHATlqx :0 :0 14:54 ?xdm? 1:35 0.55s /usr/libexec/gnome-sessiolqx pts/0 :0 15:11 12:31 0.20s 0.20s bashroot pts/1 192.168.152.1 15:13 7.00s 0.18s 0.07s w screen 实现远程协助 查看screen是否安装，输入命令df里如果无光盘，则使用mount /dev/sr0 /mnt命令挂载，mnt是专门充当挂载点的目录。 1234567891011121314[root@CentOS7 ~]# mount /dev/sr0 /mntmount: /dev/sr0 is write-protected, mounting read-only[root@CentOS7 ~]# dfFilesystem 1K-blocks Used Available Use% Mounted on/dev/sda2 104806400 4263656 100542744 5% /devtmpfs 915820 0 915820 0% /devtmpfs 931624 0 931624 0% /dev/shmtmpfs 931624 10696 920928 2% /runtmpfs 931624 0 931624 0% /sys/fs/cgroup/dev/sda3 52403200 32992 52370208 1% /data/dev/sda1 1038336 177948 860388 18% /boottmpfs 186328 24 186304 1% /run/user/1000/dev/sr0 10491772 10491772 0 100% /mnttmpfs 186328 0 186328 0% /run/user/0 安装screen软件，输入命令 rpm -ivh /mnt/Packages/screen-4.1.0-0.25.20120314git3c2946.el7.x86_64.rpm即可 12345[root@CentOS7 ~]# rpm -ivh /mnt/Packages/screen-4.1.0-0.25.20120314git3c2946.el7.x86_64.rpm warning: /mnt/Packages/screen-4.1.0-0.25.20120314git3c2946.el7.x86_64.rpm: Header V3 RSA/SHA256 Signature, key ID f4a80eb5: NOKEYPreparing... ################################# [100%]Updating / installing... 1:screen-4.1.0-0.25.20120314git3c29################################# [100%] 连接同一台电脑的同一用户，需要被协助的需输入命令screen -S A (A可为任意名称，指回话的名称)；同时协助者可通过screen -ls命令查看需要远程的对象，输入screen -x A(A可为任意名称，指回话的名称)加入回话。 输入screen命令，在此界面中输入的命令及时窗口崩溃，重新连接后仍在继续执行。 screen -r 恢复会话 快捷键Ctrl+a+b 临时退出会话 echo 显示字符 echo -n 不换行 echo -e 显示特殊字符如\c 最后不加上换行符号；给hello加颜色及特殊闪烁 ‘\033[43;31;5mhello\033[0m’ 123456[root@CentOS7 ~]# echo hellohello[root@CentOS7 ~]# echo -n[root@CentOS7 ~]# echo -n hellohello[root@CentOS7 ~]# echo -e '\033[43;31;5mhello\033[0m'hello echo 默认显示变量加双引号，识别变量；加单引号，无视变量，以字符显示；加反向单引号，以命令识别。 12345678[root@CentOS7 ~]# echo $PS1[\u@\h \W]\$[root@CentOS7 ~]# echo "echo $PS1"echo [\u@\h \W]\$ [root@CentOS7 ~]# echo 'echo $PS1'echo $PS1[root@CentOS7 ~]# echo `echo $PS1`[\u@\h \W]\$ { } 花括号表示显示的范围利用花括号配合命令可以同时查看或创建多个文件 12345678910[root@CentOS7 ~]# echo &#123;0..10&#125;0 1 2 3 4 5 6 7 8 9 10[root@CentOS7 ~]# echo &#123;0..10&#125;&#123;txt,log&#125;0txt 0log 1txt 1log 2txt 2log 3txt 3log 4txt 4log 5txt 5log 6txt 6log 7txt 7log 8txt 8log 9txt 9log 10txt 10log[root@CentOS7 ~]# touch /data/file&#123;1..10&#125;.txt[root@CentOS7 ~]# ls /datafile10.txt file2.txt file4.txt file6.txt file8.txtfile1.txt file3.txt file5.txt file7.txt file9.txt[root@CentOS7 ~]# echo &#123;000..20..2&#125;000 002 004 006 008 010 012 014 016 018 020 man ascii 查看ASCII表,按q退出。 history 查看以前执行过的命令，记录下的命令会保存在 ~/.bash_history文件中 ！！跟上history查询过的命令编码，可直接执行命令。 ！-*（ *=数字），可执行倒数第某条命令。 快捷键Ctrl+r 在历史命令中搜索命令 快捷键Ctrl+g 从历史搜索模式退出 ！$ 前一个命令最后一个参数（或ESC+. ） 1234567[root@CentOS7 ~]# ls -l anaconda-ks.cfg -rw-------. 1 root root 1959 Mar 18 21:41 anaconda-ks.cfg[root@CentOS7 ~]# cat !$cat anaconda-ks.cfg#version=DEVEL# System authorization information··· history -c 清除当前内存历史，不清除之前存储过的历史记录 whatis 查询命令的用户（cat后括号内的数字为章节的编号） 123[root@CentOS7 ~]# whatis catcat (1) - concatenate files and print on the standard outputcat (1p) - concatenate and print files help 查询内部命令的帮助说明 123456[root@CentOS7 ~]# help exitexit: exit [n] Exit the shell. Exits the shell with a status of N. If N is omitted, the exit status is that of the last command executed. –help 查询外部命令的帮助说明，少数情况使用-h1234567[root@CentOS7 ~]# cat --helpUsage: cat [OPTION]... [FILE]...Concatenate FILE(s), or standard input, to standard output. -A, --show-all equivalent to -vET -b, --number-nonblank number nonempty output lines, overrides -n··· man 提供命令帮助的文件，分章节存放；统称为Linux手册。 帮助手册中的段落说明： NAME 名称及简要说明SYNOPSIS 用法格式说明[] 可选内容；&lt;&gt;必选内容；a|b二选一；{}分组；…同一内容可出现多次DESCRIPTION 详细说明；OPTIONS 选项说明；EXAMPLES示例；FILES相关文件；AUTHOR作者；COPYRIGHT版本信息；REPORTING BUGS bug信息；SEE ALSO其他帮助参考 1：用户命令；2：系统调用；3：C库调用 4：设备文件及特殊文件；5：配置文件格式；6：游戏 7：杂项；8：管理类的命令；9：Linux内核API （注：直接使用man+命令查询，默认查询章节号小的帮助文件，如需要指定某个章节，则需输入man+章节序号+命令） 进入man帮助里后，可用 / 或 ? 进行搜索， / 往下搜， ？ 往上搜。 / 搜索状态，n ：往下搜，N ：往上搜， ？ 则反之。Q ：退出。 passwd 修改用户登陆口令（如果是以root权限登陆，使用passwd后跟需修改的用户名及可修改其口令&ensp;&ensp;&ensp;&ensp;以上为本人总结的一部分linux环境下常用的命令，后续将持续更新。&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;&ensp;附件：linux环境下常用的命令（1）]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2Flinux%2Flinux%E7%8E%AF%E5%A2%83%E4%B8%8B%E5%B8%B8%E7%94%A8%E7%9A%84%E5%91%BD%E4%BB%A4%EF%BC%881%EF%BC%89%2F</url>
    <content type="text"><![CDATA[命令提示符：# 代表管理员 ； $ 代表普通用户 命令的格式=命令+选项+参数 如ls -l .bashrc；其中ls 为命令，-l为选项，.bashrc为参数** 注：不是所有的命令都有选项及参数长短选项。 -a为短选项，–all为长选项 # 多个选项及多参数和命令之间使用空白字符分隔 取消和结束命令执行：Ctrl+c强行退出，ctrl+d正常退出 多个命令可用；符号分开 一个命令可用\分成多行TEB键可以在输入命令时自动将后续命令补全，前提是输入命令的前一部分不能有错。 命令解释及用法 ls 查看目录下的文件 12[root@CentOS7 ~]# ls anaconda-ks.cfg initial-setup-ks.cfg y ls / 查看根下的文件夹（蓝色为目录或文件夹，如：boot；浅蓝色代表快捷方式，如：lib） 123[root@CentOS7 ~]# ls /bin data etc lib media opt root sbin sys usrboot dev home lib64 mnt proc run srv tmp var ls -a 查看隐藏文件 ； ls -l 显示文件属性 ； ll -d 只查看目录本身属性，不查看该目录下所有文件属性( . 开头的文件为隐藏文件；ls -l ( 为文件名)可指定查看某个文件，ll -d等于ls -ld） 12345678910111213[root@CentOS7 ~]# ls -a. .bash_history .bashrc .cache .dbus [root@CentOS7 ~]# ls -ltotal 12-rw-------. 1 root root 1959 Mar 18 21:41 anaconda-ks.cfg-rw-r--r--. 1 root root 1990 Mar 18 21:45 initial-setup-ks.cfg-rw-r--r--. 1 root root 4 Mar 20 15:29 y[root@CentOS7 ~]# ls -l .bashrc-rw-r--r--. 1 root root 213 Mar 19 11:49 .bashrc[root@CentOS7 etc]# ls -ld /etc/drwxr-xr-x. 143 root root 8192 Mar 23 08:52 /etc/[root@CentOS7 etc]# ll -d /etc/drwxr-xr-x. 143 root root 8192 Mar 23 08:52 /etc/ tty 查看终端编号 12[root@CentOS7 ~]# tty/dev/pts/1 who 查看当前终端有多少用户在登陆（：0代表图形界面登陆） 1234[root@CentOS7 ~]# wholqx :0 2019-03-21 08:57 (:0)lqx pts/0 2019-03-21 08:57 (:0)root pts/1 2019-03-21 09:01 (192.168.18.1) echo $SHELL 系统默认的shell类型（shell指linux的命令解释器） 12[root@CentOS7 ~]# echo $SHELL/bin/bash cat /ect/shells 显示当前系统支持的shell类型 1234567[root@CentOS7 ~]# cat /etc/shells/bin/sh/bin/bash/usr/bin/sh/usr/bin/bash/bin/tcsh/bin/csh echo $PS1 显示提示符格式（\u指用户名，\h指主机名，W指在什么文件夹内） 12[root@CentOS7 ~]# echo $PS1[\u@\h \W]\$ PS1=(指所有) 修改提示符(如：PS1=PS1=”[\e[1;5;41;33m][\u@\h \W]\$[\e[0m]“ ）（其中：\u 用户名， \h主机名简称，\H 主机名，\w 当前工作目录，\W 当前工作目录基名，\t 24小时时间格式，\T 12小时时间格式，退出输入exit） 12[root@CentOS7 ~]# PS1=ABCABC enable 查看所有内部命令 12345678910[root@CentOS7 ~]# enableenable .enable :enable [enable aliasenable bgenable bindenable breakenable builtin··· hash 查看已经缓存的外部命令（1代表已执行一次） 123[root@CentOS7 ~]# hashhits command 1 /usr/bin/cat cat /etc/centos-release 查看当前系统的版本 12[root@CentOS7 ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core) alias查看系统中的所有别名； alias A=”B” 给命令定义别名（退出后命令还原，别名不存在） 1234567[root@CentOS7 ~]# aliasalias B='cat /etc/redhat-releasa'alias abc='cat /etc/centos-release'alias cp='cp -i'alias egrep='egrep --color=auto'alias fgrep='fgrep --color=auto'alias grep='grep --color=auto' 12345[root@CentOS7 ~]# cat /etc/centos-releaseCentOS Linux release 7.6.1810 (Core)[root@CentOS7 ~]# alias abc="cat /etc/centos-release"[root@CentOS7 ~]# abcCentOS Linux release 7.6.1810 (Core) nano （ =文件名） 可编辑文件内容（编辑完成后，按ctrl+x,Y确认后回车即可退出编辑状态；修改后的文件不会立即生效，需退出或输入source 或 . ( *=修改过的文件名）) nano .bashrc 永久保存别名（在.bachrc文件里定义别名，可永久保存别名；修改格式：alias A=’B’(B=需定义的别名）） unalias ( =别名) 删除别名（写入文件中的别名退出或用soure 命令即可恢复别名） type+命令 判断此命令为内/外部命令或别名（显示磁盘路径为外部命令，builtin为内部命令，aliased为别名） 123456[root@CentOS7 ~]# type catcat is /usr/bin/cat[root@CentOS7 ~]# type exitexit is a shell builtin[root@CentOS7 ~]# type abcabc is aliased to `cat /etc/centos-release' 别名的优先级别最高（如A与B同时为命令，把A定义为B，则别名A无法使用；别名前加\为使用原始命令） 123456789[root@CentOS7 ~]# lsanaconda-ks.cfg initial-setup-ks.cfg y[root@CentOS7 ~]# hostnameCentOS7.localdomain[root@CentOS7 ~]# alias ls=hostname[root@CentOS7 ~]# lsCentOS7.localdomain[root@CentOS7 ~]# \lsanaconda-ks.cfg initial-setup-ks.cfg y hostname 显示主机名 12[root@CentOS7 ~]# hostnameCentOS7.localdomain 合并多个短格式选项（长格式选项不可合并） 12345678910[root@CentOS7 ~]# ls -a -ltotal 44dr-xr-x---. 5 root root 273 Mar 21 09:50 .dr-xr-xr-x. 18 root root 236 Mar 18 21:40 ..···[root@CentOS7 ~]# ls -altotal 44dr-xr-x---. 5 root root 273 Mar 21 09:50 .dr-xr-xr-x. 18 root root 236 Mar 18 21:40 ..··· date及clock的用法 date为软件时间，clock为硬件时间 123456[root@CentOS7 ~]# dateThu Mar 21 11:12:02 CST 2019[root@CentOS7 ~]# clockThu 21 Mar 2019 11:12:05 AM CST -0.810009 seconds[root@CentOS7 ~]# date -s&apos;1 year&apos;Sat Mar 21 11:12:55 CST 2020 date -s’1 year’ 调整软件时间为一年后 timedatectl status 查看时区；cal查看日历注：cal （=年份可查看整年日历） date +%s 现在距离19700101（unux诞生日）有多少秒 date -d @ (为date +%s输出的描述) 可以反推现在的时间 1234[root@CentOS7 ~]# date +%s1553138943[root@CentOS7 ~]# date -d @1553138943Thu Mar 21 11:29:03 CST 2019 date -s 以硬件时间为准，校正软件（系统）时间 clock -w 以软件（系统）时间为准，校正硬件时间 12345[root@CentOS7 ~]# clock -w[root@CentOS7 ~]# clockSat 21 Mar 2020 11:14:11 AM CST -0.493058 seconds[root@CentOS7 ~]# dateSat Mar 21 11:14:32 CST 2020 增加网卡的网络连接为桥接模式，确保能ping通对方远程服务器IP地址；输入ntpdate （为远程服务器地址，即可使软件时间与其时间一致） 123456[root@CentOS7 ~]# dateSat Mar 21 11:18:36 CST 2020[root@CentOS7 ~]# ntpdate 172.20.0.121 Mar 11:20:24 ntpdate[11471]: step time server 172.20.0.1 offset -31622398.980836 sec[root@CentOS7 ~]# dateThu Mar 21 11:20:36 CST 2019 22. 相对路径与绝对路径 绝对路径 以正斜杠开始 完整的文件的位置路径 可用于任何想指定一个文件名的时候 相对路径名 不以斜线开始 指定相对于当前工作目录或某目录的位置 可以作为一个简短的形式指定一个文件名 名词与用法 cd 用于切换目录 cd 切换至当前用户家目录 cd .. 切换至上一级目录 cd- 切换至上一次工作的目录 pwd 显示当前在什么目录 123456789[root@CentOS7 ~]# cd /etc/sysconfig/console/[root@CentOS7 console]# cd ..[root@CentOS7 sysconfig]# cd -/etc/sysconfig/console[root@CentOS7 console]# cd[root@CentOS7 ~]#[root@CentOS7 etc]# pwd/etc 相对路径与绝对路径的用法 . . 表示当前目录的上一级目录 123456789101112[r0ot@CentOS7 ~]# cd /etc/sysconfig/[root@CentOS7 sysconfig][root@CentOS7 sysconfig]# ll kernel -rw-r--r--. 1 root root 180 Mar 18 21:40 kernel[root@CentOS7 sysconfig]# ll /etc/sysconfig/kernel -rw-r--r--. 1 root root 180 Mar 18 21:40 /etc/sysconfig/kernel[root@CentOS7 sysconfig]# pwd/etc/sysconfig[root@CentOS7 sysconfig]# ll ../motd-rw-r--r--. 1 root root 0 Jun 7 2013 ../motd[root@CentOS7 sysconfig]# ll /etc/motd-rw-r--r--. 1 root root 0 Jun 7 2013 /etc/motd basename与dirname的用法 basrname 指完整路径的文件名 dirname 指完整路径的目录123456[root@CentOS7 etc]# ll /etc/sysconfig/network-scripts/ifcfg-ens33 -rw-r--r--. 1 root root 279 Mar 18 21:40 /etc/sysconfig/network-scripts/ifcfg-ens33[root@CentOS7 etc]# basename /etc/sysconfig/network-scripts/ifcfg-ens33 ifcfg-ens33[root@CentOS7 etc]# dirname /etc/sysconfig/network-scripts/ifcfg-ens33 /etc/sysconfig/network-scripts 23. 文件的时间显示mtime 内容时间；ctime 属性时间；atime 读取时间12345678910[root@CentOS7 etc]# stat anacrontab File: ‘anacrontab’ Size: 541 Blocks: 8 IO Block: 4096 regular fileDevice: 802h/2050d Inode: 134754168 Links: 1Access: (0600/-rw-------) Uid: ( 0/ root) Gid: ( 0/ root)Context: system_u:object_r:etc_t:s0Access: 2019-03-22 10:01:01.397980307 +0800Modify: 2018-04-11 09:48:22.000000000 +0800Change: 2019-03-18 21:27:51.358018639 +0800 Birth: - 命令帮助文档在线查看网址： www.nginx.ory tomcat.apache.org httpd.apache.org www.python.org dev.mysql.com/doc/&ensp;&ensp;&ensp;&ensp;以上为本人总结的一部分linux环境下常用的命令，后续将持续更新。仅供参考， 如有错误之处，欢迎指正。谢谢！]]></content>
  </entry>
  <entry>
    <title></title>
    <url>%2F%E8%BF%90%E7%BB%B4%2Flinux%2FLinux%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Linux中的特殊进程 在Linux/Unix中，通过父进程创建子进程僵尸进程 一个进程使用了fork创建了子进程，如果子进程终止进入僵死状态，而父进程并没有调用wait或者waitpid获取子进程的状态信息，那么子进程仍留下一个数据结构保存在系统中，这种进程称为僵尸进程 僵尸进程会占用一定的内存空间，还占用了进程号，所以一定要避免大量的僵尸进程产生。有很多方法可以避免僵尸进程孤儿进程 父进程退出，而它的子进程仍在运行，那么这些子进程就会成为孤儿进程。孤儿进程会被init进程（进程号为1）收养，并由init进程对它们完成状态收集工作 init进程会循环调用wait这些孤儿进程，所以，孤儿进程没有什么危害守护进程 它是运行在后台的一种特殊进程。它独立于控制终端并周期性执行某种任务或等待处理某些事件 守护进程的父进程是init进程，因为其父进程已经故意被终止掉了 守护进程相对于普通的孤儿进程需要做一些特殊处理]]></content>
  </entry>
  <entry>
    <title><![CDATA[vmware]]></title>
    <url>%2Flinux%2FCentOS7%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、firewalld的基本使用启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed 3.配置firewalld-cmd查看版本： firewall-cmd –version查看帮助： firewall-cmd –help显示状态： firewall-cmd –state查看所有打开的端口： firewall-cmd –zone=public –list-ports更新防火墙规则： firewall-cmd –reload查看区域信息: firewall-cmd –get-active-zones查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0拒绝所有包：firewall-cmd –panic-on取消拒绝状态： firewall-cmd –panic-off查看是否拒绝： firewall-cmd –query-panic 那怎么开启一个端口呢添加firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd –reload查看firewall-cmd –zone= public –query-port=80/tcp删除firewall-cmd –zone= public –remove-port=80/tcp –permanent]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmware]]></title>
    <url>%2Flinux%2F%E6%96%B0%E6%89%8B%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AEVMware%20Workstation%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8AXshell%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新手如何安装及配置虚拟机及远程管理软件&ensp;&ensp;&ensp;&ensp;VMware Workstation Pro &amp; Xshell 下载并安装VMware Workstation Pro及Xshell。 访问mirrors.163.com，下载镜像centos。登陆后找到镜像名centos/，点击后下载最新版（如7系版本）(CentOS-7-x86_64-Everything-1810.iso) 。 打开VMware Workstation Pro软件，需要输入密钥，可在某度寻找。 如何新建虚拟机，步骤如下： &ensp;&ensp;&ensp;&ensp;点击创建新的虚拟机，选择‘ 典型 ’；&ensp;&ensp;&ensp;&ensp;安装来源选择‘ 稍后安装操作系统 ’；&ensp;&ensp;&ensp;&ensp;客户机操作系统选择Linux，版本选择CentOS 7 64位；&ensp;&ensp;&ensp;&ensp;保存位置建议为固态硬盘；&ensp;&ensp;&ensp;&ensp;磁盘大小设置为200G，选择“将虚拟磁盘储存为单个文件”，完成。 双击设备下任意处，1弹出的对话窗口中设置如下： &ensp;&ensp;&ensp;&ensp;内存设置为2048MB；&ensp;&ensp;&ensp;&ensp;处理器数量为2；&ensp;&ensp;&ensp;&ensp;CD/DVD(IDE) 连接方式为使用ISO映像文件，选择刚才下载的镜像文件装入即可；&ensp;&ensp;&ensp;&ensp;网络适配器设置为仅主机模式。 单机菜单栏绿色三角形，启动虚拟机(Ctrl+Alt+enter为切换窗口大小) 1注：第一选项为安装，第二项为测试media并安装，第三项为修复(默认选择第二项)。 测试完毕后，选择如下 &ensp;&ensp;&ensp;&ensp;语言选择默认English，点击右下角Continue；&ensp;&ensp;&ensp;&ensp;DATE&amp;TIME 设置为上海（可直接在地图上选择位置），左下角时间修改为当前北京时间；&ensp;&ensp;&ensp;&ensp;KEYBOARD 键盘默认为美国键盘，无需修改；&ensp;&ensp;&ensp;&ensp;INSTALLATION SOURCE 默认为光盘安装，无需修改；&ensp;&ensp;&ensp;&ensp;SOFTWARE SELECTION，选择如何安装，装什么软件。工作中默认为最小安装，初学者选择GNOME Desktop(图形界面)；&ensp;&ensp;&ensp;&ensp;INSTALLATION DESTINATION安装目标即为分区，点击选择I will configure partitioning（我将自己安装分区)，点击Done；&ensp;&ensp;&ensp;&ensp; 弹出的界面默认为LVM逻辑卷，更改为Standard Partition标准分区，点击添加“+”。 选择Mount Point挂载点为 /boot，大小为1G； 添加根 ‘/‘，大小为100G； 添加‘/data’，因为data不属于操作系统自带的文件夹，所以需要手写添加。创建data的目的是为了后续方便存放临时文件，大小为50G； 添加 /swap，大小为4G，物理内存的两倍大小。注：swap的Mount Point挂载点为灰色，因为swap是模拟内存用的，不为文件夹，此File System文件系统为专有的swap。 &ensp;&ensp;&ensp;&ensp;点击Done，选择Accept changes接受上列的更改。&ensp;&ensp;&ensp;&ensp;NETWORK &amp; HOST NAME网络，设置Host name主机名，Ethernet(ens33)网卡如果为Dissonnected，需要点击右边按钮打开网卡。显示后的IP地址可以从windows中ping通（从windows中打开cmd,输入ping (为IP地址)，出现来自 的回复 ，即为连通。&ensp;&ensp;&ensp;&ensp;点击 Begin installation，弹出的选项中需要设置 ROOT PASSWORD系统管理员账户，设置 USER CREATION普通用户。安装完毕后，设置 LICENSING许可，点击 I accept the license agreement。安装完毕。 备份系统，两种方法 右击当前窗口任务栏，选择快照，拍摄快照。备份完成。 右击当前窗口任务栏，选择设置，点击选项，将右侧的工作目录文件夹直接复制一份至其他磁盘（复制前如文件中有临时文件，需先关闭当前虚拟机任务）。备份完成。 重启虚拟机。点击打开虚拟机，找到刚才存放VMX的文件夹，点击任务栏的绿色小三角 ，登陆后设置初始化。设置语言、键盘、定位（建议关闭）、在线用户（没有可忽略）。 如何打开Terminal敲命令，执行操作的窗口，简称终端。点击Applications–System Tools–Terminal，完成。 注：[wang@centos7 -]$，wang指用户名，centos7指主机最前部分名称， - 指存放的文件夹位置，但是CentOS系统默认显示的‘ - ’为wang@centos7的home目录。只要为home，都会以‘ - ’显示，提示符‘$’为普通用户。 查看当前网卡是否连接通，输入 ip a回车,如果ens33未显示IP地址，则未通。 输入 nmcli connection up ens33 , 即可在ens33下查看到IP地址。 打开Xshell，点击左上角的+，输入名称（可直接设置为IP地址，方便查看），主机IP地址（刚才查询到的IP地址） 点击用户身份验证，用户名为“root“，密码为之前CentOS设置的密码，点击确定，点击链接，选择接受并保存。 root链接的提示符‘#’为管理员意思。 &ensp;&ensp;&ensp;&ensp;以上为安装及配置虚拟机及远程管理软件详细过程，仅供参考；如有错误之处，欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题]]></title>
    <url>%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[重点知识 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%2Fflask%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[下载示例代码, 安装到当前目录的flasky文件夹下. 1git clone https://github.com/miguelgrinberg/flasky.git 123456git checkout 1agit reset --hardgit fetch --allgit fetch --tagsgit reset --hard orign/mastergit diff 2a 2b flask在大多数标准中, flask都算小型框架, 小到可以称为”微框架”.它具有一个包含接班服务的强健核心, 其他功能则可通过扩展实现. flask有3个主要依赖: 路由,调试, web服务网关接口(wsgi)子系统由werkzeug提供, 模板系统由jinja2提供, 命令行集成有click提供. 创建应用目录 12git clone https://github.com/miguelgrinberg/flasky.gitcd flasky 初始化 所有的Flask应用都必须创建一个应用实例.web服务器使用一种名为web服务器网关接口(wsgi)的协议.把接收自客户端的所有请求都转交给这个对象处理.应用实例是Flask类的对象.通常有下列代码创建. 12from flask import Flaskapp = Flask(__name__) 在flask中有两种上下文: 应用上下文和请求上下文. 钩子函数:有时在处理请求之前或之后执行代码会很有用. before_request 注册一个函数, 在每次请求之前运行 before_first_request 注册一个函数, 只在处理第一个请求之前运行,可以通过这个钩子函数添加服务器初始化任务. after_request注册一个函数, 如果没有未处理的异常抛出, 在每次请求之后运行. teardown_request 注册一个函数, 即使有未处理的异常抛出, 也在每次请求之后运行. 在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g,]]></content>
      <categories>
        <category>后端框架</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible]]></title>
    <url>%2Flinux%2Fandible%2F</url>
    <content type="text"><![CDATA[ansible简介安装ansibleyun install -y ansible todoansible 文档https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#foreword]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2FPandas%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Pandas:最流行的Python数据分析库 基于Numpy, 专用于数据预处理和数据分析的Python第三方库, 最适合处理大型结构化表格数据. Pandas两大数据类型 Series: 一维 DataFrame: 二维 Series数据类型 12a = pd.Series([3, 4, 5, 6, 7])a DataFrame数据类型 12b = pd.DataFrame([3, 4, 5], [6, ,7, 8], [9, 10, 11])b 抽象和维度 维度: 观察事物的角度 日常保存数据的数据格式: 0维: 字符串, 单值变量 1维: 列表, 字典(1成括号) 2维: Excel表格, Mysql数据库 3维或以上: JSON, MongoDB, HTML Pandas各个数据类型的关系： 0维单值变量 -&gt; 1维Series -&gt; 2维DataFrame -&gt; 3维层次化DataFrame Series列表创建Series a = pd.Series([2, 3, 5]) 字典创建Series 123# 索引就是字典字典的键d = pd.Series(&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;gander&apos;:True&#125;)d 其他方式 123# 标量创建pd.Series(5)pd.Series(5, index=[1,2, 3, 4, 5]) 12345# Numpy的序列函数创建np.arange(5)np.arange(2, 5)np.arange(9, 5, -1) 查询 1class1 = pd.Series([95, 25, 59, 61], index=[&apos;ming&apos;, &apos;hua&apos;, &apos;hong&apos;,&apos;huang&apos;, &apos;bai&apos;]) 查询数据形状 1维数据的形状就是它的值个数 1class1.shape, class1.shape[0] 查询值(values) 和索引(index) 一个Series数据是由2个ndarray数组组成的 12# 查询值class1.values 查询值 根据索引查询值 索引查询 切片插叙 根据条件反查索引 布尔查询 索引查询 索引和切片都是根据索引查询值 class1 查询单值 123# Series有两套索引：默认索引，自定义索引class1[&apos;hong&apos;] # 自定义索引class1[2] # 默认索引 查询多值 12class1[[&apos;hua&apos;, &apos;bai&apos;]]class1[[1, 4]] 切片查询 1234# 默认索引：包含起始值，不包含结束值class1[:3] class1[2:]class1[1:4] 布尔查询 根据值反查索引 根据条件反查索引 12# 布尔查询class1[[False, True, True, False, False]] 向量化运算矢量运算, 并行运算 123a = pd.Series(x)aa + 5 # 向量化运算, 不需要遍历, 速度快效率高 123# Pandas向量化方式a.sum() # Pandas方法np.sum(class1) # Numpy方法 类Numpy数组操作, 和类Python字典的操作 Pandas数据可以执行全部Numpy数据操作(因为Pandas底层基于Numpy, 所以通用) 也可以执行部分Python原生列表或字典操作(仅限于Pandas实现的操作) 类Numpy数组操作 1np.mean(class1) # Numpy方法 类Python字典操作 in关键字: 判断某索引是否存在 get方法:判断某索引是否存在, 存在则直接输出值, 不存在则输出定义值 DataFrame对象 - 创建DataFrame对象是Pandas最常用的数据类型 DataFrame对象是由多个Series增加一个索引后组成一种表格类型数据结构 DataFrame对象既有行索引, 又有列索引 行索引,表明不同行, 横向索引, 叫index, 0轴, axis=0 列索引, 表名不同列, 纵向索引, 叫colums, 1轴, axis=1 列表创建 ndarry数组创建 字典内嵌套列表：要求内部列表等长 字典内嵌套字典：内部字典不需要等长 字典内嵌套Series：等同嵌套字典 列表创建 12# 默认索引pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]]) 使用Numpy数组创建 Numpy数组类似一个高级版的Python列表 123np.arange(10)np.arange(10).reshape(2, 5) 字典创建 字典内嵌套列表 列表值需要等长, 否则报错 12345678pd.DataFrame( &#123; '姓名': ['张三', '李四', '王五'], '年龄': [18, 28, 38], '性别': [True, True, False], '分数': [85.5, 59, 78], &#125;) 字典嵌套字典字典不要求等长 12345678pd.DataFrame( &#123; 'name': &#123;1: '张三', 2: '李四', 3: '王五'&#125;, 'age': &#123;1: 18, 2: 28, 3: 38&#125;, 'gender': &#123;1: True, 2: True, 3: False&#125;, 'grade': &#123;1: 85.5, 3: 78&#125;, # 不等长也不报错 &#125;,) DataFrame整体查询 123456a.shape # 表格形状，行数 列数a.dtypes # 列数据类型a.index # 行索引a.columns # 列索引a.values # 对象值，二维ndarray数组 整体数据情况 a.info()整体信息, 查看:数据是否异常 有没有缺失值 列数据类型是否正确 a.describe()整体统计指标 a.head() 前5行 a.tail() 后5行 内容查询 类列表/字典/ndarray数组的查询方式 功能简陋, 一般仅用于查询单列 Pandas专用查询方式：经过优化，推荐 三种查询方式： 索引 切片 过滤 索引和切片查询，两种查询方式： a.loc[行,列]，标签索引，自定义索引 a.iloc[行,列]，位置索引，默认索引 参数书写顺序都是都是先行后列 索引查询用于不连续(行列有间隔)行列区块查询 查询单行 1234567# 自定义索引查询a.loc[3] # 简写a.loc[3, :] # 完整写法# 默认索引a.iloc[2]a.iloc[2, :] 查询多行 1234a.loc[[2, 4]] # 选中所有列，省略了列条件a.loc[[2, 4], :] # 完整写法a.iloc[[1, 3]] 索引查询和切片查询的区别 索引查询更适合查询不连续的行列数据 切片查询适合查询连续行和列数据 索引查询可以实现切片查询的所有功能，只是有个书写效率问题 用索引查询查连续数据，需要将每个索引都写上，效率低 切片查询连续数据，只要写起始和结束索引即可。 切片不能查询不连续数据 查询时：优先使用切片查询，无法实现功能时再使用索引查询 专用查询：过滤查询索引查询和切片查询, 都是通过索引查询值 过滤查询(布尔查询) : 通过值查询索引 过滤查询不通过索引, 而是通过值查询 用于结果索引不确定的查询 通过运算所得布尔值对查询结果进行过滤 类list/字典查询方式 专用查询方式的布尔查询 12# 布尔查询a.loc[[False, True, False, True, False], [True, True, False, False, False, True, False]] 12# 查询不及格同学的姓名、年龄和成绩a.loc[a['grade'] &lt; 60, ['name', 'age', 'grade']] where过滤（了解）另一种简洁的布尔查询写法 总结 原生的布尔查询，需要每列单独判断条件，然后用逻辑运算符组合条件，得出最终结果 where过滤过滤：先将所有需要判断条件的列抽出来，整体判断，得出最终结果 优点：写法简洁 缺点：where过滤所有列的判断条件，只能有一个，使用受限 视图模式 将一个对象整体赋值给另一个变量 修改一个变量，另一个变量值也会变 多个变量数据指向同一内存数据 副本模式 将一个对象查询的一部分值赋值给另一个变量 修改一个变量，另一个变量值不会变 当将一个对象整体赋值给另一个变量时，视图模式，两个变量对应的内存地址相同，修改一个变量，另一个变量也会改变。 当使用copy()将一个对象赋值给另一个变量时 或者使用查询赋值，查询数据的一部分并赋值给其他变量 当赋值为原数据查询的一部分时，是副本模式，修改一个变量不会影响另一个变量 变量查询一部分数据理论上是副本模式，但实际上，直接修改赋值变量时会报警告（能修改成功） 1a[['name', 'sex', 'address']] 数据操作 创建：C,Create 查询：R,Read 增加：I,Insert 修改：U,Update 删除：D,Delete pandas数据操作: 其他操作 pandas对象的命名: name pandas对象的遍历 Pandas对象的命名:name Series和Dataframe对象本身, 索引都可以命名 数据的输入和输出是Pandas的基础操作 Pandas可以存取多种介质类型数据：常见的有： 文本类数据 csv JSON 二进制磁盘数据 Excel pkl HDF5 数据库 SQL（略） Web API数据 HTML 其他 内存 12345文本类数据文件读入Pandas时会自动推断每列数据类型（类型推断）和数据编码并转化。二进制类数据文件没有编码问题，且部分文件会在格式中存储数据类型不需转化对Pandas不能直接支持或不方便使用的数据格式，可以使用支持软件将其转为csv或xlsx格式后使用Pandas读写，如SPSS文件]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2Fpython%2FPyUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Pyunit(unittest) 是python 自带的单元测试框架, 用于编写和运行可重复的测试.pyunit是xunit体系的一个成员, xunit是众多测试框架的总称,pyunit主要用于进行白盒测试和回归测试. 通过Pyunit可以让测试具有持久性, 测试与开发同步进行, 测试代码与开发代码一同发布.使用PyUnit具有如下好处: 可以是测试代码与产品代码分离. 针对某一个类的测试代码只需进行较少的改动, 便可以应用于另一个类的测试. PyUnit开放源代码, 可以进行二次开发, 方便对Pyunit的扩展.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解restful]]></title>
    <url>%2Fweb%2F%E7%90%86%E8%A7%A3restful%2F</url>
    <content type="text"><![CDATA[Restful API越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件. 这种”互联网软件”采用客户端/服务器模式, 建立在分布式体系上, 通过互联网通信, 具有高延时(high latency) , 高并发等特点. 网站开发, 完全可以采用软件开发的模式, 但是传统上, 软件和网络是两个不同的领域, 很少有交集. 软件开发主要针对单机环境, 网络则主要研究系统之间的通信. RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 resourcesrest的名称”表现层状态转化” 中, 省略了主语, “ 表现层” 其实指的是”资源”(resource) 的”表现层”. 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层(representation)“资源”是一种信息实体, 他可以有多种外在表现形式. 我们把”资源” 具体呈现出来的形式. 叫做它的”表现层”(representation). 比如, 文本可以用txt格式表现, 也可以用html格式, xml格式,JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 注意:资源不能是动词. 在RESTful架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表格名对应.一般来说, 数据库中的表都是同种记录的”集合”, 所以api中的名词也应该使用复数. http方法对于资源的具体操作类型, 由http动词表示. 常用的http动词有下面五个, (括号里对应的sql命令). GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的http动词. HEAD:获取资源的元数据. OPTIONS:获取信息, 关于资源的那些属性是客户端可以改变的. 下面是一些例子: GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息(filtering) 如果记录信息很多, 服务器不可能都将他们返回给用户, API应该提供参数, 过滤返回结果. 下面是一些常见的参数. ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余, 即允许api路径和url参数偶尔有重复.比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 api的身份认证应该使用oauth 2.0框架. 服务器返回的数据格式, 应该尽量使用json, 避免使用xml.]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>理解restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python部署]]></title>
    <url>%2Fpython%2F%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Django打包 构建setup.py文件 1234567useradd pythonecho python | passwd python --stdinyum install git python-devel mysql-develyum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-develcurl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 123export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 1234567source .bashrc [global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com python setup.py sdist –formats=gztar ln -sv blog-1.0 web /root/blog/projects/web uwsgi -d –ini blog.ini 后台启动服务, 123456789101112131415161718import &#123; resolve &#125; from &quot;url&quot;;let p = new Promise((resolve, reject) =&gt; &#123; //做一些事情 //然后再某些条件下resolve, 或者reject if(/*条件随便写*/) &#123; resolve() &#125;else&#123; reject() &#125;&#125;)p.then(() =&gt; &#123; //如果p的状态被resolve, 就进入这里&#125;), () =&gt; &#123; //如果p的状态被reject,进入这里&#125; 第一段调用了Promise构造函数, 第二段是调用了promise实例的.then方法 构造实例 构造函数接受一个参数作为参数 调用构造函数得到实例p的同时,作为参数的函数会立即执行. 参数函数接受两个回调函数参数resolve和reject 在参数函数被执行的过程中, 如果在其内部调用resolve, 会被p的状态变为fulfilled, 或者调用reject, 会将p的状态变为rejected. 调用.then 调用.then可以为实例p注册两种状态回调函数 当实例p的状态为fulfilled, 会触发第一个函数执行 当实例p的状态为rejected, 则会触发第二个函数执行. 总结 上面这样构造promise实例, 然后调用.then.then.then的编写代码方式, 就是promise. 其基本模式是: 将异步过程转换成promise对象. 对象有三种状态, 通过.then注册状态的回调. 已完成的状态能触发回调. 采用这种方式来处理编程中的异步任务, 就是在使用promise了. 所以promise就是一种异步编程模式.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中的promise]]></title>
    <url>%2Fjs%2F%E7%90%86%E8%A7%A3js%20%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[概念ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示. 简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理. 12345//语法new Promise( /*下面定义的函数是executor*/ function(resolve, reject) &#123;...&#125;); executor是一个带有resolve和reject 两个参数的函数. executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败. 如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略. executor中, resolve或reject只能执行其中一个函数. promise的状态 fulfilled:意味着操作成功完成 pending:初始状态,不是成功或失败状态 rejected: 意味着操作失败. Promise.then(onfilled, onRejected) 参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉. catch(onRejected) 为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象. Promise提供2个方法: Promise.resolve(value)返回 状态为fulfilled的Promise对象 Promise.reject(reason)返回 状态为rejected状态的Promise对象. catch其实是then(undefined, () =&gt; {})的语法糖,如下: 1234let p = Promise.reject('error');p.catch(err =&gt; &#123; console.log('catch' + err);&#125;) Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调. 实例 1234567891011121314151617181920212223242526272829function runAsync()&#123; return new Promise(function(resolve, reject)&#123; setInterval(function()&#123; console.log('do sth ----') resolve('ok----') &#125;, 3000); &#125;);&#125;//调用runAsync().then( value =&gt; &#123; console.log(value); return Promise.reject(value + '*'); &#125;).catch( reason =&gt; &#123; console.log(reason); return Promise.resolve(reason + '*'); &#125;).then( value =&gt; &#123; console.log(value); console.log('Promise end') &#125;)console.log('=========')]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与json]]></title>
    <url>%2Fweb%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson%2F</url>
    <content type="text"><![CDATA[序列化与反序列化内存中的字典,列表,集合以及各种对象,如何保存到一个文件中. 如果是自己定义的类的实例, 如何保存到一个文件中. 如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例. 要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化. 定义serialization 序列化 将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制 deserialization 反序列化 将文件的一个个字节恢复成内存中对象 &lt;-二进制 序列化保存到文件就是持久化. 可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化. jsonJSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。 json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。 1、JSON语法规则JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。 （1）简单值 简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。 12345678910111213// 简单值"Hello World!" // 字符串99 // 数值true // 布尔型false // 布尔型null// 在JSON中不能使用的值NaN // 数值不能是NaNInfinity // 数值不能是Infinityundefined // 在JSON也不可以使用JavaScript中的undefined'Hello World!' // 字符串必须使用双引号表示，不能使用单引号0x1 // 数值必须以十进制表示，不能使用十六进制 （2）对象 对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。 123456789101112// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号&#123; "name": "Andy", "age": 18, "isStudent": true, "isLeader": false, "mark": null, "school": &#123; "name": "BIT", "region": "Beijing" // 这个地方不能有逗号，因为是对象的最后一个属性成员 &#125; // 这个地方也不可以有逗号，因为也是对象的最后一个属性成员&#125; （3）数组 数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。 12345678910111213141516// 示例一["Andy", "Ruby", "Danny", "Peter", "Lisa"]// 示例二[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]// 示例三[ &#123;"name": "Andy", "age": 18&#125;, &#123;"name": "Ruby", "age": 18&#125;, &#123;"name": "Danny", "age": 20&#125;]// 示例四[ [0, 1, 2], [3, 4, 5], [6, 7, 8]] 2、JSON字符串和JSON对象（1）JSON字符串 JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。 1234//JSON字符串var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string （2）JSON对象 JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。 12345678// JSON对象var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object （3）JSON字符串和JSON对象互相转换 JavaScript中有一个全局的对象，JSON。JSON中有两个方法 stringify() 和 parse()。 JSON.parse() 把JSON字符串解析为JSON对象 12345//JSON字符串通过parse转化为JSON对象var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';person = JSON.parse(p)console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object JSON.stringify() 用于把JSON对象序列化为JSON字符串。 123456789//JSON对象通过stringify转化为JSON字符串var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;var p = JSON.stringify(person)console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程的4门功课]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91%2F</url>
    <content type="text"><![CDATA[计算机组成原理首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。 操作系统原理综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。 现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！我希望我写过的程序能在任何一台机上运行。我希望我能边听音乐边干活——即同一时间可以运行多个程序。我希望别人写的傻×东西不要影响到我的工作——即多任务控制。我希望计算机里面的各种资源都能得到良好的组织，更快的访问。我希望我的用户界面更好看，使用更方便，功能更强大！我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。 而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。 既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。 至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。 数据结构数据结构的作用, 就是为了提高硬件利用率. 比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。 数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。 计算机网络计算机网络分为3块： 硬件网卡，网线，交换机这些，用来处理数据的。 协议数据在网络中通信如何组织？如何识别？如何保证数据的正确性？这2块我就不多说了。 操作系统这就是如何把计算机网络和操作系统结合起来的问题了。对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。 网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web路由]]></title>
    <url>%2Fweb%2Fweb%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[web开发中路由route和路由器router到底是什么 1. 什么是路由在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。 2. router和route的区别route就是一条路由，它将一个URL路径和一个函数进行映射，例如： /users -&gt; getAllUsers() /users/count -&gt; getUsersCount() 这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。 而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route”。 3. 服务器端路由对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。 以Express为例， 12345678app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.sendFile(&apos;index&apos;)&#125;)app.get(&apos;/users&apos;, (req, res) =&gt; &#123; db.queryAllUsers() .then(data =&gt; res.send(data))&#125;) 这里定义了两条路由： 当访问/的时候，会返回index页面 当访问/users的时候，会从数据库中取出所有用户数据并返回 不仅仅是URL 在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。 4. 客户端路由对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案： 基于Hash 基于History API (1) 基于Hash我们知道，URL中#及其后面的部分为hash。例如： 1234const url = require(&apos;url&apos;)var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)console.log(a.hash)// =&gt; #/foo/bar hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。 通过监听window对象的hashChange事件，可以实现简单的路由。例如： 123456789101112131415window.onhashchange = function() &#123; var hash = window.location.hash var path = hash.substring(1) switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; (2) 基于History API通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考： Manipulating the browser historyUsing the HTML5 History API我们可以通过监听window对象的popstate事件，来实现简单的路由： 1234567891011121314window.onpopstate = function() &#123; var path = window.location.pathname switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; 但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如： 1234567var pushState = history.pushStatehistory.pushState = function() &#123; pushState.apply(history, arguments) // emit a event or just run a callback emitEventOrRunCallback()&#125; 不过，最好的方法还是使用实现好的history库。 (3) 两种实现的比较总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。 但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。 假设服务器只有如下文件（script.js被index.html所引用）： 123/- |- index.html |- script.js 基于Hash的路径有： 12http://example.com/http://example.com/#/foobar 基于History API的路径有： 12http://example.com/http://example.com/foobar 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。 当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 5. 动态路由上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。 例如在Express中： 12345678app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123; // ... ...&#125;)在Flask中：@app.route(&apos;/user/&lt;user_id&gt;&apos;)def get_user_info(user_id): pass 6. 严格路由在很多情况下，会遇到/foobar和/foobar/的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。 在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到/foobar/，而反过来则不会。 如果使用的是Express，默认这两者是一样的，也可以通过app.set来设置strict routing，来区别对待这两种情况。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml语言]]></title>
    <url>%2F%E5%85%B6%E4%BB%96%2FYaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Yaml语言编程Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便. 一、简介YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 它的基本语法规则如下。 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML 支持的数据结构有三种。 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 以下分别介绍这三种数据结构。 二、对象对象的一组键值对，使用冒号结构表示。 12&gt; animal: pets&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: 'pets' &#125;&gt; Yaml 也允许另一种写法，将所有键值对写成一个行内对象。 12&gt; hash: &#123; name: Steve, foo: bar &#125; &gt; 转为 JavaScript 如下。 12&gt; &#123; hash: &#123; name: 'Steve', foo: 'bar' &#125; &#125;&gt; 三、数组一组连词线开头的行，构成一个数组。 1234&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ 'Cat', 'Dog', 'Goldfish' ]&gt; 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 12345&gt; -&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ [ 'Cat', 'Dog', 'Goldfish' ] ]&gt; 数组也可以采用行内表示法。 12&gt; animal: [Cat, Dog]&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: [ 'Cat', 'Dog' ] &#125;&gt; 四、复合结构对象和数组可以结合使用，形成复合结构。 12345678910&gt; languages:&gt; - Ruby&gt; - Perl&gt; - Python &gt; websites:&gt; YAML: yaml.org &gt; Ruby: ruby-lang.org &gt; Python: python.org &gt; Perl: use.perl.org &gt; 转为 JavaScript 如下。 1234567&gt; &#123; languages: [ 'Ruby', 'Perl', 'Python' ],&gt; websites: &gt; &#123; YAML: 'yaml.org',&gt; Ruby: 'ruby-lang.org',&gt; Python: 'python.org',&gt; Perl: 'use.perl.org' &#125; &#125;&gt; 五、纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示。 12&gt; number: 12.30&gt; 转为 JavaScript 如下。 12&gt; &#123; number: 12.30 &#125;&gt; 布尔值用true和false表示。 12&gt; isSet: true&gt; 转为 JavaScript 如下。 12&gt; &#123; isSet: true &#125;&gt; null用~表示。 12&gt; parent: ~ &gt; 转为 JavaScript 如下。 12&gt; &#123; parent: null &#125;&gt; 时间采用 ISO8601 格式。 12&gt; iso8601: 2001-12-14t21:59:43.10-05:00 &gt; 转为 JavaScript 如下。 12&gt; &#123; iso8601: new Date('2001-12-14t21:59:43.10-05:00') &#125;&gt; 日期采用复合 iso8601 格式的年、月、日表示。 12&gt; date: 1976-07-31&gt; 转为 JavaScript 如下。 12&gt; &#123; date: new Date('1976-07-31') &#125;&gt; YAML 允许使用两个感叹号，强制转换数据类型。 123&gt; e: !!str 123&gt; f: !!str true&gt; 转为 JavaScript 如下。 12&gt; &#123; e: '123', f: 'true' &#125;&gt; 六、字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 12&gt; str: 这是一行字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一行字符串' &#125;&gt; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 12&gt; str: '内容： 字符串'&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '内容: 字符串' &#125;&gt; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 123&gt; s1: '内容\n字符串'&gt; s2: "内容\n字符串"&gt; 转为 JavaScript 如下。 12&gt; &#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125;&gt; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 12&gt; str: 'labor''s day' &gt; 转为 JavaScript 如下。 12&gt; &#123; str: 'labor\'s day' &#125;&gt; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 1234&gt; str: 这是一段&gt; 多行&gt; 字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一段 多行 字符串' &#125;&gt; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 1234567&gt; this: |&gt; Foo&gt; Bar&gt; that: &gt;&gt; Foo&gt; Bar&gt; 转为 JavaScript 代码如下。 12&gt; &#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;&gt; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 12345678910&gt; s1: |&gt; Foo&gt; &gt; s2: |+&gt; Foo&gt; &gt; &gt; s3: |-&gt; Foo&gt; 转为 JavaScript 代码如下。 12&gt; &#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125;&gt; 字符串之中可以插入 HTML 标记。 123456&gt; message: |&gt; &gt; &lt;p style="color: red"&gt;&gt; 段落&gt; &lt;/p&gt;&gt; 转为 JavaScript 如下。 12&gt; &#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125;&gt; 七、引用锚点&amp;和别名*，可以用来引用。 123456789101112&gt; defaults: &amp;defaults&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; &lt;&lt;: *defaults&gt; &gt; test:&gt; database: myapp_test&gt; &lt;&lt;: *defaults&gt; 等同于下面的代码。 1234567891011121314&gt; defaults:&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; adapter: postgres&gt; host: localhost&gt; &gt; test:&gt; database: myapp_test&gt; adapter: postgres&gt; host: localhost&gt; &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 123456&gt; - &amp;showell Steve &gt; - Clark &gt; - Brian &gt; - Oren &gt; - *showell &gt; 转为 JavaScript 代码如下。 12&gt; [ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]&gt; 八、函数和正则表达式的转换这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 1234&gt; # example.yml&gt; fn: function () &#123; return 1 &#125;&gt; reg: /test/&gt; 解析上面的 yml 文件的代码如下。 123456789101112&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; try &#123;&gt; var doc = yaml.load(&gt; fs.readFileSync('./example.yml', 'utf8')&gt; );&gt; console.log(doc);&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt; 从 JavaScript 对象还原到 yaml 文件的代码如下。 123456789101112131415161718&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; var obj = &#123;&gt; fn: function () &#123; return 1 &#125;,&gt; reg: /test/&gt; &#125;;&gt; &gt; try &#123;&gt; fs.writeFileSync(&gt; './example.yml',&gt; yaml.dump(obj),&gt; 'utf8'&gt; );&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fjs%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[js基础语法 常量和变量标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写. 声明 123456789var声明一个变量let声明一个块作用域中的局部变量const声明一个常量js中的变量声明和初始化时可以分开的.var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug. 数据类型 序号 名称 说明 1 number 数值型,包括整型和浮点型 2 boolean 布尔型,true和false 3 string 字符串 4 null 只有一个值null 5 undefined 变量声明未赋值的;对象未定义的属性 6 symbol ES6新引入类型 7 object 是以上基本类型的复合类型,是容器 弱类型,不需要强制类型转换, 会隐式类型转换. NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN 总结: 1234567遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换. 三元运算符条件表达式?真值:假值 等价于简单的if…else结构 函数, 匿名函数,函数表达式的差异 函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已. 区别在于, 函数会声明提升, 函数表达式不会 . 高阶函数: 函数作为参数或返回 一个函数. 函数12345678function 函数名(参数列表)&#123; 函数体; return 返回值;&#125;function add(x, y)&#123; return x + y;&#125;console.log(add(3, 5)); 函数, 匿名函数, 函数表达式的差异函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已. 区别在于, 函数会申明提升, 函数表达式不会. 123456789console.log(add(4, 6));// 匿名函数function add(x, y)&#123; return x + y;&#125;const sub = function (x, y)&#123; return x -y;&#125;console.log(sub(5, 6)); 高阶函数 高阶函数: 函数作为参数或返回一个函数 箭头函数箭头函数就是匿名函数,它是一种更加精简的格式. 箭头函数参数 如果一个函数没有参数,使用() 如果只有一个参数,参数列表可以省略小括号() 多个参数不能省略小括号,且使用逗号间隔. 箭头函数返回值. 如果函数体部分有多行,就需要使用{}, 如果有返回值使用return. 如果只有一行语句, 可以同时省略大括号和return. 只有return语句, 就不能省略大括号, 如果只有一条非return语句, 加上大括号, 函数就成了无返回值, 函数参数普通参数一个参数占一个位置,支持默认参数. 可变参数(rest parameters剩余参数) js使用…表示可变参数(python用*手机多个参数) 12345678const sum = function (...args)&#123; let result = 0; for (let x in args)&#123; result += args[x] &#125; return result&#125;;console.log(sum(3, 6, 9)) arguments对象函数的所有参数会被保存在一个arguments的键值对对象中. 参数解构和python类似, js提供了参数解构, 依然使用了…符号来结构. 1234const add = (x, y) =&gt;&#123;console.log(x, y); return x + y&#125;;console.log(add(...[100, 200]))console.log(add(...[100, 200, 300]))console.log(add(...[100])) 函数返回值python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组. 表达式的值 类c的语言,都有一个概念 – 表达式的值 赋值表达式的值: 等号右边的值 逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值. 异常抛出异常 js的异常语法和java相同, 使用throw关键字抛出. 使用throw关键字可以抛出任意对象的异常. 1234throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok'; 捕获异常try…catch语句捕获异常 try …catch…finally 语句捕获异常, finally保证最终一定执行. 问题: null和undefined的异同1.undefined：是所有没有赋值变量的默认值，自动赋值。 2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。 共同点：都是原始类型，保存在栈中变量本地。 不同点： undefined——表示变量声明过但并未赋过值。 它是所有未赋值变量默认值，例如： 1var a; // a 自动被赋值为 undefined null——表示一个变量将来可能指向一个对象。 一般用于主动释放指向对象的引用，例如： 12var emps = [&apos;ss&apos;,&apos;nn&apos;]; emps = null; // 释放指向数组的引用 它是专门释放对象内存的一个程序。 在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期； 总有一个对象不再被任何变量引用时，才释放]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>JavaScrript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fpython%2F%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊属性 属性 含义 __name__ 类,函数,方法等名字 __module__ 类定义所在的模块名 __class__ 对象或类所属的类 __base__ 类的基类的元组,顺序为他们在基类中出现的顺序 __doc__ 类, 函数的文档字符串, 如果没有定义则为None __mro__ 类的mro, class.mro()返回的结果的保存在__mro__ 中 __dict__ 类或实例的属性, 可写的字典 查看属性__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它. 如果dir()参数obj包括方法_dir__(), 该方法将被调用.如果参数obj不包含\_dir__(), 该方法将最大限度地收集属性信息. dir(obj)对于不同类型的对象obj具有不同的行为: 如果对象是模块对象, 返回的列表包含模块的属性名和变量名 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名 如果是类的实例 有__dir__方法, 返回可迭代对象的返回值 没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名 如果obj不写, 返回列表包含内容不同 在模块中, 返回模块的属性和变量名 在函数中, 返回本地作用域的变量名 在方法中, 返回本地作用域的变量名 123456789# animal.pyclass Animal: x = 123 def __init__(self, name): self._name = name self.__age = 10 self.weight = 20 print('animal Module\ s names = &#123;&#125;'.format(dir()))# 模块的属性 ) 魔术方法*** 分类: 创建, 初始化与销毁 可视化 hash bool 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他杂项 实例化 方法 意义 __new__ 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法 __new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回 可视化 方法 意义 __str__ str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息 __repr__ 内建函数repr()对一个对象获取字符串表达 __bytes__ bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 123456class A: def __init__(self, name, age = 18): self.name = name self.age = age def __repr__(self): return 'repr:&#123;&#125;&#123;&#125;'.format(self.name, self.age) hash 方法 意义 __hash__ 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash __eq__ 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了 bool 方法 意义 __bool__ 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真 上下文管理文件IO操作可以对文件对象使用上下文管理，使用with。。as语法 12with open('test') as f: pass 仿照上例写一个自己的泪，实现上下文管理 1234class Point: passwith Point as p: pass 提示属性错误，没有__exit__，看了需要这个属性 某些版本会显示没有__enter__ 上下文管理对象 当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象 __enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上 __exit__退出与此对象相关的上下文 with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作 注意,with 并不开启一个新的作用域 上下文管理是安全的 上下文应用场景 1.增强功能 在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能 2.资源管理 打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等 3.权限验证 在执行代码之前,做权限验证,在__enter__ contextilb.contextmanager他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法 对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值. 也就是这个装饰器接受一个生成器对象作为参数. 总结 如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便 反射概述 运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候 反射, reflection, 指的是运行时获取类型定义信息 一个对象能够在运行时,像照镜子一样,反射出其类型信息 简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身 具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等 反射相关的函数和方法 getattar 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. setattar object的属性存在,这覆盖, 不存在,新增 hasattat 判断对象是否有这个名字的属性,name必须为字符串 反射相关的魔术方法__getattr__(), __setattr__(), __delattr__(), 三个魔术方法 实例属性会按照继承关系找, 如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出 AttributeError异常表示找不到属性. 查找属性顺序为: instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[语言的分类面向机器:抽象成机器指令, 机器容易理解.代表:汇编语言面向过程:做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.问题规模小, 可以步骤化.按部就班处理.代表:c语言面向对象OOP随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.代表:C++, java, python等 面向对象类:class类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.用计算机语言来描述类,是属性和方法的集合.对象:instance, object对象是类的具象, 是一个实体.对于我们每个人这个个体, 都是抽象概念人类不同的实体. 属性:它是对象状态的抽象,用数据结构来描述.操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.哲学:一切皆对象对象是数据和操作的封装.对象是独立的,但是对象之间可以相互作用.目前OOP是最接近人类认知的编程范式. 三要素1.封装组装:将数据和操作组装到一起.隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.2.继承多复用,继承来的就不用了自己写了多继承少修改,OCP,使用继承来改变,来体现个性.3.多态面向对象编程最灵活的地方,动态绑定人类就是封装人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:多态,继承自动物类的人类,猫类的操作’吃’不同. python的类:1.必须使用class关键字2.类名必须使用大驼峰命名3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上. 类对象及类属性类对象,类的定义执行后会生成一个类对象.类的属性,类定义中的变量和类中定义的方法都是类的属性.类变量,self指代当前实例本身. 实例化a = Myclass() # 实例化使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.实例化就真正创建一个该类的对象tom = Person()jerry = Person()每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.python类实例化后, 会调用init方法,这个方法第一个形式参数必须留给self,其他参数随意.init方法 注意:init()方法不能有返回值,也就是只能是return None 实例对象instance类实例化后一定会获得一个类的实例,就是实例对象init方法的第一参数self就是指代某一个实例自身.类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上. 实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法. 总结:是类的,也就是这个类所有实例的,器实例都可以访问到:是实例的,就是这个实例自己的,通过类访问不到.类变量是属于类的变量,这个类的所有实例可以共享这个变量.对象可以动态的给自己增加一个属性.实例属性的查找顺序指的是实例使用,.点号来访问属性.会先找自己的dict,如果没有,然后通过属性class找到自家的类, 再去类的dict中找.注意:如果实例使用dict访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找. 一般来说, 类变量可使用全大写来命名. 类方法和静态方法类方法:1.在类定义中,使用@classmethod装饰器的方法2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改4.通过cls可以直接操作类的属性.静态方法:在类定义中, 使用@staticmethod装饰器的方法2在调用时, 不会隐式的传入参数.静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理. 类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,原因是第一参数必须是类的实例.总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类. 访问控制:私有属性私有属性,使用双下划线开头的属性名就是私有属性. 私有属性的本质:类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了. 保护变量:在变量名前使用一个下划线,称为保护变量这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.私有方法:参照保护变量,私有变量,使用单下划线,双下化线的命名方法, 补丁可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变猴子补丁:在运行时,对属性,方法,函数,等进行动态替换其目的往往是为了通过替换,修改来增强,扩展原有代码的能力 属性装饰器一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性. property装饰器 后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性setter装饰器可以控制是否删除属性,很少用deleter装饰器可以控制是否删除属性,很少用property装饰器必须在前,setter deleter装饰器在后,property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果. 对象的销毁类中可以定义del方法 ,称为析构函数.作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用del方法.由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.封装:将数据和操作组织到类中,即属性和方法.将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F%E5%85%B6%E4%BB%96%2F%E8%8D%89%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[none 与NUll的区别表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为0,因为0是有意义的,而none是一个特殊的空值判断的时候 均是false属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被调用.如果参数不包含dir(),该方法将最大限度地收集参数信息. 功能性函数返回都为noneNone是一个特殊的常量。None和False不同。None不是0。None不是空字符串。None和任何其他的数据类型比较永远返回False。None有自己的数据类型NoneType。你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[OSI参考模型 模型 说明 应用层 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. 表示层 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. 会话层 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. 传输层 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). 网络层 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. 链路层 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . 物理层 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. 网络协议 链路层和物理层 描述 ARP(地址解析协议) IP地址——-&gt;MAC地址 RARP MAC地址——&gt;IP地址（逆向的） PPP协议 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 MAC地址 48位全球唯一,网络设备的身份识别 网络层 描述 IP协议 IP:（分为IPV4（168….）和IPV6（16进制用：隔开）） ICMP（Internet控制管理协议） ping命令属于ICMP IGMP（Internet分组管理协议） 广播，组播 传输层 描述 TCP（传输控制协议) 面向连接，可靠,效率低，一对一的可靠数据传输的协议 UDP（用户数据报协议） 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输 SCTP 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 应用层 描述 网页访问协议 HTTP HTTPS(S是安全) 邮件发送接收协议 POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） FTP 文件传输协议 Telnet（明文传输）/SSH（安全） 远程登录 嵌入式 描述 NTP 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） SNMP(开源（SNMP.NET）) 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 RTP/RTSP 用传输音视频传输（监控等） 中继系统中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。 中继系统之集线器光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。 这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。 中继系统之交换机还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：有记忆功能。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？ 交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。 如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。 中继系统之路由器路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。 端口IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。 这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。 socketsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系. arp协议因为ip数据包是在以太网数据包里发送, 所以我们必须同时知道两个地址, 一个是对方的MAC地址, 另一个是对方的IP地址, 通常情况下, 对方的IP地址是已知的, 但是我们不知道它的mac地址.所以, 我们需要一种地址, 能够从ip地址得到mac地址.这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 路由Routing跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络. 路由器上维护着路由表,他知道如何将数据包发往另外的网络. windows使用route print, liunx使用route -n可以查看路由表. 路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置. 静态路由:有管理员手动配置的固定的路由信息 动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的. 程序结构和执行信息存储大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.一个字节包括8位,在二进制表示法中,0000000011111111 0255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.2进制 TODO]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解预处理器]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译. 预定义符号预处理指令 指令 描述 #include 包含一个源代码 #define 定义宏 #undef 取消已定义的宏 #ifdef 如果宏已经定义,则返回真 #ifndef 如果宏没有定义,则返回真 #if 如果给定条件为真,则编译下面代码 #else #if的替代方案 #elif 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 #endif 结束一个#if…#else 条件编译块 #error 当遇到标准错误时, 输出错误消息 #pragma 使用标准化方法, 向编译器发布特殊的命令道编译器中 typedef c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 . 动态内存分配 当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据. c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需. python对象就是 c语言结构体在堆上申请的一块内存. 在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 c中大量操作字符串的函数 函数 目的 strcpy 复制字符串s2到字符串s1 strcat 连接s2 到字符串s1的末尾 strlen 返回字符串s1的长度 strcmp 如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 strchar 返回一个指针,指向字符串s1中字符ch的第一次出现的位置 strstr 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fpython%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式简绍概述:正则表达式正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.正则表达式 Regular Expression,缩写regex, regexp ,RE等.分类1.BRE基本正则表达式,grep,sed,vi等软件支持.vim有扩展.2.ERE扩展正则表达式,egrep, sed -r等.3.PCRE几乎所有高级语言都是PCRE的方言或者变种. 基本语法元字符 metacharacter转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.反斜杠自身,得使用\ \r \n还是转义后代表回车,换行 贪婪与非贪婪默认是贪婪模式,也就是说尽量多匹配更长的字符串,非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了. 单行模式:. 可以匹配所有的字符, 包括换行符.^ 表示整个字符串的开头, &amp;整个字符串的结尾多行模式:. 可以匹配除了换行符之外的字符,多行不影响.点号^ 表示行首, &amp;行尾, 只不过这里的行是每一行 默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n re模块re.M多行模式re.S单行模式re.I忽略大小写re.X忽略表达式中的空白字符使用 | 位或运算开启多种选项方法编译re.compile(pattern, flag=0)设定flags, 编译模式,返回正则表达式对象regexpattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.单次匹配re.match(pattern, string, flags=0)match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象. 全局搜索对整个字符串, 从左至右匹配,返回匹配项的列表.匹配替换使用pattern对字符串string进行匹配,对匹配使用repl替换.replacement可以是string, bytes, function. 分割字符串字符串的分割函数split,太难用, 不能指定多个字符进行分割.分组使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.2.如果使用了命名分组,可以使用group的方式取分组3.也可以使用group返回所有组.4.使用groupdict()返回命名的分组.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fpython%2F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[魔术方法 类别 方法名 可视化 __str__, __repr__, __format__, __bytes__ 数值转换 __abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__ 容器模拟 __len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__ 迭代枚举 __iter__, __reversed__, __next__ 可调用模拟 __call__ 上下文管理 __enter__, __exit__ 实例创建和销毁 __new__, __init__, __del__ 属性管理(反射) __dir__, __getattr__, __setattr__, __delattr__, __getattribute__ 属性描述符(描述器) __get__, __set__, __delete__ 特殊属性 __name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__ 比较运算符 __eq__,__lt__, __le__, __gt__, __ge__, __ne__ 算数运算符 __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 增量运算符 __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__ 反向运算符 __radd__, __rsub__ 其他 __slots__ 内置函数 内置函数名 方法名 数学运算 abs, divmod,max,min,pow, round, sum 类型转换 bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex 序列操作 all, any, filter, map,next,reversed, sorted, zip 对象操作 help,dir,id,hash, type,len, ascii,format, vars, 反射操作 __import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable 变量操作 globals, locals, 交互操作 print,input 文件操作 open 编译执行 compile, eval,exec, repr 装饰器 property,classmethod, staticmethod, 数据结构 tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object 标识符: 1234567False await else import passNone break except in raiseTrue class finally is returnand continue for lambda tryas def from nonlocal whileassert del global not withasync elif if or yield 模块常用方法 内置模块 方法名 re compile, search, match, fullmatch,split,findall, sub, string ascii_letters,ascii_lowercase.digits datetime datetime collections nametuple, deque, OrderdDict, defaultdict, bisect bisect_left,bisect_right, math ceil random randint, choice, randrange,shuffle, sample functools reduce, partial,lru_cache pathlib os shutil copyfileobj, copyfile, copymode, copystat,copy,copy2,copytree,rmtree,move, pickle csv reader time threading queue json base64 sys inspect signature(callable)获取签名, ConfigParser argparse heapq hea]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述器]]></title>
    <url>%2Fpython%2F%E6%8F%8F%E8%BF%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[描述器 Descriptors描述器的表现 用到3个魔术方法: __get__() 、 __set__() 、 __delete__() 方法签名如下 object.__get__(self, instance, owner) object.__set__(self, instance, value) object.__delete__(self, instance) self 指代当前实例，调用者 instance 是owner的实例 owner 是属性的所属的类 请思考下面程序的执行流程是什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041class A: def __init__(self): self.a1 = 'a1' print('A.init')class B: x = A() def __init__(self): print('B.init')print('-'*20)print(B.x.a1)print('='*20)b = B()print(b.x.a1)# 运行结果A.init--------------------a1====================B.inita1 可以看出执行的先后顺序吧？ 类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。 然后实例化并初始化B的实例b。 打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。 描述器定义Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。 仅实现了 __get__ ，就是非数据描述符 non-data descriptor 实现了 __get__ 、 __set__ 就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。 属性的访问顺序为上例中的类B增加实例属性x 12345678910111213141516171819202122232425262728293031323334353637class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return selfclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x)print(b.x.a1) # AttributeError: 'str' object has no attribute 'a1' 类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。 继续修改代码，为类A增加 __set__ 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return self def __set__(self, instance, value): print('A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'.format(self, instance, value)) self.data = valueclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x) # 返回什么print(b.x.a1) # 返回什么print(b.x.data) # 返回什么？ 所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。 属性查找顺序实例的 __dict__ 优先于 非数据描述器 数据描述器 优先于 实例的 __dict__ __delete__ 方法有同样的效果，有了这个方法，也是数据描述器。 尝试着增加下面的2行代码，看看字典的变化 b.x = 500 B.x = 600 b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。 B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。 ### Python中的描述器 描述器在Python中应用非常广泛。 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 12345678910111213141516171819202122232425262728293031323334353637class A: @classmethod def foo(cls): # 非数据描述器 pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300a = A()print(a.__dict__)print(A.__dict__) foo、bar都可以在实例中覆盖，但是z不可以。 新增方法 3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。 12345678910111213141516171819202122class A: def init(self): print('A init') def get(self, instance, owner): print(1, self, instance, owner) return self def set_name(self, owner, name): print(2, self, owner, name) self.name = nameclass B:x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)print(B().x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理异常]]></title>
    <url>%2Fpython%2F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常处理(Exception)错误Error逻辑错误:算法写错了, 例如加法写成了减法 笔误:例如变量名写错了,语法错误 函数或类使用错误, 其实这也属于逻辑错误 总之,错误是可以避免的 异常Eception本意就是意外情况 这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去. 例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况. 错误和异常在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获. 123with open('tetsabcd') as f: pass# 异常 产生异常产生: raise语句显示的抛出异常 Python解释器自己检测异常并引发它程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行) 异常的捕获1234try: 待捕获异常的代码块except [异常类型] 异常的处理代码块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[练习 有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。思路排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。查找插入点，使用二分查找完成。假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。直到中点就是 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) - 1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]newlst = sorted(lst) # 升序 print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41): newlst = insert_sort(newlst, x) print(newlst) 看似上面代码不错，请测试插入100。问题来了，100插入的位置不对，为什么？ 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) # 去掉减1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret # 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51] newlst = sorted(lst) # 升序print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41, 100): newlst = insert_sort(newlst, x) print(newlst) high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。 二分二分前提是有序，否则不可以二分。二分查找算法的时间复杂度O(log n) bisect模块bisect模块提供的函数有： bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。 bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。 bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。函数可以分2类： bisect系，用于查找index。Insort系，用于实际插入。默认重复时从右边插入。 应用判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’ 12345678910import bisect def get_grade(score): breakpoints = [60, 70, 80, 90] grades = 'EDCBA' return grades[bisect.bisect(breakpoints, score)] for x in (91, 82, 77, 65, 50, 60, 70, 80, 90): print('&#123;&#125; =&gt; &#123;&#125;'.format(x, get_grade(x)))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识框架]]></title>
    <url>%2Fpython%2Fpython%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[python基础python是一种动态的强类型语言,底层是用C语言开发的. 平台：*nix平台系统：线程、进程、Shell编程网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个中间件：消息队列原理和应用，例如8曲bitMQWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一可视化：WEB的前端开发多一些HTML、jS要会数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用 python学习路线:基础：操作系统、网络基础、数据库基础、python语言基础..进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).新前端开发(ES6、React、Antd）…实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..高端：数据清洗、企业数据分析、预测准荐、机器视觉． 数据类型python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none 字符串因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节. 字符串的格式化format函数或 格式符 编码字符串与bytes字符串是字符组成的有序序列，字符可以使用编码来理解bytes是字节组成的有序的不可变序列bytearray是字节组成的有序的可变序列 编码与解码：字符串按照不同的字符集编码encode返回字节序列bytesencode（encoding=‘utf-8’，errors=‘strict’）字节序列按照不同的字符集解码decode返回字符串bytes.decode（encoding=“utf-8”，errors=“strict”）ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统 要熟记31 41 61 的ascii表 字节序：大端模式，big-endian；小端模式，little-endianintel x86cpu使用小端 模式网络传输更多使用大端模式windows，linux 使用小端模式mac os使用大端模式java 虚拟机是大端模式 数字有整数 浮点数 复数等 true false主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。 None：Python里面特殊的空值，不能理解为0。 容器list（列表） tuple（元组） set（集合） dictionary（字典）这些都是可以迭代的 list创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。 tuple元组和列表类似，但是不同的是元组不能修改，元组使用小括号。 dict判断结构ifif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。 elif 语句 elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。 if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。 forfor循环可以遍历任何序列的项目： whilewhile循环，只要条件满足，就不断循环，条件不满足时退出循环： break和continue语句： break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。 continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python特殊函数]]></title>
    <url>%2Fpython%2Fpython%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[匿名函数匿名函数 :隐藏名字,即没有名称匿名函数: 没有名字的函数lambda表达式python中,使用lambda表达式构建匿名函数使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式参数列表不需要小括号,无参就不写参数冒号用来分割参数和表达式部分不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.lambda表达式匿名函数只能写在一行上,也称为单行函数. 匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码. 递归函数函数执行流程:压栈 递归函数recursion函数直接或者间接调用自身就是递归.递归需要有边界条件,递归前进段,递归返回段.递归一定要有边界条件.当边界条件不满足的时候,递归前进当边界条件满足的时候,递归返回. 递归例子:斐波那契数列如果用循环写法:1234567a = 0b = 1n = 10for i in range(n -1): a,b=b, a+belse: print(b) 递归写法:def fib(n): return 1 if n &lt;3 else fib(n-1) +fib(n-2) 递归要求递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.递归调用的深度不宜python 对递归调用的深度做了限制,以保护解释器超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度sys.getrecursionlimit() 循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了. 递归是一种很自然的表达,符合逻辑思维递归相对效率低,每一次调用都要开辟栈帧.递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.绝大多数递归,都可以使用循环实现即使递归代码很简洁,但是能不用则不用递归. 生成器生成器generator生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.生成器对象,是一个可迭代对象,是有个迭代器.生成器对象,是延时计算,惰性求值的. 函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.普通函数调用,函数会立即执行直到执行完毕.生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑. 在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回再执行会执行到下一个yield语句又会暂停执行return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration生成器函数包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.再次调用next函数,和上一条一样的处理过程.继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常. 协程生成器的高级用法他比进程,线程轻量级,是在用户空间调度函数的一种实现.协程调度器实现思路协程是一种非抢占式调度. yield from 语法yield from就是一种简化语法的语法糖. yield 和return的区别带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return 如何生成斐波那契数列:斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数. 12345678def fab(max): a, b = 1, 1 n = 1 while n &lt; max: print(b) a, b = b, a+b n +=1fab(20) 结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.123456789def fab(max): n, a, b = 0, 0, 1 l = [] while n &lt; max: l.append(b) b = b+a a = b-a n = n+1 return l 改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要用list来保存中间结果, 而是通过iterable对象来迭代. 1234567891011121314151617class Fab(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.b = self.a + self.b self.a = self.b - self.a self.n = self.n + 1 return r raise StopIteration() 然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b b = b+a a = b-a n = n + 1 第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果调用第四版的fab和第二版的fab完全一致: 简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法这样我们就可以清楚看到fab的执行流程. 高阶函数函数也是对象, 是可调用对象函数可以作为普通变量,也可以作为函数的参数, 返回值. 在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数接受一个或多个函数作为参数输出一个函数 排序sorted排序函数,可以接受key作为参数进行排序,不改变序列的原有值.排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素. 过滤filter对可迭代对象进行遍历,返回一个迭代器function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值function参数如果是None, 可迭代对象的每一个元素自身等效布尔值. 映射map对多个可迭代对象的元素,按照指定的函数进行映射返回一个迭代器 柯里化指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件io]]></title>
    <url>%2Fpython%2Fpython%E6%96%87%E4%BB%B6io%2F</url>
    <content type="text"><![CDATA[文件io常用操作一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络ioopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取seek: 文件指针操作 tell: 指针位置 打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.文件操作中,最常用的操作就是读和写.文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件a: 写入打开,如果文件存在,则追加b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力. open默认是只读模式r打开已经存在的文件. 文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOFbuffering:缓冲区0:只在二进制模式打开,表示关buffer1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush大于1:用于指定buffer的大小. 上下文管理1.异常处理当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.使用finally可以保证打开的文件可以被关闭.2.上下文管理一种特殊的语法, 交给解释器去释放文件对象.使用with … as关键字上下文管理的语句并不会开启新的作用域with语句执行的时候,自动关闭文件对象.1234f1 = open(&apos;text&apos;)with f1: f1.write(&apos;abc&apos;)f1.closed 对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题. StringIO和BytesIOStringIOio模块中的类from io import StringIO内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.当close方法被调用的时候,这个buffer被释放. 好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率. BytesIOio模块中的类from io import BytesIO内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.当close方法被调用的时候, 这个buffer会释放. file-like对象类文件对象,可以像文件一样操作socket对象,输入输出对象都是类文件对象. 路径操作from os import path3.4版本开始建议使用pathlib模块,提供path对象来操作.包括目录和文件Pathlib模块 目录操作初始化路径拼接和分解操作符分解joinpath 通配符glob通配给定的模式rglob通配给定的模式,递归目录都返回一个生成器?代表一个字符*表示任意个字符[abc]或[a-z]表示一个字符 匹配match(pattern)模式匹配,成功返回True 文件操作os模块os.name windows是nt, linux是posixos.uname() *nix支持sys.platform windows显示win32, linux 显示linuxos.listdir返回指定目录内容列表, 不递归os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似. shutil模块文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.python提供了一个方便的shutil(高级文件操作)copy复制copyfileobj(fsrc, fdst[, length]) 文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.12345import shutilwith open (&apos;text&apos;, &apos;r+&apos;) as f: f.write(&apos;abcd&apos;) with open(&apos;text1&apos;, &apos;w+&apos;) as f1: shutil.copyfileobj(f, f1) 复制文件内容,不含元数据,src,dst为文件的路径字符串. rm删除shutil.rmtree(path, ignore_errors=False, oneerror=None)递归删除,如同rm -rf一样危险,慎用.他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.shutil.retree(“text”) 类似rm -rf move移动递归移动文件,目标到目标,返回目标本身使用的是os.rename方法如果不支持rename,如果是目录则copytree再删除源目录.shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz csv文件csv是一个被行分隔符,列分割符划分成行和列的文本文件.csv不指定字符编码.行分割符为\r\n,最后一行可以没有换行符.列分割符常用逗号或者制表符.每一行称为一条记录record.字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.csv模块返回reader对象,是一个行迭代器默认使用excel方言.delimiter列分割符,逗号.lineterminator行分割符\r\n ini文件处理作为配置文件,ini文件格式的很流行. 中括号里面的部分称为section,译作节,区, 段每一个section内, 都是key=value形成的键值对,key称为option选项.注意这里的DEFAULT是缺省section的名字,必须大写.configparserconfigparser模块的configparser类就是用来操作.可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典. 序列化和反序列化为什么要序列化内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.serialization序列化将内存中对象存储下来,把他变为一个个字节.deserialization反序列化将文件的一个个字节恢复成内存中的对象序列化保存到文件就是持久化可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化python提供了pickle库 dumps 对象序列化为bytes对象dump 对象序列化到文件对象,就是存入文件loads 从bytes对象反序列化load 对象反序列化,从文件读取数据 序列化应用一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型jsonjson的数据类型 messagepackmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.他可以像json那样,在许多语言之间交换结构对象.但是他比json更快速也跟轻巧.支持python.ruby,java等众多语言,兼容json 和pickle 安装pip install msgpack 常用方法序列化对象,提供dumps来兼容pickle和jsonunpackb反序列化对象.提供了loads来兼容.pack序列化对象保存到文件对象,提供了dump来兼容.unpack反序列化对象保存到文件对象,提供了load来兼容.messagepack简单易用,高效压缩,支持语言丰富.所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要. 常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合. 数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型. 抽象数据类型抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.抽象的意义在于数据类型的数学抽象特性. 内存单元和地址计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,在计算机内存里表示数据元素之间的联系,只有两种技术:利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构. 数据结构是相互之间存在一种或多种特定关系的数据元素的集合.逻辑上分:集合结构, 线性结构, 树形结构, 图形结构物理结构:顺序存储结构, 链式存储结构. 算法算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.函数渐进式增长.判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.用O()来体现时间复杂度的记法, 我们称为大O记法.O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶. 线性表从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来. 线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素.插入删除的时间复杂度为O(n).它比较适合元素个数不太变化,而更多存取数据的应用.优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间. 可以快速地存取表中任意位置的元素.缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量造成存储空间的”碎片”. 线性表链式存储结构线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点. 头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.头指针具有标识作用,所以常用头指针冠以链表的名字.无论链表是否为空,头指针均不为空,头指针是链表的必要元素.由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显. 若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构. 静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法 将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针. 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表.对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表. 在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,栈是限定仅在表尾进行插入和删除操作的线性表.我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶. 栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.栈的删除操作,也叫出栈,或弹栈栈.特别是插入和删除操作,我们改名为push 和pop.两栈共享空间 栈的链式存储结构简称链栈顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些. 对列对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出. 串串是有零个或多个字符组成的有限序列,又名字符串.串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.串的顺序存储结构串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.在计算机中存在一个自由存储区,叫做堆. 模式匹配算法子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.一个字符的ASCII码可以看成是8位的二进制01串. 本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.所谓的回文就是一个字符串的逆转显示reverse的操作. 树树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树. 所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.树的定义其实就是我们在讲解栈提到的递归的方法.树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值. 结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.树中结点的最大层次称为树的深度或高度. 树的存储结构 树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.双亲表示法:我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行. 二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成. 二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,左子树和右子树是有顺序的,次序不能任意颠倒, 顺序存储结构一般只用于完全二叉树.二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.这里有两个关键词:访问和次序二叉树本质上,是对链表和数组的一个折中.每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据. 压缩编码方法:赫夫曼编码 图图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.图是由顶点的有穷非空集合和顶点之间边的集合组成.图不能用简单的顺序结构来表示,而是多重链表. 搜索引擎的工作原理:它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录. 查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素. python 对象特性python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值: 身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.值:对象表示的数据. python基本数据类型python的数据类型:number(数字), string(字符串), bool(布尔), None(空值) python 内建数据结构线性结构字符串在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变. 列表元组bytes非线性结构集合set字典dict]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python小技巧]]></title>
    <url>%2Fpython%2Fpython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[为多个变量赋值有时，有多个变量需要赋值，这时你会怎么赋值呢？常规方法：常规方法是给变量逐个赋值。123a = 0 b = 1 c = 2 优雅方法：直接按顺序对应一一赋值.a, b, c = 0, 1, 2 序列解包需要取出列表中的元素。常规方法：一般我们知道可以通过下标获取具体元素。1234567info = ['brucepk', 'man', 'python']name = info[0]sex = info[1]tech = info[2]print(name,sex,tech)结果:brucepk man python 优雅方法：给出对应变量接收所有元素。12345info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]name,sex,tech = infoprint(name,sex,tech)结果:brucepk man python 优雅你的判断语句我们用判断语句来定义一个绝对值函数。常规方法：1234567891011121314x = -6if x &lt; 0: y = -xelse: y = xprint(y)结果:6优雅方法：x = -6y = -x if x&lt;0 else xprint(y)结果6 区间判断使用 and 连续两次判断的语句，条件都符合时才执行语句。常规方法：123456score = 82if score &gt;=80 and score &lt; 90: level = 'B'print(level)结果B 优雅方法：使用链式判断。123456score = 82if 80 &lt;= score &lt; 90: level = &apos;B&apos;print(level)结果B 多个值符合条件判断多个值任意一个值符合条件即为 True 的情况。常规方法：123456num = 1if num == 1 or num == 3 or num == 5: type = &apos;奇数&apos;print(type)结果奇数 优雅方法：使用关键字 in，让你的语句更优雅。123456num = 1if num in(1,3,5): type = &apos;奇数&apos;print(type)结果奇数 判断是否为空判断元素是空还是非空。常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;if len(A) &gt; 0: print(&apos;A 为非空&apos;)if len(B) &gt; 0: print(&apos;B 为非空&apos;)if len(C) &gt; 0: print(&apos;C 为非空&apos;)结果A 为非空 优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。 123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos; if A: print(&apos;A 为非空&apos;) if B: print(&apos;B 为非空&apos;) if C: print(&apos;C 为非空&apos;) 结果A 为非空 多条件内容判断至少一个成立常规方法：用 or 连接多个条件。12345math,English,computer =90,80,88if math&lt;60 or English&lt;60 or computer&lt;60: print(&apos;not pass&apos;)结果not pass 优雅方法：使用 any 语句。12345math,English,computer =90,59,88if any([math&lt;60,English&lt;60,computer&lt;60]): print(&apos;not pass&apos;)结果not pass 多条件内容判断全部成立常规方法：使用 and 连接条件做判断。12345math,English,computer =90,80,88if math&gt;60 and English&gt;60 and computer&gt;60: print(&apos;pass&apos;)结果pass 优雅方法：使用 all 方法。12345math,English,computer =90,80,88if all([math&gt;60,English&gt;60,computer&gt;60]): print(&apos;pass&apos;)结果pass 遍历序列的元素和元素下标常规方法：使用 for 循环进行遍历元素和下标。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for i in range(len(L)): print(i, &apos;:&apos;, L[i])结果0 : math1 : English2 : computer3 : Physics 优雅方法：使用 enumerate 函数。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for k,v in enumerate(L): print(k, &apos;:&apos;, v)结果0 : math1 : English2 : computer3 : Physics 循环语句优化之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。常规方法：使用简单的 for 循环可以达到目的。123456L = []for i in range(1, 6): L.append(i*i)print(L) 结果：[1, 4, 9, 16, 25] 优雅方法：使用列表生成式，一行代码搞定。123print([x*x for x in range(1, 6)]) 结果：[1, 4, 9, 16, 25] 将list中的所有元素转为单个字符串12a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]print(&quot; &quot;,join(a)) 字符串倒转方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。方法二：用Python自带reversed()函数，它可被用于list倒转。方法三：第三种是通过倒转数据类型和切片倒转整数. 链式调用在python 中实现链式调用只需在函数返回对象自己就行123456def product(a, b): return a * bdef add(a, b): return a + bb = Trueprint((product if b else add)(5, 7)) 复制list在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：方法一：b=a[:]。方法二：b=list(a)。方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。方法四：使用copy.deepcopy()。 按value排序字典Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：方法一：用sorted函数排序，其中key参数是lamda表达式。方法二：用operator.itemgetter而不是lamda表达式进行排序。方法三：如果只需得到排序后的key，可用.get。 for … else语法合并字典方法一：Python 3.5可以存在重复键值，print({d1 ,d2})。方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。方法三：d1.update()。 从list中删除重复项方法一：把list转成set，去除重复项，再转回list。方法二：调用collections里的OrderedDict，和set差不多。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fpython%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本概念数学定义y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)python函数:是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元完成一定的功能函数的作用结构化编程对代码的最基本的封装, 一般按照功能组织一段代码封装的目的为了复用,减少冗余代码代码更加简洁美观,可读易懂 函数的分类:内建函数,如max()库函数,如math.ceil自定义函数,使用def关键字定义 函数定义def 函数名(参数列表): 函数体(代码块) [return 返回值]函数名就是标识符,命名要求一样语句块必须缩进,约定4个空格函数名就是标识符就是变量python的函数没有return,会返回none定义中的参数列表称为形式参数,只是一种标识符占位置的函数的标识符就是指向函数对象函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参不定义会报nameERREO 传参方式: 位置传参按照参数定义顺序传入实参 关键字使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的参数缺省值缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用 可变位置参数在形参使用* 表示该形参是可变位置参数, 可以接受多个实参它将收集来的实参组织到一个tuple中tuple 有序按位置传参可变关键字参数在形参使用表示该形参是可变关键字参数,可以接受多个关键字参数它将收集来的实参的名称和值,组织到一个dict中可变的关键字传参 kwargs 有可变位置参数和可变关键字参数可变位置参数在形参前使用一个*号可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple可变关键字参数收集形成一个dict混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面要在可变关键字参数之前. keyword-only 参数def fn(args, x, y, **kwargs): print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)fn(3, 5)fn(3, ,5, 7)在python3之后,新增了keyword-only参数keyword-only参数:在形参定义时,在一个星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数keyword-only参数,言下之意就是这个参数必须采取关键字传参可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.星号后所有的普通参数都成了keyword-only参数参数的混合使用参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数代码应该易读易懂, 而不是为难别人请按照书写习惯定义函数参数.参数解构:在给函数提供实参的时候,可以在可迭代对象前使用或者来进行的解构,提取出其中所有元素作为函数的实参.使用*解构成位置参数使用解构成位置 传参提取出来的元素数目要和参数的要求匹配 python函数使用return语句返回”返回值”所有函数都有返回值,如果没有return语句, 隐式调用return Nonereturn语句并不一定是函数的语句块的最后一条语句一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None如果有必要,可以显示调用return None ,可以简写return如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行返回值的作用: 结束函数调用,返回返回值函数不能同时返回多个值. 作用域一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域注意:每一个函数都会开辟一个作用域分类:全局作用域:在整个程序运行环境中都可见全局作用域中的变量称为全局变量局部作用域:在函数 ,类等内部可见局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域函数嵌套在一个函数中定义了另一个函数内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见 global语句使用global关键字的变量,将声明为外部的全局作用域中定义的使用了global 不再是局部变量,它是全局变量global使用原则外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决一句话:不要global,学习他就是深入理解变量作用域 闭包自由变量:未在本地作用域中定义的变量闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript nonlocal语句将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义代码中内层函数引到外部局部作用域中的自由变量,形成闭包 函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期查看default属性,他是个元组 变量名解析原则LEGB***local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡所以一个名词的查找顺序就是LEGB. |]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门笔记]]></title>
    <url>%2Fpython%2Fpython%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机基础程序是一组让计算机识别和执行的指令电子计算机:能够执行程序的机器计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.即8位 2**8=256种状态 内存 掉电易失 与晶振频率有关 临时数据 mermorycpu与内存速度差几个数量级cpu 只认内存 io设备最慢CPU 缓存 cache bus 总线先写源程序 通过编译程序把源程序转换成机器指令的程序python是跑在虚拟机上的 动态语言 做节点 集群优化编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样 机器语言: 是一定位数组成的0 1序列 称为机器指令 机器指令的集合就是机器语言汇编: 是用助记符替代机器指令静态语言: 是声明变量类型,不能再改变,编译需要检查动态语言: 不用声明类型 随时可以赋值为其他类型强类型: 不同类型之间操作 必须强制类型转换为同一类型弱类型: 不同类型之间操作 自动隐式转换 python基础介绍python 的源代码需要被解释器编译成中间代码,在虚拟机上运行*`程序 = 算法 +数据结构`*数据一切程序的核心数据结构是数据在计算机中的类型和组织方式算法是处理数据的方式,算法有优劣之分.python自带了一个IDLE的程序,全称是交互式开发环境.注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要. import math #对角线的长度i = 4w = 10d = math.sqrt(12 + w2)即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的编写尽量用pep8风格 数据类型:python将数据划分为不同的类别,即数据类型.每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.对象的数据类型是对象所属的数据类别.“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号数据类型为bool的对象被称为布尔值.数据类型为nonetype的对象,其值永远我none 用来表示数据缺失. 系统编程python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展此外很多python的系统工具设计都考虑了其可移植性. python解释器python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行. python变量和内存变量在python是表示内存的地址.可以用id()函数获取内存地址 a=5id(a)id(5)会发现这两个地址一样,都输出140720362218448 即python的编程哲学 :一切皆对象,一切皆指针只有指针,要说变量也是指针变量variable 变量是改变的值.变量由一个或多个字符组成的名称构成并使用赋值符 等号赋予了这个名称一个值变量是记住内存中 0 1数字 开始和结束的一串 指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。对于C和C++这样的没有Garbage Collection 的语言来讲我们主要关注两种类型的内存泄漏： 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 python虚拟机原理python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.pycodeobject保存字节码以及进程上下文信息. 过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象.pyc文件字节码在磁盘上的表现形式pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,从技术上将,他才是所谓python解释器的最后一步.代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式. 开发环境 —-pyenvpython多版本管理工具pip包管理器pip install xxxpip listpip search keyword 或者 pypipip help installpip install redis ipythonpip install jupyterpip -Vpip freeze &gt; requirementpip install-r requirement 原码补码反码原码是给人看的,补码是给计算机用的127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。因为它是用补码的编码方式。正数的补码就是它的原码，也就是单纯的二进制数。负数的话，1111 1111这个二进制串，首先它最高位是1，明确他是个负数。那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001也就是1，再加上符号位。最终结果是-1 补码 从小到大 二进制1000 0000—-0000 0000—-0111 1111首尾相连，刚好连个时钟，最大的加一到最小的 字符串使用单双三引号括起来的序列叫字符串 r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理f前缀:3.6版本开始,新增f前缀,格式化字符串转义序列\ \t \r \n \’ \”缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系约定使用4个空格缩进续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\extend 魔术方法add() 标识符一个名字,用来指代一个值只能是字母,下划线和数字只能以字母或下划线开头不能是python的关键字,例如def,class等python是大小写敏感的约定:不允许使用中文不要使用歧义单词,例如class_在python中不要随便使用下划线开头的标识符 运算符 算术运算符 +-*/%**自然除/结果是浮点数,整除// 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 比较运算符 == != &gt; &lt; &gt;= &lt;=返回一个bool值 逻辑运算符 与或非 and or not短路运算符 赋值运算符0 *? =0短路1+? =1短路运算 可以提高效率 可以提前算完了赋值运算 先算右边 和左边相连(映射) a=min(3,5) 运算符优先级 就记住一句话 a+b&gt;c and 折半思想可以优化程序 程序控制顺序结构:按照先后顺序一条条执行分支结构:根据不同情况判断,条件满足执行某条件下的语句循环结构:条件满足就反复执行,不满足就不执行或不再执行 内置类型内置对象使程序更容易编写内置对象使扩展的组件内置对象往往比定制的数据结构更有效率内置对象使语言的标准的一部分python的核心数据类型模式匹配 循环while 语句whlie condition: block当他成立则进入循环while true: pass #死循环 冒号后要形成语句块 死循环都用这个语法例子: flag = 10while flag: print(flag) flag-= 1 在做循环时,一定要分析边界 边界最容易出错range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包 for i in range(10): print(i+1) i= i+10循环 隐含赋值 原来有什么会被冲掉for相当于遍历 不会重复拿 挨个拿如果要倒着遍历 应当在range函数内加步长-1例子:for i in range(10): if i %2 == 0: print(i) for i in range(10): if not i % 2: print(i)not 经常用for i in range (10): if i &amp;1 == 0: print(i) for i in range(10): if i &amp; 1: continue print(i) 写程序要减少循环提高效率 for i in range(10): if i % 2: continue print(i) 如果循环嵌套 continue 和break也只影响语句所在的那一层循环 迭代器和生成器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： from collections import Iterableisinstance([], Iterable)Trueisinstance({}, Iterable)Trueisinstance(‘abc’, Iterable)Trueisinstance((x for x in range(10)), Iterable)Trueisinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： L = [x x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x x for x in range(10))g &lt;generator object at 0x1022ef630&gt; 函数python 内置了很多有用的函数,我们可以直接调用要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 三大器]]></title>
    <url>%2Fpython%2Fpython%20%E4%B8%89%E5%A4%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用. 12345678def 炼丹炉(func): def 变身(*args): 火眼金睛 returrn 孙悟空 return 变身@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)def 孙悟空: return 装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper 单层的只需要function 如:注册器 双层的是返回一个全新的函数 如:打印log 迭代器迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代可迭代对象就是,实现了迭代器协议的对象.协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)使用迭代器协议访问对象.举个例子:for n in [1, 2, 3, 4]: print(n) 但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象with open (‘/etc/passwd’) as f: for line in f: print(line) def gensquares(n): for i in range(n): yield i ** 2for item in genquares(s): print(item) 生成器语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.自动实现迭代器协议:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python pep]]></title>
    <url>%2Fpython%2Fpython%20pep%2F</url>
    <content type="text"><![CDATA[PEPPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0 https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅import thisBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题） PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148 PEP8016Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识框架]]></title>
    <url>%2Flinux%2Flinux%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍操作系统os(operating system),通用目的的软件程序 硬件驱动进程管理内存管理网络管理安全管理文件管理 安装linux linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的manjaro或mint分区和启动:硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tbuefi的GPT分区:逐渐代替MBR标准主分区 一块硬盘最多4个,不能划分更小,最小单位扩展分区:一块硬盘最多一个,不能直接创建文件系统安装过程大同小异 详细步骤需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌./dev/sda 100g/dev/sda1 /boot mountpoint 1g/dev/sda2 / 50g/dev/sda3 /data 20g/dev/sda5 /swap 2g 开发接口标准 ABI:application binary interface ABI描述了程序与os之间的底层接口API:application programming interface开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit 用户和内核空间 username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响内核空间:kernel space linux哲学思想在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的 文件操作文件和目录被组织成单根倒置树结构文件系统从根目录下开始,用”/“表示proc虚拟的,在硬盘上不存在文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)以.开头的文件为隐藏文件元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.数据:data(内容在硬盘上)文件系统分成结构:LSB文件名最长255个字节,文件系统不一样大小不一样包括路径在内文件名称最长4095个字节蓝色—目录 绿色—可执行文件 红色—压缩文件浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递管道文件 p开头(pipe)单工传输 文件系统结构元素/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64：专用于x86_64系统上的辅助共享库文件存放位置/etc：配置文件目录/home/USERNAME：普通用户家目录/root：管理员的家目录/media：便携式移动设备挂载点/mnt：临时文件系统挂载点/dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问/opt：第三方应用程序的安装位置/srv：系统上运行的服务用到的数据/tmp：临时文件存储位置/proc: 用于输出内核与进程信息相关的虚拟文件系统/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文/usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序sbin: lib：32位使用 lib64：只存在64位系统include: C程序的头文件(header files)share：结构化独立的数据，例如doc, man等local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文 /var: variable data files cache: 应用程序缓存数据目录lib: 应用程序状态信息数据local：专用于为/usr/local下的应用程序存储可变数据lock: 锁文件 log: 日志目录及文件opt: 专用于为/opt下的应用程序存储可变数据run: 运行中的进程相关数据,通常用于存储进程pid文件spool: 应用程序数据池tmp: 保存系统两次重启之间产生的临时数据 Linux下的文件类型-：普通文件d: 目录文件b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)c: 字符设备(设备主要以字符为单位,键盘为主)l: 符号链接文件p: 管道文件pipes: 套接字文件socket 显示当前工作目录每个shell和系统进程都有一个当前的工作目录CWD:current work directory显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 更改目录cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -选项：-P相关的环境变量： PWD：当前目录路径 OLDPWD：上一次目录路径 列出目录内容列出当前目录的内容或指定目录用法：ls [options] [ files_or_dirs ]示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R 目录递归通过 ls -ld 目录和符号链接信息 ls -1 文件分行显示 ls –S 按从大到小排序 ls –t 按mtime排序 ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示 ls –X 按文件后缀排序 [root@centos7 sysconfig]# ll /etc/motd-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd[root@centos7 sysconfig]# ll ../motd-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd-a 全部-r 递归ll 是别名 (ls -l) 查看文件状态stat文件：metadata, data三个时间戳: access time：访问时间，atime，读取文件内容modify time: 修改时间,mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变data 时间不会一直更新通配符* 任意字符二进制查看hexdump -C 创建和查看文件touch 命令是个外部命令[]表示其中一个字母[^ ]表示除去其中字符的任意字符两个大于号比 touch安全 文件统配符man 7 glob 复制和转移删除文件cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失原始命令前加\拷贝文件夹 -r(递归)cp 有可能丢失数据不能用rmdir删除 data是个挂载点cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中 基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中cp SRC… DEST SRC…：多个文件DEST必须存在，且为目录，其它情形均会出错；cp SRC DESTSRC是目录：此时使用选项：-r如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；如果DEST存在：如果DEST是文件：报错如果DEST是目录：inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 inode 唯一标识在元数据里删除其实删的元数据.删文件比建文件快多了 软和硬链接硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区语法: ln filename [linkname ]软连接一个符号文件链接指向一个文件ls -s显示链接的名称和应用的文件一个符号链接的内容是他引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数语法:ln -s 文件 链接名 i/0 重定向至文件程序:指令+数据input 和output打开的文件都有一个fd:file descrptor(文件描述符)linux 给程序提供三种i/o设备标准输入(STDIN)-0 默认接受来自键盘的输入标准输出(STDOUT) -1默认输出到终端窗口标准错误(STDERR) -2 默认输出到窗口i/o重定向:改变默认位置语法:命令 操作符号 文件名操作符&gt;把STDOUT重定向到文件2&gt; 把STDERR重定向到文件$&gt; 把所有输出重定向到文件tr 转换和删除字符 管道管道用来连接命令命令1|命令2|命令3将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDINless 一页一页地查看输入重定向到多个目标(tee)把命令1的STDOUT保存在文件中,作为命令2的输入-a追加使用:保存不同阶段的输入复杂管道的故障排除同时查看和记录输出 用户组权限用户user令牌token,identitylinux用户:username/UID管理员:root,0普通用户:1-65535系统用户:1-499,1-999对守护进程获取资源进行权限进行分配登录用户:500+,1000交互式登录nologin 是软件启动没有用户登录 组grouplinux:Groupname/GID管理员:系统 :1-499,1-999普通组:500+,1000+安全上下文:进行中的程序:程序(process)以进程发起者的身份运行:root:/bin/catmage:/bin/cat组的类别用户的主要组:用户必须属于一个且只有一个主组组名同用户名,且包含一个用户,私有组用户和组的配置文件/etc/passwd:用户及其属性信息/etc/group:组及其属性信息/etc/shadow:用户密码及其相关属性/etc/gshadow:组密码及其相关属性passwd文件格式login name:登录用名passwd:密码UID:用户身份编号GID:登录默认所在组编号GECOS:用户全名或注释home diretory:用户主目录shell:用户默认使用shellshadow文件格式useradd usermod userdel组账号维护命令:groupaddgroupmod groupdel 用户创建:useradduseradd [options]LOGIN-u UID-o 配合-u选项,不检查UID的唯一性-g GID:指明用户所属基本组,可谓组名,也可以GID-c “COMMENT”:用户的注释信息默认设置:/etc/default/useradd文件中删除用户:userdel -r删除用户目录 查看用户相关的ID信息id [OPTIONS]…[USER]-u :显示UID-g :显示GID-G :显示用户所属的组的ID-n :显示名称,需配合ugG使用 切换用户或以其他用户身份执行命令su[options] [-] [user[args…]]切换用户的方式ssh root@ipcurl wwservice network restat 设置密码passwd常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 创建组groupadd[option]…group_name-g GID:指明GID号:-r:创建系统组修改和删除组:组属性修改:groupmod组删除:groupdel组密码:gpasswdnewgrp命令:临时切换主组chown设置文件的所有者chgrp设置文件的属组信息修改文件的属主和属组chown修改文件的属组:chgrp 文件权限文件的权限主要针对三类对象进行定义owner: 属主, ugroup: 属组, gother: 其他, o每个文件针对每类访问者都定义了三种权限r: Readablew: Writablex: eXcutable 修改文件权限chmod [OPTION]… OCTAL-MODE FILE… -R: 递归修改权限chmod [OPTION]… MODE[,MODE]… FILE… MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]… –reference=RFILE FILE…参考RFILE文件的权限，将FILE的修改为同RFILE数字权限法:chmod数字 filerwx r-x r– file其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 文本工具基础文件内容:less和cat文件截取:head和tail按列抽取:cut按关键字抽取:grep文件查看:cat tac rev分页查看:more一页一页的查看:lessless 命令是man命令使用的分页器 显示文本前后或后行内容head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行tail[option]…[FILE]看文本尾tail-f 跟踪看日志cut命令取字段past 横着合并文件wc 收集文本 文本排序sort把整理过的文本显示在STDOUT,不改变原始文件sort[opiton]file(s)uniq:从输入中删除前后相接的重复的行,处理日志liunx:文本处理三剑客grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红sed:stream editor, 文本编辑工具awk:liunx上的实现gawk,文本报告生成器grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行 正则表达式匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数位置锚定:定位正则字符特殊 元字符.单个任意字符[abc]表示其中一个字符[^abc]除去abc任意字母[:lower:]小写[:upper:]大写分组方式abc{3}\搜索替代工具grep过滤特定行,sed也可以并且编辑修改文件 vim编辑器vi:visual interface 文本编辑器文本:asscii ,unicode文本编辑种类:行编辑器:sed全屏编辑器:nano,vivim -viimproved其他编辑器gedit 一个简单的图形编辑器gvim 一个vim编辑器的图形版本vi一开始是vim的别名vim有三种模式:normal(普通) insert(插入) extendcommand(命令)normal :默认模式,移动光标,剪切/粘贴文本insert :修改文本extend command:保存,退出 搜索替代/ :从当前光标所在处向文件尾部查找? :从当前光标所在处向文件首部查找n :与命令同方向N :与命令反方向处理文本的工具sedstream editor 行编辑器sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.vim不适合修改大批量文件,sed可以sed 配合管道可以使用awk 语言sed ‘’ passwd‘地址命令’地址不写代表全部文件 命令不写代表输出 软件管理包管理器rpm 打包文件 不需要考虑部署 安装路径都定义好二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件程序包管理器：debian：deb文件, dpkg包管理器redhat: rpm文件, rpm包管理器rpm: Redhat Package Manager RPM Package Manager源代码：name-VERSION.tar.gz|bz2|xz VERSION: major.minor.releaserpm包命名方式:name-VERSION-release.arch.rpm例：bash-4.2.46-19.el7.x86_64.rpm VERSION: major.minor.release release：release.OS常见的arch： x86: i386, i486, i586, i686 x86_64: x64, x86_64, amd64 powerpc: ppc 跟平台无关：noarch 包：分类和拆包Application-VERSION-ARCH.rpm: 主包Application-devel-VERSION-ARCH.rpm 开发子包 Application-utils-VERSION-ARHC.rpm 其它子包 Application-libs-VERSION-ARHC.rpm 其它子包包之间：可能存在依赖关系，甚至循环依赖解决依赖包管理工具:yum：rpm包管理器的前端工具 apt-get：deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具 查看二进制程序所依赖的库文件 ldd /PATH/TO/BINARY_FILE管理及查看本机装载的库文件 ldconfig 加载库文件 /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf 缓存文件：/etc/ld.so.cache 程序包管理器功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.包文件组成 (每个包独有)RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.安装或卸载时运行的脚本数据库(公共)：/var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息管理程序包的方式:使用包管理器：rpm 使用前端工具：yum, dnf获取程序包的途径：(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com(2) 项目官方站点程序包的来源(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/(4) 自己制作 注意：第三方包建议要检查其合法性 来源合法性,程序包的完整性 rpm包管理CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护 安装：rpm {-i|–install} [install-options] PACKAGE_FILE… -v: verbose -h: 以#显示程序包管理执行进度 rpm -ivh PACKAGE_FILE … rpm包安装[install-options]–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs | replacefiles–nosignature: 不检查来源合法性–nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre: 安装前脚本；–nopre %post: 安装后脚本；–nopost %preun: 卸载前脚本；–nopreun %postun: 卸载后脚本； –nopostun rpm包升级升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…rpm {-F|–freshen} [install-options] PACKAGE_FILE…upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装”freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE … rpm -Fvh PACKAGE_FILE …–oldpackage：降级–force: 强制安装 升级注意项注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留 包查询rpm {-q|–query} [select-options] [query-options] [select-options]-a: 所有包-f: 查看指定的文件由哪个程序包安装生成-p rpmfile：针对尚未安装的程序包文件做查询操作–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 常用查询用法： -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, … -qa包卸载： rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME … 包校验rpm {-V|–verify} [select-options] [verify-options] S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ包校验包来源合法性验正及完整性验正完整性验正：SHA256来源合法性验正：RSA 公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人 rpm数据库数据库重建： /var/lib/rpm rpm {–initdb|–rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之 否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 yumCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下） 文件服务器: http:// https:// ftp:// file:// yum配置文件yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义： [repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000 yum仓库yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号 $arch: 平台，i386,i486,i586,x86_64等 $basearch：基础平台；i386, x86_64 $YUM0-$YUM9:自定义变量 实例: http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64 http://server/centos/6/i384yum源阿里云repo文件:http://mirrors.aliyun.com/repo/CentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/EPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 yum命令yum命令的用法： yum [options] [command] [package …]显示仓库列表： yum repolist [all|enabled|disabled]显示程序包： yum list yum list [all | glob_exp1] [glob_exp2] […] yum list {available|installed|updates} [glob_exp1] […] 安装程序包： yum install package1 [package2] […] yum reinstall package1 [package2] […] (重新安装)yum命令升级程序包： yum update [package1] [package2] […] yum downgrade package1 [package2] […] (降级)检查可用升级： yum check-update卸载程序包： yum remove | erase package1 [package2] […]yum命令查看程序包information： yum info […]查看指定的特性(可以是某文件)是由哪个程序包所提供： yum provides | whatprovides feature1 [feature2] […]清理本地缓存： 清除/var/cache/yum/$basearch/$releasever缓存 yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]构建缓存： yum makecacheyum命令搜索：yum search string1 [string2] […] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilities： yum deplist package1 [package2] […]查看yum事务历史： yum history [info|list|packages-list|packages-info| summary|addon-info|redo|undo| rollback|new|sync|stats] yum history yum history info 6 yum history undo 6日志 ：/var/log/yum.log安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] …yum localupdate rpmfile1 [rpmfile2] […] (用update替代)包组管理的相关命令： yum groupinstall group1 [group2] […] groupupdate group1 [group2] […] yum grouplist [hidden] [groupwildcard] […] yum groupremove group1 [group2] […] yum groupinfo group1 […]yum命令yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件系统光盘yum仓库系统安装光盘作为本地yum仓库：(1) 挂载光盘至某目录，例如/mnt/cdrom mount /dev/cdrom /mnt/cdrom(2) 创建配置文件 [CentOS7] name= baseurl= gpgcheck= enabled= 创建yum仓库： createrepo [options] 程序包编译程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 C、C++：make 项目管理器 configure脚本 –&gt; Makefile.in –&gt; Makefile java: maven C语言源代码编译安装三步骤:1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make 根据Makefile文件，构建应用程序3、make install 复制文件到相应路径开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in注意：安装前查看INSTALL，README 开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software Foundation) mariadb.org 代码托管:SourceForge.net Github.com code.google.comc/c++编译器: gcc (GNU C Complier) 编译C源代码： 准备：提供开发工具及开发环境 开发工具：make, gcc等 开发环境：开发库，头文件 glibc：标准库 实现：通过“包组”提供开发组件 Development Tools Server Platform Development 第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项 选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译 Optional Features: 可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包 –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION 第二步：make 第三步：make install 安装后的配置：(1) 二进制程序目录导入至PATH环境变量中 编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH(2) 导入帮助手册 编辑/etc/man.config|man_db.conf文件 添加一个MANPATH shell编程基础程序：指令+数据程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 shell程序：提供了编程能力，解释执行 编程基本概念编程逻辑处理方式：顺序执行循环执行选择执行 shell编程：过程式、解释执行编程语言的基本结构：各种系统命令的组合数据存储：变量、数组表达式: a + b语句:ifshell脚本基础shell脚本:包含一些命令或声明，并符合一定格式的文本文件格式要求:首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perlshell脚本的用途有：自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 添加注释注释以#开头第二步：运行脚本给予执行权限，在命令行上指定脚本的绝对或相对路径直接运行解释器，将脚本作为解释器程序的参数运行 脚本规范脚本代码开头约定1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 脚本调试检测脚本中的语法错误bash -n /path/to/some_script调试执行bash -x /path/to/some_script 变量变量：命名的内存空间数据存储方式：字符：数值：整型，浮点型变量：变量类型作用：1、数据存储格式2、参与的运算3、表示的数据范围类型：字符数值：整型、浮点型变量命名法则：1、不能使程序中的保留字：例如 if, for2、只能使用数字、字母及下划线，且不能以数字开头3、见名知义4、统一命名规则：驼峰命名法，建议大写 bash中变量的种类根据变量的生效范围等标准划分下面变量类型：局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程， 包括当前shell的子shell进程均无效环境（全局）变量：生效范围为当前shell进程及其子进程 本地变量：生效范围为当前shell进程中某代码片断，通常指函数 位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传 递给它的参数特殊变量：$?, $0, $*, $@, $#,$$ 局部变量变量赋值：name=‘value’可以使用引用value:(1) 可以是直接字串; name=“root”(2) 变量引用：name=”$USER”(3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name“”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set删除变量：unset name 环境变量bash内建的环境变量：PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE— 只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量： readonly name declare -r name查看只读变量： readonly –p位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置$0: 命令本身$: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/nullecho $?退出状态码bash自定义退出状态码exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 运算bash中的算术运算:help let+, -, , /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如bash有内建的随机数生成器：RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数赋值 增强型赋值：+=, -=, *=, /=, %=let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1 let var++ let var-=1 let var-- 逻辑运算true, false1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! 0 = 1 短路运算 短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算 短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算 异或：^异或的两个值,相同为假，不同为真 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1 测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符bash的数值测试-v VAR变量VAR是否设置 数值测试：-gt 是否大于-ge 是否大于等于-eq 是否等于-ne 是否不等于-lt 是否小于-le 是否小于等于bash的字符串测试 字符串测试: == 是否等于ascii码是否大于ascii码&lt; 是否小于!= 是否不等于=~ 左侧字符串是否能够被右侧的PATTERN所匹配注意: 此表达式一般用于[[ ]]中；扩展的正则表达式-z “STRING“ 字符串是否为空，空为真，不空为假-n “STRING“ 字符串是否不空，不空为真，空为假注意：用于字符串比较时的用到的操作数都应该使用引号Bash的文件测试 存在性测试 -a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件Bash的文件权限测试 文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限Bash的文件属性测试 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组Bash的文件属性测试 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 使用read命令来接受输入使用read来把输入值分配给一个或多个shell变量-p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE 流程控制过程式编程语言： 顺序执行 选择执行 循环执行条件选择if语句 选择执行: 注意：if语句可嵌套单分支 if 判断条件;then 条件为真的分支代码 fi双分支 if 判断条件; then 条件为真的分支代码 else条件为假的分支代码fi 多分支 if 判断条件1; then 条件为真的分支代码 elif 判断条件2; then 条件为真的分支代码 elif 判断条件3; then 条件为真的分支代码 else 以上条件都为假的分支代码 fi 逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断：case语句 case 变量引用 in PAT1) 分支1 ;; PAT2) 分支2 ;; ... *) 默认分支 ;; esac case支持glob风格的通配符： *: 任意长度任意字符 ?: 任意单个字符 []：指定范围内的任意单个字符 a|b: a或b 循环 循环执行将某代码段重复运行多次重复运行多少次：循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, untilfor循环for 变量名 in 列表;do循环体done执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 for循环列表生成方式：(1) 直接给出列表(2) 整数列表：(a) {start..end}(b) $(seq [start [step]] end)(3) 返回列表的命令$(COMMAND)(4) 使用glob，如：.sh(5) 变量引用；$@, $while循环while CONDITION; do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为falseuntil循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true循环控制语句continue用于循环体中ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thencontinuefiCMDn…done循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thenbreakfiCMDn…done特殊用法双小括号方法，即((…))格式，也可以用于算术运算双小括号方法也可以使bash Shell实现C语言风格的变量操作I=10((I++))for循环的特殊格式：for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))do 循环体done控制变量初始化：仅在运行到循环代码段时执行一次控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于：Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改定义函数函数由两部分组成：函数名和函数体help function语法一：f_name （）{…函数体…} 语法二：function f_name {…函数体…} 语法三：function f_name （） {…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止函数返回值函数有两种返回值：函数的执行结果返回值：(1) 使用echo等命令进行输出(2) 函数体中调用命令的输出结果函数的退出状态码：(1) 默认取决于函数中执行的最后一条命令的退出状态码(2) 自定义退出状态码，其格式为：return 从函数中返回，用最后状态命令决定返回值return 0 无错误返回。return 1-255 有错误返回交互式环境下定义和使用函数 示例:dir() {ls -l}定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir在脚本中定义及使用函数函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用调用函数仅使用其函数名即可示例：cat func1!/bin/bashfunc1hello(){echo “Hello there today’s date is date +%F“}echo “now going to the function hello”helloecho “back from the function”使用函数文件可以将经常使用的函数存入函数文件，然后将函数文件载入shell文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例： cat functions.main #!/bin/bash #functions.mainfindit(){if [ $# -lt 1 ] ; thenecho “Usage:findit file”return 1fifind / -name $1 –print} 载入函数函数文件已创建好后，要将它载入shell定位函数文件并载入shell的格式：. filename 或 source filename注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径 检查载入函数使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 示例：setfindit=( ){if [ $# -lt 1 ]; thenecho “usage :findit file”;return 1fifind / -name $1 -print} 执行shell函数要执行函数，简单地键入函数名即可示例：findit groups/usr/bin/groups/usr/local/backups/groups.bak 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量在函数中定义局部变量的方法local NAME=VALUE函数递归示例 函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)!函数递归示例: 示例：fact.sh fact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi } fact $1 fork炸弹 fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现:(){ :|:&amp; };:bomb() { bomb | bomb &amp; }; bomb 实际上: 代表bomb脚本实现 cat Bomb.sh./$0|./$0&amp;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(3)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(3)%2F</url>
    <content type="text"><![CDATA[磁盘管理cdLinux cd命令用于切换当前工作目录至 dirName(目录参数)。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。 另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。 语法cd [dirName]dirName：要切换的目标目录。 dfLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 语法df [选项]… [FILE]…文件-a, –all 包含所有的具有 0 Blocks 的文件系统文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, –inodes 列出 inode 资讯，不列出已使用 block文件-k, –kilobytes 就像是 –block-size=1024文件-l, –local 限制列出的文件结构文件-m, –megabytes 就像 –block-size=1048576文件–no-sync 取得资讯前不 sync (预设值)文件-P, –portability 使用 POSIX 输出格式文件–sync 在取得资讯前 sync文件-t, –type=TYPE 限制列出文件系统的 TYPE文件-T, –print-type 显示文件系统的形式文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件–help 显示这个帮手并且离开文件–version 输出版本资讯并且离开 duLinux du命令用于显示目录或文件的大小。 du会显示指定的目录或文件所占用的磁盘空间。 语法du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]参数说明： -a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或–dereference-args 显示指定符号连接的源文件大小。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或–kilobytes 以1024 bytes为单位。-l或–count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或–megabytes 以1MB为单位。-s或–summarize 仅显示总计。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。–help 显示帮助。–version 显示版本信息。 mkdirLinux mkdir命令用于建立名称为 dirName 之子目录。 语法mkdir [-p] dirName参数说明： -p 确保目录名称存在，不存在的就建一个。 pwdLinux pwd命令用于显示工作目录。 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。 语法pwd [–help][–version]参数说明: –help 在线帮助。–version 显示版本信息。 mountLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 语法mount [-hV]mount -a [-fFnrsvw] [-t vfstype]mount [-fnrsvw] [-o options [,…]] device | dirmount [-fnrsvw] [-t vfstype] [-o options] device dir参数说明： -V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 lsLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法 ls [-alrtAFR] [name…]参数 : -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出 系统管理useraddLinux useradd命令用于建立用户帐号。 useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 语法useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ]参数说明： -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。-d&lt;登入目录&gt; 指定用户登入时的启始目录。-D 变更预设值．-e&lt;有效期限&gt; 指定帐号的有效期限。-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。-g&lt;群组&gt; 指定用户所属的群组。-G&lt;群组&gt; 指定用户所属的附加群组。-m 自动建立用户的登入目录。-M 不要自动建立用户的登入目录。-n 取消建立以用户名称为名的群组．-r 建立系统帐号。-s 指定用户登入后所使用的shell。-u 指定用户ID dataLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 时间方面： % : 印出 %%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面： %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。 使用权限：所有使用者。 当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。 当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。 语法date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]参数说明： -d datestr : 显示 datestr 中所设定的时间 (非系统时间)–help : 显示辅助讯息-s datestr : 将系统时间设为 datestr 中所设定的时间-u : 显示目前的格林威治时间–version : 显示版本编号 psLinux ps命令用于显示当前进程 (process) 的状态。 语法ps [options] [–help]参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义-A 列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程au(x) 输出格式 :USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDUSER: 行程拥有者PID: pid%CPU: 占用的 CPU 使用率%MEM: 占用的记忆体使用率VSZ: 占用的虚拟记忆体大小RSS: 占用的记忆体大小TTY: 终端的次要装置号码 (minor device number of tty)STAT: 该行程的状态:D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的行程N: 低优先序的行程L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)START: 行程开始时间TIME: 执行的时间COMMAND:所执行的指令 topLinux top命令用于实时显示 process 的动态。 使用权限：所有使用者。 语法top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]参数说明： d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 sq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来s : 安全模式，将交谈式指令取消, 避免潜在的危机i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程n : 更新的次数，完成后将会退出 topb : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 pstreeLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。 使用权限：所有使用者。 语法pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]或 pstree -V参数说明： -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） rebootLinux reboot命令用于用来重新启动计算机。 若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代 语法reboot [-n] [-w] [-d] [-f] [-i]参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 screenLinux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。 语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明： -A 将所有的视窗都调整为目前终端机的大小。-d&lt;作业名称&gt; 将指定的screen作业离线。-h&lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r&lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S&lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 shutdownLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 使用权限：系统管理者。 语法shutdown [-t seconds] [-rkhncfF] time [message]参数说明： -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。 swatchLinux swatch命令用于系统监控程序。 swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。 语法swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]参数说明： -A&lt;分隔字符&gt; 预设配置文件中，动作的分隔字符，预设为逗号。-c&lt;设置文件&gt; 指定配置文件，而不使用预设的配置文件。-f&lt;记录文件&gt; 检查指定的记录文件，检查完毕后不会继续监控该记录文件。-I&lt;分隔字符&gt; 指定输入记录的分隔字符，预设为换行字符。-P&lt;分隔字符&gt; 指定配置文件中，事件的分隔字符，预设为逗号。-r&lt;时间&gt; 在指定的时间重新启动。-t&lt;记录文件&gt; 检查指定的记录文件，并且会监控加入记录文件中的后继记录。 idLinux id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 语法id [-gGnru][–help][–version][用户名称]参数说明： -g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法free [-bkmotV][-s &lt;间隔秒数&gt;]参数说明： -b 以Byte为单位显示内存使用情况。-k 以KB为单位显示内存使用情况。-m 以MB为单位显示内存使用情况。-o 不显示缓冲区调节列。-s&lt;间隔秒数&gt; 持续观察内存使用状况。-t 显示内存总和列。-V 显示版本信息。 系统设置setupLinux setup命令设置公用程序，是一个启动图形设置系统的命令。 setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。 语法setupsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项： １.登陆认证方式２.键盘组态设置３.鼠标组态设置４.开机时所要启动的系统服务５.声卡组态设置６.时区设置７.X Windows组态设置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(2)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(2)%2F</url>
    <content type="text"><![CDATA[文档编辑grepLinux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。 语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]参数： -a 或 –text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 –count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 –fixed-regexp : 将样式视为固定字符串的列表。-G 或 –basic-regexp : 将样式视为普通的表示法来使用。-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 –ignore-case : 忽略字符大小写的差别。-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 –only-matching : 只显示匹配PATTERN 部分。-q 或 –quiet或–silent : 不显示任何信息。-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。-s 或 –no-messages : 不显示错误信息。-v 或 –revert-match : 显示不包含匹配文本的所有行。-V 或 –version : 显示版本信息。-w 或 –word-regexp : 只显示全字符合的列。-x –line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定”-i”参数相同。 sortLinux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 语法sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]参数说明： -b 忽略每行前面开始出的空格字符。-c 检查文件是否已经按照顺序排序。-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-f 排序时，将小写字母视为大写字母。-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。-m 将几个排序好的文件进行合并。-M 将前面3个字母依照月份的缩写进行排序。-n 依照数值的大小排序。-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r 以相反的顺序来排序。-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。–help 显示帮助。–version 显示版本信息。 trLinux tr 命令用于转换或删除文件中的字符。 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 语法tr [-cdst][–help][–version][第一字符集][第二字符集]tr [OPTION]…SET1[SET2]参数说明： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息字符集合的范围： \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。[CHAR] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止[CHARREPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)[:alnum:] ：所有字母字符与数字[:alpha:] ：所有字母字符[:blank:] ：所有水平空格[:cntrl:] ：所有控制字符[:digit:] ：所有数字[:graph:] ：所有可打印的字符(不包含空格符)[:lower:] ：所有小写字母[:print:] ：所有可打印的字符(包含空格符)[:punct:] ：所有标点字符[:space:] ：所有水平与垂直空格符[:upper:] ：所有大写字母[:xdigit:] ：所有 16 进位制的数字[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符) uniqLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 语法uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]参数： -c或–count 在每列旁边显示该行重复出现的次数。-d或–repeated 仅显示重复出现的行列。-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。-u或–unique 仅显示出一次的行列。-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。–help 显示帮助。–version 显示版本信息。[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 wcLinux wc命令用于计算字数。 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…]参数： -c或–bytes或–chars 只显示Bytes数。-l或–lines 只显示行数。-w或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 letlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 语法格式let arg [arg …]参数说明：arg：要执行的表达式 sedLinux sed命令是利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法sed [-hnV][-e][-f&lt;script文件&gt;][文本文件]参数说明： -e或–expression= 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或–help 显示帮助。-n或–quiet或–silent 仅显示script处理后的结果。-V或–version 显示版本信息。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(1)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[1 文档管理cat chgrp chmod chown file find cut in less more mv tee touch which cp read2 文档编辑:grep sed tr sort uniq wc let3 磁盘管理:cd df du mkdir pwd mount stat tree ls4 网络通讯:telnet httpd ifconfig netatat ping tty write5 系统管理:useradd data adduser exit kill ps pstree top reboot sudo uname who whoami whois w id free6 系统设置:reset clear alias enable rpm set passwd time setup7 备份压缩:zip tar8 其他命令: bc tail 文档命令cat全称: concatenate files and print on the standard outputcat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0注： OUTFILE 指输出的镜像文件名. IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用制作开机磁片 chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法:chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法chmod [-cfvR] [–help] [–version] mode file…参数说明mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本实例将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r *此外chmod也可以用数字来表示权限如 : chmod 777 file语法为： chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。chmod a=rwx file和 chmod 777 file效果相同 chmod ug=rwx,o=x file和 chmod 771 file效果相同 若用chmod 4755 filename可使此程序具有root的权限 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。使用权限 : root语法chown [-cfhvR] [–help] [–version] user[:group] file…参数 :user : 新的文件拥有者的使用者 IDgroup : 新的文件拥有者的使用者组(group)-c : 显示更改的部分的信息-f : 忽略错误信息-h :修复符号链接-v : 显示详细的处理信息-R : 处理指定目录以及其子目录下的所有文件–help : 显示辅助说明–version : 显示版本 fileLinux file命令用于辨识文件类型。 通过file指令，我们得以辨识该文件的类型。 语法file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]参数： -b 列出辨识结果时，不显示文件名称。-c 详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 指定魔法数字文件。-v 显示版本信息。-z 尝试去解读压缩文件的内容。[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 findLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法find path -option [ -print ] [ -exec -ok command ] {} \;参数说明 : find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 你可以使用 ( ) 将运算式分隔，并使用下列运算。 exp1 -and exp2 ! expr -not expr exp1 -or exp2 exp1, exp2 cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 语法cut [-bn] [file]cut [-c] [file]cut [-df] [file]使用说明: cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 参数: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符。-f ：与-d一起使用，指定显示哪个区域。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 lnLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 语法 ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] [–help] [–version] [–] 命令功能 :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数必要参数： -b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数： -S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”–help 显示帮助信息–version 显示版本信息 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 语法less [参数] 文件参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 moreLinux more命令Linux 命令大全 Linux 命令大全 Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 语法more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料-s 当遇到有连续两行以上的空白行，就代换为一行的空白行-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示+num 从第 num 行开始显示fileNames 欲显示内容的文档，可为复数个数 mvLinux mv命令Linux 命令大全 Linux 命令大全 Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 语法mv [options] source destmv [options] source… directory参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果 mv 文件名 文件名 将源文件名改为目标文件名mv 文件名 目录名 将文件移动到目标目录mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名mv 目录名 文件名 出错 rmrm命令用于删除一个文件或者目录。 语法rm [options] name…参数： -i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 teeLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。 tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 语法tee [-ai][–help][–version][文件…]参数： -a或–append 附加到既有文件的后面，而非覆盖它．-i或–ignore-interrupts 忽略中断信号。–help 在线帮助。–version 显示版本信息。 touchLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录。 语法touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]参数说明：a 改变档案的读取时间记录。m 改变档案的修改时间记录。c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。f 不使用，是为了与其他 unix 系统的相容性而保留。r 使用参考档的时间记录，与 –file 的效果一样。d 设定时间与日期，可以使用各种不同的格式。t 设定档案的时间记录，格式与 date 指令相同。–no-create 不会建立新档案。–help 列出指令格式。–version 列出版本讯息。 whichLinux which命令用于查找文件。 which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法which [文件…]参数： -n&lt;文件名长度&gt; 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p&lt;文件名长度&gt; 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 cpLinux cp命令主要用于复制文件或目录。 语法cp [options] source dest或 cp [options] source… directory参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。 readLinux read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]参数说明: -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以使用命令补全功能。-n 后跟一个数字，定义输入文本的长度，很实用。-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本入门算法有三个经典算法:冒泡,选择和插入算法 1.冒泡排序 冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现： 123456789101112# -*- coding:utf-8 -*-def bubble_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(1,length-index): if raw_list[i-1]&gt;raw_list[i]: raw_list[i],raw_list[i-1]=raw_list[i-1],raw_list[i] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = bubble_sort(data_test)print(sorted_list) 2.选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 12345678910111213# -*- coding:utf-8 -*-def select_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(index,length): if raw_list[index]&gt;raw_list[i]: raw_list[index],raw_list[i]=raw_list[i],raw_list[index] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = select_sort(data_test)print(sorted_list) 3.插入排序 每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 代码实现： 1234567891011121314151617# -*- coding:utf-8 -*-def insert_sort(raw_list): length = len(raw_list) for i in range(1, length): temp = raw_list[i] #j从i-1 到 0倒序 for j in range(i-1,-1,-1): if(raw_list[j]&lt;=temp): break if(raw_list[j]&gt;temp): raw_list[j],raw_list[j+1] = temp,raw_list[j] j -= 1 return raw_list#测试data_test = [10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = insert_sort(data_test)print(sorted_list) 4.希尔排序 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 即所有记录放在同一组中进行直接插入排序为止。 123456789101112131415161718# -*- coding:utf-8 -*-def shell_sort(list): length=len(list) dist=length/2 while dist&gt;0: for i in range(dist,length): temp=list[i] j=i while j&gt;=dist and temp&lt;list[j-dist]: list[j]=list[j-dist] j-=dist list[j]=temp dist/=2 return list#测试list=[10,23,1,53,654,54,16,646,65,3155,546,31]print shell_sort(list) 5.归并排序 归并排序，就是把两个已经排列好的序列合并为一个序列。 代码实现： 1234567891011121314151617181920# -*- coding:utf-8 -*-#算法逻辑比较简单，以第一个list为基准，第二个向第一个插空def merge_sort(list1,list2): length_list1=len(list1) length_list2=len(list2) list3=[] j=0 for i in range(length_list1): while list2[j]&lt;list1[i] and j&lt;length_list2: list3.append(list2[j]) j=j+1 list3.append(list1[i]) if j&lt;(length_list2-1): for k in range(j,length_list2): list3.append(list2[k]) return list3#测试list1=[1,3,5,10]list2=[2,4,6,8,9,11,12,13,14]print merge_sort(list1,list2) 6.快速排序 123456789101112131415161718192021222324随意选择一个数字作为基准，比基准数字大的在右，比基准数字小的在左。# -*- coding:utf-8 -*-def kp(arr,i,j):#快排总函数 #制定从哪开始快排 if i&lt;j: base=kpgc(arr,i,j) kp(arr,i,base) kp(arr,base+1,j)def kpgc(arr,i,j):#快排排序过程 base=arr[i] while i&lt;j: while i&lt;j and arr[j]&gt;=base: j-=1 while i&lt;j and arr[j]&lt;base: arr[i]=arr[j] i+=1 arr[j]=arr[i] arr[i]=base return iww=[3,2,4,1,59,23,13,1,3]print wwkp(ww,0,len(ww)-1)print ww 7.堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤： 创建最大堆:将堆所有数据重新排序，使其成为最大堆 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算 代码实现： 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-def head_sort(list): length_list = len(list) first=int(length_list/2-1) for start in range(first,-1,-1): max_heapify(list,start,length_list-1) for end in range(length_list-1,0,-1): list[end],list[0]=list[0],list[end] max_heapify(list,0,end-1) return listdef max_heapify(ary,start,end): root = start while True: child = root*2 + 1 if child &gt; end: break if child + 1 &lt;= end and ary[child]&lt;ary[child+1]: child = child + 1 if ary[root]&lt;ary[child]: ary[root],ary[child]=ary[child],ary[root] root=child else: break#测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print head_sort(list) 8.计数排序 12345678910111213141516171819202122# -*- coding:utf-8 -*-def count_sort(list): max=min=0 for i in list: if i &lt; min: min = i if i &gt; max: max = i count = [0] * (max - min +1) for j in range(max-min+1): count[j]=0 for index in list: count[index-min]+=1 index=0 for a in range(max-min+1): for c in range(count[a]): list[index]=a+min index+=1 return list #测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print count_sort(list)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@TOC 什么是网络 网络是由节点和连线构成的图，表示诸多对象及其关系什么是计算机网络 计算机网络指的是将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路物理连接（包括有线、无线连接），并在网络操作系统、网络管理软件和网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统带宽 在数字设备中，指的是单位时间数据的传输量 网络传输习惯上使用比特率，即bps每秒传输的二进制位数 拓扑总线型 所有设备都连接到公共总线上，结点间使用广播通信方式。一个结点发出的信息，总线上所有其他结点都可以接收到。一段时间只允许一个结点独占总线 常见使用同轴电缆连接，总线两端需要终结器优点 结构简单、易于实现 易于扩充，增加或者移除结点比较灵活 可靠性较高，个别结点发生故障时，不影响网络中其他结点的正常工作 缺点 网络传输能力低，安全性低，总线发生故障时，会导致全网瘫痪 所有数据都需要经过总线传输，总线是整个网络的瓶颈。结点数量的增多会影响网络性能环形结构 环形结构是将联网的计算机由通信线路连接成一个闭合的环，在环形结构网络中信息按照固定方向流动，或顺时针方向，或逆时针方向优点令牌控制，没有线路竞争，实时性强，传输控制容易缺点维护困难，可靠性不高。一个结点发生故障时，可能导致全网瘫痪。可以使用双环拓扑结构，但是复杂性提升星型拓扑 每个结点都由一条单独的通信线路与中心结点连结。其他各结点都与该中心结点有着物理链路的直接互连，其他结点直接不能直接通信，其他结点直接的通信需要该中心结点进行转发。因此中心结点必须有着较强的功能和较高的可靠性。需要中心设备，例如hub、switch、router优点 可靠性高，方便管理，易于扩展，传输效率高缺点 线路利用率低，中心节点需要很高的可靠性和冗余度注意 hub工作在一层，这种星型实际上就是芯片化的总线网络。只是物理拓扑结构上感觉像是星型OSI参考模型 OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架 OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层 物理层 定义了电气规范，设备规范、物理接口等，电信号的变化，或数字信号变化，比特链路层 二层。将比特组织成帧，即对字节进行定义，支持错误检查。使用物理地址、MAC地址。MAC有48位，前24位厂商编号由IEEE分配，后24位设备序号网络层 三层。将帧组织成包，包传递的路径选择（路由），将包传输到目标地址。使用逻辑地址、IP地址传输层 四层。解决传输的问题，确保数据传输的可靠性；建立、维护、终止虚拟电路；错误检测和恢复会话层 建立、管理、终止应用程序间的逻辑通路，即会话表示层 对应用数据格式化、加密解密等。将上层数据转换为适合网络传输的格式，或将下层数据转化为上应用层 七层。为应用程序提供网络服务接口，用户使用的时候并不关心会话如何建立保持，也不关心协议的协商是否加密等数据传输 数据很大，在应用层切分，每一份数据都会在下一层被封装 在数据链路层会增加tail即校验位，最后在物理层上都是电平信号0、1发送出去 到了对端设备，由下至上逐层解包组合。直到合成并还原应用层的一份数据通讯的三种模式单播 包在计算机网络传输中，目的地址为单一目标的传输方式。每次都是点对点的2个实体间相互通信 广播 数据在网络中传输，目标地址是网络中所有设备的传输方式。所有设备是有范围的，这个范围称为广播域 IP v6不支持广播，由组播替代 多播、组播： 把数据同时传递给一组目的地址。数据源只发出一份数据，会在尽可能远的的设备上复制和分发 冲突域、广播域参看https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9F%9F 冲突域 网络中设备A发送数据时，设备B也发送数据，数据碰撞，发生了冲突，这两个设备就属于同一个冲突域 交换机可以隔离冲突域 路由器可以隔离广播域局域网LAN 局域网Local Area Network，指的是某一个区域内，多台计算机互联的计算机组常见组网设备网线、有线网卡、无线网卡、集线器、交换机、路由器等网络设备网络线缆 有线连接，需要使用网线，最早使用同轴电缆，后来使用双绞线，现在高速网络布线可以采用光纤 常用的双绞线使用RJ45水晶头 直通采用两端T568B，互连使用一端T568A一端T568B的交叉线，不过目前新型网卡可以自适应，都使用直通线连接即可集线器hub 工作在一层。使用HUB连接的设备看似是星型，实际是总线型 它是物理层设备，只认识电信号，所以根本不认识什么MAC地址之类的信息。早期用来多机互连，信号中继的作用户 连入设备越多，广播信号，在一个冲突域，网络效率很低 使用HUB连接的所有设备，都在同一个冲突域交换机switch 工作在二层。内部记录着MAC表，通过自学习，建立交换机端口和MAC地址对应表。内部有电路交换数据，如同信号立交桥。网桥也工作这一层路由器Router 工作在三层。内部记录路由表，记录着路由器的端口到 网络 对应关系。这个表可以静态配置，也可以动态更新 功能：分割广播域；选择路由；维护和检查路由信息；连接广域网广域网WAN 广域网，又称外网、公网。连接不同局域网或城域网的计算机通讯网络互联网Internet 互联网Internet，也称因特网。前身是美国军用ARPA网，后来连入了很多的科研院校，并逐步商业化走向全球 它连接了覆盖全球的网络，是众多的广域网互联的大型网络 互联网使用了TCP/IP协议TCP/IP协议栈 TCP/IP，Transmission Control Protocol/Internet Protocol ，传输控制协议/因特网互联协议 它是一个包含很多工作在不同层的协议的协议族，其中最著名的2个协议分别是TCP和IP协议 它最早起源于美国国防部（缩写为DoD）的ARPA网项目，共定义了四层：网络访问层、Internet层、传输层、应用层 TCP/IP协议是事实标准。目前局域网和广域网基本上也都用该协议传输层协议| | TCP|UDP||:–|:–|:–||连续类型 |面向连接 |无连接 || 可靠性| 可靠 | 不可靠 || 有序 | 数据包有序号 | 没有包序 || 使用场景 | 大多数场合，数据不能出任何问题 | 视频、音频 |连接 TCP需要通讯双方预先建立连接，需要三次握手、四次断开 UDP不需要预先建立连接可靠性 TCP需要确定每一个包是否收到，丢包重发，效率低一些 UDP尽最大努力交付数据，不要要确认数据包，丢包无法知道，也不重复，效率高一些有序 TCP包有序号，可以进行顺序控制。第一个包序号随机生成，之后的序号都和它有关 UDP包无序，无法纠正，只能在应用层进行验证TCP协议三次握手/四次断开 三次握手建立连接 Three-way Handshake Client端首先发送一个SYN包告诉Server端我的初始序列号是X Server端收到SYN包后回复给Client一个ACK确认包，告诉Client说我收到了。Server端也需要告诉Client端自己的初始序列号，于是Server也发送一个SYN包告诉Client我的初始序列号是Y。这两个包一起发送 Client收到后，回复Server一个ACK确认包说我知道了 四次断开 Client发送一个FIN包来告诉Server需要断开 Server收到后回复一个ACK确认FIN包收到 Server在自己也没数据发送给Client后，Server也发送一个FIN包给Client，表示也无数据发送 Client收到后，就会回复一个ACK确认Server的FIN包 主动发出Fin包就是主动关闭方，就会进入TIME_WAIT，原因是被动关闭方发来的FIN包需要确认，万一此包丢失，被动关闭方未收到确认会超时重发FIN包，主动关闭方还在，可以重发ACK。 IP地址 IP地址是IP协议提供的一种同一个地址格式，它为互联网上的网络设备分配一个用来通信的逻辑地址 目前分为IP v4和IP v6IP v4 IP v4 是一个32位二进制数，不便记忆，为了使用方便，使用“点分十进制”表示法，将这个二进制数每8位断开，每8位是一个字节，一个字节表示的十进制正整数范围是0~255 IP v4地址早期比较充足，随着全球连入互联网，在2011年IP v4地址分配完毕IP地址的分类 公有地址：需向因特网信息中心申请，在互联网上可以直接使用的IP地址 私有地址：不需要注册，可以组织内部网络使用的IP地址 IP地址这个数被分成2部分，即网络位 + 主机位 网络位表示设备同属一个网络；主机位表示网络中不同的设备的唯一ID子网掩码 子网掩码将IP地址划分为网络ID和主机ID IP地址 位与 子网掩码就是网络IDIP v4地址被分为A、B、C、D、E五类A类 最高位是 0 第一字节（最高字节）为网络位。第一个字节变化为 0000 0001 到 0111 1111，共127，减去回环地址，剩余126个网络 A类IP地址范围1.0.0.0到127.255.255.255。二进制表示为：00000001 00000000 00000000 00000000 至01111111 11111111 11111111 11111111。最后一个是广播地址。 子网掩码 255.0.0.0 每一个网络中主机个数等于 256³ - 2 = 1677716 -2 = 1677714B类 最高位是10 前2个字节为网络位，其变化为128.0~191.255，相当于 1000 0000 0000 0000 到 1011 1111 1111 1111，实际上就是后14位变化，共2^14 = 16384个网络 B类IP地址范围128.0.0.0-191.255.255.255 。二进制表示为：10000000 00000000 00000000 00000000 至10111111 11111111 11111111 11111111 最后一个是广播地址 子网掩码255.255.0.0 每一个网络中主机个数等于 256² - 2 = 65535 -2 = 65534C类 最高位是110 前3个字节为网络位，其变化为192.0.0~223.255.255，相当于1100 0000 0000 0000 0000 0000 到 1101 1111 1111 1111 1111 1111 ，实际上就是后21位变化，共2^21 = 2097152个网络。 C类IP地址地址范围192.0.0.0-223.255.255.255 。二进制表示为：11000000 00000000 00000000 00000000 至11011111 11111111 11111111 11111111。 最后一个是广播地址 子网掩码255.255.255.0 每一个网络中主机个数等于 256 -2 = 254D类 多播地址，或组播地址 多播地址最高4位必须是1110，那么地址范围就是224.0.0.0到239.255.255.255 224.0.0.1特指所有主机 E类 实验用地址 特殊IP地址 0.0.0.0表示当前主机 255.255.255.255 限制广播地址。路由器不会转发这个受限广播地址的数据报文，此地址只能用于本网广播 IP地址中以127开头的地址称为Loopback回环地址 169.254.x.x，windows主机使用了DHCP获取IP，但没有获得地址，windows会临时获得这样的地址 网关GATEWAY 网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，用于网络间互联举例 IP地址192.168.3.200，要配合子网掩码使用，假设子网掩码为255.255.255.0，说明它是C类地址 网络ID为192.168.3.0，广播地址为192.168.3.255 剩余192.168.3.1~192.168.3.254能够分配给网络中其他设备 网关地址配置一般习惯使用1、100、254等。本例使用192.168.3.1其作用是连接不同的网络，也称为处在不同的网段 又有一个IP地址为192.168.100.10/24，它也是C类地址，/16指B类地址，/8指A类地址。网络ID是192.168.100.0 和上面的IP处在不同的网络，这两个地址的主机通信，就需要使用网关，由网关将数据包转发到另一个网络IP v6 互联网上的公有地址在2011年分配完，而随着互联网的发展，接入设备越来越多，尤其是物联网的到来，此问题必须解决。由此，提出了IP v6 IP v6采用128位二进制数表示，基本解决IP地址短缺现象，同时，该协议还解决原有协议的诸多问题路由Routing 跨网络通信就需要使用路由，通过路由器将数据包从一个网络发往另一个网络 路由器上维护着路由表，它知道如何将数据包发往另外的网络 windows使用 route print ，Linux使用 route -n 可以查看路由表 路由器所有端口都有自己的IP地址，这些IP地址往往处在不同的网络，所以，路由器连接了不同了网络 路由表中记录着路由设备所有端口对应的网络，分为静态、动态配置 静态路由：由管理员手动配置的固定的路由信息 动态路由：网络中的路由器，根据实时网络拓扑变化，相互通信传递路由信息，利用这些路由信息通过路由选择协议动态计算，并更新路由表。常见的协议有RIP、OSPF等等网关：下一跳地址，就是到下一个网络，从哪个网关出去到192.168.0.0/24和10.0.0.0/8网络，R1本身就直接连接着这些网络，所以网关为空，不需要到172.16.0.0/16网络需要找到R2，所以写R2的接口1地址即可DHCP 动态主机设置协议（Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，基于UDP协议工作 主要用途就是用于内部网或网络服务供应商自动给网络中的主机分配IP地址]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库面试题]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[什么是存储过程？有哪些优缺点？存储过程是一些预编译的SQL语句。 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 存储过程是一个预编译的代码块，执行效率比较高 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率 可以一定程度上确保数据安全 如果你对存储过程不熟悉，建议阅读：存储过程详解-博客园 索引是什么？有什么作用以及优缺点？索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引 索引加快数据库的检索速度 索引降低了插入、删除、修改等维护任务的速度 唯一索引可以确保每一行数据的唯一性 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 索引需要占物理和数据空间 如果你对索引还不太熟悉，建议阅读：漫谈数据库索引 什么是事务？事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 如果你对索引还不太熟悉，建议阅读：数据库事务 - Mr. David 专栏 数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 如果你对两种锁还不太熟悉，建议阅读：深入理解乐观锁与悲观锁 使用索引查询一定能提高查询的性能吗？为什么通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索,一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 简单说一说drop、delete与truncate的区别SQL中的drop、delete、truncate都表示删除，但是三者有一些差别 delete和truncate只删除表的数据不删除表的结构 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 如果你对这三者的用法还不太熟悉，建议阅读： drop、truncate和delete的区别 drop、delete与truncate分别在什么场景之下使用？ 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 超键、候选键、主键、外键分别是什么？超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异 说一说三个范式。第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 什么是数据库？数据库(database)保存有组织的数据的容器(通常是一个文件或一组文件). 确切的说, 数据库软件应称为DBMS(数据库管理系统).数据库是通过DBMS创建和操纵的容器.数据库可以是保存在硬设备上的文件,但也可以不是.你使用的DBMS,它替你访问数据库. 在你将资料放入自己的文件柜中, 并不是随便将他们扔进某个抽屉就完事了， 而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中， 这种文件称为表，表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单，产品目录，或者其他信息清单。 表某种特定类型数据的结构化清单。列（column）表中的一个字段]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多种概念]]></title>
    <url>%2Fweb%2FIO%E5%A4%9A%E7%A7%8D%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@toc 重要概念同步、异步函数或方法被调用的时候，调用者是否得到最终结果的 直接得到最终结果的，就是同步调用 不直接得到最终结果的，就是异步调用阻塞、非阻塞函数或方法调用的时候，是否立刻返回 立即返回就是非阻塞调用 不立即返回就是阻塞调用区别同步、异步，与阻塞、非阻塞不相关同步、异步强调的是，是否得到（最终的）结果阻塞、非阻塞强调是时间，是否等待 同步与异步区别在于：调用者是否得到了想要的最终结果同步就是一直要执行到返回最终结果异步就是直接返回了，但是返回的不是最终结果。调用者不能通过这种调用得到结果，以后可以通过被调用者提供的某种方式（被调用着通知调用者、调用者反复查询、回调），来取回最终结果 阻塞与非阻塞的区别在于，调用者是否还能干其他事阻塞，调用者就只能干等非阻塞，调用者可以先去忙会别的，不用一直等 联系同步阻塞，我啥事不干，就等你打饭打给我。打到饭是结果，而且我啥事不干一直等，同步加阻塞同步非阻塞，我等着你打饭给我，但我可以玩会手机、看看电视。打饭是结果，但是我不一直等 异步阻塞，我要打饭，你说等叫号，并没有返回饭给我，我啥事不干，就干等着饭好了你叫我。例如，取了号什么不干就等叫自己的号异步非阻塞，我要打饭，你给我号，你说等叫号，并没有返回饭给我，我在旁边看电视、玩手机，饭打好了叫我 操作系统知识在386之前，CPU工作在实模式下，之后，开始支持保护模式，对内存进行了划分X86 CPU有4种工作级别： Ring0级，可以执行特权指令，可以访问所有级别数据，可以访问IO设备等 Ring3级，级别最低，只能访问本级别数据 内核代码运行在Ring0，用户代码运行在Ring3 现代操作系统采用虚拟存储器，理论上，对于32位系统来说，进程对虚拟内存地址的内存寻址空间为4G（2^32)64位操作系统理论上最大内存寻址空间（2^64）操作系统中，内核程序独立且运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，这部分内存称为内核空间（内核态，最高地址1G） 普通应用程序运行在用户空间（用户态） 应用程序想访问某些硬件资源就需要通过操作系统提供的系统调用，系统调用可以使用特权指令运行在内核空间，此时进程陷入内核态运行。系统调用完成，进程将回到用户态执行用户空间代码 同步IO、异步IO、IO多路复用IO两个阶段IO过程分两阶段： 数据准备阶段 内核空间复制回用户空间进程缓冲区阶段 发生IO的时候： 内核从IO设备读、写数据（淘米，把米放饭锅里煮饭） 进程从内核复制数据（盛饭，从内核这个饭锅里面把饭装到碗里来） 系统调用——read函数 IO模型同步IO 同步IO模型包括 阻塞IO、非阻塞IO、IO多路复用、信号驱动IO阻塞IO 进程等待（阻塞），直到读写完成。（全程等待） 非阻塞IO进程调用read操作，如果IO设备没有准备好，立即返回ERROR，进程不阻塞。用户可以再次发起系统调用，如果内核已经准备好，就阻塞，然后复制数据到用户空间 第一阶段数据没有准备好，就先忙别的，等会再来看看。检查数据是否准备好了的过程是非阻塞的 第二阶段是阻塞的，即内核空间和用户空间之间复制数据是阻塞的 例：淘米、蒸饭我不等，我去玩会，盛饭过程我等着你装好饭，但是要等到盛好饭才算完事，这是同步的，结果就是盛好饭 IO多路复用所谓IO多路复用，就是同时监控多个IO，有一个准备好了，就不需要等了开始处理，提高了同时处理IO的能力 select几乎所有操作系统平台都支持，poll是对的select的升级 epoll，Linux系统内核2.5+开始支持，对select和poll的增强，在监视的基础上，增加回调机制。BSD、Mac平台有kqueue，Windows有iocp 以select为例 将关注的IO操作告诉select函数并调用，进程阻塞，内核“监视”select关注的文件描述符fd，被关注的任何一个fd对应的IO准备好了数据，select返回。再使用read将数据复制到用户进程 select举例 食堂供应很多菜（众多的IO），你需要吃某三菜一汤，大师傅（操作系统）说要现做，需要等，你只好等待大师傅叫。其中一样菜好了，大师傅叫你，说你点的菜有好的了，你得自己遍历找找看哪一样才好了，请服务员把做好的菜打给你 epoll是有菜准备好了，大师傅喊你去几号窗口直接打菜，不用自己找菜了 一般情况下，select最多能监听1024个fd（可以修改，但不建议改），但是由于select采用轮询的方式，当管理的IO多了，每次都要遍历全部fd，效率低下epoll没有管理的fd的上限，且是回调机制，不需遍历，效率很高 信号驱动IO进程在IO访问时，先通过sigaction系统调用，提交一个信号处理函数，立即返回。进程不阻塞当内核准备好数据后，产生一个SIGIO信号并投递给信号处理函数。可以在此函数中调用recvfrom函数操作数据从内核空间复制到用户空间，这段过程进程阻塞 异步IO 进程发起异步IO请求，立即返回。内核完成IO的两个阶段，内核给进程发一个信号。 举例 来打饭，跟大师傅说饭好了叫你，饭菜准备好了，窗口服务员把饭盛好了打电话叫你。两阶段都是异步的。在整个过程中，进程都可以忙别的，等好了才过来。 今天不想出去到饭店吃饭了，点外卖，饭菜在饭店做好了（第一阶段），快递员从饭店送到你家门口（第二阶段）。 Linux的aio的系统调用，内核从版本2.6开始支持 前4个都是同步IO，因为核心操作recv函数调用时，进程阻塞直到拿到最终结果为止。 而异步IO进程全程不阻塞]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库面试题]]></title>
    <url>%2Fbook%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[什么是存储过程？有哪些优缺点？存储过程是一些预编译的SQL语句。 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 存储过程是一个预编译的代码块，执行效率比较高 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率 可以一定程度上确保数据安全 如果你对存储过程不熟悉，建议阅读：存储过程详解-博客园 索引是什么？有什么作用以及优缺点？索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引 索引加快数据库的检索速度 索引降低了插入、删除、修改等维护任务的速度 唯一索引可以确保每一行数据的唯一性 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 索引需要占物理和数据空间 如果你对索引还不太熟悉，建议阅读：漫谈数据库索引 什么是事务？事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 如果你对索引还不太熟悉，建议阅读：数据库事务 - Mr. David 专栏 数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 如果你对两种锁还不太熟悉，建议阅读：深入理解乐观锁与悲观锁 使用索引查询一定能提高查询的性能吗？为什么通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索,一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 简单说一说drop、delete与truncate的区别SQL中的drop、delete、truncate都表示删除，但是三者有一些差别 delete和truncate只删除表的数据不删除表的结构 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 如果你对这三者的用法还不太熟悉，建议阅读： drop、truncate和delete的区别 drop、delete与truncate分别在什么场景之下使用？ 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 超键、候选键、主键、外键分别是什么？超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异 说一说三个范式。第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 什么是数据库？数据库(database)保存有组织的数据的容器(通常是一个文件或一组文件). 确切的说, 数据库软件应称为DBMS(数据库管理系统).数据库是通过DBMS创建和操纵的容器.数据库可以是保存在硬设备上的文件,但也可以不是.你使用的DBMS,它替你访问数据库. 在你将资料放入自己的文件柜中, 并不是随便将他们扔进某个抽屉就完事了， 而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中， 这种文件称为表，表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单，产品目录，或者其他信息清单。 表某种特定类型数据的结构化清单。列（column）表中的一个字段]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSGI]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%2FWSGI%20%2F</url>
    <content type="text"><![CDATA[@toc WSGI（Web Server Gateway Interface）主要规定了服务器端和应用程序间的接口 WSGI服务器——wsgiref wsgiref是Python提供的一个WSGI参考实现库，不适合生产环境使用 wsgiref.simple_server 模块实现一个简单的WSGI HTTP服务器 123456from wsgiref.simple_server import make_server,demo_appip = '127.0.0.1'port = 9999server = make_server(ip, port, demo_app) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 查看demo_app源码 12345678910def demo_app(environ,start_response): from io import StringIO stdout = StringIO() print("Hello world!", file=stdout) print(file=stdout) h = sorted(environ.items()) for k,v in h: print(k,'=',repr(v), file=stdout) start_response("200 OK", [('Content-Type','text/plain; charset=utf-8')]) return [stdout.getvalue().encode("utf-8")] StringIO 在内存中读写str print(&quot;Hello world!&quot;, file=stdout)将Hello world!内容写入内存中 start_response 构造head getvalue 把缓冲区的内容全部读取出来，内容必须为btyesWSGI服务器作用 监听HTTP服务端口（TCPServer，默认端口80） 接收浏览器端的HTTP请求并解析封装成environ环境数据 负责调用应用程序，将environ数据和start_response方法两个实参传入给Application 将应用程序响应的正文封装成HTTP响应报文返回浏览器端 所有头和内容都是由server来封装WSGI APP应用程序端 应用程序应该是一个可调用对象Python中应该是函数、类、实现了 __call__ 方法的类的实例 这个可调用对象应该接收两个参数1. 函数实现123456789101112from wsgiref.simple_server import make_serverreturn_res = b'Hello World'def application(environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 2. 类实现1234567891011121314151617from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __init__(self, environ, start_response): self.env = environ self.sr = start_response def __iter__(self): # 对象可迭代 self.sr("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) yield return_resip = '127.0.0.1'port = 9999server = make_server(ip, port, Application) # Demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 3. 类实现，可调用对象1234567891011121314from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application(e,s)server.serve_forever() # server.handle_request() 执行一次 environ和start_response这两个参数名可以是任何合法名，但是一般默认都是这2个名字 应用程序端还有些其他的规定，暂不用关心 注意：第2、第3种实现调用时的不同 自定义 返回头一般自定义习惯用‘X’开头12345678910111213141516from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [ ('Content-Type', 'text/plain; charset=utf-8'), ('X-Server', 'MyDemo_app') ]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 environenviron是包含Http请求信息的dict字典对象| 名称 | 含义 ||:–|:–||REQUEST_METHOD |请求方法，GET、POST等||PATH_INFO| URL中的路径部分||QUERY_STRING| 查询字符串||SERVER_NAME, SERVER_PORT| 服务器名、端口||HTTP_HOST| 地址和端口||SERVER_PROTOCOL |协议||HTTP_USER_AGENT| UserAgent信息| 12345678910111213CONTENT_TYPE = &apos;text/plain&apos;HTTP_HOST = &apos;127.0.0.1:9999&apos;HTTP_USER_AGENT = &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML, like Gecko) Version/5.0.1 Safari/537.36&apos;PATH_INFO = &apos;/&apos;QUERY_STRING = &apos;&apos;REMOTE_ADDR = &apos;127.0.0.1&apos;REMOTE_HOST = &apos;&apos;REQUEST_METHOD = &apos;GET&apos;SERVER_NAME = &apos;DESKTOP-D34H5HF&apos;SERVER_PORT = &apos;9999&apos;SERVER_PROTOCOL = &apos;HTTP/1.1&apos;SERVER_SOFTWARE = &apos;WSGIServer/0.2&apos; start_response它是一个可调用对象。有3个参数，定义如下：start_response(status, response_headers, exc_info=None)|参数名称 |说明||:–|:–||status |状态码和状态描述，例如 200 OK||response_headers |一个元素为二元组的列表例如[(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;)]||exc_info |在错误处理的时候使用|start_response应该在返回可迭代对象之前调用，因为它返回的是Response Header。返回的可迭代对象是Response Body 服务器端服务器程序需要调用符合上述定义的可调用对象APP，传入environ、start_response，APP处理后，返回响应头和可迭代对象的正文，由服务器封装返回浏览器端 返回网页的例子1234567891011121314from wsgiref.simple_server import make_serverdef application(environ, start_response): status = '200 OK' headers = [('Content-Type', 'text/html;charset=utf-8')] start_response(status, headers) # 返回可迭代对象 html = '&lt;h1&gt;Hello World&lt;/h1&gt;'.encode("utf-8") return [html]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application)server.serve_forever() # server.handle_request() 执行一次 simple_server 只是参考用，不能用于生产环境 Linux 测试用命令12$ curl -I http://192.168.142.1:9999/xxx?id=5$ curl -X POST http://192.168.142.1:9999/yyy -d &apos;&#123;&quot;x&quot;:2&#125;&apos; -I 使用HEAD方法 -X 指定方法，-d传输数据 到这里就完成了一个简单的WEB 程序开发 WSGI WEB服务器 本质上就是一个TCP服务器，监听在特定端口上 支持HTTP协议，能够将HTTP请求报文进行解析，能够把响应数据进行HTTP协议的报文封装并返回浏览器端 实现了WSGI协议，该协议约定了和应用程序之间接口（参看PEP333，https://www.python.org/dev/peps/pep-0333/ ）WSGI APP应用程序 遵从WSGI协议 本身是一个可调用对象 调用start_response，返回响应头部 返回包含正文的可迭代对象 WSGI 框架库往往可以看做增强的更加复杂的Application]]></content>
      <categories>
        <category>后端</category>
      </categories>
      <tags>
        <tag>后端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@toc 概念 数据库按照数据结构来组织、存储、管理数据的仓库 诞生计算机的发明是为了做科学计算的，而科学计算需要大量的数据输入和输出早期，可以使用打孔卡片的孔、灯泡的亮灭来表示数据输入、输出 1940年，数据可以存储在磁带上，顺序的读取、写入磁带。1956年IBM发明了磁盘驱动器这个革命性产品，支持随机访问。随着信息化时代的到来，有了硬件存储技术的发展，有大量的数据需要存储和管理 数据库DBMS发展 萌芽期：文件管理 第一代：层次数据库、网状数据库 第二代：SQL、关系型数据库 第三代：面向对象的DBMS（OODBMS）、对象关系的DBMS（ORDBMS）文件系统管理 磁盘上一个个文件，数据孤立，数据冗余 格式不统一，很难统一管理 无法高效查询，无法灵活查询层次数据库 以树型结构表示实体及其之间的联系。关系只支持一对多 代表数据库IBM IMS网状数据库 通用电气最早在1964年开发出网状数据库IDS，只能运行在GE自家的主机上 结点描述数据，结点的联系就是数据的关系能够直接描述客观世界，可以表示实体间多种复杂关系，而这是层次数据模型无法做到的。比如，一个结点可以有多个父结点，结点之间支持可以多对多关联关系数据库 使用行、列组成的二维表来组织数据和关系，表中行（记录）即可以描述数据实体，也可以描述实体间关系 关系模型比网状模型、层次模型更简单，不需要关系数存储的物理细节，专心于数据的逻辑构建，而且关系模型有论文的严格的数学理论基础支撑![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062111513723.png) 1970年6月，IBM的研究员E.F.Codd发表了名为“A Relational Model of Data for Large Shared Data Banks”的论文，提出了关系模型的概念，奠定了关系模型的理论基础 1976年，IBM实验室System R项目，通过实现数据结构和操作来证明关系模型实用性，并直接产生了结构化查询语言SQL。1987年，SQL被ISO组织标准化 关系模型，有严格的数学基础，抽象级别较高，简单清晰，便于理解和使用 经过几十年的发展，关系数据库百花齐放，技术日臻成熟和完善 基于关系模型构建的数据库系统称为RDBMS(Relational DataBase System) BM DB2、Oracle的Oracle和Mysql、微软的MS SQL。以前的Infomix、Sybase等Oracle的发展 拉里·埃里森(Larry Ellison)仔细阅读了IBM的关系数据库的论文，敏锐意识到在这个研究基础上可以开发商用软件系统。他们几个创始人决定开发通用商用数据库系统Oracle，这个名字来源于他们曾给中央情报局做过的项目名 1979年发布了ORACLE 2.0版本（实际上是1.0）。1983年，Oracle v3。1984年，Oracle v4。1985年，Oraclev5。1988年，Oracle v6引入了行级锁等新技术，然而这是个不稳定的版本。直到1992年的时候，Oracle7才逐渐稳定下来，并取得巨大成功。2001年的9i版本被广泛应用 2009年4月20日，甲骨文公司宣布将以每股9.50美元，总计74亿美金收购SUN（计算机系统）公司。2010年1月成功收购 2013年，甲骨文超过IBM，成为继微软之后的全球第二大软件公司Mysql发展 1985年几个瑞典人为大型零售商的项目设计了一种利用索引顺序存取数据的软件，这就是MyISAM的前身。1996年，MySQL 1.0发布，随后发布了3.11.1版本，并开始往其它平台移植。2000年MySQL采用GPL协议开源 MySQL 4.0开始支持MyISAM、InnoDB引擎。2005年10月，MySQL 5.0成为里程碑版本 2008年1月被Sun公司收购 2009年1月，在Oracle收购MySQL之前，Monty Widenius担心收购，就从MySQL Server 5.5开始一条新的GPL分支，起名MariaDB MySQL的引擎是插件化的，可以支持很多种引擎： MyISASM，不支持事务，插入、查询速度快。 InnoDB，支持事务，行级锁，MySQL 5.5起的默认引擎 去IOE 它是阿里巴巴造出的概念。其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，取而代之使用自己在开源软件基础上开发的系统。传统上，一个高端大气的数据中心，IBM小型机、Oracle数据库、EMC存储设备，可以说缺一不可。而使用这些架构的企业，不但采购、维护成本极高，核心架构还掌握在他人手中 对于阿里巴巴这样大规模的互联网应用，应该采用开源、开放的系统架构。这种思路并不是阿里巴巴的新发明，国外的谷歌、Facebook、亚马逊等早已为之。只不过它们几乎一开始就有没有采用IT商业公司的架构，所以他们也不用“去IOE” 去IOE，转而使用廉价的架构，稳定性一定下降，需要较高的运维水平解决NoSQL NoSQL是对非SQL、非传统关系型数据库的统称。 NoSQL一词诞生于1998年，2009年这个词汇被再次提出指非关系型、分布式、不提供ACID的数据库设计模式 随着互联网时代的到来，数据爆发式增长，数据库技术发展日新月异，要适应新的业务需求。 随着移动互联网、物联网的到来，大数据的技术中NoSQL也同样重要 数据库流行度排名 2017.12 数据库流行度排名 2018.6]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发]]></title>
    <url>%2Fweb%2FWEB%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[@toc CS编程CS编程，即客户端、服务器编程 客户端、服务端之间需要使用Socket，约定协议、版本（往往使用的协议是TCP或者UDP），指定地址和端口，就可以通信 客户端、服务端传输数据，数据可以有一定的格式，双方必须先约定好 BS编程BS编程，即Browser、Server开发 Browser浏览器，一种特殊的客户端，支持HTTP(s)协议，能够通过URL向服务端发起请求，等待服务端返回HTML等数据，并在浏览器内可视化展示的程序 Server，支持HTTP(s)协议，能够接受众多客户端发起的HTTP协议请求，经过处理，将HTML等数据返回给浏览器 本质上来说，BS是一种特殊的CS，即客户端必须是一种支持HTTP协议且能解析并渲染HTML的软件，服务端必须是能够接收多客户端HTTP访问的服务器软件 HTTP协议底层基于TCP协议实现 BS开发分为两端开发 客户端开发，或称前端开发。HTML、CSS、JavaScript等 服务端开发，Python有WSGI、Django、Flask、Tornado等 HTTP协议安装httpd可以安装httpd或nginx等服务端服务程序，通过浏览器访问，观察http协议 无状态，有连接和短连接 无状态：指的是服务器无法知道2次请求之间的联系，即使是前后2次同一个浏览器也没有任何数据能够判断出是同一个浏览器的请求。后来可以通过cookie、session来判断 有连接：是因为它基于TCP协议，是面向连接的，需要3次握手、4次断开 短连接：Http 1.1之前，都是一个请求一个连接，而Tcp的连接创建销毁成本高，对服务器有很大的影响。所以，自Http 1.1开始，支持keep-alive，默认也开启，一个连接打开后，会保持一段时间（可设置），浏览器再访问该服务器就使用这个Tcp连接，减轻了服务器压力，提高了效率 协议Http协议是无状态协议 同一个客户端的两次请求之间没有任何关系，从服务器端角度来说，它不知道这两个请求来自同一个客户端URL组成 URL可以说就是地址，uniform resource locator 统一资源定位符，每一个链接指向一个资源供客户端访问schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] 例如，通过下面的URL访问网页http://www.bing.com/pathon/index.html?id=5&amp;name=python 访问静态资源时，通过上面这个URL访问的是网站的某路径下的index.html文件，而这个文件对应磁盘上的真实的文件。就会从磁盘上读取这个文件，并把文件的内容发回浏览器端 scheme 模式、协议http、ftp、https、file、mailto等等 host:portwww.python.org:80 ，80端口是默认端口可以不写。域名会使用DNS解析，域名会解析成IP才能使用。实际上会对解析后返回的IP的TCP的80端口发起访问 /path/to/resourcepath，指向资源的路径 ?key1=value1&amp;key2=value2query string，查询字符串，问号用来和路径分开，后面key=value形式，且使用&amp;符号分割 HTTP消息消息分为Request请求、Response响应 Request：浏览器向服务器发起的请求Response：服务器对客户端请求的响应 请求报文由Header消息报头、Body消息正文组成（可选）请求报文第一行称为请求行 响应报文由Header消息报头、Body消息正文组成（可选）响应报头第一行称为状态行 每一行使用回车和换行符作为结尾 如果有Body部分，Header、Body之间留一行空行 请求报文 请求消息行：请求方法Method 请求路径 协议版本CRLF 请求方法Method 方法 说明 GET 请求获取URL对应的资源 POST 提交数据至服务器端 HEAD 和GET类似，不过不返回响应报文的正文 常见传递信息的方式 GET方法使用Query Stringhttp://www.bing.com/pathon/index.html?id=5&amp;name=python&amp;name=linux通过查询字符串在URL中传递参数，而URL在请求报文的头部的第一行 POST方法提交数据请求时提交的数据是在请求报文的正文Body部分 1234567请求消息如下POST /xxx/yyy?id=5&amp;name=bing HTTP/1.1HOST: 127.0.0.1:9999content-length: 26content-type: application/x-www-form-urlencodedage=5&amp;weight=80&amp;height=170 URL中本身就包含着信息http://www.bing.com/python/student/001 响应报文 响应消息行：协议版本 状态码 消息描述CRLFstatus code状态码 状态码在响应头第一行1234567891011121314151xx 提示信息，表示请求已被成功接收，继续处理2xx 表示正常响应 200 正常返回了网页内容3xx 重定向 301 页面永久性移走，永久重定向。返回新的URL，浏览器会根据返回的url发起新的request请求 302 临时重定向 304 资源未修改，浏览器使用本地缓存4xx 客户端请求错误 404 Not Found，网页找不到，客户端请求的资源有错 400 请求语法错误 401 请求要求身份验证 403 服务器拒绝请求5xx 服务器端错误 500 服务器内部错误 502 上游服务器错误，例如nginx反向代理的时候 Cookie技术 键值对信息 是一种客户端、服务器端传递数据的技术 一般来说cookie信息是在服务器端生成，返回给浏览器端的 浏览器端可以保持这些值，浏览器对同一域发起每一请求时，都会把Cookie信息发给服务器端 服务端收到浏览器端发过来的Cookie，处理这些信息，可以用来判断这次请求是否和之前的请求有关联 曾经Cookie唯一在浏览器端存储数据的手段，目前浏览器端存储数据的方案很多，Cookie正在被淘汰 当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie键值对。浏览器收到响应后通常会保存这些Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器 另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。可以使用 Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE 例如：12345Set-Cookie:aliyungf_tc=AQAAAJDwJ3Bu8gkAHbrHb4zlNZGw4Y; Path=/; HttpOnlyset-cookie:test_cookie=CheckForPermission; expires=Tue, 19-Mar-2018 15:53:02 GMT; path=/; domain=.doubleclick.netSet-Cookie: BD_HOME=1; path=/ key value说明 Cookie过期 Cookie可以设定过期终止时间，过期后将被浏览器清除如果缺省，Cookie不会持久化，浏览器关闭Cookie消失，称为会话级Cookie Cookie域 域确定有哪些域可以存取这个Cookie缺省设置属性值为当前主机，例如 www.python.org如果设置为 python.org 表示包含子域 Path 确定哪些目录及子目录访问可以使用该Cookie Secure 表示Cookie随着HTTPS加密过得请求发送给服务端有些浏览器已经不允许http://协议使用Secure这个Secure不能保证Cookie是安全的，Cookie中不要传输敏感信息 HttpOnly 将Cookie设置此标记，就不能被JavaScript访问，只能发给服务器端 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly告诉浏览器端设置这个Cookie的键值对，有过期时间，使用HTTPS加密传输到服务器端，且不能被浏览器中JS脚本访问该Cookie 12345678910Cookie的作用域：Domain和Path定义Cookie的作用域Domaindomain=www.baidu.com 表示只有该域的URL才能使用domain=.baidu.com 表示可以包含子域，例如www.baidu.com 、python.baidu.com 等Pathpath=/ 所有/的子路径可以使用domain=www.baidu.com; path=/webapp 表示只有www.baidu.com/webapp下的URL匹配，例如http://www.baidu.com/webapp/a.html就可以 缺点 Cookie一般明文传输（Secure是加密传输），安全性极差，不要传输敏感数据 有4kB大小限制 每次请求中都会发送Cookie，增加了流量Session技术WEB 服务器端，尤其是动态网页服务端Server，有时需要知道浏览器方是谁，但是HTTP是无状态的，怎么办？ 服务端会为每一次浏览器端第一次访问生成一个SessionID，用来唯一标识该浏览器，通过Set-Cookie发送到浏览器端 浏览器端收到之后并不永久保持这个Cookie，只是会话级的。浏览器访问服务端时，会使用Cookie，也会带上这个SessionID的Cookie值 1Set-Cookie:JSESSIONID=741248A52EEB83DF182009912A4ABD86.Tomcat1; Path=/; HttpOnly 服务端会维持这个SessionID一段时间，如果超时，会清理这些超时没有人访问的SessionID。如果浏览器端发来的SessionID无法在服务端找到，就会自动再次分配新的SessionID，并通过Set-Cookie发送到浏览器端以覆盖原有的存在浏览器中的会话级的SessionID 推荐图书《HTTP权威指南》]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react高阶组件]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E4%B9%8B%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[@toc 高阶组件let Root = props =&gt; &lt;div&gt;{props.schoolName}&lt;/div&gt;;如果要在上例的Root组件进行增强怎么办？例如将Root组件的div外部再加入其它div柯里化这个Wrapper函数1234567891011let Wrapper = function (Component, props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125;;let Root = props =&gt; &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;; 柯里化这个Wrapper函数123456789101112131415161718192021import React from 'react';import ReactDom from 'react-dom';let Wrapper = function (Component) &#123; function _wrapper(props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; ); &#125; return _wrapper;&#125;;let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;;let NewComp = Wrapper(Root) // 返回一个包装后的元素ReactDom.render(&lt;NewComp schoolName="Hello World"/&gt;, document.getElementById('root')); 下面代码本身就是一个无状态组件，内部包裹这一个传入的组件，可以看做增强了传入的组件 传入的组件作为返回的新组件的子组件123456789function _wrapper(props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125; 那么上面代码的Wrapper函数可以看做参数是一个组件，返回一个新组件，即高阶组件 简化Wrapper，箭头函数1234567891011let Wrapper = function (Component) &#123; return (props) =&gt; &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; ); &#125;;&#125;; 再次变化12345678910let Wrapper = function (Component) &#123; return props =&gt; ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125;; 再次变化123456789101112131415import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt;);let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;;let NewComp = Wrapper(Root)ReactDom.render(&lt;NewComp schoolName="Hello World" /&gt;, document.getElementById('root')); 装饰器新版ES 2016中增加了装饰器的支持，因此可以使用装饰器来改造上面的代码12@Wrapper // 这是不对的，装饰器装饰函数或类let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;; ES 2016的装饰器只能装饰类，所以，将Root改写成类1234567891011121314151617import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt;);@Wrapperclass Root extends React.Component &#123; render() &#123; return &lt;div&gt;Root&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 如何让Root也显示出schoolName？1234567891011121314151617import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/div&gt;);@Wrapperclass Root extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.schoolName&#125;&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 使用 &lt;Component {...props} /&gt; 相当于给组件增加了属性 带参装饰器想给装饰器函数增加一个id参数1234567891011121314151617181920import React from 'react';import ReactDom from 'react-dom';// 带参装饰器函数let Wrapper = id =&gt; Component =&gt; props =&gt; (&lt;div id=&#123;id&#125;&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/div&gt;);@Wrapper('wrapper') // 带参class Root extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.schoolName&#125;&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 通过上面的改写，就得到带参装饰器如果觉得不好接受，可以先写成原始的形式，熟悉了箭头函数语法后，再改成精简的形式]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react项目构建]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[@toc 项目依赖安装将项目开发基础文件 react-mobx-starter-master.zip 解压缩，并用这个目录作为项目根目录。在项目根目录中，执行下面的命令，就会自动按照package.json的配置安装依赖模块。$ npm install 或者 $ npm i安装完成后，会生成一个目录 node_modules ，里面是安装的所有依赖的模块 项目整体说明12345678910111213141516171819项目目录结构.├── .babelrc├── .gitignore├── index.html├── jsconfig.json├── LICENSE├── .npmrc├── package.json├── README.md├── src│ ├── App.js│ ├── AppState.js│ ├── index.html│ └── index.js├── node_modules│ ├── ...├── webpack.config.dev.js└── webpack.config.prod.js 配置文件详解package.json$ npm init 产生的文件，里面记录项目信息，所有项目依赖 版本管理可指定到对应的git仓库1234"repository": &#123; "type": "git", "url": "https://192.168.124.135/react-mobx/react-mobx-starter.git"&#125; 项目管理12345"scripts": &#123; "test": "jest", "start": "webpack-dev-server --config webpack.config.dev.js --hot --inline", "build": "rimraf dist &amp;&amp; webpack -p --config webpack.config.prod.js"&#125; start 指定启动webpack的dev server开发用WEB Server主要提供2个功能：静态文件支持、自动刷新和热替换HMR(Hot Module replacement) --hot 启动HMRHRM可以在应用程序运行中替换、添加、删除模块，而无需重载页面，只把变化部分替换掉。不使用HMR则自动刷新会导致这个页面刷新 --inline 默认模式使用HMR的时候建议开启inline模式。热替换时会有消息显示在控制台 build 使用webpack构建打包。对应 $ npm run build 项目依赖 devDependencies 开发时依赖，不会打包到目标文件中。对应 npm install xxx --save-dev例如babel的一些依赖，只是为了帮我们转译代码，没有必要发布到生产环境中 dependencies 运行时依赖，会打包到项目中。对应 npm install xxx --save 开发是依赖1234567891011121314151617181920212223"devDependencies": &#123; "babel-core": "^6.24.1", "babel-jest": "^19.0.0", "babel-loader": "^6.4.1", "babel-plugin-transform-decorators-legacy": "^1.3.4", "babel-plugin-transform-runtime": "^6.23.0", "babel-preset-env": "^1.4.0", "babel-preset-react": "^6.24.1", "babel-preset-stage-0": "^6.24.1", "css-loader": "^0.28.0", "html-webpack-plugin": "^2.28.0", "jest": "^19.0.2", "less": "^2.7.2", "less-loader": "^4.0.3", "react-hot-loader": "^4.3.12", "rimraf": "^2.6.2", "source-map": "^0.5.6", "source-map-loader": "^0.2.1", "style-loader": "^0.16.1", "uglify-js": "^2.8.22", "webpack": "^2.4.1", "webpack-dev-server": "^2.4.2"&#125; 版本号指定 版本号 ，只安装指定版本号的 ~版本号 ，例如 ~1.2.3 表示安装1.2.x中最新版本，不低于1.2.3，但不能安装1.3.x ^版本号 ，例如 ^2.4.1 表示安装2.x.x最新版本不低于2.4.1 latest ，安装最新版本 babel 转译，因为开发用了很多ES6语法。从6.x开始babel拆分成很多插件，需要什么引入什么 babel-core 核心 babel-loader webpack的loader，webpack是基于loader装载器的 babel-preset-xxx 预设的转换插件 babel-plugin-transform-decorators-legacy 下面的课程用到了装饰器，这个插件就是转换装饰器用的 css样式相关的包括： css-loader、less、less-loader、style-loader react-hot-loader react热加载插件，希望改动保存后，直接在页面上直接反馈出来，不需要手动刷新 source-map 文件打包，js会合并或者压缩，没法调试，用它来看js原文件是什么 source-map-loader也需 webpack的 loader webpack 打包工具，2.4.1 发布于2017年4月，当前2.7.0发布于2017年7月 webpack-dev-server 启动一个开发时用的server运行时依赖123456789101112"dependencies": &#123; "antd": "^3.10.9", "axios": "^0.16.1", "babel-polyfill": "^6.23.0", "babel-runtime": "^6.23.0", "mobx": "^4.6.0", "mobx-react": "^5.4.2", "react": "^16.6.3", "react-dom": "^16.6.3", "react-router": "^4.3.1", "react-router-dom": "^4.3.1"&#125; antd 即 ant design，基于react实现，蚂蚁金服开源的react的UI库。做中后台管理非常方便 axios 异步请求支持 polyfill 解决浏览器api不支持的问题。写好polyfill就让你的浏览器支持，帮你抹平差异化 react开发的主框架react-dom 支持DOMreact-router 支持路由react-router-dom DOM绑定路由 mobx 状态管理库，透明化。mobx-react mobx和react结合的模块 react和mobx是一个强强联合 babel配置.babelrc babel转译的配置文件123456789101112&#123; "presets": [ "react", "env", "stage-0" ], "plugins": [ "transform-decorators-legacy", "transform-runtime", "react-hot-loader/babel" ]&#125; webpack配置webpack.config.dev.js这是一个符合Commonjs的模块 module.exports 导出 devtool：’source-map’ 生成及如何生成source-map文件 source-map适合生成环境使用，会生成完成Sourcemap独立文件 由于在Bundle中添加了引用注释，所以开发工具知道如何找到Sourcemap entry入口 描述入口。webpack会从入口开始，找出直接或间接的模块和库构建依赖树，最后输出为bundles文件中 entry如果是一个字符串，定义就是入口文件 如果是一个数组，数组中每一项都会执行，里面包含入口文件，另一个参数可以用来配置一个服务器，我们这里配置的是热加载插件，可以自动刷新 output输出 告诉webpack输出bundles到哪里去，如何命名。 filename定义输出的bundle的名称 path 输出目录是 __dirname+&#39;dist&#39; ，名字叫做 bundle.js 。 __dirname 是nodejs中获取当前js文件所在的目录名 publicPath 可以是绝对路径或者相对路径，一般会以/结尾。/assets/表示网站根目录下assets目录下 resolve解析 设置模块如何被解析。 extensions 自动解析扩展名。&#39;.js&#39;的意思是，如果用户导入模块的时候不带扩展名，它尝试补全 module 模块 如何处理不同的模块 rules 匹配请求的规则，以应用不同的加载器、解析器等 12345678910111213141516171819202122232425module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader' &#125; ] &#125;, &#123; test: /\.css$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;, ] &#125;, &#123; test: /\.less$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;, &#123; loader: "less-loader" &#125; ] &#125; ]&#125;, test 匹配条件的exclude 排除的， /node_modules/打包排除目录。这一句一定要有，否则，编译就把这个目录下所有文件也拿进来了，巨大无比use 使用模块的UseEntries列表中的loaderrules中对.js结尾的但不在node_modules目录的文件使用转译babel-loader 加载器：倒着写，先应用数组中的最后一个 style-loader通过 &lt;style&gt; 标签把css添加到DOM中 css-loader 加载css less-loader 对less的支持 LESSCSS好处简单易学，但是坏处是没有模块化、复用的概念，因为它不是语言LESS是一门CSS的预处理语言，扩展了CSS，增加了变量、Mixin、函数等开发语言的特性，从而简化了CSS的编写LESS本身是一套语法规则及解析器，将写好的LESS解析成CSS。LESS可以使用在浏览器端和服务器端12345678@color: #4D926F; #header &#123; color: @color; &#125; h2 &#123; color: @color; &#125; 可以使用解析成如下的CSS123456#header &#123; color: #4D926F; &#125; h2 &#123; color: #4D926F; &#125; LESS在服务器端使用，需要使用LESS编译器， $ npm install less ，本项目目录已经安装过了12345编译输出到控制台$ node_modules/.bin/lessc test.less编译输出到文件$ node_modules/.bin/lessc test.less test.css plugins：webpack的插件1234plugins: [ new webpack.optimize.OccurrenceOrderPlugin(true), new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin(&#123;'process.env': &#123;NODE_ENV: JSON.stringify('development')&#125;&#125;) HotModuleReplacementPlugin 开启HMR DefinePlugin 全局常量配置 devServer，开发用server123456789101112131415161718devServer: &#123; compress: true, port: 3000, publicPath: '/assets/', hot: true, inline: true, historyApiFallback: true, stats: &#123; chunks: false &#125;, proxy: &#123; '/api': &#123; target: 'http://127.0.0.1:8000', changeOrigin: true, pathRewrite: &#123;'^/api':''&#125; &#125; &#125;&#125; compress 启动gzip port 启动端口3000 hot 启用HMR proxy指定访问/api 开头URL都代理到 http://127.0.0.1:8000 去vscode配置jsconfig.json是vscode的配置文件，覆盖当前配置 以上是所有配置文件的解释。拿到这个文件夹后，需要修改name项目名称、version版本、description描述，需要修改repository仓库地址，需要修改author作者、license许可证信息。这些信息修改好之后，就可以开始开发了 启动项目在项目根目录，使用$ npm start启动成功应该就可以访问了webpack使用babel转译、打包，较为耗时，需要等一会儿]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react技术]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[@TOC 简介React是Facebook开发并开源的前端框架当时他们的团队在市面上没有找到合适的MVC框架，就自己写了一个Js框架，用来架设Instagram（图片分享社交网络）。2013年React开源 React解决的是前端MVC框架中的View视图层的问题 Virtual DOMDOM（文档对象模型Document Object Model） 将网页内所有内容映射到一棵树型结构的层级对象模型上，浏览器提供对DOM的支持，用户可以是用脚本调用DOM API来动态的修改DOM结点，从而达到修改网页的目的，这种修改是浏览器中完成，浏览器会根据DOM的改变重绘改变的DOM结点部分 修改DOM重新渲染代价太高，前端框架为了提高效率，尽量减少DOM的重绘，提出了Virtual DOM。Virtual DOM是一个JavaScript对象，性能更高。所有的修改都是先生成一个新的Virtual DOM，通过比较算法比较新旧Virtual DOM，得到差异化VirtualDOM，将这部分差异更新到浏览器DOM，浏览器只需要渲染这部分变化就行了 React实现了DOM Diff算法可以高效比对Virtual DOM支持JSX语法JSX是一种JavaScript和XML混写的语法，是JavaScript的扩展12345678React.render( &lt;div&gt; &lt;div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;, document.getElementById('example')); 测试程序替换 /src/index.js 为下面的代码12345678910import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root/&gt;, document.getElementById('root')); 保存文件后，会自动编译，并重新装载刷新浏览器端页面 程序解释import React from &#39;react&#39;; 导入react模块import ReactDOM from &#39;react-dom&#39;; 导入react的DOM模块 class Root extends React.Component 组件类定义，从React.Component类上继承。这个类生成JSXElement对象即React元素render() 渲染函数。返回组件中渲染的内容。注意，只能返回唯一 一个顶级元素回去 ReactDom.render(&lt;Root/&gt;, document.getElementById(&#39;root&#39;)); 第一个参数是JSXElement对象，第二个是DOM的Element元素。将React元素添加到DOM的Element元素中并渲染 还可以使用React.createElement创建react元素，第一参数是React组件或者一个HTML的标签名称（例如div、span） 改写后代码为12345678910import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; render() &#123; //return &lt;div&gt;Hello World&lt;/div&gt;; return React.createElement('div', null, 'Hello World'); &#125;&#125;//ReactDom.render(&lt;Root/&gt;, document.getElementById('root'));ReactDom.render(React.createElement(Root), document.getElementById('root')); 很明显JSX更简洁易懂，推荐使用JSX语法 增加一个子元素 123456789101112131415161718192021import React from 'react';import ReactDom from 'react-dom';class SubEle extends React.Component &#123; render() &#123; return &lt;div&gt;Sub content&lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Hello World&lt;/h2&gt; &lt;br /&gt; &lt;SubEle /&gt; &lt;/div &gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 注意： React组件的render函数return，只能是一个顶级元素 JSX语法是XML，要求所有元素必须闭合，注意 &lt;br /&gt; 不能写成 &lt;br&gt;JSX规范 约定标签中首字母小写就是html标记，首字母大写就是组件 要求严格的HTML标记，要求所有标签都必须闭合 br也应该写成 &lt;br /&gt; ，/前留一个空格 单行省略小括号，多行请使用小括号 元素有嵌套，建议多行，注意缩进 JSX表达式：表达式使用{}括起来，如果大括号内使用了引号，会当做字符串处理，例如 &lt;div&gt;{&#39;2&gt;1?true:false&#39;}&lt;/div&gt; 里面的表达式成了字符串组件状态state每一个React组件都有一个状态属性state，它是一个JavaScript对象，可以为它定义属性来保存值如果状态变化了，会触发UI的重新渲染。使用setState()方法可以修改state值注意：state是每个组件自己内部使用的，是组件自己的属性 依然修改/src/index.js1234567891011121314151617181920import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; // this.state.p1 = 'python.com'; // 可以修改属性值 // this.setState(&#123;p1:'python.com'&#125;); // 不可以对还在更新中的state使用setState // Warning: setState(...): Cannot update during an existing state transition (such as within render). setTimeout(() =&gt; this.setState(&#123; p1: 'python' &#125;), 5000); return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 如果将 ·this.state.p1 = ‘www.python&#39;· 改为 ·this.setState({p1:’python.com’});· 就会出警告 可以使用延时函数 setTimeout(() =&gt; this.setState({ p1: &#39;python.com&#39; }), 5000); 即可复杂的状态例子先看一个网页123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; function getEventTrigger(event) &#123; x = event.target; // 从事件中获取元素 alert("触发的元素的id是：" + x.id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="t1" onmousedown="getEventTrigger(event)"&gt; 点击这句话，会触发一个事件，并弹出一个警示框 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div的id是t1，鼠标按下事件捆绑了一个函数，只要鼠标在对象上按下就会触发调用getEventTrigger函数，浏览器会送给它一个参数event。event是事件对象，当事件触发时，event包含触发这个事件的对象 HTML DOM的JavaScript事件 属性 此事件发生在何时 onabort 图像的加载被中断 onblur 元素失去焦点 onchange 域的内容被改变 onclick（常用） 当用户点击某个对象时调用的事件句柄 ondblclick 当用户双击某个对象时调用的事件句柄 onerror 在加载文档或图像时发生错误 onfocus 元素获得焦点 onkeydown 某个键盘按键被按下 onkeypress 某个键盘按键被按下并松开 onkeyup 某个键盘按键被松开 onload 一张页面或一幅图像完成加载 onmousedown 鼠标按钮被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标移到某元素之上 onmouseup 鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被重新调整大小 onselect 文本被选中 onsubmit 确认按钮被点击 onunload 用户退出页面 使用React实现上面的传统的HTML1234567891011121314151617181920212223242526272829303132import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 分析Toggle类 它有自己的state属性 当render完成后，网页上有一个div标签，div标签对象捆绑了一个click事件的处理函数，div标签内有文本内容 如果通过点击左键，就触发了click方法关联的handleClick函数，在这个函数里将状态值改变 状态值state的改变将引发render重绘 如果组件自己的state变了，只会触发自己的render方法重绘 注意 {this.handleClick.bind(this)}，不能外加引号 this.handleClick.bind(this) 一定要绑定this，否则当触发捆绑的函数时，this是函数执行的上下文决定的，this已经不是触发事件的对象 console.log(event.target.id)，取回的产生事件的对象的id，但是这不是我们封装的组件对象。所以，console.log(event.target===this)是false。所以这里一定要用this，而这个this是通过绑定来的 this写在类中，始终指的是React组件实例本身 React中的事件 使用小驼峰命名 使用JSX表达式，表达式中指定事件处理函数 不能使用return false，如果要阻止事件默认行为，使用event.preventDefault() 属性propsprops就是组件的属性properties把React组件当做标签使用，可以为其增加属性，如下 &lt;Toggle name=&quot;school&quot; parent={this} /&gt; 为上面的Toggle元素增加属性： name = &quot;school&quot; ，这个属性会作为一个单一的对象传递给组件，加入到组件的props属性中 parent = {this} ，注意这个this是在Root元素中，指的是Root组件本身 在Root中为使用JSX语法为Toggle增加子元素，这些子元素也会被加入Toggle组件的props.children中 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1&#125;&#123;this.props.parent.state.p2&#125; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 尝试修改props中的属性值，会抛出 TypeError: Cannot assign to read only property &#39;name&#39; of object &#39;#&lt;Object&gt;&#39;异常 也就是说props在组件内部不能修改，只读 应该说，state是私有private的属于组件自己的属性，组件外无法直接访问。可以修改state，但是建议使用setState方法 props是公有public属性，组件外也可以访问，但组件内只读props是一种组件外部传入向组件内部传入数据的一种方式，只不过采用标签属性的方式 构造器constructor使用ES6的构造器，要提供一个参数props，并把这个参数使用super传递给父类1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; //state = &#123; flag: true &#125;; // 类中定义state constructor(props) &#123; super(props); // 一定要调用super父类构造器，否则报错 this.state = &#123; flag: true &#125;; // 类中定义state &#125; handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1&#125;&#123;this.props.parent.state.p2&#125; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 组件的生命周期组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 组件的生命周期状态，说明在不同时机访问组件，组件正处在生命周期的不同状态上。在不同的生命周期状态访问，就产生不同的方法。 生命周期的方法如下： 装载组件触发 componentWillMount 在渲染前调用，在客户端也在服务端。只会在装载之前调用一次 componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送A JAX请求等操作(防止异部操作阻塞UI)。只在装载完成后调用一次，在render之后 更新组件触发。这些方法不会在首次render组件的周期调用 componentWillReceiveProps(nextProps) 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用 shouldComponentUpdate(nextProps,nextState)返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用 可以在你确认不需要更新组件时使用 如果设置为false，就是不允许更新组件，那么componentWillUpdate、componentDidUpdate不会执行 componentWillUpdate(nextProps, nextState) 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用 componentDidUpdate(prevProps, prevState) 在组件完成更新后立即调用。在初始化时不会被调用。 卸载组件触发 componentWillUnmount在组件从 DOM 中移除的时候立刻被调用由图可知 constructor构造器是最早执行的函数 组件构建好之后，如果更新组件的state或props（注意在组件内props是只读的），就会在render渲染前触发一系列的 更新生命周期函数 因此，重新编写/src/index.js构造两个组件，在子组件Sub中，加入所有生命周期函数 下面的例子添加是装载、卸载组件的生命周期函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from 'react';import ReactDom from 'react-dom';class Sub extends React.Component &#123; constructor(props) &#123; console.log('Sub constructor') super(props); // 调用父类构造器 this.state = &#123; count: 0 &#125;; &#125; handleClick(event) &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125; render() &#123; console.log('Sub render'); return (&lt;div id="sub" onClick=&#123;this.handleClick.bind(this)&#125;&gt; Sub's count = &#123;this.state.count&#125; &lt;/div&gt;); &#125; componentWillMount() &#123; // constructor之后，第一次render之前 console.log('Sub componentWillMount'); &#125; componentDidMount() &#123; // 第一次render之后 console.log('Sub componentDidMount'); &#125; componentWillUnmount() &#123; // 清理工作 console.log('Sub componentWillUnmount'); &#125;&#125;class Root extends React.Component &#123; constructor(props) &#123; console.log('Root Constructor') super(props); // 调用父类构造器 // 定义一个对象 this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Sub /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 上面可以看到顺序是 1constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount ----state或props改变----&gt; render 增加 更新组件函数为了演示props的改变，为Root元素增加一个click事件处理函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React from 'react';import ReactDom from 'react-dom';class Sub extends React.Component &#123; constructor(props) &#123; console.log('Sub constructor') super(props); // 调用父类构造器 this.state = &#123; count: 0 &#125;; &#125; handleClick(event) &#123; this.setState(&#123; count: this.state.count + 1 &#125;);// 不要用++ &#125; render() &#123; console.log('Sub render'); return (&lt;div style=&#123;&#123; height: 200 + 'px', color: 'red', backgroundColor: '#f0f0f0', padding: '20px' &#125;&#125;&gt; &lt;a id="sub" onClick=&#123;this.handleClick.bind(this)&#125; style=&#123;&#123; backgroundColor: 'white' &#125;&#125;&gt; Sub's count = &#123;this.state.count&#125; &lt;/a&gt; &lt;/div&gt;); &#125; componentWillMount() &#123; // constructor之后，第一次render之前 console.log('Sub componentWillMount'); &#125; componentDidMount() &#123; // 第一次render之后 console.log('Sub componentDidMount'); &#125; componentWillUnmount() &#123; // 清理工作 console.log('Sub componentWillUnmount'); &#125; componentWillReceiveProps(nextProps) &#123; // props变更时，接到新props了，交给shouldComponentUpdate。 // props组件内只读，只能从外部改变 console.log(this.props); console.log(nextProps); console.log('Sub componentWillReceiveProps', this.state.count); &#125; shouldComponentUpdate(nextProps, nextState) &#123; // 是否组件更新，props或state方式改变时，返回布尔值，true才会更新 console.log('Sub shouldComponentUpdate', this.state.count, nextState); return true; // return false将拦截更新 &#125; componentWillUpdate(nextProps, nextState) &#123; // 同意更新后，真正更新前，之后调用render console.log('Sub componentWillUpdate', this.state.count, nextState); &#125; componentDidUpdate(prevProps, prevState) &#123; // 同意更新后，真正更新后，在render之后调用 console.log('Sub componentDidUpdate', this.state.count, prevState); &#125;&#125;class Root extends React.Component &#123; constructor(props) &#123; console.log('Root Constructor') super(props); // 调用父类构造器 // 定义一个对象 this.state = &#123; flag: true, name: 'root' &#125;; &#125; handleClick(event) &#123; this.setState(&#123; flag: !this.state.flag, name: this.state.flag ? this.state.name.toLowerCase() : this.state.name.toUpperCase() &#125;); &#125; render() &#123; return ( &lt;div id="app" onClick=&#123;this.handleClick.bind(this)&#125;&gt; My Name is &#123;this.state.name&#125; &lt;hr /&gt; &lt;Sub /&gt; &#123;/*父组件的render，会引起下一级组件的更新流程，导致props重新发送，即使子组件props没有 改变过*/&#125; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); componentWillMount 第一次装载，在首次render之前。例如控制state、propscomponentDidMount 第一次装载结束，在首次render之后。例如控制state、props componentWillReceiveProps 在组件内部，props是只读不可变的，但是这个函数可以接收到新的props，可以对props做一些处理，this.props = {name:’roooooot’};这就是偷梁换柱。componentWillReceiveProps触发，也会走shouldComponentUpdateshouldComponentUpdate 判断是否需要组件更新，就是是否render，精确的控制渲染，提高性能componentWillUpdate 在除了首次render外，每次render前执行，componentDidUpdate在render之后调用 不过，大多数时候，用不上这些函数，这些钩子函数是为了精确的控制 修改Root组件render中的这一句为 &lt;div id=&quot;root&quot; onDoubleClick={this.handleClick.bind(this)}&gt; ，可以看到点击Sub中红色的文字，Root不会重绘 如果子组件和父组件使用了相同的事件，可以认为点击子组件也是点击了父组件，父组件重绘，就会把子组件props更新，引起子组件组件更新流程，就会从componentWillReceiveProps开始执行。如果子组件自己修改自己的state，不会执行componentWillReceiveProps 函数式组件 React从15.0开始支持函数式组件，定义如下1234567import React from 'react';import ReactDom from 'react-dom';function Root(props) &#123; return &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 开发中，很多情况下，组件其实很简单，不需要state状态，也不需要使用生命周期函数函数式组件的函数应该提供一个参数props，返回一个React元素函数式组件的函数本身就是render函数 改写上面代码123456import React from 'react';import ReactDom from 'react-dom';let Root = props =&gt; &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 以前函数式组件还有个名字叫stateless components无状态组件当前React发布了16.8，已经可以在函数式组件中使用state了，所以官方建议叫函数式组件]]></content>
      <categories>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2Fjs%2F%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[前端风云录 前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 html html(hypertext markup language)超文本标记语言,它不同于编程语言 超文本就是超出纯文本的范畴, 例如描述文本的颜色、大小、字体等信息、 或使用图片音频、 视屏等非文本内容. 12345html定义了网页的内容css描述了网页的布局javascript网页的行为 cs原理client客户端向server发起请求 通过资源定位符, 找到映射文件, server端读取文件后, 一个个字节又通过管道发回到客户端, 客户端收到之后save下来, 打开html 文本流就是字节流(区别是字节流没有编码) . 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Web 2.0Ajax 技术促成了 Web 2.0 的诞生。 Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 12345678var AppView = Backbone.View.extend(&#123; // ... events: &#123; "keypress #new-todo": "createOnEnter", "click #clear-completed": "clearCompleted", "click #toggle-all": "toggleAllComplete" &#125;,&#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123; '': 'index', 'show': 'show' &#125;, index: function () &#123; $(document.body).append("调用了 Index 路由"); &#125;, show: function () &#123; $(document.body).append("调用了 Show 路由"); &#125;,&#125;); 示例：Backbone Router打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。 MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。 传统的架构 单页应用的架构 多了一个前端 MVC 层 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 1234567891011&lt;div ng-app=""&gt; &lt;p&gt; 姓名 : &lt;input type="text" ng-model="name" placeholder="在这里输入您的大名" &gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id="journal"&gt; &lt;input type="text" v-model="message"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端 现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端风云录]]></title>
    <url>%2Fjs%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%A3%8E%E4%BA%91%E5%BD%95%2F</url>
    <content type="text"><![CDATA[@TOC HTMLHTML（HyperText Markup Language）超文本标记语言，它不同于编程语言 超文本就是超出纯文本的范畴，例如描述文本的颜色、大小、字体等信息，或使用图片、音频、视频等非文本内容 HTML由一个个标签组成，这些标签各司其职。有的提供网页信息，有的负责图片，有的负责网页布局 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 超文本需要显示，就得有软件能够呈现超文本定义的排版格式，例如显示图片、表格，显示字体的大小、颜色，这个软件就是浏览器 超文本的诞生是为了解决纯文本不能格式显示的问题，是为了好看，但是只有通过网络才能分享超文本的内容，所以制定了HTTP协议 浏览器历史1980年代，Tim Berners-Lee为CERN（欧洲核子研究中心，当时欧洲最大的互联网节点）设计基于超文本思想的ENQUIRE项目，以促进科研人员之间的信息共享和更新。1989年他编写了《信息化管理：建议》一文，并构建基于Internet的Hypertext系统，并在CERN开发了World Wide Web项目，打造了世界上第一个网站，于1991年8月6日正式上线 Tim Berners-Lee于1990年发明了第一个浏览器，还发明了HTTP协议 1994年MIT他创建了W3C。W3C万维网联盟，负责万维网持续发展。他提出W3C的标准应该基于无专利权、无版税 Marc Andreessen于1993年发明了Mosaic浏览器，看到了这个技术的前景，不久后他成立自己的公司——网景Netscape。1994发布了Netscape Navigator浏览器，席卷全球 1995年微软发布IE，开启第一次浏览器大战，最终后来居上 由于IE的捆绑销售行为，网景的单一浏览器市场萎缩，从1990年代的90%下降至2006年的1%1999年网景被AOL收购，收购后不久，Netscape公开了浏览器代码，并创建了Mozilla组织。Mozilla组织使用Gecko引擎重写浏览器Mozilla组织使用Gecko引擎发布了几款浏览器，最终于2004年更名为Firefox浏览器2003年5月，网景被解散AOL于2007年12月宣布停止支持Netscape浏览器 Apple的Safari于2003发布第一个测试版 2008年Google的Chrome浏览器带着 V8 引擎横空出世 网景公司的技术： HTTP Cookie，解决HTTP无状态 JavaScript SSL协议 JAR格式文件，将Java的class文件打包压缩，并加上签名 2012年4月9日，微软以10亿5千6百万美元购买800项美国在线的专利或专利授权，专家们认为网景的SSL、Cookie等专利可能是微软愿意出高价的理由之一【摘自wiki百科】 浏览器技术浏览器是一种特殊的客户端，能够基于HTTP(s)、FTP等协议和WEB服务器进行交互，呈现网页内容的软件可以简单的认为浏览器软件分为2个部分： 外壳 外壳提供用户交互的界面 内核（引擎Engine） 提供HTML、CSS、图像的渲染引擎，提供DOM编程接口 提供JavaScript引擎 提供浏览器内建对象 |排版（渲染）引擎| 浏览器 | 说明||:–|:–|:–|| Gecko | Firefox | C++开发并最早开源，可以支持复杂的网页效果，提供强大的浏览器扩展接口||Trident | IE、AOL| 早期未按照W3C标准实现，兼容性很差，IE9之后内核升级以符合标准|| KHTML| | KDE，于1998年开发 ||Presto | Opera | 目前公认的网页浏览速度最快的内核，但牺牲一部分兼容性 ||WebKit | Safari、Chrome |WebKit基于KHTML开发。网页浏览速度较快，但网页容错性不高||Blink |Chrome、Opera |基于WebKit WebCore |其他国内浏览器，一般都是采用了以上的一个或两个内核加上外壳实现 JS引擎不同浏览器内核中也使用不同的JS引擎，常见的JS引擎有JScript、TraceMonkey（Firefox）、V8等这些引擎差异不小，实现ECMA标准不同，甚至有不按照标准实现的使用jQuery等框架来解决兼容性问题，抹平平台差异 JavaScriptJSJavascript 简称JS，是一种动态的弱类型脚本解释性语言，和HTML、CSS并称三大WEB核心技术，得到了几乎主流浏览器支持 1994年，网景Netscape公司成立并发布了Netscape Navigator浏览器，占据了很大的市场份额，网景意识到WEB需要动态，需要一种技术来实现 1995年9月网景浏览器2发布测试版本发布了LiveScript，随即在12月的测试版就更名为JavaScript。同时期，微软推出IE并支持JScript、VBScript，与之抗衡 1997年，网景、微软、SUN、Borland公司和其他组织在ECMA确定了ECMAScript语言标准。JS就成为ECMAScript标准的实现之一 ESES，ECMAScript是由ECMA国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。该语言被广泛的应用于互联网 JavaScript是商品名，目前商标权在Oracle公司手中。ES是标准名根据ES标准，有很多实现引擎，其中包括JavaScript、JScript等，它们都ECMA-262标准的实现和扩展 为什么之前浏览器兼容是个大问题？HTML、CSS、JS技术都在发展，标准版本很多。浏览器内嵌的引擎实现不太一致，甚至有不按照标准实现，或减少实现，或改变实现，或增加功能的实现，比如IE，这就导致了开发人员负担，很难做到一套代码可以兼容地跑在多种浏览器中，甚至都不能跑在同一种浏览器的不同版本中 1997年，制定首个版本ECMA-2621999年12月，ES 3，支持更强大的正则表达式等ES4太激进，最终放弃2009年，ES5发布，得到广泛支持。支持严格模式，支持Json2015年，ES6发布，引入非常多的新的语言特性，还兼容旧版本特性。ES6之前按照版本号命名，从ES6开始使用年份作为版本号，ES6即ECMAScript 2015 JavaScript 的标准是 ECMAScript。截至 2012 年，所有的现代浏览器都完整的支持 ECMAScript 5.1，旧式的浏览器至少支持 ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了 ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为 ECMAScript 6 或者 ES6。自此，ECMAScript 每年发布一次新标准。本文档目前覆盖了最新 ECMAScript 的草案，也就是 ECMAScript2019 – 摘自MDN V8 引擎就在浏览器市场一家独大的时候，Firefox、chrome异军突起2008年9月2日，Google的chrome浏览器发布，一并发布的Js引擎，就是V8引擎。V8使用BSD协议开源 V8引擎使用 C++ 开发，将JavaScript编译成了机器码，而不是字节码，还用很多优化方法提高性能，因此，V8引擎速度非常快V8引擎还可以独立运行，可以嵌入到其他任何C++程序中V8引擎的诞生，使得服务器端运行JS成为了可能且方便的事情 2009年，基于V8引擎，诞生了Nodejs，这是服务器端运行JS的运行环境 CSS（Cascading Style Sheets）层叠样式表HTML本身为了格式化显示文本，但是当网页呈现大家面前的时候，需求HTML提供更多样式能力。这使得HTML变得越来越臃肿。这促使了CSS的诞生 1994年，W3C成立，CSS设计小组所有成员加入W3C，并努力研发CSS的标准，微软最终加入1996年12月发布CSS 1.01998年5月发布CSS 2.0CSS 3采用了模块化思想，每个模块都在CSS 2基础上分别增强功能。所以，这些模块是陆续发布的 不同厂家的浏览器使用的引擎，对CSS的支持不一样，导致网页布局、样式在不同浏览器不一样。因此，想要保证不同用户使用不同浏览器看到的网页效果一直非常困难 动态网页技术JS的引入使得浏览器可以显示动态的效果，但这不是动态网页 发明WEB技术的初衷是为了分享文档，而这些内容是静态的，就是写好的不变的文件。通过URL定位到这些文档，将内容下载到浏览器上，由浏览器呈现 互联网发展，网民的需求增加，大家希望提供交互式访问。用户提交需求，服务端找到需求匹配的资源并发回浏览器端显示。这就是动态网页动态网页指的是网页的内容是动态的，URL不变，里面的内容变化。例如访问一个查询页面，提交的关键字不同，下面表格的内容变化动态网页，表现的是浏览器端内容的变化，而本质上它是一种服务端动态网页技术server-side dynamic web page。最早诞生的动态网页技术有ASP、JSP、PHP等，后来几乎所有流行的高级语言都提供了开发动态网页的能力 网页布局早期的网页只需要简单的显示标题、正文、图片，使用&lt;P&gt;标签分段后来有人大量使用表格标签，可以做到很好的内容布局，也出现结构化的布局方案。但随着页面内容的堆积，出现了成百上千个表格嵌套的情况，浏览器绘制很慢后来出现了Div + CSS布局风格，舍弃了表格布局，加上JavaScript，使得前后端开发分离，而且可以做到很好的自适应布局。例如流式瀑布一样的布局 同步和异步同步早期，网页就是一页页的文本，没什么图片、样式后来，互联网时代到来，网页内容越来越多，页面文件越来越大浏览器渲染HTML，需要先下载CSS加载，为的是准备渲染网页之后，下载网页内容，并逐步渲染。还要构建DOM树，加载JS脚本并执行，JS可能需要修改DOM，网页就要重新渲染如果JS放在网页HEAD中，还需要等待JS下载并加载图片使用 &lt;img&gt; 标签，是发起新的HTTP请求，如果图片返回，需要重新绘制网页好不容易，一张网页绘制完毕。这里面发起了很多的HTTP请求 交互式网页，用户提交了请求，就是想看到查询的结果。服务器响应到来后是一个全新的页面内容，哪怕URL不变，整个网页都需要重新渲染。例如，用户填写注册信息，只是2次密码不一致，提交后，整个注册页面重新刷新，所有填写项目重新填写（当然有办法让用户减少重填）。这种交互非常不友好从代价的角度看，就是为了注册的一点点信息，结果返回了整个网页内容，不但浪费了网络带宽，还需要浏览器重新渲染网页，太浪费资源了，影响了用户体验和感受 上面这些请求的过程，就是同步过程，用户发起请求，页面整个刷新，直到服务器端响应的数据到来并重新渲染 异步1996年微软实现了iframe标签，可以在一个网页使用iframe标签局部异步加载内容1999年微软推出异步数据传输的ActiveX插件技术，太笨重了，但是也火了很多年。有一个组件XMLHttpRequest被大多数浏览器支持 A JAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），使用XMLHttpRequest组件，结合JS，数据格式采用XML（可扩展标记语言），将这三者结合，实现网页的异步请求。A JAX是一种技术的组合，技术的重新发现，而不是发明，但是它深远的影响了整个WEB开发 2005，google在Gmail和地图中应用Ajax，使它大受欢迎并推广开来 有了异步请求，就可以动态的从浏览器发起请求到服务器端，服务器端返回响应的数据封装成XML（JSON）返回给浏览器，浏览器只需要使用JS把内容加入到DOM中，局部渲染就可以了。这个过程中，整个网页不用重新刷新，只需要局部动态改变即可 前端开发早期前端开发使用网页三剑客：Dreamweaver、Firework、Flash。微软的有Frontpage 不管使用什么工具，都不能改变JS兼容、CSS兼容、浏览器版本兼容问题 2006年 jQuery库诞生，出现了JS框架，抹平了平台差异。基于它产生了众多的插件，前端开发终于轻松了些 2008年 V8引擎伴随着Chrome浏览器发布2009年 ES5标准发布2009年 Nodejs发布，服务器端也可以使用JavaScript了2009年 AngularJS诞生，之后被谷歌收购2010年 Backbone.js诞生2011年 React和ember诞生，React于2013年5月开源2014年 国人 尤雨溪 的Vue.js诞生2014年 HTML5标准发布 前端工具和框架越来越多，前端开发已经不是随便使用一个什么文本编辑器就可以完成的了。如果使用框架，需要很多工具的配合，配置好一个开发环境非常重要 硬件发展最初，网页就是简单的文本，计算机轻松胜任后来，网页对多媒体的支持，动态效果的支持，都需要使用大量的CPU、内存资源，甚至是显卡的渲染能力所以，个人PC需要不断升级，否则浏览网页很困难 移动互联网到来的早期，手机看的网页，都需要单独处理手机屏幕小、CPU弱、内存小，能看的网页纯文本加小图。这样产生的流量也小，2G时代谈不上网速2007年第一代IPhone诞生，2008年安卓手机诞生，3G的移动互联网时代到来了手机硬件水平不断提升，手机的开发平台可以让众多开发者开发APP，用户可以下载安装使用这些APP对于开发者来说，开发就是个问题了，是不是需要开发一套IPhone版本、再开发一套安卓，在开发一套网页的版本呢？2013年，中国开始进入4G时代。手机硬件水平也得到了很大的提升众多平台都在思考是否能够一套架构，解决所有前端问题。使用的还是最通用的技术网页+JS 如今的前端开发已经不是以前的几个js文件、几百行代码了。为了适应需求，新框架、新编程模式不断涌现，这些工具都大大方便了协作开发，同时解决平台兼容性问题]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL%2F</url>
    <content type="text"><![CDATA[@[toc] 关系模型和SQL为了介绍关系模型，以MySQL数据库为例 安装MariaDB 安装 # yum list | grep mariadb 123456789101112mariadb-libs.x86_64 1:5.5.60-1.el7_5 @anacondamariadb.x86_64 1:5.5.60-1.el7_5 base mariadb-bench.x86_64 1:5.5.60-1.el7_5 base mariadb-devel.i686 1:5.5.60-1.el7_5 base mariadb-devel.x86_64 1:5.5.60-1.el7_5 base mariadb-embedded.i686 1:5.5.60-1.el7_5 base mariadb-embedded.x86_64 1:5.5.60-1.el7_5 base mariadb-embedded-devel.i686 1:5.5.60-1.el7_5 base mariadb-embedded-devel.x86_64 1:5.5.60-1.el7_5 base mariadb-libs.i686 1:5.5.60-1.el7_5 base mariadb-server.x86_64 1:5.5.60-1.el7_5 base mariadb-test.x86_64 1:5.5.60-1.el7_5 base 安装mariadb 服务，会自动安装mairadb# yum install mariadb-server # systemctl start mariadb.service# ss -tanl12State Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 50 *:3306 *:* 开机启动 systemctl enable mariadb.service```123456789101112131415- 为了安全设置Mysql服务`# mysql_secure_installation`- 数据库密码登录`# mysql -u root -p````pythonmysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建并授权用户 12mysql&gt; grant all on *.* to 'tom'@'%' identified by 'tom';mysql&gt; flush privileges; 导入测试脚本 testsql文件# mysql -u root -p &lt; test.sql 如果使用客户端连接数据库提示这个证明防火墙未关闭，CentOS7可以使用systemctl stop firewalld.service来关闭，或者参考下面连接https://www.cnblogs.com/moxiaoan/p/5683743.html SQL语句SQL是结构化查询语言Structured Query Language。1987年被ISO组织标准化所有主流的关系型数据库都支持SQL，NoSQL也有很大一部分支持SQL SQL语句分为 DDL数据定义语言，负责数据库定义、数据库对象定义，由CREATE、ALTER与DROP三种语句组成 DML数据操作语言，负责对数据库对象的操作，CRUD增删改查 DCL数据控制语言，负责数据库权限访问控制，由 GRANT 和 REVOKE 两个指令组成 TCL事务控制语言，负责处理ACID事务，支持commit、rollback指令语言规范 SQL语句大小写不敏感一般建议，SQL的关键字、函数等大写 SQL语句末尾应该使用分号结束 注释多行注释/*注释内容*/单行注释 -- 注释内容MySQL 注释可以使用# 使用空格或缩进来提高可读性 命名规范必须以字母开头可以使用数字、#、$和_不可使用关键字DCL GRANT授权、REVOKE撤销 12GRANT ALL ON employees.* TO 'tom'@'%' IDENTIFIED by 'tom';REVOKE ALL ON *.* FROM tom; *为通配符，指代任意库或者任意表。 *.* 所有库的所有表； employees.* 表示employees库下所有的表 % 为通配符，它是SQL语句的通配符，匹配任意长度字符串DDL删除用户（慎用）DROP USER tom;创建数据库 库是数据的集合，所有数据按照数据模型组织在数据库中 12CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8; CHARACTER SET指定字符集 utf8mb4是utf8的扩展，支持4字节utf8mb4，需要MySQL5.5.3+ COLLATE指定字符集的校对规则，用来做字符串的比较的。例如a、A谁大？删除数据库DROP DATABASE IF EXISTS gogs;创建表 表分为行和列，MySQL是行存数据库。数据是一行行存的，列必须固定多少列 行Row，也称为记录Record，元组 列Column，也称为字段Field、属性 字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值123456789CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL, `birth_date` date NOT NULL, `first_name` varchar(14) NOT NULL, `last_name` varchar(16) NOT NULL, `gender` enum('M','F') NOT NULL, `hire_date` date NOT NULL, PRIMARY KEY (`emp_no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 反引号标注的名称，会被认为是非关键字，使用反引号避免冲突 DESC查看列信息{DESCRIBE | DESC} tbl_name [col_name | wild]12DESC employees;DESC employees '%name'; 练习设计一张表，记录登录账户的注册信息，应该存储用户的姓名、登录名、密码12DROP DATABASE IF EXISTS test;CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 1234567CREATE TABLE `reg` ( `id` int(11) NOT NULL, `loginname` varchar(50) NOT NULL, `name` varchar(64) DEFAULT NULL, `password` varchar(128) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB; 关系 在关系数据库中，关系就是二维表，由行和列组成行Row，也称为记录Record，元组列Column，也称为字段Field、属性 字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值 维数：关系的维数指关系中属性的个数基数：元组的个数 注意在关系中，属性的顺序并不重要。理论上，元组顺序也不重要，但是由于元组顺序与存储相关，会影响查询效率 候选键 关系中，能唯一标识一条元组的属性或属性集合，称为候选键PRIMARY KEY主键 表中一列或者多列组成唯一的key，也就是通过这一个或者多个列能唯一的标识一条记录。即被选择的候选键 主键的列不能包含空值null。主键往往设置为整型、长整型，可以为自增AUTO_INCREMENT字段 表中可以没有主键，但是，一般表设计中，往往都会有主键，以避免记录重复Foreign KEY外键严格来说，当一个关系中的某个属性或属性集合与另一个关系（也可以是自身）的候选键匹配时，就称作这个属性或属性集合是外键索引Index可以看做是一本字典的目录，为了快速检索用的。空间换时间，显著提高查询效率可以对一列或者多列字段设定索引 主键索引，主键会自动建立主键索引，主键本身就是为了快速定位唯一记录的唯一索引，表中的索引列组成的索引必须唯一，但可以为空，非空值必须唯一普通索引，没有唯一性的要求，就是建了一个字典的目录而已 在MySQL中，InnoDB和MyISAM的索引数据结构可以使用Hash或BTree，默认是BTree Hash时间复杂度是O(1)，但是只能进行精确匹配，也就是Hash值的匹配，比如范围匹配就没办法了，hash值无序所以无法知道原有记录的顺序。Hash问题较多 BTree索引，以B+树为存储结构 虽然，索引可以提高查询所读，但是却影响增删改的效率，因为需要索引更新或重构。频繁出现在where子句中的列可以考虑使用索引。要避免把性别这种字段设索引 约束Constraint为了保证数据的完整正确，数据模型还必须支持完整性约束 “必须有值”约束 某些列的值必须有值，不许为空NULL域约束Domain Constraint 限定了表中字段的取值范围实体完整性Entity Integrity PRIMARY KEY约束定义了主键，就定义了主键约束。主键不重复且唯一，不能为空引用完整性Referential Integrity *** 外键定义中，可以不是引用另一张表的主键，但是，往往实际只会关注引用主键 外键：在表B中的列，引用了表A中的主键，表B中的列就是外键A表称为主表，B表称为从表插入规则 不需要指定 如果在表B插入一条记录，B的外键列插入了一个值，这个值必须是表A中存在的主键值更新规则 定义外键约束时指定该规则删除规则 定义外键约束时指定该规则外键约束的操作| 设定值| 说明 ||:–|:–|| CASCADE | 级联，从父表删除或更新会自动删除或更新子表中匹配的行 || SET NULL | 从父表删除或更新行，会设置子表中的外键列为NULL，但必须保证子表列没有指定NOT NULL，也就是说子表的字段可以为NULL才行|| RESTRICT | 如果从父表删除主键，如果子表引用了，则拒绝对父表的删除或更新操作 ||NO ACTION | 标准SQL的关键字，在MySQL中与RESTRICT相同。拒绝对父表的删除或更新操作 |外键约束，是为了保证数据完整性、一致性，杜绝数冗余、数据错误实体-联系E-R 数据库建立，需要收集用户需求，设计符合企业要求的数据模型。而构建这种模型需要方法，这种方法需要成为E-R实体-联系建模。也出现了一种建模语言——UML（Unified Modeling Language）统一建模语言 实体Entity：现实世界中具有相同属性的一组对象，可以是物理存在的事物或抽象的事物 联系Relationship：实体之间的关联集合实体间联系类型假设有实体部门，实体员工| 类型 | 描述| 解决方案||:–|:–|:–|| 一对多联系 1:n | 一个员工属于一个部门，一个部门有多个员工 |员工外键；部门主键 || 多对多联系 m:n| 一个员工属于多个部门，一个部门有多个员工 |建立第三表 || 一对一联系 1:1| 假设有实体管理者，一个管理者管理一个部门，一个部门只有一个管理者 |字段建在哪张表都行|一对一关系用的较少，往往表示表A的一条记录唯一关联表B的一条记录，反之亦然它往往是为了将一张表多列分割并产生成了多张表，合起来是完整的信息，或为了方便查询，或为了数据安全隔离一部分字段的数据等等视图视图，也称虚表，看起来像表。它是由查询语句生成的。可以通过视图进行CRUD操作视图的作用 简化操作，将复杂查询SQL语句定义为视图，可以简化查询 数据安全，视图可以只显示真实表的部分列，或计算后的结果，从而隐藏真实表的数据数据类型 MySQL中的数据类型 类型 含义 tinyint 1字节，带符号的范围是-128到127。无符号的范围是0到255。bool或boolean，就是tinyint，0表示假，非0表示真 smallint 2字节，带符号的范围是-32768到32767。无符号的范围是0到65535 int 整型，4字节，同Integer，带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295 bigint 长整型，8字节，带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615 float 单精度浮点数精确到大约7位小数位 double 双精度浮点数精确到大约15位小数位 DATE 日期。支持的范围为’1000-01-01’到’9999-12-31’ DATETIME 支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’ TIMESTAMP 时间戳。范围是’1970-01-01 00:00:00’到2037年 char(M) 固定长度，右边填充空格以达到长度要求。M为长度，范围为0~255。M指的是字符个数 varchar(M) 变长字符串。M 表示最大列长度。M的范围是0到65,535。但不能突破行最大字节数65535 text 大文本。最大长度为65535(2^16-1)个字符 BLOB 大字节。最大长度为65535(2^16–1)字节的BLOB列 LENGTH函数返回字节数。而char和varchar定义的M是字符数限制 char可以将字符串定义为固定长度，空间换时间，效率略高；varchar为变长，省了空间关系操作关系：在关系数据库中，关系就是二维表关系操作就是对表的操作 选择（selection）：又称为限制，是从关系中选择出满足给定条件的元组 投影（projection）：在关系上投影就是从选择出若干属性列组成新的关系 连接（join）：将不同的两个关系连接成一个关系]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务和隔离级别]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL-%20%E4%BA%8B%E5%8A%A1%E3%80%81MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@[toc] 事务TransactionInnoDB引擎，支持事务。事务，由若干条语句组成的，指的是要做的一系列操作。 关系型数据库中支持事务，必须支持其四个属性（ACID）： 特性 描述 原子性（atomicity） 一个事务是一个不可分割的工作单位，事务中包括的所有操作要么全部做完，要么什么都不做 一致性（consistency） 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的 隔离性（isolation） 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（durability） 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响 原子性，要求事务中的所有操作，不可分割，不能做了一部分操作，还剩一部分操作 一致性，多个事务并行执行的结果，应该和事务排队执行的结果一致。如果事务的并行执行和多线程读写共享资源一样不可预期，就不能保证一致性 隔离性，就是指多个事务访问共同的数据了，应该互不干扰。隔离性，指的是究竟在一个事务处理期间，其他事务能不能访问的问题 持久性，比较好理解，就是事务提交后，数据不能丢失MySQL隔离级别隔离性不好，事务的操作就会互相影响，带来不同严重程度的后果首先看看隔离性不好，带来哪些问题： 更新丢失Lost Update事务A和B，更新同一个数据，它们都读取了初始值100，A要减10，B要加100，A减去10后更新为90，B加100更新为200，A的更新丢失了，就像从来没有减过10一样 脏读事务A和B，事务B读取到了事务A未提交的数据（这个数据可能是一个中间值，也可能事务A后来回滚事务）。事务A是否最后提交并不关心。只要读取到了这个被修改的数据就是脏读 不可重复读Unrepeatable read事务A在事务执行中相同查询语句，得到了不同的结果，不能保证同一条查询语句重复读相同的结果就是不可以重复读例如，事务A查询了一次后，事务B修改了数据，事务A又查询了一次，发现数据不一致了注意，脏读讲的是可以读到相同的数据的，但是读取的是一个未提交的数据，而不是提交的最终结果。 幻读Phantom read事务A中同一个查询要进行多次，事务B插入数据，导致A返回不同的结果集，如同幻觉，就是幻读数据集有记录增加了，可以看做是增加了记录的不可重复读 有了上述问题，数据库就必须要解决，提出了隔离级别。隔离级别由低到高，如下表|隔离级别| 描述 ||:–|:–|| READ UNCOMMITTED | 读取到未提交的数据|| READ COMMITTED | 读已经提交的数据，ORACLE默认隔离级别 || REPEATABLE READ |可以重复读，MySQL的 默认隔离级别 || SERIALIZABLE |可串行化。事务间完全隔离，事务不能并发，只能串行执行 |隔离级别越高，串行化越高，数据库执行效率低；隔离级别越低，并行度越高，性能越高隔离级别越高，当前事务处理的中间结果对其它事务不可见程度越高 设置会话级或者全局隔离级别 12SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL&#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 查询隔离级别 12345SELECT @@global.tx_isolation;SELECT @@tx_isolation;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; 禁用自动提交 1SET AUTOCOMMIT = 0 SERIALIZABLE，串行了，解决所有问题 REPEATABLE READ，事务A中同一条查询语句返回同样的结果，就是可以重复读数据了。例如语句为(select * from user)。解决的办法有： 对select的数据加锁，不允许其它事务删除、修改的操作 第一次select的时候，对最后一次确切提交的事务的结果做快照 解决了不可以重复读，但是有可能出现幻读。因为另一个事务可以增删数据 READ COMMITTED，在事务中，每次select可以读取到别的事务刚提交成功的新的数据。因为读到的是提交后的数据，解决了脏读，但是不能解决 不可重复读 和 幻读 的问题。因为其他事务前后修改了数据或增删了数据 READ UNCOMMITTED，能读取到别的事务还没有提交的数据，完全没有隔离性可言，出现了脏读，当前其他问题都可能出现 事务语法 START TRANSACTION或BEGIN开始一个事务，START TRANSACTION是标准SQL的语法 使用COMMIT提交事务后，变更成为永久变更 ROLLBACK可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样（原子性） SET AUTOCOMMIT语句可以禁用或启用默认的autocommit模式，用于当前连接。SET AUTOCOMMIT = 0禁用自动提交事务。如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘数据仓库和数据库的区别本质上来说没有区别，都是存放数据的地方 但是数据库关注数据的持久化、数据的关系，为业务系统提供支持，事务支持 数据仓库存储数据的是为了分析或者发掘而设计的表结构，可以存储海量数据 数据库存储在线交易数据OLTP（联机事务处理OLTP，On-line Transaction Processing）；数据仓库存储历史数据用于分析OLAP（联机分析处理OLAP，On-Line Analytical Processing） 数据库支持在线业务，需要频繁增删改查；数据仓库一般囤积历史数据支持用于分析的SQL，一般不建议删改 游标Cursor 操作查询的结果集的一种方法 可以将游标当做一个指针，指向结果集中的某一行]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系模型和sql]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL%20(DML%20%E2%80%94%E2%80%94%20CRUD%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)%2F</url>
    <content type="text"><![CDATA[@toc所有操作一定要加==条件== Insert语句 向表中插入一行数据，自增字段、缺省值字段、可为空字段可以不写INSERT INTO table_name(col_name,...) VALUES (value1,...); 将select查询的结果插入到表中INSERT INTO table_name SELECT ... ; 如果主键冲突、唯一键冲突就执行update后的设置。这条语句的意思，就是主键不在新增记录，主键在就更新部分字段INSERT INTO table_name (col_name1,...) VALUES (value1,...) ON DUPLICATE KEY UPDATE col_name1=value1,...; 如果主键冲突、唯一键冲突就忽略错误，返回一个警告INSERT IGNORE INTO table_name (col_name,...) VALUES (value1,...);例：123456789INSERT INTO reg(loginname, `name`, `password`) VALUES('tom', 'tom', 'tom');INSERT INTO reg(if, loginname, `name`, `password`) VALUES (5, 'tom', 'tom', 'tom');INSERT INTO reg(id, loginname, `name`, `password`) VALUED (1, 'tom', 'tom', 'tom') ON DUPLICATE KEY UPDATE name = 'jerry' Update语句 IFNORE 意义同Insert语句 [IGNORE] tal_name SET col_name1123```python-- 例UPDATE reg SET name=&apos;tom· WHERE id=5; 注意这一句非常危险，会更新所有数据 1UPDATE reg SET name ='ben'; 更新一定要加条件 1UPDATE reg SET name = 'ben', password = 'benpwd' WHRER id = 1; Delete语句 删除符合条件的记录DELETE FROM tal_name [WHERE where_defintion] 删除一定要有条件1DELETE FROM reg WHERE id =1; Select语句123456789101112SELECT [DISTINCT] select_expr, ... [FROM table_references [WHERE where_definition] [FROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING whrer_definition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,&#125; roe_count | row_count OFFSET offset&#125;] [FOR UPDATE | LOCK IN SHARE MODE]] FOR UPDATE会把行进行写锁定，这是排它锁 查询 查询的结果成为结果集recordset 最简单的查询SELECT 1;SELECT * FROM employees; 字符串合并SELECT emp_no, first_name + last_name FROM employees; 执行前执行后 使用字符串相加函数 CONCATSELECT emp_no, CONCAT(first_name,&#39; &#39;,last_name) FROM employees; 执行后 AS定义别名，可选。 写AS是一个好习惯SELECT emp_no as en, CONCAT(first_name,&#39; &#39;,last_name) as name FROM employees; 执行后 Limit子句 返回5条记录， [1,5]左闭右闭SELECT * FROM employees as emp LIMIT 5; 返回5条记录，偏移3条，(3,8]左开右闭SELECT * FROM employees as emp LIMIT 3, 5;等价于SELECT * FROM employees as emp LIMIT 5 offset 3; ， Where子句 运算符 描述符 = 等于 &lt;&gt; 不等于 &gt;、 &lt;、 &gt;=、 &lt;= 大于、小于、大于等于、小于等于 BETWEEN 在某个范围之内，between a and b等价于[a, b] LIKE 字符串模式匹配，%表示任意多个字符，_表示一个字符 IN 指定针对某个列的多个可能值 AND 与 OR 或 能用键匹配用键 LIKE 只能使用左前缀，尽量不使用，性能差 注意：如果很多表达式需要使用AND、OR计算逻辑表达式的值的时候，由于有结合律的问题，建议使用小括号来避免产生错误 查询条件123SELECT * FROM employees WHERE emp_no &lt; 10015 and last_name LIKE 'P%';SELECT * FROM employees WHERE emp_no BETWEEN 10010 AND 10015 AND last_name LIKE 'P%';SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010); EXPLAIN 可判断查询条件性能如何12EXPLAIN SELECT emp_no AS id, birth_date, concat(FIRST_name, ' ', last_name) as name FROM employees as emp WHERE last_name='Sluis'; 12EXPLAIN SELECT emp_no AS id, birth_date, concat(FIRST_name, ' ', last_name) as name FROM employees as emp WHERE emp_no BETWEEN 10010 and 10015 and last_name='Sluis'; 说明第二个查询条件优于第一个 ORder by 子句对查询结果进行排序，可以升序ASC、降序DESC。默认不填为升序 升序SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY emp_no; 降序SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY emp_no DESC OROER BY 先执行，在执行 LIMIT12SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY birth_date, emp_no DESC LIMIT 1, 2; 会先按照第一条件进行排序，如果无法区分先后顺序，在使用第二条件进行排序DISTINCT不返回重复记录 原表 SELECT DISTINCT dept_no FROM dept_emp;执行结果如下 SELECT DISTINCT emp_no FROM dept_emp;执行结果如下 SELECT dept_no,emp_no FROM dept_emp;会将dept_no与emp_no看成二元祖来筛选聚合函数|函数 | 描述 ||:–|:–|| COUNT(expr) | 返回记录中记录的数目，如果指定列，则返回非NULL值的行数 || COUNT(DISTINCT expr,[expr…]) | 返回不重复的非NULL值的行数|| AVG([DISTINCT] expr) | 返回平均值，返回不同值的平均值 || MIN(expr), MAX(expr) | 最小值，最大值|| SUM([DISTINCT] expr) | 求和，Distinct返回不同值求和 | SELECT COUNT(*), AVG(emp_no), sum(emp_no), min(emp_no), max(emp_no) FROM employees; 原表 执行后1234SELECT emp_no, COUNT( emp_no ), sum( emp_no ), avg( emp_no ) AS sal_avg FROM employees WHERE emp_no &gt; 10001 GROUP BY emp_no HAVING sal_avg &gt; 10005 ORDER BY sal_avg DESC LIMIT 1; 执行顺序 ：HAVING &gt; select &gt; GROUP BY &gt; HAVING &gt; ORDER BY 分别查询使用Group by子句，如果有条件，使用Having子句过滤分组、聚合过的结果 原表1234567891011121314151617181920212223242526272829303132333435363738394041emp_no salary from_date to_date10001 60117 1986-06-26 1987-06-2610001 62102 1987-06-26 1988-06-2510001 66074 1988-06-25 1989-06-2510001 66596 1989-06-25 1990-06-2510001 66961 1990-06-25 1991-06-2510001 71046 1991-06-25 1992-06-2410001 74333 1992-06-24 1993-06-2410001 75286 1993-06-24 1994-06-2410001 75994 1994-06-24 1995-06-2410001 76884 1995-06-24 1996-06-2310001 80013 1996-06-23 1997-06-2310001 81025 1997-06-23 1998-06-2310001 81097 1998-06-23 1999-06-2310001 84917 1999-06-23 2000-06-2210001 85112 2000-06-22 2001-06-2210001 85097 2001-06-22 2002-06-2210001 88958 2002-06-22 9999-01-0110002 65828 1996-08-03 1997-08-0310002 65909 1997-08-03 1998-08-0310002 67534 1998-08-03 1999-08-0310002 69366 1999-08-03 2000-08-0210002 71963 2000-08-02 2001-08-0210002 72527 2001-08-02 9999-01-0110003 40006 1995-12-03 1996-12-0210003 43616 1996-12-02 1997-12-0210003 43466 1997-12-02 1998-12-0210003 43636 1998-12-02 1999-12-0210003 43478 1999-12-02 2000-12-0110003 43699 2000-12-01 2001-12-0110003 43311 2001-12-01 9999-01-0110004 40054 1986-12-01 1987-12-0110004 42283 1987-12-01 1988-11-3010004 42542 1988-11-30 1989-11-3010004 46065 1989-11-30 1990-11-3010004 48271 1990-11-30 1991-11-3010004 50594 1991-11-30 1992-11-2910004 52119 1992-11-29 1993-11-2910004 54693 1993-11-29 1994-11-2910004 58326 1994-11-29 1995-11-2910004 60770 1995-11-29 1996-11-28 聚合所有SELECT emp_no, SUM(salary), avg(salary), count(emp_no) from salaries; 聚合被选择的记录SELECT emp_no, SUM(salary), avg(salary), count(emp_no) from salaries WHERE emp_no &lt; 10003; 分组SELECT emp_no FROM salaries GROUP BY emp_no;SELECT emp_no FROM salaries WHERE emp_no &lt; 10003 GROUP BY emp_no; 按照不同emp_no分组，每组分别聚合12SELECT emp_no, SUM(salary), AVG(salary), count(emp_no) from salaries WHERE emp_no &lt; 10003 GROUP BY emp_no; HAVING子句对分组结果过滤12SELECT emp_no, SUM(salary), AVG(salary), count(emp_no) from salaries GROUP BY emp_no HAVING AVG(salary) &gt; 45000 使用别名12SELECT emp_no, SUM(salary), AVG(salary) as sal_avg, count(emp_no) from salaries GROUP BY emp_no HAVING sal_avg &gt; 45000 最后对分组过滤后的结果排序12SELECT emp_no, SUM(salary), AVG(salary) AS sal_avg, COUNT(emp_no) from salaries GROUP BY emp_no HAVING sal_avg &gt; 60000 ORDER BY sal_avg; 分组是将数据按照指定的字段分组，最终每组只能出来一条记录。这就带来了问题，每一组谁做代表，其实谁做代表都不合适 如果只投影分组字段、聚合数据，不会有问题，如果投影非分组字段，显示的时候不能确定是组内谁的数据 分组12SELECT emp_no, MAX(salary) FROM salaries; -- 10001 88958SELECT emp_no, MIN(salary) FROM salaries; -- 10001 40006 上例很好的说明了使用了聚合函数，虽然没有显式使用Group By语句，但是其实就是把所有记录当做一组，每组只能出一条，那么一组也只能出一条，所以结果就一条 但是emp_no就是非分组字段，那么它就要开始覆盖，所以，显示为10001。当求最大值的时候，正好工资表中10001的工资最高，感觉是对的。但是，求最小工资的时候，明明最小工资是10003的40006，由于emp_no不是分组字段，导致最后被覆盖为100011SELECT emp_no, MIN(salary) FROM salaries GROUP BY emp_no; 上句才是正确的语义，按照不同员工emp_no工号分组，每一个人一组，每一个人有多个工资记录，按时每组只能按照人头出一条记录 单标较为复杂的语句1234567891011121314SELECT emp_no, AVG( salary ) AS avg_sal FROM salaries WHERE salary &gt; 70000 GROUP BY emp_no HAVING avg( salary ) &gt; 50000 ORDER BY avg_sal DESC LIMIT 1; 子查询 查询语句可以嵌套，内部查询就是子查询 子查询必须在一组小括号中 子查询中不能使用Order by12345678SELECT * FROM employees WHERE emp_no IN ( SELECT emp_no FROM employees WHERE emp_no &gt; 10015 ) ORDER BY emp_no DESC; 12345678910SELECT emp.emp_no, emp.first_name, gender FROM ( SELECT * FROM employees WHERE emp_no &gt; 10015 ) AS emp WHERE emp.emp_no &lt; 10019 ORDER BY emp_no DESC; 连接join交叉连接 cross join 笛卡尔乘积，全部交叉 在MySQL中，CROSS JOIN从语法上说与INNER JOIN等同 没有 join 就不能用 on Join会构建一张临时表1234567891011-- 工资40行SELECT * FROM salaries;-- 20行SELECT * FROM employees;-- 800行SELECT * FROM employees CROSS JOIN salaries;-- 隐式连接，800行SELECT * FROM employees, salaries; 注意：salaries和employees并没有直接的关系，做笛卡尔乘积只是为了看的清楚 内连接 inner join 可省略为join 等值连接，只选某些field相等的元组（行），使用On限定关联的结果 自然连接，特殊的等值连接，会去掉重复的列。用的少123456789-- 内连接，笛卡尔乘积 800 行SELECT * FROM employees JOIN salaries;SELECT * FROM employees INNER JOIN salaries;-- on等值连接 40行SELECT * FROM employees JOIN salaries ON employees.emp_no = salaries.emp_no;-- 自然连接，去掉了重复列，且自行使用 employees.emp_no = salaries.emp_no的条件SELECT * FROM employees NATURAL JOIN salaries; 外连接 outer join 可以省略为join分为左外连接，即左连接；右外连接，即右连接；全外连接左连接（56条记录）1SELECT * FROM employees LEFT JOIN salaries ON employees.emp_no = salaries.emp_no; 右连接（40 条记录）1SELECT * FROM employees RIGHT JOIN salaries ON employees.emp_no = salaries.emp_no; 这个右连接等价于上面的左连接（56条记录）1SELECT * FROM salaries RIGHT JOIN employees ON employees.emp_no = salaries.emp_no; 左外连接、右外连接1SELECT * FROM employees RIGHT JOIN salaries ON employees.emp_no = salaries.emp_no; 结果是先employees后salaries的字段显示，Right是看表的数据的方向，从salaries往employees看，以salaries为准，它的所有数据都显示12345678SELECT employees.*FROM salaries RIGHT JOIN employees ON employees.emp_nosalaries.emp_no WHERE salaries.emp_no IS NULL 自连接表，自己和自己连接12345select manager.* from emp manager,emp worker where manaer.empno=worker.mgr and worker.empno=1;select manager.* from emp manager inner join emp worker on manaer.empno=worker.mgr where worker.empno=1; 存储过程、触发器 存储过程（Stored Procedure），数据库系统中，一段完成特定功能的SQL语句。编写成类似函数的方式，可以传参并调用。支持流程控制语句 触发器（Trigger），由事件触发的特殊的存储过程，例如insert数据时触发 这两种技术，虽然是数据库高级内容，性能不错，但基本很少用了 它们移植性差，使用时占用的服务器资源，排错、维护不方便 最大的原因，不太建议把逻辑放在数据库中]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-控制语句]]></title>
    <url>%2Fjs%2FJS%E8%AF%AD%E6%B3%95%20--%20%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[@toc 语句块JS使用大括号构成语句块。ES6 之前语句块是没有作用域的，从ES6开始支持 块作用域 ，let只能在块作用域内可见123456789101112131415161718192021222324252627282930313233function hello()&#123; let a = 1; var b = 2; c = 3&#125;if (1)&#123; let d = 4; var e = 5; f = 6 if (true)&#123; console.log(d) // 可见 console.log(e) // 可见 console.log(f) // 可见 console.log('----------') g = 10 var h = 11 &#125;&#125;// console.log(a) 不可见// console.log(b) 不可见// console.log(c) 不可见，函数为执行hello()console.log(c) // 块作用域隐式声明，可见// console.log(d) // 块作用域使用let，不可见;但是块外的d可见console.log(e)) // 块作用域使用var，可见console.log(f)) // 块作用域隐式声明，可见console.log(g)) // 可见console.log(h)) // 可见 let 不能突破函数、{ } 块作用域 var 不能突破函数作用域 c = 3 隐式申明，为全局作用域流程控制条件分支123456789101112if (cond1)&#123;&#125;else if (cond2) &#123;&#125;else if (cond3) &#123;&#125;else &#123;&#125; 123456789条件的False等效 false undefined null 0 NaN 空字符串 其它值都将被视为True switch…case分支语句 当进入case语句后，如果没有break语句，会产生穿透现象 一直穿透到break语句结束 如果一直没有，将把代码执行完 12345678910111213switch (expression) &#123; case label_1: statements_1 [break;] case label_2: statements_2 [break;] ... default: statements_def [break;]&#125; 穿透问题，一定要在case中恰当的使用break语句，否则就会继续顺序向下执行 1234567891011121314151617181920212223242526let x = 5 // 换成1试一试switch (x) &#123; case 0: console.log('zero') break; case 1: console.log('one'); case 2: console.log('two'); case 3: console.log('three'); break; case 5: case 4: console.log('four'); default: console.log('other') // break;&#125;// 执行结果fourother// 如果x = 2，执行结果为twothree for循环12345// C风格for循环for ([initialExpression]; [condition]; [incrementExpression])&#123; statement&#125; 12345678910111213141516171819202122232425262728293031for (let i=0;i&lt;5;i++)&#123; console.log(i)&#125;console.log('-'.repeat(30))for (var x=0,y=9;x&lt;5;x++,y--)&#123; console.log(x*y)&#125;console.log('-'.repeat(30))for (let i=0;i&lt;10;i+=3)&#123; // 步长 console.log(i) &#125;// 执行结果01234------------------------------08141820------------------------------0369 九九乘法表12345678for (let i=1;i&lt;10;i++)&#123; line = '' for (let j=1;j&lt;=i;j++)&#123; line += j + '*' + i + '=' + j*i + ' ' // line += `$&#123;j&#125;*$&#123;i&#125;=$&#123;i*j?'t':'f'&#125; ` &#125; console.log(line)&#125; while循环 和 do…while循环 条件满足，进入循环，条件为真，继续循环 12while (condition) statement 先进入do语句循环，然后判断，为真就继续循环 123do statementwhile (condition); 123456789101112131415161718192021222324let x = 5while (x--)&#123; console.log(x);&#125;console.log('~~~~~~~~~~')do &#123; console.log(x)&#125;while(x++&lt;5)// 执行结果43210~~~~~~~~~~-1012345 for…in循环对象操作语句for...in用来遍历对象的属性123for (variable in object) &#123; statements&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 数组let arr = [10, 20, 30, 40];console.log(arr[1]) // 20for (let x in arr)&#123; console.log(x); // 返回索引&#125;for (let index in arr)&#123; console.log(`$&#123;index&#125; : $&#123;arr[index]&#125;`); //插值&#125;// C风格for(let i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125;// 对象let obj = &#123; a:1, b:'hello', c:true&#125;;console.log(obj.a);console.log(obj['b']); // 对象属性当索引访问console.log(obj.d); // undefinedconsole.log('~~~~~')for (let x in obj)&#123; console.log(x); // 属性名&#125;for (let key in obj)&#123; // 返回数组的index console.log(`$&#123;key&#125; : $&#123;obj[key]&#125;`);&#125;// 执行结果2001230 : 101 : 202 : 303 : 40102030401helloundefined~~~~~abca : 1b : helloc : true for in 循环返回的是索引或者key，需要间接访问到值 *数组8反正返回的是索引，C风格for循环操作可能方便点 对象用for in合适 for…of 循环ES6的新语法123456789101112131415161718192021let arr = [1, 2, 3, 4, 5]let obj =&#123; a:1, b:'hello', c:true&#125;for (let i of arr)&#123; //返回数组元素 console.log(i)&#125;//执行结果12345for (let i of obj)&#123; // 异常，不可以迭代 console.log(i)&#125; 注意 for ... of 不能迭代一个普通对象 原因是，of后面必须是一个迭代器（TypeError: obj[Symbol.iterator] is not a function） 可类比python中的for in，例如for x in [ ]break 、 continue break 结束当前循环 continue 中断当前循环，直接进入下一次循环for迭代的差别123456789101112131415161718192021222324function sum(arr)&#123; for (let x in arr)&#123; // 遍历index或对象属性 console.log(x, typeof(x), arr[x]); &#125; for (let x of arr)&#123; // 遍历元素 console.log(x, typeof(x)); &#125; for (let x=0;x&lt;arr.length;x++)&#123; // 自己定义索引数值遍历 console.log(x, typeof(x), arr[x]); &#125;&#125;sum([3,6,9]); // 执行结果0 string 31 string 62 string 93 'number'6 'number'9 'number'0 'number' 31 'number' 62 'number' 9 Symbols类型 ES6提供Symbol类型，内建原生类型 symbol值是唯一的1234let sym1 =Symbol()let sym2 = Symbol('key1')let sym3 = Symbol('key2')console.log(sym2 == sym3) //false 作为对象的属性key1234567891011121314151617let s = Symbol()let t = 'abc'let a = &#123; [s]:'xyz', // symbol做key，注意要使用中括号，这个key一定唯一 t:'tt', [t]:'oo'&#125;console.log(a)console.log(a[s])a[s] = 2000console.log(a[s])// 执行结果&#123; t: 'tt', abc: 'oo', [Symbol()]: 'xyz' &#125;xyz2000 构建常量 以前的用法 123456var COLOR_RED = 'RED';var COLOR_ORANGE = 'ORANGE';var COLOR_YELLOW = 'YELLOW';var COLOR_GREEN = 'GREEN';var COLOR_BLUE = 'BLUE';var COLOR_VIOLET = 'VIOLET'; 现在的用法 123456const COLOR_RED = Symbol();const COLOR_ORANGE = Symbol();const COLOR_YELLOW = Symbol();const COLOR_GREEN = Symbol();const COLOR_BLUE = Symbol();const COLOR_VIOLET = Symbol();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js语法]]></title>
    <url>%2Fjs%2FJS%E8%AF%AD%E6%B3%95%20--%20%E5%87%BD%E6%95%B0%E5%8F%8A%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[@toc 函数123456789function 函数名(参数列表) &#123; 函数体; return 返回值;&#125;function add(x,y)&#123; return x+y;&#125;console.log(add(3,5)); 函数表达式使用表达式来定义函数，表达式中的函数名可以省略，如果这个函数名不省略，也只能用在此函数内部 匿名函数1234const add = function(x, y)&#123; return x + y;&#125;;console.log(add(4, 6) 有名字的函数表达式12345const sub = function fn(x, y) &#123; return x -y;&#125;console.log(sub(5, 3))// console.log(fn(3, 2)) // fn 只能用在函数内部 内部使用，相当于递归调用 12345const sub = function fn(n) &#123; if (n===1) return n; return n + fn(--n) // fn 只能在函数内部使用&#125;console.log(sub(4)) 函数、匿名函数、函数表达式的差异 函数和匿名函数，本质上都是一样的，都是函数对象，只不过函数有自己的标识符——函数名，匿名函数需要借助其它的标识符而已 区别在于，函数会声明提升，函数表达式不会123456789101112console.log(add(4,6))// 匿名函数function add(x, y)&#123; // 声明提升 return x + y;&#125;;// console.log(sub(5, 3)); // sub 未定义// 有名字的函数表达式const sub = function (x,y)&#123; return x - y;&#125;;console.log(sub(5, 3)); 高阶函数高阶函数：函数作为参数或返回一个函数 完成一个计数器counter 1234567891011const counter = function()&#123; let c = 0 return function()&#123; return ++c; &#125;;&#125;;const c = counter()console.log(c()) // 1console.log(c()) // 2console.log(c()) // 3 完成一个map函数：可以对某一个数组的元素进行某种处理 123456789101112131415161718const map = function(arr,fn)&#123; let newarr = []; for (let i in arr)&#123; newarr[i] = fn(arr[i]); &#125; return newarr&#125;console.log(map([1,2,3,4], function(x) &#123;return x++&#125;))console.log(map([1,2,3,4], function(x) &#123;return ++x&#125;))console.log(map([1,2,3,4], function(x) &#123;return x+1&#125;))console.log(map([1,2,3,4], function(x) &#123;return x+=1&#125;))// 执行结果[ 1, 2, 3, 4 ][ 2, 3, 4, 5 ][ 2, 3, 4, 5 ][ 2, 3, 4, 5 ] 另附counter的生成器版本，仅供参考123456789101112131415const counter = (function * () &#123; let c = 1 while (true) &#123; yield c++ &#125;&#125;)()console.log(counter.next())console.log(counter.next())console.log(counter.next())// 执行结果&#123; value: 1, done: false &#125;&#123; value: 2, done: false &#125;&#123; value: 3, done: false &#125; 箭头函数箭头函数就是匿名函数，它是一种更加精简的格式。将上例中的函数更改为箭头函数1234567891011121314151617const map = function(arr,fn)&#123; let newarr = []; for (let i in arr)&#123; newarr[i] = fn(arr[i]); &#125; return newarr&#125;// 以下三行等价console.log(map([1,2,3,4], (x) =&gt; &#123;return x*2&#125;));console.log(map([1,2,3,4], x =&gt; &#123;return x*2&#125;));console.log(map([1,2,3,4], x =&gt; x*2));// 执行结果[ 2, 4, 6, 8 ][ 2, 4, 6, 8 ][ 2, 4, 6, 8 ] 箭头函数参数 如果一个函数没有参数，使用() 如果只有一个参数，参数列表可以省略小括号() 多个参数不能省略小括号，且使用逗号间隔箭头函数返回值 如果函数体部分有多行，就需要使用{}，如果有返回值使用return 如果只有一行语句，可以同时省略大括号和return 只要有return语句，就不能省略大括号console.log(map([1,2,3,4], x =&gt; {return ++x})) ，有return必须有大括号 如果只有一条非return语句，加上大括号，函数就成了无返回值console.log(map([1,2,3,4], x =&gt; {x*2}));加上了大括号，它不等价于x =&gt;{return x*2}因此，记住 x =&gt; x*2 这种正确的形式就行函数参数普通参数 一个参数占一个位置，支持默认参数1234567const add = (x, y) =&gt; x + yconsole.log(add(4, 5)) // 9// 缺省值const add1 = (x, y=5) =&gt; x + yconsole.log(add1(4, 7)) // 11console.log(add1(4)) // 9 测试下面代码123456const add = (x=6, y) =&gt; x + yconsole.log(add()) // NaNconsole.log(add(1)) // NaNconsole.log(add(y=2, z=3)) // 5console.log(add(3, 4, 5, 6)) // 7 观察上面diamagnetic执行结果，原因 JS中并没有Python中的关键字传参 JS只是做参数位置的对应 JS并不限制默认参数的位置 JS传参个数超范围，多余的参数不影响函数调用 add2(y=2,z=3)相当于add2(2,3)，因为JS没有关键字传参，但是它的赋值表达式有值值，y=2就是2，z=3就是3建议，默认参数写到后面，这是一个好的习惯 可变参数(rest parameters剩余参数)JS使用…表示可变参数（Python用*收集多个参数）12345678910const sum = function (...args)&#123; let result = 0; console.log(...args) // 3 6 9 参数解构 for (let x in args)&#123; result += args[x] &#125;; return result&#125;;console.log(sum(3, 6, 9)) // 18 arguments对象函数的所有参数会被保存在一个arguments的键值对对象中123456789101112131415161718(function (p1, ...args) &#123; console.log(p1) console.log(args) console.log('----------------') console.log(arguments) // 对象 for (let x of arguments) // 该对象可以使用of console.log(x);&#125;)('abc', 1,3,5) // 执行结果abc[ 1, 3, 5 ]----------------[Arguments] &#123; '0': 'abc', '1': 1, '2': 3, '3': 5 &#125;abc135 ES6之前，arguments是唯一可变参数的实现。ES6开始，不推荐，建议使用可变参数。为了兼容而保留。注意，使用箭头函数，取到的arguments不是我们想要的，如下12345((x, ...args) =&gt; &#123; console.log(args); console.log(x); console.log(arguments);&#125;)(...[1,2,3,4]) 参数解构和Python类似，Js提供了参数解构，依然使用了...符号来解构1234const add = (x, y) =&gt; &#123;console.log(x,y);return x + y&#125;;console.log(add(...[100,200]))console.log(add(...[100,200,300,3,5,3]))console.log(add(...[100])) Js支持参数解构，不需要解构后的值个数和参数个数对应 函数返回值python 中可以使用 return 1,2 返回多值，本质上也是一个值，就是一个元组。Js中呢12const add = (x, y) =&gt; &#123;return x,y&#125;;console.log(add(4,100)); // 100 表达式的值 类C的语言，都有一个概念——表达式的值 赋值表达式的值：等号右边的值 逗号表达式的值：类C语言，都支持逗号表达式，逗号表达式的值，就是最后一个表达式的值1234567891011a = (x = 5, y = 6, true);console.log(a); //trueb = (123, true, z = 'test')console.log(b) // testfunction c() &#123; return x = 5, y = 6, true, 'ok';&#125;console.log(c()); // ok 所以，JS的函数返回值依然是单值 作用域1234567891011121314151617181920212223// 函数中变量的作用域function test()&#123; a = 100; var b = 200; let c = 300;&#125; // 先要运行test函数test()console.log(a);// console.log(b); // 不可见// console.log(c); // 不可见 // 块作用域中变量if (1)&#123; a = 100; var b = 200; let c = 300;&#125;console.log(a);console.log(b);// console.log(c); // 不可见 function是函数的定义，是一个独立的作用域，其中定义的变量在函数外不可见 var a = 100 可以提升声明，也可以突破非函数的块作用域 a = 100 隐式声明不能提升声明，在“严格模式”下会出错，但是可以把变量隐式声明为全局变量。建议少用 let a = 100 不能提升声明，而且不能突破任何的块作用域。推荐使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function show(i, arg) &#123; console.log(i, arg)&#125;// 作用域测试x = 500;var j = 'jjjj';var k = 'kkkk';function fn()&#123; let z = 400; &#123; var o = 100; // var 作用域当前上下文 show(1, x); t = 'free'; // 此语句执行后，t作用域就是全局的，不推荐 let p = 200; &#125; var y = 300; show(2,z); show(3,x); show(4,o); show(5,t); //show(6,p); // 异常，let出不来上一个语句块 &#123; show(7,y); show(8,o); show(9,t); &#123; show(10,o); show(11,t); show(12,z); &#125; &#125; j = 'aaaa'; var k = 'bbbb'; show(20, j); show(21, k);&#125;// 先执行函数fn()show(22, j);show(23, k);//show(13,y); // 异常，y只能存在于定义的上下文中，出不了函数show(14,t); // 全局，但是严格模式会抛异常//show(15,o) // 看不到o，异常原因同yshow(16,z); // 变量声明提升，var声明了z，但是此时还没有赋值var z = 10;const m = 1//m = 2 // 常量不可以重新赋值// 执行结果1 5002 4003 5004 1005 'free'7 3008 1009 'free'10 10011 'free'12 40020 'aaaa'21 'bbbb'22 'aaaa'23 'kkkk'14 'free'16 undefined 严格模式 使用”use strict”;，这条语句放到函数的首行，或者js脚本首行异常抛出异常Js的异常语法和Java相同，使用throw关键字抛出。使用throw关键字可以抛出任意对象的异常1234567throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok';throw [1, 2, 3];throw &#123;'a':1&#125;;throw () =&gt; &#123;&#125;; // 函数 捕获异常try...catch 语句捕获异常try...catch...finally 语句捕获异常，finally保证最终一定执行 注意这里的catch不支持类型，也就是说至多一个catch语句 可以在catch的语句块内，自行处理异常12345678910111213141516try &#123; //throw new Error('new error'); //throw new ReferenceError('Ref Error'); //throw 1; //throw new Number(100); // throw 'not ok'; // throw [1,2,3]; // throw &#123;'a':1&#125;; throw () =&gt; &#123;&#125;; // 函数&#125; catch (error) &#123; console.log(error); console.log(typeof(error)); console.log(error.constructor.name);&#125; finally &#123; console.log('===end===')&#125;]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-对象模型]]></title>
    <url>%2Fjs%2FJS%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[@tocJavaScript 是一种基于原型（Prototype）的面向对象语言，而不是基于类的面向对象语言 C++、Java有类Class和实例Instance的概念，类是一类事物的抽象，而实例则是类的实体 JS是基于原型的语言，它只有原型对象的概念。原型对象就是一个模板，新的对象从这个模板构建从而获取最初的属性。任何对象在运行时可以动态的增加属性。而且，任何一个对象都可以作为另一个对象的原型，这样后者就可以共享前者的属性 定义类字面式声明方式1234567891011121314var obj = &#123; property_1: value_1, // property_# may be an identifier... property_2: value_2, // or a number... ..., "property n": value_n // or a string&#125;;var obj = &#123; x: 1, 1: 'abc', 'y': '123'&#125;for (let s in obj) console.log(s, typeof (s)); 这种方法也称作字面值创建对象Js 1.2开始支持1234567891011let a = 1, b = 2let obj = &#123; a, b &#125;let obj1 = &#123; a: a, 'b': b &#125; // 引号可以省console.log(obj) // &#123; a: 1, b: 2 &#125;console.log(obj1) // &#123; a: 1, b: 2 &#125;let c = 'pro1'let d = &#123; c: 1000, // 注意这个c是'c'，不是上面的变量c [c]: 2000 // 如果要用c变量，就要把c用中括号括起来&#125; 对象的键key只能是字符串类型，最后都会被转换成字符串 ES6之前——构造器1、定义一个函数（构造器）对象，函数名首字母大写2、使用this定义属性3、使用new和构造器创建一个新对象1234567891011121314151617181920212223242526272829303132333435// 定义类，构造器function Point(x, y) &#123; this.x = x; this.y = y; this.show = () =&gt; &#123; console.log(this, this.x, this.y) &#125;; console.log('Point~~~~~~~~');&#125;console.log(Point);p1 = new Point(4, 5);console.log(p1);console.log('----------------');// 继承function Point3D(x, y, z) &#123; Point.call(this, x, y); // "继承" this.z = z; console.log('Point3D~~~~~~~~');&#125;console.log(Point3D);p2 = new Point3D(14, 15, 16);console.log(p2);p2.show();/* 执行结果[Function: Point]Point~~~~~~~~Point &#123; x: 4, y: 5, show: [Function] &#125;----------------[Function: Point3D]Point~~~~~~~~Point3D~~~~~~~~Point3D &#123; x: 14, y: 15, show: [Function], z: 16 &#125;Point3D &#123; x: 14, y: 15, show: [Function], z: 16 &#125; 14 15*/ new 构建一个新的通用对象，new操作符会将新对象的this值传递给Point3D构造器函数，函数为这个对象创建z属性。从上句话知道，new后得到一个对象，使用这个对象的this来调用构造器，那么如何执行“基类”的构造器方法呢？使用Point3D对象的this来执行Point的构造器，所以使用call方法，传入子类的this。最终，构造完成后，将对象赋给p2。 注意：如果不使用new关键字，就是一次普通的函数调用，this不代表实例。 ES6中的class从ES6开始，新提供了class关键字，使得创建对象更加简单、清晰 类定义使用class关键字。创建的本质上还是函数，是一个特殊的函数 一个类只能拥有一个名为constructor的构造器方法。如果没有显式的定义一个构造方法，则会添加一个默认的constuctor方法 继承使用extends关键字 一个构造器可以使用super关键字来调用一个父类的构造函数 类没有私有属性12345678910111213141516171819202122232425262728// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;let p1 = new Point(10, 11)p1.show()// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show()/* 执行结果Point &#123; x: 10, y: 11 &#125; 10 11Point3D &#123; x: 20, y: 21, z: 22 &#125; 20 21*/ 重写方法子类Point3D的show方法，需要重写123456789101112131415161718192021222324252627282930313233// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;let p1 = new Point(10, 11)p1.show()// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125; show() &#123; // 重写 console.log(this, this.x, this.y, this.z); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show();/* 执行结果Point &#123; x: 10, y: 11 &#125; 10 11Point3D &#123; x: 20, y: 21, z: 22 &#125; 20 21 22*/ 子类中直接重写父类的方法即可如果需要使用父类的方法，使用super.method()的 方式调用 使用箭头函数重写上面的方法12345678910111213141516171819202122// 基类定义// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = function () &#123;console.log(this,this.x,this.y)&#125;; this.show = () =&gt; console.log('Point'); &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point3D 从运行结果来看，箭头函数也支持子类的覆盖1234567891011121314151617181920212223242526// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; this.show = () =&gt; console.log('Point'); &#125; // show() /*方法*/ &#123; // console.log(this,this.x,this.y); // &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; //this.show = () =&gt; console.log('Point3D'); &#125; show() &#123; // 重写 console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point 上例优先使用了父类的属性show1234567891011121314151617181920212223// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = () =&gt; console.log('Point'); &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point3D 优先使用了子类的属性 总结 父类、子类使用同一种方式类定义属性或者方法，子类覆盖父类 访问同名属性或方法时，优先使用属性静态属性静态属性目前还没有得到很好的支持静态方法在方法名前加上static，就是静态方法123456789101112131415161718192021class Add &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static print() &#123; console.log(this.x); // ? this是什么 &#125;&#125;add = new Add(40, 50);console.log(Add);Add.print();//add.print(); // 实例不能访问直接访问静态方法，和C++、Java一致add.constructor.print(); // 实例可以通过constructor访问静态方法/* 执行结果[Function: Add]undefinedundefined*/ 静态方法中的this是Add类，而不是Add的实例 注意：静态的概念和Python的静态不同，相当于Python中的类变量this的坑虽然Js和 C++ 、Java一样有this，但是Js的表现是不同的。原因在于， C++ 、Java是静态编译型语言，this是编译期绑定，而Js是动态语言，运行期绑定1234567891011121314151617181920var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this === global); // this是否是global对象 return this.name; &#125;; &#125;&#125;;console.log(school.getNameFunc()());/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;trueundefined*/ 函数执行时，会开启新的执行上下文环境ExecutionContext 创建this属性，但是this是什么就要看函数是怎么调用的了 myFunction(1,2,3)，普通函数调用方式，this指向全局对象。全局对象是nodejs的global或者浏览器中的windows myObject.myFunction(1,2,3)，对象方法的调用方式，this指向包含该方法的对象 call、apply、bind方法调用时，要看第一个参数是谁 分析上例 js 和 { name: &#39;js&#39;, getNameFunc: [Function: getNameFunc] } 很好理解 第三行打印的true，是 console.log(this == global) 执行的结果，说明当前是global，因为调用这个返回的函数是直接调用的，这就是个普通函数调用，所以this是全局对象 第四行undefined，就是因为this是global，没有name属性 这就是函数调用的时候，调用方式不同，this对应的对象不同，它已经不是C++、Java的指向实例本身了this的问题，这是历史遗留问题，新版只能保留且兼容了而我们在使用时，有时候需要明确的让this必须是我们期望的对象，如何解决这个问题呢？ 1 显式传入12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return function (that) &#123; console.log(this == global); // this是否是global对象 return that.name; &#125;; &#125;&#125;console.log(school.getNameFunc()(school)); /* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;truejs*/ 通过主动传入对象，这样就避开了this的问题 2、 ES3（ES-262第三版）引入了apply、call方法12345678910111213141516171819var school = &#123; name : 'js', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125; &#125; console.log(school.getNameFunc().call(school)); // call方法显式传入this对应的对象/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;falsejs*/ apply、call方法都是函数对象的方法，第一参数都是传入对象引入的apply传其他参数需要使用数组call传其他参数需要使用可变参数收集12345678910111213141516171819202122232425262728293031function Point(x, y) &#123; this.x = x; this.y = y; console.log(this === global); console.log('Point ~~~~');&#125;p1 = Point(4, 5);console.log(p1); // undefinedconsole.log('~~~~~~~~~~~~~~~~')p2 = new Object();console.log(p2); // &#123;&#125;p3 = Point.call(p2, 10, 11);// p3 = Point.apply(p2, [11, 13]);console.log(p3); // undefinedconsole.log(p2); // &#123; x: 10, y: 11 &#125;/* 执行结果truePoint ~~~~undefined~~~~~~~~~~~~~~~~&#123;&#125;falsePoint ~~~~undefined&#123; x: 10, y: 11 &#125;*/ 3、ES5 引入了bind方法bind方法来设置函数的this值12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); // console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc().bind(school)); // bind方法绑定/* 执行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;[Function: bound ]*/ 只打印了三行，说明哪里有问题，问题出在bind方法用错了12345678910111213141516171819202122232425262728var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); // console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;var func = school.getNameFunc();console.log(func);var boundfunc = func.bind(school); // bind绑定后返回新的函数console.log(boundfunc);console.log(boundfunc());/* 执行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;[Function][Function: bound ]falsejs*/ apply、call方法，参数不同，调用时传入thisbind方法是为函数先绑定this，调用时直接用 4、ES6引入支持this的箭头函数ES6 新技术，就不需要兼容this问题12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc()());/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;falsejs */ ES6 新的定义方式如下123456789101112131415161718192021class school &#123; constructor() &#123; this.name = 'js'; &#125; getNameFunc() &#123; console.log(this.name); console.log(this, typeof (this)); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(new school().getNameFunc()());/* 执行结果jsschool &#123; name: 'js' &#125; 'object'falsejs*/ 以上解决this问题的方法，bind方法最常用]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2Fjs%2FCSS%EF%BC%88Cascading%20Style%20Sheet%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC层叠样式表，控制HTML的布局和样式 使用方式三种使用方式 内联样式：在标签内使用属性stype 页内样式：在 &lt;head&gt; 标签中使用 &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 外部样式：使用CSS文件，使用 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; 优先级从高到低 基本语法selector {property1: value1, ..., propertyN:valueN} 例如 a {color:red; text-decoration:line-through} ，将链接标签文字颜色变成红色且有横线穿过 颜色写法123p &#123; color: #ff0000; &#125; /*大小写无所谓*/p &#123; color: #f00; &#125; /*FF0000的缩写*/p &#123; color: rgb(255,0,0); &#125; /*三原色表示，0~255*/ 颜色，写16进制，可以压缩 选择器标签选择器body {text-align: center} 上例直接使用HTML标签的选择器，就是标签选择器，元素选择器 注意，如果将标签改为*，表示统配所有HTML标签id选择器id指的是HTML标签内的属性id，例如 &lt;div id=&quot;menu&quot;&gt;# 代表 id123456#menu &#123; background-color: rgb(255, 255, 255); width: 100%; border-bottom: #f0f0f0 solid 1px; margin: 0px 0px 5px 0px;&#125; background-color 背景色border-bottom 向下的边界线margin 外边框 上 右 下 左 类选择器类，指的是标签中的class属性，例如 &lt;div class=&#39;main center&#39;&gt;1234.center &#123; width: 80%; margin: auto;&#125; 居中 margin:auto 选择器分组分组的选择就可以使用同样的样式声明同一个样式的时候可以使用可以是标签,可以是ID 也可以是class123h1,h2,h3,h4,h5,h6 &#123; color: green;&#125; 层次选择器1、后代选择器123div li &#123; display: inline;&#125; 所有div标签下任意层下的li标签123div#menu li &#123; display: inline;&#125; 2、子选择器123ul &gt; li &#123; display: inline;&#125; 所有div标签下直接的子元素li标签123div#menu ul &gt; li &#123; display: inline;&#125; 3、相邻兄弟选择器 兄弟标签改变属性，自己本身不改变123div.detail p + p &#123; color: green;&#125; 4、显示消失123div#menu ul &gt; li &#123; display: none;&#125; class为detail的div标签下任意层下的近邻p标签的下一个p标签 伪类 pseudo-classes 伪类能增加样式，类似于class 锚伪类，链接标签a的四种状态 1234a:link &#123;color: red&#125; /* 未访问的链接 */a:visited &#123;color: green&#125; /* 已访问的链接 */a:hover &#123;color: blue&#125; /* 鼠标移动到链接上 */a:active &#123;color: black&#125; /* 选定的链接 */ 伪类可以和css类配合使用 12345678910a.red:visited &#123;color: #FF0000&#125;a:hover &#123; color: red;&#125;a &#123; color: chartreuse; text-decoration-line: none;&#125;&lt;a class="red" href="css_syntax.asp"&gt;CSS Syntax&lt;/a&gt; 注意，伪类和前面部分中间不要有空格 伪元素pseudo-element伪元素能增加元素 :before 和 :after 可以在元素前后插入内容123456#homepage:after content:url(http://www.baidu.com/kczx/images/why1.png);&#125;a:before &#123; content:"这是链接~~~";&#125; 属性选择器 E [ attr ] { sRules } 具有某属性 E [ attr = value ] { sRules } 具有某属性且等于value E [ attr ~= value ] { sRules } 具有某属性且属性值中的一个是value `E [ attr = value ] { sRules }` 具有某属性且属性值使用了-，且-之前的部分是value的才匹配`*[class =”main”]能和` 减号之前的部分匹配 123456789101112131415161718链接具有href属性a[href] &#123; color: blue; text-decoration:line-through&#125;图片alt属性为magedu_logoimg[alt=magedu_logo] &#123; height: 20px;&#125;*[class="main center"] &#123; color:black&#125;*[class~="center"] &#123; color:black&#125; 继承1234body &#123; text-align: center; color:red;&#125; 观察整个页面文字颜色，几乎都变成了红色。页面中父元素中使用的样式，通过CSS继承，子孙元素将继承并使用祖先元素的属性，除非子元素重新定义了该属性 常见样式背景 background复合属性 http://www.w3school.com.cn/css/css_background.asp字体 font复合属性 http://www.w3school.com.cn/css/css_font.asp 表格border 123456789table&#123; border-collapse:collapse;&#125;table,td&#123; border: 1px solid black;&#125; margin外边距和padding内边距 12345678margin: top right bottom leftpadding: top right bottom leftpadding:10px 5px 15px 20px; /*顺时针上右下左*/padding:10px 5px 15px; /*上10px、左右5px、下15px*/padding:10px 5px; /*上下10px、左右5px*/padding:10px /*4方向全是10px*/margin:auto /*浏览器计算外边距*/ 内外边距都是顺时针设置4个方向，也可以单独设置 测试用HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;html&gt;&lt;head&gt; &lt;title&gt;test page&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='main center'&gt; &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a id="homepage"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Linux&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a href="https://github.com/" target="_blank" title="abc"&gt;请点击&lt;/a&gt;&lt;span&gt;inline span&lt;/span&gt; &lt;p&gt; &lt;span&gt;biggest title&lt;/span&gt; &lt;img src="https://github.githubassets.com/images/modules/site/integrators/google.png" alt="github_logo"&gt; &lt;/p&gt; &lt;div id='detail' name='detail' class="detail"&gt; &lt;p&gt;title&lt;/p&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;form action="" method="POST"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;input name='h' type="hidden" value="001111256"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name='username' type="text" value="abc"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input name='pwd' type="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;&lt;input name=gender type="radio" checked value="M"&gt;男&lt;input name=gender type="radio" value="F"&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input name="interest" type="checkbox" checked value="music"&gt;音乐 &lt;input name="interest" type="checkbox" checked value="movie"&gt;电影 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;其他&lt;/td&gt; &lt;td&gt; &lt;textarea&gt; line1 line2 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input name=submit type="submit" value="提交"&gt; &lt;input type="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2Fbook%2F%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[前端风云录 前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 html html(hypertext markup language)超文本标记语言,它不同于编程语言 超文本就是超出纯文本的范畴, 例如描述文本的颜色、大小、字体等信息、 或使用图片音频、 视屏等非文本内容. 12345html定义了网页的内容css描述了网页的布局javascript网页的行为 cs原理client客户端向server发起请求 通过资源定位符, 找到映射文件, server端读取文件后, 一个个字节又通过管道发回到客户端, 客户端收到之后save下来, 打开html 文本流就是字节流(区别是字节流没有编码) . 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Web 2.0Ajax 技术促成了 Web 2.0 的诞生。 Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 12345678var AppView = Backbone.View.extend(&#123; // ... events: &#123; "keypress #new-todo": "createOnEnter", "click #clear-completed": "clearCompleted", "click #toggle-all": "toggleAllComplete" &#125;,&#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123; '': 'index', 'show': 'show' &#125;, index: function () &#123; $(document.body).append("调用了 Index 路由"); &#125;, show: function () &#123; $(document.body).append("调用了 Show 路由"); &#125;,&#125;); 示例：Backbone Router打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。 MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。 传统的架构 单页应用的架构 多了一个前端 MVC 层 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 1234567891011&lt;div ng-app=""&gt; &lt;p&gt; 姓名 : &lt;input type="text" ng-model="name" placeholder="在这里输入您的大名" &gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id="journal"&gt; &lt;input type="text" v-model="message"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端 现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2Fjs%2FHTML%2F</url>
    <content type="text"><![CDATA[@toc1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是分段&lt;/p&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;div&gt;&lt;a href="http://www.baidu.com"&gt;这是链接&lt;/a&gt;&lt;/div&gt; &lt;div id="logo" class="logo"&gt; &lt;img src="http://www.baidu.com/wp-content/uploads/2018/12/2018122312035677.png"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML（超文本标记语言——HyperText Markup Language），它使用标签来定义文本的显示方式。简单来说，HTML就是一种文本文件，里面的内容超出一般文本文件表示，它是用来控制显示格式和对内容进行排版的。 1997年W3C发布HTML 4.0。 2014年发布HTML5 标签12&lt;p&gt;这是分段&lt;/p&gt;&lt;h1&gt;这是大标题&lt;/h1&gt; 如上， &lt;p&gt; 中的p就是标签，且是开始标签， &lt;/p&gt; 是结束标签。开始、结束标签和内容组成完整的元素&lt;p&gt; 标签，它的作用范围是下一个和它层次对应的结束标签 &lt;/p&gt;1&lt;a href="www.baidu.com" target="_blank"&gt;这是链接&lt;/a&gt; href和target是标签的属性 &lt;p /&gt; 空元素可以在开始标签中关闭，也可以 &lt;p&gt;&lt;/p&gt; 。由于p标签是容器标签，在 &lt;p&gt;&lt;/p&gt; 中间可以插入其它标签在HTML中使用单独标签，例如 &lt;br&gt; &lt;hr&gt; &lt;img&gt; 等。它们中就不能插入其它标签标签名可以使用大小写，但是推荐使用小写标签会被解析成一个有层次的DOM树，不要出现标签交错的现象，这是错误的，但是浏览器有容错能力，但是可能显示的格式就不对了 HTML文档结构 文档声明： &lt;!DOCTYPE html&gt; 声明文档类型，这是Html5的声明方式。早期的文档声明很长，规定了HTML遵从的规范，能自动检查错误等 根标签：html标签是根标签 头部：head标签就是头部，一般不是用来显示 内部可以写meta信息、title网页标题、script脚本、样式表等标签 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为utf-8。浏览器会按照这个编码显示字符 正文：body标签才是浏览器显示的正文部分 alt + shift + f 对齐 常用标签链接1&lt;a href="http://www.baidu.com" target="_blank" onclick="alert('anchor')"&gt;这是链接&lt;/a&gt; href属性，指定链接，资源定位符默认 self 打开一个新标签，打开一个新页面，_blank，超链接是最常使用的 target属性，指定是否在本窗口中打开。_blank就是指新窗口打开链接 onclick是点击事件，等号后面往往写一个js函数或脚本执行。很多HTML标签都支持很多事件属性，常见有onclick、ondblclick、onkeydown、onkeyup、onkeypress、onmousedown、onmousemove、onmouseover、onsubmit、onchange等等。后面写的函数称作事件响应函数或事件回调函数。 链接，锚点，定位本页面中资源，还可以定位另一个页面的资源href=“#test” 锚点，前面一定要加# ，在地址栏网页后加#test 123456// 锚点使用&lt;body&gt; &lt;h1&gt;这是最大的标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;div&gt; style="backgroud-color: #f0f0f0"&gt;&lt;a href="#test" target="_blank"&gt;anchor&lt;/a&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt; 默认情况下，超链接点击后会发起一个HTTP GET请求 12345&lt;body&gt; &lt;h1&gt;这是最大的标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;div&gt; style="backgroud-color: #f0f0f0"&gt;&lt;a href="http://www.baidu.com" target="_blank"&gt;anchor&lt;/a&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt; 一般连接内部直接写内容,也可以放图片 如果需要访问超链接，需要加http:// 不然会当做文件访问，跳转相对路径url index.html 静态页面,更快 如果一个都找不到 会抛404错误,配置错误 .. 上一层的图片1&lt;img src="http://www.baidu.com/wp-content/uploads/2018/12/2018122312035677.png"&gt; 图片标签，src指定图片路径注意，图片会发起一个HTTP GET请求如果去掉http:// 为相对路径直接发起请求 标题&lt;h1&gt;~&lt;h6&gt; ，标题标签，默认h1字体最大，h6字体最小 图层1&lt;div id="logo" class="logo"&gt;&lt;/div&gt; id属性，非常重要，标签的唯一标识 class属性，非常重要，样式表定位并附加样式 &lt;div&gt; 标签，目前该标签加上CSS，被广泛用于网页布局中 script http请求，200 是OK，找不到 404错误 列表 无序列表无符号的默认样子1234&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 表格登录使用 div报表展示 table HTML 表格的基本结构： &lt;table&gt;…&lt;/table&gt;：定义表格 &lt;tr&gt;…&lt;/tr&gt;：定义表格的行 &lt;th&gt;…&lt;/th&gt;：定义表格的标题列（文字加粗），一般不用 &lt;td&gt;…&lt;/td&gt;：定义表格的列不过th现在用的少了，表格表头是否字体加粗，都用css控制。所以表中有tr表示行，td表示格子 &lt;br&gt; 换行&lt;hr&gt; 分割线&amp;nbsp; 空格12345678910111213&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;1,1&lt;/th&gt; &lt;th&gt;1,2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2,1&lt;/td&gt; &lt;td&gt;2,2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;占2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; path 路径windows 会先搜索当前工作路径,在搜索path路径linux 需要加 ./ 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;helloword html&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; td &#123; padding: 5px &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="POST" enctype="application/x-www-form-urlencoded"&gt; &lt;table border="1" style="border-collapse: collapse"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;用户注册&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" placeholder="用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password" id="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="gender" id="gender" checked value="M"&gt;男 &lt;input type="radio" name="gender" id="gender" value="F"&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input type="checkbox" name="interest" id="interest" value="music"&gt;音乐 &lt;input type="checkbox" name="interest" id="interest" checked value="movie"&gt; 电影 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"&gt; &lt;input type="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 特别注意：表单控件如果要提交数据，必须使用name属性，否则不能提交到服务端 form标签的重要属性 action，表单数据submit提交到哪里 method，提交的方法，常用POST enctype，对提交的数据编码 application/x-www-form-urlencoded，在发送前编码所有字符（默认） 空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值 multipart/form-data，不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 text/plain，空格转换为 “+” 加号，但不对特殊字符编码 form标签方法有 get post get 我要这个资源你给我，get 只有 head post 提交数据,返回数据 ,常用于表单 GET方法 /test.html 请求路径 HTTP/1.1 请求协议 Host: 127.0.0.1 请求主机 keep-alive 留一段时间URL= 路径 + 协议 + 主机 304 用网页本地缓存 referer 基于某个页面 get 方法请求 以问号开头，使用谁and谁方式 ID给JS用的 name是提交用的，没有name就没有资格提交]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-模块化]]></title>
    <url>%2Fjs%2FJS%20--%20%E6%A8%A1%E5%9D%97%E5%8C%96(babel%E8%BD%AC%E8%AF%91%E5%B7%A5%E5%85%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@toc 概念ES6之前，JS没有出现模块化系统。因为它在设计之初根本没有想到今天的JS应用场景 JS主要在前端的浏览器中使用，js文件下载缓存到客户端，在浏览器中执行比如简单的表单本地验证，漂浮一个广告服务器端使用ASP、JSP等动态网页技术，将动态生成数据嵌入一个HTML模板，里面夹杂着JS后使用 &lt;script&gt; 标签，返回浏览器端执行。 &lt;script&gt; 还可以使用src属性，发起一个GET请求返回一个js文件，嵌入到当前页面执行环境中执行 这时候的JS只是一些简单函数和语句的组合 2005年之后，随着Google大量使用了A JAX技术之后，可以异步请求服务器端数据，带来了前端交互的巨大变化前端功能需求越来越多，代码也越来也多。随着js文件的增多，灾难性的后果产生了： 众多js文件通过 &lt;script&gt; 引入到当前页面中，每一个js文件发起一个GET请求，众多的js文件都需要返回到浏览器端。网络开销成本颇高 习惯了随便写，js脚本中各种全局变量污染，函数名冲突 JS脚本加载有顺序，JS文件中的代码之间的依赖关系（依赖前后顺序、相互依赖） 亟待模块化的出现 2008年V8引擎发布，2009年诞生了Nodejs，支持服务端JS编程。使用JS编程的项目规模越来越大，没有模块化是不可以的之后社区中诞生诸多模块化解决方案 CommonJS规范（2009年），使用全局require函数导入模块，将所有对象约束在模块对象内部，使用exports导出指定的对象最早这种规范是用在Nodejs后端的，后来又向前端开发移植，这样浏览器端开发也可以使用CommonJS了 AMD（Asynchronous Module Definition）异步模块定义，这是由社区提出的一种浏览器端模块化标准。使用异步方式加载模块，模块的加载不影响它后面语句的执行。所有依赖这个模块的语句，都需要定义在一个回调函数，回调函数中使用模块的变量和函数，等模块加载完成之后，这个回调函数才会执行，就可以安全的使用模块的资源了。其实现就是AMD/RequireJs。AMD虽然是异步，但是会预先加载和执行。目前应用较少 CMD（Common Module Definition），使用seajs，作者是淘宝前端玉伯，兼容并包解决了RequireJs的问题CMD推崇as lazy as possible，尽可能的懒加载 由于社区的模块化呼声很高，ES6开始提供支持模块的语法，但是浏览器目前支持还不够 ES6模块化ES6中模块自动采用严格模式 import语句，导入另一个模块导出的绑定 export语句，从模块中导出函数、对象、值的，供其它模块import导入用导出建立一个模块目录src，然后在这个目录下新建一个moda.js，内容如下：缺省导出12345678export default class A&#123; constructor(x)&#123; this.x = x; &#125; show()&#123; console.log(this.x); &#125;&#125; 导出函数123export function foo()&#123; console.log('foo function');&#125; 导出常量1export const CONSTA = 'aaa' 导入其它模块中导入语句如下12import &#123;CONSTA, foo&#125; from "./moda";import * as mod_a from "./moda"; VS Code可以很好的语法支持了，但是运行环境，包括V8引擎，都不能很好的支持模块化语法 转译工具转译就是从一种语言代码转换到另一个语言代码，当然也可以从高版本转译到低版本的支持语句 由于JS存在不同版本，不同浏览器兼容的问题使用transpiler转译工具解决对语法的支持问题 babel开发中可以使用较新的ES6语法，通过转译器转换为指定的某些版本代码 官网 http://babeljs.io/ 参考文档 https://babeljs.io/docs/en/6.26.3/index.html 注意当前版本7.x已经有了较大的变化，请参看6.x文档 打开Try it out，测试一段代码12345678function * counter()&#123; let i = 0; while(true) yield (++i);&#125;g = counter();console.log(g.next().value); 预设有如下一些预设presets，我们先看看有哪些，一会儿再进行预设的安装和配置1234567891011121314presets：babel-preset-env 当前环境支持的代码，新targetES2015转码规则$ npm install --save-dev babel-preset-es2015react转码规则$ npm install --save-dev babel-preset-reactES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 离线转译安装配置1、初始化npm在项目目录中使用$ npm initnpm 相当于 linux 的yum ；相当于python 的pip在项目根目录下会生成package.json文件，内容就是上面花括号的内容descriotion 描述entry point 入口 test command 测试的命令license 许可证 package.json 根目录 这个文件很重要 先对项目初始化，才可以使用babel 2、设置镜像 为了连接国内的服务器，当前项目创建一个配置 .npmrc文件 可以放在全局配置下，所有人用 可以放到用户家目录中，当前用户下所有项目使用 可以放到项目根目录中，当前项目用（推荐此种做法） 参考 http://npm.taobao.org/本次放到项目根目录中，内容如下 registry=https://registry.npm.taobao.org1`$ echo "registry=https://registry.npm.taobao.org" &gt; .npmrc` 3、安装项目根目录下执行$ npm install babel-core babel-cli --save-dev --save-dev说明 当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（dependencies）。开发用 --save和--save-dev可以省掉你手动修改package.json文件的步骤 spm install module-name --save 自动把模块和版本号添加到dependencies部分。部署运行时用 spm install module-name --save-dev 自动把模块和版本号添加到devdependencies部分 安装完后，在项目根目录下出现 node_modules目录 ，里面有babel相关模块及依赖的模块 -g 安装全局，非万不得，不要使用没有加 -g 默认安装到当前项目中 4、配置babel和安装预设在目录根目录下创建 .babelrc 文件，Json格式123&#123; "presets": ["env"]&#125; env 可以根据当前环境自动选择安装依赖$ npm install babel-preset-env --save-dev 5、准备目录项目根目录下建立src和lib目录 src 是源码目录 lib 是目标目录 6、修改package.json替换为 scripts 的部分12345678910111213141516&#123; "name": "src", "version": "1.0.0", "description": "", "main": "moda.js", "scripts": &#123; "build": "babel src -d lib" &#125;, "author": "luxia", "license": "ISC", "devDependencies": &#123; "babel-cli": "^6.26.0", "babel-core": "^6.26.3", "babel-preset-env": "^1.7.0" &#125;&#125; babel src -d lib 意思是从src目录中转译后的文件输出到lib目录 7、准备js文件在src中的moda.js文件12345678910111213// 缺省导出export default class A&#123; constructor(x)&#123; this.x = x; &#125; show()&#123; console.log(this.x) &#125;&#125;export function foo()&#123; console.log('foo function')&#125; src目录下新建index.js123456import A, &#123;foo&#125; from "./moda";var a = new A(100);a.show();foo(); 直接在VS Code的环境下执行出错。估计很难有能够正常运行的环境。所以，要转译为ES5的代码。 在项目根目录下执行命令1$ npm run build 可以在lib文件夹中看到，2个文件被转译 运行文件 1$ node lib/index.js 使用babel等转译器转译JS非常流行开发者可以在高版本中使用新的语法特性，提高开发效率，把兼容性问题交给转译器处理 npx是包之心器命令从npm 5.2开始提供。npx可以直接执行已经安装过的包的命令，而不用配置package.json中的run-script1npx babel src -d lib 1node lib/index.js 导入导出导出代码都在src/moda.js中，导入代码都写在src/index.js中 缺省导入导出只允许一个缺省导出，缺省导出可以是变量、函数、类，但不能使用let、var、const关键字作为默认导出 缺省导入的时候，可以自己重新命名，可以不需要和缺省导出时的名称一致，但最好一致 缺省导入，不需要在import后使用花括号12345678// 缺省导出 匿名函数export default function()&#123; console.log('default export function')&#125;// 缺省导入import defaultFunc from '/.moda'defaultFunc(); 12345678// 缺省导出 命名函数export default function xyz()&#123; console.log('default export function')&#125;// 缺省导入import defaultFunc from './moda'defaultFunc(); 命名导入导出 导出举例 123456789101112131415161718192021222324252627// 缺省导出类export default class &#123; constructor(x) &#123; this.x = x; &#125; show() &#123; console.log(this.x); &#125;&#125;// 命名导出 函数export function foo() &#123; console.log('regular foo()');&#125;// 函数定义function bar() &#123; console.log('regular bar()');&#125;// 变量常量定义let x = 100;var y = 200;const z = 300;// 导出export &#123; bar, x, y, z &#125;; 导入举例as 设置别名12345678import defaultCls, &#123; foo, bar, x, y, z as CONST_C &#125; from './moda';foo();bar();console.log(x); // x只读，不可修改，x++异常console.log(y); // y只读console.log(CONST_C);new defaultCls(1000).show(); 也可以使用下面的形式，导入所有导出，但是会定义一个新的名词空间。使用名词空间可以避免冲突12345import * as newmod from './mod';newmod.foo();newmod.bar();new newmod.default(2000).show();]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js]]></title>
    <url>%2Fjs%2FNodejs%20--%20ES6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[@[toc] NodejsNodejs是服务器端运行JavaScript的开源、跨平台运行环境Nodejs原始作者瑞安·达尔（Ryan Dahl），于2009年发布，使用了V8引擎，并采用事件驱动、非阻塞、异步IO模型 2010年，npm软件包管理器诞生，通过它，可以方便的发布、分享Nodejs的库和源代码 Nodejs 4.0引入了ES6语言特性 安装 国内可以去阿里云镜像站https://npm.taobao.org/mirrors/node Linuxhttps://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.xz解压即可运行 windowshttps://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x64.msi 10版本 长期支持版本 11、12 临时版本 10.16.x是LTS msi安装会增加path路径全局安装目录 C:\Program Files\nodejs\本用户目录 C:\Users\Administrator\AppData\Roaming\npm$ node -v 查看版本开发文档搜索MDN，Mozilla Developer Network，提供非常完善HTML、CSS、JS等的技术资料。https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 指南 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide 非常好的JS文档使用任何一种文本编辑器，都可以开发JS，此次使用微软的Visual Studio Code进行开发 Visual Studio Code下载 https://code.visualstudio.com/Download支持windows、mac、Linux平台新版VS Code Windows版分为System 和 User两个版本，当前用户使用安装User版即可 有代码自动完成功能，还可以安装Node exec插件，将写的js跑在nodejs上Node Exec插件快捷键：F8运行js脚本，F9停止前端开发中，JS脚本一般来说是为了控制浏览器的网页的，这里使用了VSCode，只是为了开发调试方便 解决快捷键冲突F8和某些软件冲突，无法使用，例如某些词典软件可以通过调整VSCode的快捷键设置。当然可以修改其他软件的快捷键 设定 工作目录 创建文件 注释console.log() 输出到控制台，类似于python的print() 和C、Java一样 // 单行注释 /* 注释 */ 多行注释，也可以用在语句中常量和变量标识符标识符必须是字母、下划线、美元符号$和数字，但必须是字母、下划线、美元符号开头，依然是不能数字开头就行标识符区分大小写声明 var 声明一个变量，不能突破函数作用域 let 声明一个块作用域中的局部变量，小范围使用，不能突破大括号作用域，更加不能突破函数作用域 const 声明一个常量常量不允许改变, 常量不能分开写，必须立即赋值 JS中的变量声明和初始化是可以分开的123456789101112var a // 只是声明，a为undefinedlet bconsole.log(1,a,b)a = 1b = 'a string'console.log(2,a,b)//const c // 不可以const c = 100 // 常量必须声明时赋值，之后不能再改console.log(c)//c = 200 // 不可以更改 var y只是声明，y值为undefined var x = 5规范的声明并初始化，声明全局或局部变量。 z = 6不规范的初始化，不推荐。在严格模式下会产生异常。在赋值之前不能引用，因为它没有声明。一旦这样赋值就是全局作用域函数1234567891011function hello()&#123; var a // 只是声明，a为undefined，作用域在函数中 a = 100&#125;console.log(a) // 未声明变量a，异常//a = 200 // 不能声明提升//let a = 200 // 不能声明提升//var a = 200; hello(); // var声明提升hoisting var 可以声明提升 相当于放在console.log()前面 没有赋值打印的是 undefined 如果变量在console.log()后，没有var 会报nameError1234var aconsole.log(a) // undefineda = 100console.log(a) // 100 常量和变量的选择如果明确知道一个标识符定义后不再修改，应该尽量声明成const常量，减少被修改的风险，减少Bug 数据类型 名称 说明 number 数值型，包括整型和浮点型 boolean 布尔型，true和false string 字符串。需用单双引号、反引号 null 只有一个值null undefined 变量声明未赋值的；对象未定义的属性 symbol ES6 新引入类型 object类型 是以上基本类型的复合类型，是容器 ES是动态语言，弱类型语言 动态语言：变量使用时无需事先声明类型 弱类型语言：字符串加整型，不报错就是弱类型console.log(&#39;a&#39; + 1) // a1 虽然先声明了变量，但是变量可以重新赋值任何类型 对象的定义1234567891011let a = &#123;a:100&#125;console.log(a.a) // 100b = 200let c = &#123;b&#125;console.log(c.b) // 200d = 1000e = 2000let f = &#123;d, e&#125;console.log(f) // &#123; d: 1000, e: 2000 &#125; 类型转换字符串1234console.log(a = 3 + 'hello', typeof(a)) // 3hello stringconsole.log(a = null + 'hello', typeof(a)) // nullhello stringconsole.log(a = undefined + 'hello', typeof(a)) // undefinedhello stringconsole.log(a = true + 'hello', typeof(a)) // truehello string python的 typy(str) 返回的是class js的 typeof(str) 返回的是str数字1234console.log(a = null + 8, typeof(a)) // 8 'number'console.log(a = undefined + 8, typeof(a)) // NaN 'number'console.log(a = true + 8, typeof(a)) // 9 'number'console.log(a = false + 8, typeof(a)) // 8 'number' NaN ： not a number不是一个数字，但是他是数字类型 undefined 没法转换成一个对应的数字 null = 0 true = 1 false = 0boolean123456console.log(a = null + true, typeof(a)) // 1 'number'console.log(a = null + false, typeof(a)) // 0 'number'console.log(a = undefined + true, typeof(a)) // NaN 'number'console.log(a = undefined + false, typeof(a)) // NaN 'number'console.log(a = null &amp; true, typeof(a)) // 0 'number'console.log(a = undefined &amp; true, typeof(a)) // 0 'number' 短路12345console.log(a = null &amp;&amp; true, typeof(a)) // null 'object'console.log(a = false &amp;&amp; null, typeof(a)) // false 'boolean'console.log(a = false &amp;&amp; 'hello', typeof(a)) // false 'boolean'console.log(a = true &amp;&amp; 'hello', typeof(a)) // hello stringconsole.log(a = true &amp;&amp; '', typeof(a)) // string 解析： 第一个：逻辑运算符，null 直接就是false短路 第二个：逻辑运算符，false短路返回false 第三个：boolean 第三个：字符串 第五个：返回的是空字符串，看不见。 null1console.log(a = null + undefined, typeof(a)) // NaN 'number' 弱类型，不需要强制类型转换，会隐式类型转换。 NaN，即Not a Number，转换数字失败。它和任何值都不等，和自己也不等，只能使用Number.isNaN(NaN) &amp;&amp; and|| or&amp; 位与 | 位或 总结： 遇到字符串，加号就是拼接字符串，所有非字符串隐式转换为字符串。 如果没有字符串，加号把其他所有类型都当数字处理，非数字类型隐式转换为数字。undefined特殊，因为它都没有定义值，所以转换数字失败得到一个特殊值NaN。 如果运算符是逻辑运算符，短路符，返回就是短路时的类型。没有隐式转换。 除非你十分明确，否则不要依赖隐式转换。写代码的时候，往往为了程序的健壮，请显式转换。注意： 以上的原则不要死记，忘了就实验，或者显式的类型转换 字符串将一个值使用’ 单引号或者 “双引号 引用起来就是字符串ES6提供了反引号定义一个字符串，可以支持多行，还支持插值123456789101112131415161718let a = 'abc'let b = "135"let c = `line1line2line3` // 支持多行console.log(c)// 字符串插值,要求在反引号字符串中.python3.6支持let name="tom", age = 19console.log(`my name is $&#123;name&#125;. I am $&#123;age&#125;`)// 执行结果line1line2line3my name is tom. I am 19 %{} 里面还可以写表达式，例如123456789101112let a = 'abc'let b = "135"let c = `line1$&#123;a + b&#125;line3`console.log(c)# 执行结果line1abc135line3 转义字符 名称 说明 \0 ASCII 0，Null字符，空字符 \b 退格符 \f 换页符 \n 换行符 \r 回车符 \t Tab(制表符) \v 垂直制表符 \’ 单引号 \” 双引号 \ 反斜杠字符 ( \ ) \XXX 由从0到377最多三位八进制数XXX表示的Latin-1字符。例如，\251是版本符号的八进制序列 \xXX 由从00到FF的两位十六进制数字XX表示的Latin-1字符。例如，\xA49是版本符号的十六进制序列 \uXXXX 由四位十六进制数字XXXX表示的Unicode字符。例如，\u00A9是版本符号的Unicode序列。见Unicode escape sequences(Unicode 转义字符) \u{XXXXX} Unicode代码点（code point）转义字符。例如，\u{2f804}相当于Uicode转义字符\uD87E\uDC04的简写 字符串操作方法字符串操作方法很多，但和Python类似12345678910111213141516171819202122232425262728let test = 'Python'console.log(test.charAt(2)) // t 索引console.log(test[2]) // t 索引 常用console.log(test.toUpperCase()) // PYTHONconsole.log(test.concat('.org')) // Python.org 字符串拼接console.log(test.slice(3)) // hon 切片,支持负索引console.log(test.slice(3,5)) // ho [3, 5)前包后不包console.log(test.slice(-2, -1)) // oconsole.log(test.slice(-2)) // onconsole.log(test.repeat(3)) // PythonPythonPythonconsole.log(test.endsWith('n')) // trueconsole.log(test.endsWith('P')) // falseconsole.log(test.search('t')) // 2console.log(test.length) // 6 长度let url = "www.python.org"console.log(url.split('.')) // [ 'www', 'python', 'org' ]console.log(url.substr(7, 2)) // ho 返回字符串从何处开始,取多长console.log(url.substring(7, 10)) //hon 返回子串,从何处开始,到什么为止,前包后不包let s ='python.hon'console.log(s.indexOf('ho')) // 3console.log(s.indexOf('ho', 4)) // 7console.log(s.replace('.hon', '.com')) // python.com 字符串替换s = '\tpyt hon \r\n'console.log(s.trim()) // pyt hon 去除两端的空白字符// trimLeft、trimRight是非标函数，少用 数值型number在JS中，数据均为双精度浮点型范围只能在-(2^53 -1) 和 2^53 -1之间，整型也不例外数字类型还有三种符号值 +Infinity（正无穷） -Infinity（负无穷） NaN (not-a-number非数字) 二进制0b0010、0B110八进制0755。注意0855，将被认作十进制，因为8不在八进制中。ES6中最好使用0o前缀表示八进制。十六进制0xAA、0Xff。指数表示1E3（1000），2e-2（0.02） 常用属性1234567891011121314console.log(Number.MAX_VALUE)console.log(Number.MAX_SAFE_INTEGER)console.log(Number.MIN_VALUE)console.log(Number.POSITIVE_INFINITY) // 正无穷console.log(Number.NEGATIVE_INFINITY) // 负无穷console.log(Number.NaN)// 执行结果1.7976931348623157e+30890071992547409915e-324Infinity-InfinityNaN 数字的方法 方法 描述 Number.parseFloat() 把字符串参数解析成浮点数，和全局方法 parseFloat() 作用一致 Number.parseInt() 把字符串解析成特定基数对应的整型数字，和全局方法 parseInt() 作用一致 Number.isFinite() 判断传递的值是否为有限数字 Number.isInteger() 判断传递的值是否为整数 Number.isNaN() 判断传递的值是否为 NaN 123456789let a = 0x712console.log(Number.MAX_SAFE_INTEGER)console.log(Number.isNaN(NaN))console.log(Number.NaN ==Number.NaN)// 执行结果9007199254740991truefalse NaN不能用等值来做 只能用判断来做 内置数学对象MathMath提供了绝对值、对数指数运算、三角函数运算、最大值、最小值、随机数、开方等运算函数，提供了PI值123456789101112console.log(Math.PI)console.log(Math.abs(-1))console.log(Math.log2(16))console.log(Math.sqrt(2))console.log(Math.random()) // (0,1)// 执行结果3.141592653589793141.41421356237309510.8018837833232821 运算符算数运算符 parseInt 直接截取 整数部分 Math.ceil 向上取整 Math.floor 向下取整 Math.round 四舍五入 + - * / %等运算符和Python一样1234567891011121314151617181920212223242526272829console.log(1/2)console.log(1/0)console.log(5 % 3)console.log(parseInt(1/2),parseInt(3/2),parseInt(5/2))console.log(parseInt(-1/2),parseInt(-3/2),parseInt(-5/2))console.log(Math.floor(1/2),Math.floor(3/2),Math.floor(5/2))console.log(Math.floor(-1/2),Math.floor(-3/2),Math.floor(-5/2))console.log(Math.ceil(1/2),Math.ceil(3/2),Math.ceil(5/2))console.log(Math.ceil(-1/2),Math.ceil(-3/2),Math.ceil(-5/2))console.log(Math.round(1/2),Math.round(3/2),Math.round(5/2))console.log(Math.round(-1/2),Math.round(-3/2),Math.round(-5/2))// 执行结果0.5Infinity2-0 1 2-0 -1 -20 1 2-1 -2 -31 2 3-0 -1 -21 2 3-0 -1 -2 ++ 和 –单目运算符，代表变量自增、自减 i++ 先用i，用完之后i再自增加1++i i先自增，再使用i 123456let i = 0 let a = i++console.log(a , i) // 0 1console.log(a, i++) // 0 1a = ++iconsole.log(a, ++i) // 3 4 123i = 0;let a = ++i+i+++i+++i; // 等价于 (++i) + (i++) + (i++) + iconsole.log(a); // / 1 + 1 + 2 + 3 =7 1、单目运算符优先级高于双目运算符2、加号+是双目运算符，两边的表达式必须先计算好 正负无穷1234console.log(1/2) // 0.5console.log(5 % 2) // 1console.log(1/0) // Infinity 正无穷console.log(-1/0) // -Infinity 负无穷 比较运算符12345&gt; &lt; &gt;= &lt;= 没有什么区别!= == !== ===== 宽松相等，进行类型转换，=== 严格相等，不进行类型转换 123456789101112131415console.log(100 &gt; 200) // falseconsole.log(100 &gt; '200') // falseconsole.log(300 &gt; '200') // trueconsole.log(1000 &gt; '200') // trueconsole.log('1000' &gt; 200) // trueconsole.log('100'&gt; '200') // falseconsole.log('1000' &gt; '200') // falseconsole.log('-'.repeat(30))// 类型转换失败 为falseconsole.log(1000 &gt; '200a') // falseconsole.log(1000 &gt; '0a') // falseconsole.log(1000 &gt; 'a') // falseconsole.log(1000 &gt; NaN) // falseconsole.log(1000 &lt; NaN) // false 类型转换失败 为false == 隐式类型转换=== 严格等式，内容相等，类型相等安全代码，建议使用 三等号1234console.log(100 == 200) // falseconsole.log(100 == '200') // falseconsole.log(200 == '200') // trueconsole.log(200 === '200') // false 逻辑运算符&amp;&amp; 、|| 、 !与、或、非这些运算符和其他高级语言都一样，支持短路 位运算&amp; | ^ ~ &lt;&lt; &gt;&gt;位与、位或、异或、取反、左移、右移，和Python一样异或，相异出1 三元运算符12345678910条件表达式?真值:假值等价于简单的if...else结构if (条件表达式) &#123; 真值&#125;else &#123; 假值&#125; 123456789console.log(('3' &gt; 30)?'t':'f') // flet a = 100console.log(a); // 100let b=a++console.log(b); // 100let c = 100 &gt; ++b?'t':'f'console.log(a, b, c); // 101 101 f 逗号操作符JS运行多个表达式写在一起return 会返回最后一个变量的值 其他 名称 说明 instanceof 判断是否属于指定类型 typeof 返回类型字符串 delete delete操作符, 删除一个对象(an object)或一个对象的属性(an object’s property)或者一个数组中某一个键值(an element at a specified index in an array) in 如果指定的属性在对象内，则返回true instanceof、typeofinstanceof 要求必须明确使用类型定义变量，就是对象必须是new关键字声明创建的。它可以用于继承关系的判断 typeof就是返回对象的类型字符串 实例化 必须要加 new [ ] { } 是 object对象1234567891011console.log('a' instanceof String); // falseconsole.log(typeof 'a', typeof 'a' == 'string'); // string trueconsole.log(1 instanceof Number); // falseconsole.log(typeof 1, typeof 1 == 'number'); // number trueconsole.log(a = new String('a'), a instanceof String,) ; // [String: 'a'] trueconsole.log(typeof a, typeof a == 'string'); // object falseconsole.log(b = new Number(1), b instanceof Number) ; // [Number: 1] trueconsole.log(typeof b, typeof b == 'number'); // object falseconsole.log([] instanceof Object) // true delete删除对象、属性、数组元素 自定义的可以删除 隐式赋值可以删除1234567891011121314151617181920212223242526272829303132333435363738394041x = 42;var y = 43;let z = 60;myobj = new Number();myobj.h = 4; // create property hconsole.log(delete x); // returns true (can delete if declared implicitly)console.log(delete y); // returns false (cannot delete if declared with var)console.log(delete z); // returns falseconsole.log(delete Math.PI); // returns false (cannot delete predefined properties)console.log(delete myobj.h); // returns true (can delete user-defined properties)console.log(delete myobj); // returns true (can delete if declared implicitly)console.log('~~~~~~~~~~~~~~~~~~~~')var trees = new Array("redwood", "bay", "cedar", "oak", "maple");for(var i=0;i&lt;trees.length;i++) console.log(trees[i])console.log('==================')delete trees[3]; // 数组中元素被删除，但空着的位置是undefinedfor(var i=0;i&lt;trees.length;i++) console.log(trees[i])// 执行结果truefalsefalsefalsetruetrue~~~~~~~~~~~~~~~~~~~~redwoodbaycedaroakmaple==================redwoodbaycedarundefinedmaple 删了数组的元素，个数不会少，会补充undefined pop可以pop掉，删除最后一个元素长度会变短，元素会移除123456789101112131415161718var trees = new Array("redwood", "bay", "cedar", "oak");for (var i=0;i&lt;trees.length;i++) console.log(trees[i])console.log('=============')trees.pop()for (var i=0;i&lt;trees.length;i++) console.log(trees[i])// 执行结果redwoodbaycedaroak=============redwoodbaycedar in判断属性是否在对象内1234567891011121314151617181920212223242526272829303132333435363738394041let trees = new Array("redwood", "bay", "cedar", "oak", "maple");console.log(0 in trees); // returns true ，0在数组对象的index中console.log(3 in trees); // returns true ，3在数组对象的index中console.log(6 in trees); // returns false，6不在数组对象的index中console.log("bay" in trees); // return false，bay不是属性，它是值console.log("length" in trees); // returns true，length是对象的属性console.log('~~~~~~~~~~~~~~~~~~~~')delete trees[3];console.log(3 in trees); // return falsefor(var i=0;i&lt;trees.length;i++) console.log(trees[i]);console.log('~~~~~~~~~~~~~~~~~~~~')// Custom objectslet mycar = &#123; color: "red", year: 1998&#125;;console.log("color" in mycar); // returns trueconsole.log("model" in mycar); // returns falseconsole.log('year' in mycar) // true// 执行结果truetruefalsefalsetrue~~~~~~~~~~~~~~~~~~~~falseredwoodbaycedarundefinedmaple~~~~~~~~~~~~~~~~~~~~truefalsetrue 运算符优先级 运算符由高到低，顺序如下* / % 双目,以下都是双目逗号运算符优先级最低，比赋值语句还低。记不住，就使用括号。表达式基本表达式，和Python差不多 解析式也和Python的相似，但在ES6中非标准不推荐使用生成器推荐使用生成器函数，ES6开始支持1234567891011121314151617181920212223function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next());// 执行结果&#123; value: 0, done: false &#125;&#123; value: 1, done: false &#125;&#123; value: 2, done: false &#125;&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: 6, done: false &#125;&#123; value: 7, done: false &#125;&#123; value: 100, done: true &#125;&#123; value: undefined, done: true &#125; j = 7 !j 值取not, 7 为真，取not 为false value 取 值123456789101112131415161718192021222324function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next().value);// 执行结果01234567100undefined done 取状态123456789101112131415161718192021222324function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next().done);// 执行结果falsefalsefalsefalsefalsefalsefalsefalsetruetrue]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-高阶对象]]></title>
    <url>%2Fjs%2FJS%20-%20%E9%AB%98%E9%98%B6%E5%AF%B9%E8%B1%A1%E3%80%81%E9%AB%98%E9%98%B6%E7%B1%BB%E6%88%96%E7%A7%B0Mixin%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[@tocMixin模式，混合模式 JS是基于对象的，类和对象都是对象模板混合mixin，指的是将一个对象的全部或者部分拷贝到另一个对象上去。其实就是属性可以将多个类或对象混合成一个类或对象 继承实现继承：子子孙孙都有基类的功能1234567891011121314151617181920class Serialization &#123; constructor() &#123; console.log('Serialization constructor~~~'); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125;&#125;//s = new Serialization(); // 构造Serialization失败//p = new Point(4,5); // 构造子类对象时，调用父类构造器执行也会失败 父类构造函数中，要求具有属性是stringify的序列化函数，如果没有则抛出异常 完整继承的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Serialization &#123; constructor() &#123; console.log('Serialization constructor~~~'); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125; stringify() &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;&gt;` &#125;&#125;class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125; stringify() &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;, z=$&#123;this.z&#125;&gt;` &#125;&#125;p = new Point(4, 5);console.log(p.stringify())p3d = new Point3D(7, 8, 9);console.log(p3d.stringify());/* 执行结果Point Constructor~~~~Serialization constructor~~~&lt;Point x=4, y=5&gt;Point Constructor~~~~Serialization constructor~~~&lt;Point x=7, y=8, z=9&gt;*/ 高阶对象实现将类的继承构建成箭头函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 普通的继承class A extends Object &#123; &#125;;console.log(A);// 匿名类const A1 = class &#123; constructor(x) &#123; this.x = x; &#125;&#125;console.log(A1);console.log(new A1(100).x);// 匿名继承const B = class extends Object &#123; constructor() &#123; super(); console.log('B constructor'); &#125;&#125;;console.log(B);b = new B();console.log(b);// 箭头函数，参数是类，返回值也是类// 把上例中的Object看成参数const x = (Sup) =&gt; &#123; return class extends Sup &#123; constructor() &#123; super(); console.log('C constructor'); &#125; &#125;;&#125;// 演化成下面的形式const C = Sup =&gt; class extends Sup &#123; constructor() &#123; super(); console.log('C constructor'); &#125;&#125;;//cls = new C(Object); // 不可以new，因为C是一个普通函数，它的返回值是一个带constructor的类cls = C(A); // 调用它返回一个类，一个带constructor的classconsole.log(cls);c = new cls();console.log(c);// 其它写法c1 = new (C(Object))(); // new优先级太高了，所有后面要加括号才能先调用/* 执行结果[Function: A][Function: A1]100[Function: B]B constructorB &#123;&#125;[Function: A]C constructorA &#123;&#125;C constructor*/ 说到底，上面的C这个函数，本质上就是传入一个基类，然后通过基类继承构造一个新的类。 Mixin类缺什么能力 补什么能力 可以改造上面序列化的例子1234567891011121314151617181920212223242526272829303132333435363738const SerializationMixin = Sup =&gt; class extends Sup &#123; constructor(...args) &#123; console.log('SerializationMixin constructor~~~'); super(...args); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); this.x = x; this.y = y; &#125;&#125;class Point3D extends SerializationMixin(Point) &#123; constructor(x, y, z) &#123; super(x, y); // super是Serialization(Point)包装过的新类型 this.z = z; &#125; stringify() &#123; return `&lt;Point3D $&#123;this.x&#125;.$&#123;this.y&#125;.$&#123;this.z&#125;&gt;`; &#125;&#125;let p3d = new Point3D(70, 80, 90);console.log(p3d.stringify());/*执行结果SerializationMixin constructor~~~Point Constructor~~~~&lt;Point3D 70.80.90&gt;*/ 注意： Serialization(Point)这一步实际上是一个匿名箭头函数调用，返回了一个新的类型，Point3D继承自这个新的匿名类型，增强了功能。 React框架大量使用了这种Mixin技术 Serialization(Point)传入的参数是类，返回值也是一个类，这就是高阶类]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-Promise]]></title>
    <url>%2Fjs%2FJS%20--%20Promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[@toc 概念ES6开始支持Promise对象用于一个异步操作的最终完成（包括成功和失败）及结果值的表示 简单说，就是处理异步请求的。之所以叫做Promise，就是我承诺做这件事，如果成功则怎么处理，失败则怎么处理12345// 语法new Promise( /* 下面定义的函数是executor */ function(resolve, reject) &#123;...&#125;); executor executor 是一个带有 resolve 和 reject 两个参数的函数 executor 函数在Promise构造函数执行时立即执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用） executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled即完成，或者在发生错误时将它的状态改为rejected即失败 如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略 executor中，resolve或reject只能执行其中一个函数Promise的状态 pending: 初始状态，不是成功或失败状态 fulfilled: 意味着操作成功完成 rejected: 意味着操作失败1234567891011121314151617setInterval(function[, delay]); // 间隔多少毫秒就执行函数一次，循环执行setTimeout(function[, delay]); // 等待多少毫秒就执行函数一次，结束delay // 延时，缺省0，立即执行function // 延时到的时候执行的函数var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); &#125;, 3000); // &#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++')&#125;, 1000); // 每隔1秒执行一次 Promise.then(onFulfilled, onRejected)参数是2个函数，根据当前Promise对象A的状态来调用不同的函数，fulfilled走onFulfilled函数F1，rejected走onRejected函数F2then的返回值是一个新的promise对象B，执行任意一个回调函数，对这个promise对象来说就是其返回值调用任何一个函数后，其返回值可以被后续的then方法继续捕捉（链式） 任何一个回调函数执行，其返回值ret被resolve(ret)，作为B的完成结果1234567891011121314151617181920212223242526272829var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++');&#125;, 1000); // 每隔1秒执行一次let pro1 = myPromise.then( value =&gt; &#123; console.log('successful'); return 1111; &#125;, reason =&gt; &#123; console.log('failed'); return 2222; &#125;)setInterval(() =&gt; &#123; console.log(pro1, '@@@@');&#125;, 1000); // 每隔1秒执行一次 catch(onRejected) 为当前Promise对象A添加一个拒绝回调F，返回一个新的Promise对象B 如果A进入fulfilled状态，则A的完成结果作为B的完成结果 如果A进入rejected状态，回调F执行，F的返回值ret来resolve(ret) 12345678910111213141516171819202122var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++');&#125;, 1000); // 每隔1秒执行一次let pro2 = myPromise.catch(reason=&gt;&#123; console.log(reason, '****')&#125;)setInterval(() =&gt; &#123; console.log(pro2, '####');&#125;, 1000); // 每隔1秒执行一次 Promise 提供2个方法： Promise.resolve(value) 返回 状态为fulfilled的Promise对象 Promise.reject(reason)返回 状态为rejected状态的Promise对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)let pro1 = myPromise.then( value =&gt; &#123;/*如果成功则显示结果*/ console.log(1, 'successful'); return 1111; &#125;, reason =&gt; &#123;/*如果失败则显示原因*/ console.log(2, 'failed'); return 2222; &#125;)let pro2 = myPromise.catch(reason=&gt;&#123; console.log(3, reason)&#125;)// 开始链式调用pro2.then( value =&gt; console.log(4, value), // value是什么？ reason =&gt; console.log(5, reason) // reason是什么？).then( value =&gt; &#123; console.log(6, value) // 已经不是pro2对象了，value是什么 return Promise.reject('pro2 =&gt; new Promise object rejected'); &#125;).catch( reason =&gt; &#123; console.log(7, reason); return Promise.resolve(reason + ' *') &#125;).then( value =&gt; console.log(8, value), // value是什么？ reason =&gt; console.log(9, reason) // reason是什么？) // 返回的是什么？/*执行结果do sth.~~~~~1 'successful'4 'ok'6 undefined7 'pro2 =&gt; new Promise object rejected'8 'pro2 =&gt; new Promise object rejected *'*/ 异步实例1234567891011121314151617181920212223242526272829303132333435363738function runAsync() &#123; return new Promise(function (resolve, reject) &#123; // 异步操作 setTimeout(function () &#123; console.log('do sth...'); resolve('ok...'); &#125;, 3000); &#125;);&#125;// 调用runAsync().then( value =&gt; &#123; console.log(value); return Promise.reject(value + '*'); &#125;).catch( reason =&gt; &#123; console.log(reason); return Promise.resolve(reason + '*'); &#125;).then( value =&gt; &#123; console.log(value); console.log('Promise END'); &#125;)console.log('==== FIN ====');/*执行结果==== FIN ====do sth...ok...ok...*ok...**Promise END*/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-解构]]></title>
    <url>%2Fjs%2FJS%20-%E8%A7%A3%E6%9E%84%E5%8F%8A%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOCJS的解构很灵活，参考https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator 列表解构123var parts = ['shoulder', 'knees'];var lyrics = ['head', ...parts, 'and', 'toes']; // 使用...解构console.log(lyrics) // [ 'head', 'shoulder', 'knees', 'and', 'toes' ] 参数解构12345678910let arr = [1, 2]let arr1 = [...arr]function f(x, y, z) &#123; console.log(x + y + z)&#125;var args = [2, 3, 4];f(...arr); // NaNf(...args); // 9f(...['a', 'b']); // abundefined 数组解构JS的数组解构非常强大1234567891011121314151617181920212223242526272829303132333435const arr = [100,200,300];let [x,y,z] = arr;console.log(1,x,y,z);// 丢弃const [,b,] = arr;console.log(2,b);//b = 5 // 异常，b声明为const// 少于数组元素const [d,e] = arr;console.log(3,d,e);// 多于数组元素const [m,n,o,p] = arrconsole.log(4,m,n,o,p);// 可变变量const [f,...args] = arrconsole.log(5,f);console.log(5,args);// 支持默认值const [j=1,k,,,l=10] = arrconsole.log(j,k,l);/* 执行结果1 100 200 3002 2003 100 2004 100 200 300 undefined5 1005 [ 200, 300 ]100 200 10*/ 解构的时候，变量从左到右和元素对齐，可变参数放到最右边能对应到数据就返回数据，对应不到数据的返回默认值，如果没有默认值返回undefined 对象解构简单对象解构，非常有用1234567891011121314151617const obj = &#123; a: 100, b: 200, c: 300&#125;var &#123;x, y, z&#125; = obj;console.log(x, y, z); // undefined undefined undefinedvar &#123;a, b, c&#125; = obj; // key名称console.log(a, b, c); // 100 200 300var &#123;a: m, b: n, c&#125; = obj; // 重命名console.log(m, n, c); // 100 200 300var &#123;a: M, c: N, d: D = 'python'&#125; = obj; //缺省值console.log(M, N, D); // 100 300 'python' 解构时，需要提供对象的属性名，会根据属性名找到对应的值。没有找到的返回缺省值，没有缺省值则返回undefined 复杂解构嵌套数组123456789101112const arr = [1, [2, 3], 4];const [a, [b, c], d] = arr;console.log(a, b, c, d); //1 2 3 4const [e, f] = arr;console.log(e, f); //1 [ 2, 3 ]const [g, h, i, j = 18] = arr;console.log(g, h, i, j); //1 [ 2, 3 ] 4 18const [k, ...l] = arr;console.log(k, l); //1 [ [ 2, 3 ], 4 ] 对象1234567891011121314151617181920var data = &#123; a: 100, b: [ &#123; c: 200, d: [], a: 300 &#125;, &#123; c: 1200, d: [1], a: 1300 &#125;, ], c: 500&#125;// 提取3个a出来var &#123; a: m, b: [&#123; a: n &#125;, &#123; a: n1 &#125;] &#125; = data;console.log(m, n, n1) // 100 300 1300 数组的操作 方法 描述 push(…items) 尾部增加多个元素 pop() 移除最后一个元素，并返回它 map 引入处理函数来处理数组中每一个元素，返回新的数组 filter 引入处理函数处理数组中每一个元素，此处理函数返回true的元素保留，否则该元素被过滤掉，保留的元素构成新的数组返回 foreach 迭代所有元素，无返回值 1234567891011121314151617181920const arr = [1, 2, 3, 4, 5];arr.push(6, 7);console.log(arr); // [ 1, 2, 3, 4, 5, 6, 7 ]arr.pop()console.log(arr); // [ 1, 2, 3, 4, 5, 6 ]// mapconst powerArr = arr.map(x =&gt; x * x); // 新数组console.log(powerArr); // [ 1, 4, 9, 16, 25, 36 ]// forEachconst newarr = arr.forEach(x =&gt; x + 10); // 无返回值console.log(newarr, arr); // undefined [ 1, 2, 3, 4, 5, 6 ]narr = []newArr = arr.forEach(x =&gt; narr.push(x + 10));console.log(newArr, narr); // undefined [ 11, 12, 13, 14, 15, 16 ]// filter 只做判断console.log(arr.filter(x =&gt; x % 2 == 0)) // 新数组 [ 2, 4, 6 ] forEach用索引第一个参数是值第二个参数是索引 123456789let arr = [1, 2, 3];let newarr = [];arr.forEach((x, index) =&gt; &#123; newarr.push(arr[index] + 10);&#125;);console.log(newarr); // [ 11, 12, 13 ]console.log(arr); // [ 1, 2, 3 ] 数组练习有一个数组 const arr = [1, 2, 3, 4, 5]; ，要求算出所有元素平方值，且输出平方值是偶数且大于10的平方值 效率偏差 12const arr = [1, 2, 3, 4, 5]console.log(arr.map(x =&gt; x * x).filter(x =&gt; x % 2 === 0).filter(x =&gt; x &gt; 10)); 应该先过滤,再求值比较好 1234567891011121314const arr = [1, 2, 3, 4, 5]// 1console.log(arr.filter(x =&gt; x % 2 === 0).map(x =&gt; x * x).filter(x =&gt; x &gt; 10)); // 先过滤减少迭代次数// 2s = Math.sqrt(10) // 10开方算一次console.log(arr.filter(x =&gt; x &gt; s &amp;&amp; !(x % 2)).map(x =&gt; x * x))// 3let newarr = []arr.forEach(x =&gt; &#123; if (x &gt; s &amp;&amp; !(x % 2)) newarr.push(x * x);&#125;)console.log(newarr); 对象的操作 Object的静态方法 描述 Object.keys(obj) ES5开始支持。返回所有key Object.values(obj) 返回所有值，试验阶段，支持较差 Object.entries(obj) 返回所有值，试验阶段，支持较差 Object.assign(target, …sources) 使用多个source对象，来填充target对象，返回target对象第一参数是目标往往不说明，大部分赋值都是浅拷贝有重复的，后面的覆盖前面的 1234567891011121314151617181920212223242526272829const obj = &#123; a: 100, b: 200, c: 300&#125;;console.log(Object.keys(obj)); // key，ES5console.log(Object.values(obj)); // 值，实验性console.log(Object.entries(obj)); // 键值对，实验性// assignvar o1 = Object.assign(&#123;&#125;, obj, &#123; a: 1000, b: 2000 &#125;, /*覆盖*/ &#123; c: 'abc' &#125;, /*覆盖*/ &#123; c: 3000, d: 'python' &#125;); /*覆盖，新增*/console.log(o1);// 包装一个对象var o2 = new Object(o1);console.log(o2);/* 执行结果[ 'a', 'b', 'c' ][ 100, 200, 300 ][ [ 'a', 100 ], [ 'b', 200 ], [ 'c', 300 ] ]&#123; a: 1000, b: 2000, c: 3000, d: 'python' &#125;&#123; a: 1000, b: 2000, c: 3000, d: 'python' &#125;*/]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux特殊进程]]></title>
    <url>%2Flinux%2FLinux%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Linux中的特殊进程 在Linux/Unix中，通过父进程创建子进程僵尸进程 一个进程使用了fork创建了子进程，如果子进程终止进入僵死状态，而父进程并没有调用wait或者waitpid获取子进程的状态信息，那么子进程仍留下一个数据结构保存在系统中，这种进程称为僵尸进程 僵尸进程会占用一定的内存空间，还占用了进程号，所以一定要避免大量的僵尸进程产生。有很多方法可以避免僵尸进程孤儿进程 父进程退出，而它的子进程仍在运行，那么这些子进程就会成为孤儿进程。孤儿进程会被init进程（进程号为1）收养，并由init进程对它们完成状态收集工作 init进程会循环调用wait这些孤儿进程，所以，孤儿进程没有什么危害守护进程 它是运行在后台的一种特殊进程。它独立于控制终端并周期性执行某种任务或等待处理某些事件 守护进程的父进程是init进程，因为其父进程已经故意被终止掉了 守护进程相对于普通的孤儿进程需要做一些特殊处理]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
</search>
