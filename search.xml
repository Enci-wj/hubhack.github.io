<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[序列化与json]]></title>
    <url>%2Fbook%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson%2F</url>
    <content type="text"><![CDATA[序列化与反序列化内存中的字典,列表,集合以及各种对象,如何保存到一个文件中. 如果是自己定义的类的实例, 如何保存到一个文件中. 如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例. 要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化. 定义serialization 序列化 将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制 deserialization 反序列化 将文件的一个个字节恢复成内存中对象 &lt;-二进制 序列化保存到文件就是持久化. 可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化. jsonJSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。 json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。 1、JSON语法规则JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。 （1）简单值 简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。 12345678910111213// 简单值"Hello World!" // 字符串99 // 数值true // 布尔型false // 布尔型null// 在JSON中不能使用的值NaN // 数值不能是NaNInfinity // 数值不能是Infinityundefined // 在JSON也不可以使用JavaScript中的undefined'Hello World!' // 字符串必须使用双引号表示，不能使用单引号0x1 // 数值必须以十进制表示，不能使用十六进制 （2）对象 对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。 123456789101112// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号&#123; "name": "Andy", "age": 18, "isStudent": true, "isLeader": false, "mark": null, "school": &#123; "name": "BIT", "region": "Beijing" // 这个地方不能有逗号，因为是对象的最后一个属性成员 &#125; // 这个地方也不可以有逗号，因为也是对象的最后一个属性成员&#125; （3）数组 数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。 12345678910111213141516// 示例一["Andy", "Ruby", "Danny", "Peter", "Lisa"]// 示例二[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]// 示例三[ &#123;"name": "Andy", "age": 18&#125;, &#123;"name": "Ruby", "age": 18&#125;, &#123;"name": "Danny", "age": 20&#125;]// 示例四[ [0, 1, 2], [3, 4, 5], [6, 7, 8]] 2、JSON字符串和JSON对象（1）JSON字符串 JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。 1234//JSON字符串var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string （2）JSON对象 JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。 12345678// JSON对象var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object （3）JSON字符串和JSON对象互相转换 JavaScript中有一个全局的对象，JSON。JSON中有两个方法 stringify() 和 parse()。 JSON.parse() 把JSON字符串解析为JSON对象 12345//JSON字符串通过parse转化为JSON对象var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';person = JSON.parse(p)console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object JSON.stringify() 用于把JSON对象序列化为JSON字符串。 123456789//JSON对象通过stringify转化为JSON字符串var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;var p = JSON.stringify(person)console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string]]></content>
      <categories>
        <category>json</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程的4门功课]]></title>
    <url>%2Fbook%2F%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91%2F</url>
    <content type="text"><![CDATA[计算机组成原理首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。 操作系统原理综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。 现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！我希望我写过的程序能在任何一台机上运行。我希望我能边听音乐边干活——即同一时间可以运行多个程序。我希望别人写的傻×东西不要影响到我的工作——即多任务控制。我希望计算机里面的各种资源都能得到良好的组织，更快的访问。我希望我的用户界面更好看，使用更方便，功能更强大！我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。 而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。 既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。 至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。 数据结构数据结构的作用, 就是为了提高硬件利用率. 比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。 数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。 计算机网络计算机网络分为3块： 硬件网卡，网线，交换机这些，用来处理数据的。 协议数据在网络中通信如何组织？如何识别？如何保证数据的正确性？这2块我就不多说了。 操作系统这就是如何把计算机网络和操作系统结合起来的问题了。对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。 网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web路由]]></title>
    <url>%2Fbook%2Fweb%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[web开发中路由route和路由器router到底是什么 1. 什么是路由在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。 2. router和route的区别route就是一条路由，它将一个URL路径和一个函数进行映射，例如： /users -&gt; getAllUsers() /users/count -&gt; getUsersCount() 这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。 而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route”。 3. 服务器端路由对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。 以Express为例， 12345678app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.sendFile(&apos;index&apos;)&#125;)app.get(&apos;/users&apos;, (req, res) =&gt; &#123; db.queryAllUsers() .then(data =&gt; res.send(data))&#125;) 这里定义了两条路由： 当访问/的时候，会返回index页面 当访问/users的时候，会从数据库中取出所有用户数据并返回 不仅仅是URL 在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。 4. 客户端路由对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案： 基于Hash 基于History API (1) 基于Hash我们知道，URL中#及其后面的部分为hash。例如： 1234const url = require(&apos;url&apos;)var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)console.log(a.hash)// =&gt; #/foo/bar hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。 通过监听window对象的hashChange事件，可以实现简单的路由。例如： 123456789101112131415window.onhashchange = function() &#123; var hash = window.location.hash var path = hash.substring(1) switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; (2) 基于History API通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考： Manipulating the browser historyUsing the HTML5 History API我们可以通过监听window对象的popstate事件，来实现简单的路由： 1234567891011121314window.onpopstate = function() &#123; var path = window.location.pathname switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; 但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如： 1234567var pushState = history.pushStatehistory.pushState = function() &#123; pushState.apply(history, arguments) // emit a event or just run a callback emitEventOrRunCallback()&#125; 不过，最好的方法还是使用实现好的history库。 (3) 两种实现的比较总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。 但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。 假设服务器只有如下文件（script.js被index.html所引用）： 123/- |- index.html |- script.js 基于Hash的路径有： 12http://example.com/http://example.com/#/foobar 基于History API的路径有： 12http://example.com/http://example.com/foobar 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。 当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 5. 动态路由上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。 例如在Express中： 12345678app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123; // ... ...&#125;)在Flask中：@app.route(&apos;/user/&lt;user_id&gt;&apos;)def get_user_info(user_id): pass 6. 严格路由在很多情况下，会遇到/foobar和/foobar/的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。 在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到/foobar/，而反过来则不会。 如果使用的是Express，默认这两者是一样的，也可以通过app.set来设置strict routing，来区别对待这两种情况。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml语言]]></title>
    <url>%2Fbook%2FYaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Yaml语言编程Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便. 一、简介YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 它的基本语法规则如下。 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML 支持的数据结构有三种。 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 以下分别介绍这三种数据结构。 二、对象对象的一组键值对，使用冒号结构表示。 12&gt; animal: pets&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: 'pets' &#125;&gt; Yaml 也允许另一种写法，将所有键值对写成一个行内对象。 12&gt; hash: &#123; name: Steve, foo: bar &#125; &gt; 转为 JavaScript 如下。 12&gt; &#123; hash: &#123; name: 'Steve', foo: 'bar' &#125; &#125;&gt; 三、数组一组连词线开头的行，构成一个数组。 1234&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ 'Cat', 'Dog', 'Goldfish' ]&gt; 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 12345&gt; -&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ [ 'Cat', 'Dog', 'Goldfish' ] ]&gt; 数组也可以采用行内表示法。 12&gt; animal: [Cat, Dog]&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: [ 'Cat', 'Dog' ] &#125;&gt; 四、复合结构对象和数组可以结合使用，形成复合结构。 12345678910&gt; languages:&gt; - Ruby&gt; - Perl&gt; - Python &gt; websites:&gt; YAML: yaml.org &gt; Ruby: ruby-lang.org &gt; Python: python.org &gt; Perl: use.perl.org &gt; 转为 JavaScript 如下。 1234567&gt; &#123; languages: [ 'Ruby', 'Perl', 'Python' ],&gt; websites: &gt; &#123; YAML: 'yaml.org',&gt; Ruby: 'ruby-lang.org',&gt; Python: 'python.org',&gt; Perl: 'use.perl.org' &#125; &#125;&gt; 五、纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示。 12&gt; number: 12.30&gt; 转为 JavaScript 如下。 12&gt; &#123; number: 12.30 &#125;&gt; 布尔值用true和false表示。 12&gt; isSet: true&gt; 转为 JavaScript 如下。 12&gt; &#123; isSet: true &#125;&gt; null用~表示。 12&gt; parent: ~ &gt; 转为 JavaScript 如下。 12&gt; &#123; parent: null &#125;&gt; 时间采用 ISO8601 格式。 12&gt; iso8601: 2001-12-14t21:59:43.10-05:00 &gt; 转为 JavaScript 如下。 12&gt; &#123; iso8601: new Date('2001-12-14t21:59:43.10-05:00') &#125;&gt; 日期采用复合 iso8601 格式的年、月、日表示。 12&gt; date: 1976-07-31&gt; 转为 JavaScript 如下。 12&gt; &#123; date: new Date('1976-07-31') &#125;&gt; YAML 允许使用两个感叹号，强制转换数据类型。 123&gt; e: !!str 123&gt; f: !!str true&gt; 转为 JavaScript 如下。 12&gt; &#123; e: '123', f: 'true' &#125;&gt; 六、字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 12&gt; str: 这是一行字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一行字符串' &#125;&gt; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 12&gt; str: '内容： 字符串'&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '内容: 字符串' &#125;&gt; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 123&gt; s1: '内容\n字符串'&gt; s2: "内容\n字符串"&gt; 转为 JavaScript 如下。 12&gt; &#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125;&gt; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 12&gt; str: 'labor''s day' &gt; 转为 JavaScript 如下。 12&gt; &#123; str: 'labor\'s day' &#125;&gt; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 1234&gt; str: 这是一段&gt; 多行&gt; 字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一段 多行 字符串' &#125;&gt; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 1234567&gt; this: |&gt; Foo&gt; Bar&gt; that: &gt;&gt; Foo&gt; Bar&gt; 转为 JavaScript 代码如下。 12&gt; &#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;&gt; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 12345678910&gt; s1: |&gt; Foo&gt; &gt; s2: |+&gt; Foo&gt; &gt; &gt; s3: |-&gt; Foo&gt; 转为 JavaScript 代码如下。 12&gt; &#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125;&gt; 字符串之中可以插入 HTML 标记。 123456&gt; message: |&gt; &gt; &lt;p style="color: red"&gt;&gt; 段落&gt; &lt;/p&gt;&gt; 转为 JavaScript 如下。 12&gt; &#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125;&gt; 七、引用锚点&amp;和别名*，可以用来引用。 123456789101112&gt; defaults: &amp;defaults&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; &lt;&lt;: *defaults&gt; &gt; test:&gt; database: myapp_test&gt; &lt;&lt;: *defaults&gt; 等同于下面的代码。 1234567891011121314&gt; defaults:&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; adapter: postgres&gt; host: localhost&gt; &gt; test:&gt; database: myapp_test&gt; adapter: postgres&gt; host: localhost&gt; &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 123456&gt; - &amp;showell Steve &gt; - Clark &gt; - Brian &gt; - Oren &gt; - *showell &gt; 转为 JavaScript 代码如下。 12&gt; [ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]&gt; 八、函数和正则表达式的转换这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 1234&gt; # example.yml&gt; fn: function () &#123; return 1 &#125;&gt; reg: /test/&gt; 解析上面的 yml 文件的代码如下。 123456789101112&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; try &#123;&gt; var doc = yaml.load(&gt; fs.readFileSync('./example.yml', 'utf8')&gt; );&gt; console.log(doc);&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt; 从 JavaScript 对象还原到 yaml 文件的代码如下。 123456789101112131415161718&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; var obj = &#123;&gt; fn: function () &#123; return 1 &#125;,&gt; reg: /test/&gt; &#125;;&gt; &gt; try &#123;&gt; fs.writeFileSync(&gt; './example.yml',&gt; yaml.dump(obj),&gt; 'utf8'&gt; );&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt;]]></content>
      <categories>
        <category>yaml</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fbook%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[js基础语法 常量和变量标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写. 声明 123456789var声明一个变量let声明一个块作用域中的局部变量const声明一个常量js中的变量声明和初始化时可以分开的.var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug. 数据类型 序号 名称 说明 1 number 数值型,包括整型和浮点型 2 boolean 布尔型,true和false 3 string 字符串 4 null 只有一个值null 5 undefined 变量声明未赋值的;对象未定义的属性 6 symbol ES6新引入类型 7 object 是以上基本类型的复合类型,是容器 弱类型,不需要强制类型转换, 会隐式类型转换. NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN 总结: 1234567遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换. 三元运算符条件表达式?真值:假值 等价于简单的if…else结构 函数, 匿名函数,函数表达式的差异 函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已. 区别在于, 函数会声明提升, 函数表达式不会 . 高阶函数: 函数作为参数或返回 一个函数. 函数12345678function 函数名(参数列表)&#123; 函数体; return 返回值;&#125;function add(x, y)&#123; return x + y;&#125;console.log(add(3, 5)); 函数, 匿名函数, 函数表达式的差异函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已. 区别在于, 函数会申明提升, 函数表达式不会. 123456789console.log(add(4, 6));// 匿名函数function add(x, y)&#123; return x + y;&#125;const sub = function (x, y)&#123; return x -y;&#125;console.log(sub(5, 6)); 高阶函数 高阶函数: 函数作为参数或返回一个函数 箭头函数箭头函数就是匿名函数,它是一种更加精简的格式. 箭头函数参数 如果一个函数没有参数,使用() 如果只有一个参数,参数列表可以省略小括号() 多个参数不能省略小括号,且使用逗号间隔. 箭头函数返回值. 如果函数体部分有多行,就需要使用{}, 如果有返回值使用return. 如果只有一行语句, 可以同时省略大括号和return. 只有return语句, 就不能省略大括号, 如果只有一条非return语句, 加上大括号, 函数就成了无返回值, 函数参数普通参数一个参数占一个位置,支持默认参数. 可变参数(rest parameters剩余参数) js使用…表示可变参数(python用*手机多个参数) 12345678const sum = function (...args)&#123; let result = 0; for (let x in args)&#123; result += args[x] &#125; return result&#125;;console.log(sum(3, 6, 9)) arguments对象函数的所有参数会被保存在一个arguments的键值对对象中. 参数解构和python类似, js提供了参数解构, 依然使用了…符号来结构. 1234const add = (x, y) =&gt;&#123;console.log(x, y); return x + y&#125;;console.log(add(...[100, 200]))console.log(add(...[100, 200, 300]))console.log(add(...[100])) 函数返回值python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组. 表达式的值 类c的语言,都有一个概念 – 表达式的值 赋值表达式的值: 等号右边的值 逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值. 异常抛出异常 js的异常语法和java相同, 使用throw关键字抛出. 使用throw关键字可以抛出任意对象的异常. 1234throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok'; 捕获异常try…catch语句捕获异常 try …catch…finally 语句捕获异常, finally保证最终一定执行. 问题: null和undefined的异同1.undefined：是所有没有赋值变量的默认值，自动赋值。 2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。 共同点：都是原始类型，保存在栈中变量本地。 不同点： undefined——表示变量声明过但并未赋过值。 它是所有未赋值变量默认值，例如： 1var a; // a 自动被赋值为 undefined null——表示一个变量将来可能指向一个对象。 一般用于主动释放指向对象的引用，例如： 12var emps = [&apos;ss&apos;,&apos;nn&apos;]; emps = null; // 释放指向数组的引用 它是专门释放对象内存的一个程序。 在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期； 总有一个对象不再被任何变量引用时，才释放]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>JavaScrript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fbook%2F%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊属性 属性 含义 __name__ 类,函数,方法等名字 __module__ 类定义所在的模块名 __class__ 对象或类所属的类 __base__ 类的基类的元组,顺序为他们在基类中出现的顺序 __doc__ 类, 函数的文档字符串, 如果没有定义则为None __mro__ 类的mro, class.mro()返回的结果的保存在__mro__ 中 __dict__ 类或实例的属性, 可写的字典 查看属性__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它. 如果dir()参数obj包括方法_dir__(), 该方法将被调用.如果参数obj不包含\_dir__(), 该方法将最大限度地收集属性信息. dir(obj)对于不同类型的对象obj具有不同的行为: 如果对象是模块对象, 返回的列表包含模块的属性名和变量名 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名 如果是类的实例 有__dir__方法, 返回可迭代对象的返回值 没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名 如果obj不写, 返回列表包含内容不同 在模块中, 返回模块的属性和变量名 在函数中, 返回本地作用域的变量名 在方法中, 返回本地作用域的变量名 123456789# animal.pyclass Animal: x = 123 def __init__(self, name): self._name = name self.__age = 10 self.weight = 20 print('animal Module\ s names = &#123;&#125;'.format(dir()))# 模块的属性 ) 魔术方法*** 分类: 创建, 初始化与销毁 可视化 hash bool 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他杂项 实例化 方法 意义 __new__ 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法 __new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回 可视化 方法 意义 __str__ str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息 __repr__ 内建函数repr()对一个对象获取字符串表达 __bytes__ bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 123456class A: def __init__(self, name, age = 18): self.name = name self.age = age def __repr__(self): return 'repr:&#123;&#125;&#123;&#125;'.format(self.name, self.age) hash 方法 意义 __hash__ 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash __eq__ 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了 bool 方法 意义 __bool__ 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真 上下文管理文件IO操作可以对文件对象使用上下文管理，使用with。。as语法 12with open('test') as f: pass 仿照上例写一个自己的泪，实现上下文管理 1234class Point: passwith Point as p: pass 提示属性错误，没有__exit__，看了需要这个属性 某些版本会显示没有__enter__ 上下文管理对象 当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象 __enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上 __exit__退出与此对象相关的上下文 with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作 注意,with 并不开启一个新的作用域 上下文管理是安全的 上下文应用场景 1.增强功能 在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能 2.资源管理 打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等 3.权限验证 在执行代码之前,做权限验证,在__enter__ contextilb.contextmanager他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法 对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值. 也就是这个装饰器接受一个生成器对象作为参数. 总结 如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便 反射概述 运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候 反射, reflection, 指的是运行时获取类型定义信息 一个对象能够在运行时,像照镜子一样,反射出其类型信息 简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身 具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等 反射相关的函数和方法 getattar 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. setattar object的属性存在,这覆盖, 不存在,新增 hasattat 判断对象是否有这个名字的属性,name必须为字符串 反射相关的魔术方法__getattr__(), __setattr__(), __delattr__(), 三个魔术方法 实例属性会按照继承关系找, 如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出 AttributeError异常表示找不到属性. 查找属性顺序为: instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fbook%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[语言的分类面向机器:抽象成机器指令, 机器容易理解.代表:汇编语言面向过程:做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.问题规模小, 可以步骤化.按部就班处理.代表:c语言面向对象OOP随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.代表:C++, java, python等 面向对象类:class类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.用计算机语言来描述类,是属性和方法的集合.对象:instance, object对象是类的具象, 是一个实体.对于我们每个人这个个体, 都是抽象概念人类不同的实体. 属性:它是对象状态的抽象,用数据结构来描述.操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.哲学:一切皆对象对象是数据和操作的封装.对象是独立的,但是对象之间可以相互作用.目前OOP是最接近人类认知的编程范式. 三要素1.封装组装:将数据和操作组装到一起.隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.2.继承多复用,继承来的就不用了自己写了多继承少修改,OCP,使用继承来改变,来体现个性.3.多态面向对象编程最灵活的地方,动态绑定人类就是封装人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:多态,继承自动物类的人类,猫类的操作’吃’不同. python的类:1.必须使用class关键字2.类名必须使用大驼峰命名3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上. 类对象及类属性类对象,类的定义执行后会生成一个类对象.类的属性,类定义中的变量和类中定义的方法都是类的属性.类变量,self指代当前实例本身. 实例化a = Myclass() # 实例化使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.实例化就真正创建一个该类的对象tom = Person()jerry = Person()每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.python类实例化后, 会调用init方法,这个方法第一个形式参数必须留给self,其他参数随意.init方法 注意:init()方法不能有返回值,也就是只能是return None 实例对象instance类实例化后一定会获得一个类的实例,就是实例对象init方法的第一参数self就是指代某一个实例自身.类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上. 实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法. 总结:是类的,也就是这个类所有实例的,器实例都可以访问到:是实例的,就是这个实例自己的,通过类访问不到.类变量是属于类的变量,这个类的所有实例可以共享这个变量.对象可以动态的给自己增加一个属性.实例属性的查找顺序指的是实例使用,.点号来访问属性.会先找自己的dict,如果没有,然后通过属性class找到自家的类, 再去类的dict中找.注意:如果实例使用dict访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找. 一般来说, 类变量可使用全大写来命名. 类方法和静态方法类方法:1.在类定义中,使用@classmethod装饰器的方法2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改4.通过cls可以直接操作类的属性.静态方法:在类定义中, 使用@staticmethod装饰器的方法2在调用时, 不会隐式的传入参数.静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理. 类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,原因是第一参数必须是类的实例.总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类. 访问控制:私有属性私有属性,使用双下划线开头的属性名就是私有属性. 私有属性的本质:类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了. 保护变量:在变量名前使用一个下划线,称为保护变量这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.私有方法:参照保护变量,私有变量,使用单下划线,双下化线的命名方法, 补丁可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变猴子补丁:在运行时,对属性,方法,函数,等进行动态替换其目的往往是为了通过替换,修改来增强,扩展原有代码的能力 属性装饰器一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性. property装饰器 后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性setter装饰器可以控制是否删除属性,很少用deleter装饰器可以控制是否删除属性,很少用property装饰器必须在前,setter deleter装饰器在后,property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果. 对象的销毁类中可以定义del方法 ,称为析构函数.作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用del方法.由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.封装:将数据和操作组织到类中,即属性和方法.将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2Fbook%2F%E8%8D%89%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[none 与NUll的区别表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为0,因为0是有意义的,而none是一个特殊的空值判断的时候 均是false属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被调用.如果参数不包含dir(),该方法将最大限度地收集参数信息. 功能性函数返回都为noneNone是一个特殊的常量。None和False不同。None不是0。None不是空字符串。None和任何其他的数据类型比较永远返回False。None有自己的数据类型NoneType。你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2Fbook%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[OSI参考模型 模型 说明 应用层 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. 表示层 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. 会话层 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. 传输层 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). 网络层 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. 链路层 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . 物理层 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. 网络协议 链路层和物理层 描述 ARP(地址解析协议) IP地址——-&gt;MAC地址 RARP MAC地址——&gt;IP地址（逆向的） PPP协议 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 MAC地址 48位全球唯一,网络设备的身份识别 网络层 描述 IP协议 IP:（分为IPV4（168….）和IPV6（16进制用：隔开）） ICMP（Internet控制管理协议） ping命令属于ICMP IGMP（Internet分组管理协议） 广播，组播 传输层 描述 TCP（传输控制协议) 面向连接，可靠,效率低，一对一的可靠数据传输的协议 UDP（用户数据报协议） 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输 SCTP 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 应用层 描述 网页访问协议 HTTP HTTPS(S是安全) 邮件发送接收协议 POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） FTP 文件传输协议 Telnet（明文传输）/SSH（安全） 远程登录 嵌入式 描述 NTP 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） SNMP(开源（SNMP.NET）) 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 RTP/RTSP 用传输音视频传输（监控等） 中继系统中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。 中继系统之集线器光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。 这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。 中继系统之交换机还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：有记忆功能。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？ 交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。 如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。 中继系统之路由器路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。 端口IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。 这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。 socketsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系. 路由Routing跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络. 路由器上维护着路由表,他知道如何将数据包发往另外的网络. windows使用route print, liunx使用route -n可以查看路由表. 路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置. 静态路由:有管理员手动配置的固定的路由信息 动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.]]></content>
      <categories>
        <category>网络原理</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统]]></title>
    <url>%2Fbook%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的. 程序结构和执行信息存储大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.一个字节包括8位,在二进制表示法中,0000000011111111 0255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.2进制]]></content>
      <categories>
        <category>系统</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解预处理器]]></title>
    <url>%2Fbook%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译. 预定义符号预处理指令 指令 描述 #include 包含一个源代码 #define 定义宏 #undef 取消已定义的宏 #ifdef 如果宏已经定义,则返回真 #ifndef 如果宏没有定义,则返回真 #if 如果给定条件为真,则编译下面代码 #else #if的替代方案 #elif 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 #endif 结束一个#if…#else 条件编译块 #error 当遇到标准错误时, 输出错误消息 #pragma 使用标准化方法, 向编译器发布特殊的命令道编译器中 typedef c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 . 动态内存分配 当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据. c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需. python对象就是 c语言结构体在堆上申请的一块内存. 在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 c中大量操作字符串的函数 函数 目的 strcpy 复制字符串s2到字符串s1 strcat 连接s2 到字符串s1的末尾 strlen 返回字符串s1的长度 strcmp 如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 strchar 返回一个指针,指向字符串s1中字符ch的第一次出现的位置 strstr 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置]]></content>
      <categories>
        <category>c语言</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fbook%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式简绍概述:正则表达式正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.正则表达式 Regular Expression,缩写regex, regexp ,RE等.分类1.BRE基本正则表达式,grep,sed,vi等软件支持.vim有扩展.2.ERE扩展正则表达式,egrep, sed -r等.3.PCRE几乎所有高级语言都是PCRE的方言或者变种. 基本语法元字符 metacharacter转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.反斜杠自身,得使用\ \r \n还是转义后代表回车,换行 贪婪与非贪婪默认是贪婪模式,也就是说尽量多匹配更长的字符串,非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了. 单行模式:. 可以匹配所有的字符, 包括换行符.^ 表示整个字符串的开头, &amp;整个字符串的结尾多行模式:. 可以匹配除了换行符之外的字符,多行不影响.点号^ 表示行首, &amp;行尾, 只不过这里的行是每一行 默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n re模块re.M多行模式re.S单行模式re.I忽略大小写re.X忽略表达式中的空白字符使用 | 位或运算开启多种选项方法编译re.compile(pattern, flag=0)设定flags, 编译模式,返回正则表达式对象regexpattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.单次匹配re.match(pattern, string, flags=0)match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象. 全局搜索对整个字符串, 从左至右匹配,返回匹配项的列表.匹配替换使用pattern对字符串string进行匹配,对匹配使用repl替换.replacement可以是string, bytes, function. 分割字符串字符串的分割函数split,太难用, 不能指定多个字符进行分割.分组使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.2.如果使用了命名分组,可以使用group的方式取分组3.也可以使用group返回所有组.4.使用groupdict()返回命名的分组.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fbook%2F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[魔术方法 类别 方法名 可视化 __str__, __repr__, __format__, __bytes__ 数值转换 __abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__ 容器模拟 __len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__ 迭代枚举 __iter__, __reversed__, __next__ 可调用模拟 __call__ 上下文管理 __enter__, __exit__ 实例创建和销毁 __new__, __init__, __del__ 属性管理(反射) __dir__, __getattr__, __setattr__, __delattr__, __getattribute__ 属性描述符(描述器) __get__, __set__, __delete__ 特殊属性 __name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__ 比较运算符 __eq__,__lt__, __le__, __gt__, __ge__, __ne__ 算数运算符 __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 增量运算符 __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__ 反向运算符 __radd__, __rsub__ 其他 __slots__ 内置函数 内置函数名 方法名 数学运算 abs, divmod,max,min,pow, round, sum 类型转换 bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex 序列操作 all, any, filter, map,next,reversed, sorted, zip 对象操作 help,dir,id,hash, type,len, ascii,format, vars, 反射操作 __import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable 变量操作 globals, locals, 交互操作 print,input 文件操作 open 编译执行 compile, eval,exec, repr 装饰器 property,classmethod, staticmethod, 数据结构 tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object 标识符: 1234567False await else import passNone break except in raiseTrue class finally is returnand continue for lambda tryas def from nonlocal whileassert del global not withasync elif if or yield 模块常用方法 内置模块 方法名 re compile, search, match, fullmatch,split,findall, sub, string ascii_letters,ascii_lowercase.digits datetime datetime collections nametuple, deque, OrderdDict, defaultdict, bisect bisect_left,bisect_right, math ceil random randint, choice, randrange,shuffle, sample functools reduce, partial,lru_cache pathlib os shutil copyfileobj, copyfile, copymode, copystat,copy,copy2,copytree,rmtree,move, pickle csv reader time threading queue json base64 sys inspect signature(callable)获取签名, ConfigParser argparse heapq hea]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述器]]></title>
    <url>%2Fbook%2F%E6%8F%8F%E8%BF%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[描述器 Descriptors描述器的表现 用到3个魔术方法: __get__() 、 __set__() 、 __delete__() 方法签名如下 object.__get__(self, instance, owner) object.__set__(self, instance, value) object.__delete__(self, instance) self 指代当前实例，调用者 instance 是owner的实例 owner 是属性的所属的类 请思考下面程序的执行流程是什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041class A: def __init__(self): self.a1 = 'a1' print('A.init')class B: x = A() def __init__(self): print('B.init')print('-'*20)print(B.x.a1)print('='*20)b = B()print(b.x.a1)# 运行结果A.init--------------------a1====================B.inita1 可以看出执行的先后顺序吧？ 类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。 然后实例化并初始化B的实例b。 打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。 描述器定义Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。 仅实现了 __get__ ，就是非数据描述符 non-data descriptor 实现了 __get__ 、 __set__ 就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。 属性的访问顺序为上例中的类B增加实例属性x 12345678910111213141516171819202122232425262728293031323334353637class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return selfclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x)print(b.x.a1) # AttributeError: 'str' object has no attribute 'a1' 类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。 继续修改代码，为类A增加 __set__ 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return self def __set__(self, instance, value): print('A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'.format(self, instance, value)) self.data = valueclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x) # 返回什么print(b.x.a1) # 返回什么print(b.x.data) # 返回什么？ 所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。 属性查找顺序实例的 __dict__ 优先于 非数据描述器 数据描述器 优先于 实例的 __dict__ __delete__ 方法有同样的效果，有了这个方法，也是数据描述器。 尝试着增加下面的2行代码，看看字典的变化 b.x = 500 B.x = 600 b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。 B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。 ### Python中的描述器 描述器在Python中应用非常广泛。 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 12345678910111213141516171819202122232425262728293031323334353637class A: @classmethod def foo(cls): # 非数据描述器 pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300a = A()print(a.__dict__)print(A.__dict__) foo、bar都可以在实例中覆盖，但是z不可以。 新增方法 3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。 12345678910111213141516171819202122class A: def init(self): print('A init') def get(self, instance, owner): print(1, self, instance, owner) return self def set_name(self, owner, name): print(2, self, owner, name) self.name = nameclass B:x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)print(B().x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理异常]]></title>
    <url>%2Fbook%2F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常处理(Exception)错误Error逻辑错误:算法写错了, 例如加法写成了减法 笔误:例如变量名写错了,语法错误 函数或类使用错误, 其实这也属于逻辑错误 总之,错误是可以避免的 异常Eception本意就是意外情况 这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去. 例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况. 错误和异常在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获. 123with open('tetsabcd') as f: pass# 异常 产生异常产生: raise语句显示的抛出异常 Python解释器自己检测异常并引发它程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行) 异常的捕获1234try: 待捕获异常的代码块except [异常类型] 异常的处理代码块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2Fbook%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[练习 有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。思路排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。查找插入点，使用二分查找完成。假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。直到中点就是 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) - 1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]newlst = sorted(lst) # 升序 print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41): newlst = insert_sort(newlst, x) print(newlst) 看似上面代码不错，请测试插入100。问题来了，100插入的位置不对，为什么？ 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) # 去掉减1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret # 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51] newlst = sorted(lst) # 升序print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41, 100): newlst = insert_sort(newlst, x) print(newlst) high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。 二分二分前提是有序，否则不可以二分。二分查找算法的时间复杂度O(log n) bisect模块bisect模块提供的函数有： bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。 bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。 bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。函数可以分2类： bisect系，用于查找index。Insort系，用于实际插入。默认重复时从右边插入。 应用判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’ 12345678910import bisect def get_grade(score): breakpoints = [60, 70, 80, 90] grades = 'EDCBA' return grades[bisect.bisect(breakpoints, score)] for x in (91, 82, 77, 65, 50, 60, 70, 80, 90): print('&#123;&#125; =&gt; &#123;&#125;'.format(x, get_grade(x)))]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识框架]]></title>
    <url>%2Fbook%2Fpython%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[python基础python是一种动态的强类型语言,底层是用C语言开发的. 平台：*nix平台系统：线程、进程、Shell编程网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个中间件：消息队列原理和应用，例如8曲bitMQWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一可视化：WEB的前端开发多一些HTML、jS要会数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用 python学习路线:基础：操作系统、网络基础、数据库基础、python语言基础..进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).新前端开发(ES6、React、Antd）…实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..高端：数据清洗、企业数据分析、预测准荐、机器视觉． 数据类型python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none 字符串因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节. 字符串的格式化format函数或 格式符 编码字符串与bytes字符串是字符组成的有序序列，字符可以使用编码来理解bytes是字节组成的有序的不可变序列bytearray是字节组成的有序的可变序列 编码与解码：字符串按照不同的字符集编码encode返回字节序列bytesencode（encoding=‘utf-8’，errors=‘strict’）字节序列按照不同的字符集解码decode返回字符串bytes.decode（encoding=“utf-8”，errors=“strict”）ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统 要熟记31 41 61 的ascii表 字节序：大端模式，big-endian；小端模式，little-endianintel x86cpu使用小端 模式网络传输更多使用大端模式windows，linux 使用小端模式mac os使用大端模式java 虚拟机是大端模式 数字有整数 浮点数 复数等 true false主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。 None：Python里面特殊的空值，不能理解为0。 容器list（列表） tuple（元组） set（集合） dictionary（字典）这些都是可以迭代的 list创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。 tuple元组和列表类似，但是不同的是元组不能修改，元组使用小括号。 dict判断结构ifif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。 elif 语句 elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。 if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。 forfor循环可以遍历任何序列的项目： whilewhile循环，只要条件满足，就不断循环，条件不满足时退出循环： break和continue语句： break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。 continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python特殊函数]]></title>
    <url>%2Fbook%2Fpython%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[匿名函数匿名函数 :隐藏名字,即没有名称匿名函数: 没有名字的函数lambda表达式python中,使用lambda表达式构建匿名函数使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式参数列表不需要小括号,无参就不写参数冒号用来分割参数和表达式部分不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.lambda表达式匿名函数只能写在一行上,也称为单行函数. 匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码. 递归函数函数执行流程:压栈 递归函数recursion函数直接或者间接调用自身就是递归.递归需要有边界条件,递归前进段,递归返回段.递归一定要有边界条件.当边界条件不满足的时候,递归前进当边界条件满足的时候,递归返回. 递归例子:斐波那契数列如果用循环写法:1234567a = 0b = 1n = 10for i in range(n -1): a,b=b, a+belse: print(b) 递归写法:def fib(n): return 1 if n &lt;3 else fib(n-1) +fib(n-2) 递归要求递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.递归调用的深度不宜python 对递归调用的深度做了限制,以保护解释器超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度sys.getrecursionlimit() 循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了. 递归是一种很自然的表达,符合逻辑思维递归相对效率低,每一次调用都要开辟栈帧.递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.绝大多数递归,都可以使用循环实现即使递归代码很简洁,但是能不用则不用递归. 生成器生成器generator生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.生成器对象,是一个可迭代对象,是有个迭代器.生成器对象,是延时计算,惰性求值的. 函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.普通函数调用,函数会立即执行直到执行完毕.生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑. 在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回再执行会执行到下一个yield语句又会暂停执行return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration生成器函数包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.再次调用next函数,和上一条一样的处理过程.继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常. 协程生成器的高级用法他比进程,线程轻量级,是在用户空间调度函数的一种实现.协程调度器实现思路协程是一种非抢占式调度. yield from 语法yield from就是一种简化语法的语法糖. yield 和return的区别带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return 如何生成斐波那契数列:斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数. 12345678def fab(max): a, b = 1, 1 n = 1 while n &lt; max: print(b) a, b = b, a+b n +=1fab(20) 结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.123456789def fab(max): n, a, b = 0, 0, 1 l = [] while n &lt; max: l.append(b) b = b+a a = b-a n = n+1 return l 改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要用list来保存中间结果, 而是通过iterable对象来迭代. 1234567891011121314151617class Fab(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.b = self.a + self.b self.a = self.b - self.a self.n = self.n + 1 return r raise StopIteration() 然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b b = b+a a = b-a n = n + 1 第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果调用第四版的fab和第二版的fab完全一致: 简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法这样我们就可以清楚看到fab的执行流程. 高阶函数函数也是对象, 是可调用对象函数可以作为普通变量,也可以作为函数的参数, 返回值. 在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数接受一个或多个函数作为参数输出一个函数 排序sorted排序函数,可以接受key作为参数进行排序,不改变序列的原有值.排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素. 过滤filter对可迭代对象进行遍历,返回一个迭代器function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值function参数如果是None, 可迭代对象的每一个元素自身等效布尔值. 映射map对多个可迭代对象的元素,按照指定的函数进行映射返回一个迭代器 柯里化指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件io]]></title>
    <url>%2Fbook%2Fpython%E6%96%87%E4%BB%B6io%2F</url>
    <content type="text"><![CDATA[文件io常用操作一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络ioopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取seek: 文件指针操作 tell: 指针位置 打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.文件操作中,最常用的操作就是读和写.文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件a: 写入打开,如果文件存在,则追加b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力. open默认是只读模式r打开已经存在的文件. 文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOFbuffering:缓冲区0:只在二进制模式打开,表示关buffer1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush大于1:用于指定buffer的大小. 上下文管理1.异常处理当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.使用finally可以保证打开的文件可以被关闭.2.上下文管理一种特殊的语法, 交给解释器去释放文件对象.使用with … as关键字上下文管理的语句并不会开启新的作用域with语句执行的时候,自动关闭文件对象.1234f1 = open(&apos;text&apos;)with f1: f1.write(&apos;abc&apos;)f1.closed 对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题. StringIO和BytesIOStringIOio模块中的类from io import StringIO内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.当close方法被调用的时候,这个buffer被释放. 好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率. BytesIOio模块中的类from io import BytesIO内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.当close方法被调用的时候, 这个buffer会释放. file-like对象类文件对象,可以像文件一样操作socket对象,输入输出对象都是类文件对象. 路径操作from os import path3.4版本开始建议使用pathlib模块,提供path对象来操作.包括目录和文件Pathlib模块 目录操作初始化路径拼接和分解操作符分解joinpath 通配符glob通配给定的模式rglob通配给定的模式,递归目录都返回一个生成器?代表一个字符*表示任意个字符[abc]或[a-z]表示一个字符 匹配match(pattern)模式匹配,成功返回True 文件操作os模块os.name windows是nt, linux是posixos.uname() *nix支持sys.platform windows显示win32, linux 显示linuxos.listdir返回指定目录内容列表, 不递归os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似. shutil模块文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.python提供了一个方便的shutil(高级文件操作)copy复制copyfileobj(fsrc, fdst[, length]) 文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.12345import shutilwith open (&apos;text&apos;, &apos;r+&apos;) as f: f.write(&apos;abcd&apos;) with open(&apos;text1&apos;, &apos;w+&apos;) as f1: shutil.copyfileobj(f, f1) 复制文件内容,不含元数据,src,dst为文件的路径字符串. rm删除shutil.rmtree(path, ignore_errors=False, oneerror=None)递归删除,如同rm -rf一样危险,慎用.他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.shutil.retree(“text”) 类似rm -rf move移动递归移动文件,目标到目标,返回目标本身使用的是os.rename方法如果不支持rename,如果是目录则copytree再删除源目录.shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz csv文件csv是一个被行分隔符,列分割符划分成行和列的文本文件.csv不指定字符编码.行分割符为\r\n,最后一行可以没有换行符.列分割符常用逗号或者制表符.每一行称为一条记录record.字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.csv模块返回reader对象,是一个行迭代器默认使用excel方言.delimiter列分割符,逗号.lineterminator行分割符\r\n ini文件处理作为配置文件,ini文件格式的很流行. 中括号里面的部分称为section,译作节,区, 段每一个section内, 都是key=value形成的键值对,key称为option选项.注意这里的DEFAULT是缺省section的名字,必须大写.configparserconfigparser模块的configparser类就是用来操作.可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典. 序列化和反序列化为什么要序列化内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.serialization序列化将内存中对象存储下来,把他变为一个个字节.deserialization反序列化将文件的一个个字节恢复成内存中的对象序列化保存到文件就是持久化可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化python提供了pickle库 dumps 对象序列化为bytes对象dump 对象序列化到文件对象,就是存入文件loads 从bytes对象反序列化load 对象反序列化,从文件读取数据 序列化应用一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型jsonjson的数据类型 messagepackmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.他可以像json那样,在许多语言之间交换结构对象.但是他比json更快速也跟轻巧.支持python.ruby,java等众多语言,兼容json 和pickle 安装pip install msgpack 常用方法序列化对象,提供dumps来兼容pickle和jsonunpackb反序列化对象.提供了loads来兼容.pack序列化对象保存到文件对象,提供了dump来兼容.unpack反序列化对象保存到文件对象,提供了load来兼容.messagepack简单易用,高效压缩,支持语言丰富.所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python数据结构]]></title>
    <url>%2Fbook%2Fpython%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要. 常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合. 数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型. 抽象数据类型抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.抽象的意义在于数据类型的数学抽象特性. 内存单元和地址计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,在计算机内存里表示数据元素之间的联系,只有两种技术:利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构. 数据结构是相互之间存在一种或多种特定关系的数据元素的集合.逻辑上分:集合结构, 线性结构, 树形结构, 图形结构物理结构:顺序存储结构, 链式存储结构. 算法算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.函数渐进式增长.判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.用O()来体现时间复杂度的记法, 我们称为大O记法.O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶. 线性表从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来. 线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素.插入删除的时间复杂度为O(n).它比较适合元素个数不太变化,而更多存取数据的应用.优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间. 可以快速地存取表中任意位置的元素.缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量造成存储空间的”碎片”. 线性表链式存储结构线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点. 头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.头指针具有标识作用,所以常用头指针冠以链表的名字.无论链表是否为空,头指针均不为空,头指针是链表的必要元素.由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显. 若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构. 静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法 将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针. 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表.对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表. 在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,栈是限定仅在表尾进行插入和删除操作的线性表.我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶. 栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.栈的删除操作,也叫出栈,或弹栈栈.特别是插入和删除操作,我们改名为push 和pop.两栈共享空间 栈的链式存储结构简称链栈顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些. 对列对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出. 串串是有零个或多个字符组成的有限序列,又名字符串.串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.串的顺序存储结构串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.在计算机中存在一个自由存储区,叫做堆. 模式匹配算法子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.一个字符的ASCII码可以看成是8位的二进制01串. 本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.所谓的回文就是一个字符串的逆转显示reverse的操作. 树树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树. 所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.树的定义其实就是我们在讲解栈提到的递归的方法.树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值. 结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.树中结点的最大层次称为树的深度或高度. 树的存储结构 树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.双亲表示法:我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行. 二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成. 二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,左子树和右子树是有顺序的,次序不能任意颠倒, 顺序存储结构一般只用于完全二叉树.二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.这里有两个关键词:访问和次序二叉树本质上,是对链表和数组的一个折中.每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据. 压缩编码方法:赫夫曼编码 图图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.图是由顶点的有穷非空集合和顶点之间边的集合组成.图不能用简单的顺序结构来表示,而是多重链表. 搜索引擎的工作原理:它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录. 查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素. python 对象特性python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值: 身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.值:对象表示的数据. python基本数据类型python的数据类型:number(数字), string(字符串), bool(布尔), None(空值) python 内建数据结构线性结构字符串在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变. 列表元组bytes非线性结构集合set字典dict]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python小技巧]]></title>
    <url>%2Fbook%2Fpython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[为多个变量赋值有时，有多个变量需要赋值，这时你会怎么赋值呢？常规方法：常规方法是给变量逐个赋值。123a = 0 b = 1 c = 2 优雅方法：直接按顺序对应一一赋值.a, b, c = 0, 1, 2 序列解包需要取出列表中的元素。常规方法：一般我们知道可以通过下标获取具体元素。1234567info = ['brucepk', 'man', 'python']name = info[0]sex = info[1]tech = info[2]print(name,sex,tech)结果:brucepk man python 优雅方法：给出对应变量接收所有元素。12345info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]name,sex,tech = infoprint(name,sex,tech)结果:brucepk man python 优雅你的判断语句我们用判断语句来定义一个绝对值函数。常规方法：1234567891011121314x = -6if x &lt; 0: y = -xelse: y = xprint(y)结果:6优雅方法：x = -6y = -x if x&lt;0 else xprint(y)结果6 区间判断使用 and 连续两次判断的语句，条件都符合时才执行语句。常规方法：123456score = 82if score &gt;=80 and score &lt; 90: level = 'B'print(level)结果B 优雅方法：使用链式判断。123456score = 82if 80 &lt;= score &lt; 90: level = &apos;B&apos;print(level)结果B 多个值符合条件判断多个值任意一个值符合条件即为 True 的情况。常规方法：123456num = 1if num == 1 or num == 3 or num == 5: type = &apos;奇数&apos;print(type)结果奇数 优雅方法：使用关键字 in，让你的语句更优雅。123456num = 1if num in(1,3,5): type = &apos;奇数&apos;print(type)结果奇数 判断是否为空判断元素是空还是非空。常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;if len(A) &gt; 0: print(&apos;A 为非空&apos;)if len(B) &gt; 0: print(&apos;B 为非空&apos;)if len(C) &gt; 0: print(&apos;C 为非空&apos;)结果A 为非空 优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。 123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos; if A: print(&apos;A 为非空&apos;) if B: print(&apos;B 为非空&apos;) if C: print(&apos;C 为非空&apos;) 结果A 为非空 多条件内容判断至少一个成立常规方法：用 or 连接多个条件。12345math,English,computer =90,80,88if math&lt;60 or English&lt;60 or computer&lt;60: print(&apos;not pass&apos;)结果not pass 优雅方法：使用 any 语句。12345math,English,computer =90,59,88if any([math&lt;60,English&lt;60,computer&lt;60]): print(&apos;not pass&apos;)结果not pass 多条件内容判断全部成立常规方法：使用 and 连接条件做判断。12345math,English,computer =90,80,88if math&gt;60 and English&gt;60 and computer&gt;60: print(&apos;pass&apos;)结果pass 优雅方法：使用 all 方法。12345math,English,computer =90,80,88if all([math&gt;60,English&gt;60,computer&gt;60]): print(&apos;pass&apos;)结果pass 遍历序列的元素和元素下标常规方法：使用 for 循环进行遍历元素和下标。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for i in range(len(L)): print(i, &apos;:&apos;, L[i])结果0 : math1 : English2 : computer3 : Physics 优雅方法：使用 enumerate 函数。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for k,v in enumerate(L): print(k, &apos;:&apos;, v)结果0 : math1 : English2 : computer3 : Physics 循环语句优化之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。常规方法：使用简单的 for 循环可以达到目的。123456L = []for i in range(1, 6): L.append(i*i)print(L) 结果：[1, 4, 9, 16, 25] 优雅方法：使用列表生成式，一行代码搞定。123print([x*x for x in range(1, 6)]) 结果：[1, 4, 9, 16, 25] 将list中的所有元素转为单个字符串12a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]print(&quot; &quot;,join(a)) 字符串倒转方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。方法二：用Python自带reversed()函数，它可被用于list倒转。方法三：第三种是通过倒转数据类型和切片倒转整数. 链式调用在python 中实现链式调用只需在函数返回对象自己就行123456def product(a, b): return a * bdef add(a, b): return a + bb = Trueprint((product if b else add)(5, 7)) 复制list在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：方法一：b=a[:]。方法二：b=list(a)。方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。方法四：使用copy.deepcopy()。 按value排序字典Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：方法一：用sorted函数排序，其中key参数是lamda表达式。方法二：用operator.itemgetter而不是lamda表达式进行排序。方法三：如果只需得到排序后的key，可用.get。 for … else语法合并字典方法一：Python 3.5可以存在重复键值，print({d1 ,d2})。方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。方法三：d1.update()。 从list中删除重复项方法一：把list转成set，去除重复项，再转回list。方法二：调用collections里的OrderedDict，和set差不多。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fbook%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本概念数学定义y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)python函数:是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元完成一定的功能函数的作用结构化编程对代码的最基本的封装, 一般按照功能组织一段代码封装的目的为了复用,减少冗余代码代码更加简洁美观,可读易懂 函数的分类:内建函数,如max()库函数,如math.ceil自定义函数,使用def关键字定义 函数定义def 函数名(参数列表): 函数体(代码块) [return 返回值]函数名就是标识符,命名要求一样语句块必须缩进,约定4个空格函数名就是标识符就是变量python的函数没有return,会返回none定义中的参数列表称为形式参数,只是一种标识符占位置的函数的标识符就是指向函数对象函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参不定义会报nameERREO 传参方式: 位置传参按照参数定义顺序传入实参 关键字使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的参数缺省值缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用 可变位置参数在形参使用* 表示该形参是可变位置参数, 可以接受多个实参它将收集来的实参组织到一个tuple中tuple 有序按位置传参可变关键字参数在形参使用表示该形参是可变关键字参数,可以接受多个关键字参数它将收集来的实参的名称和值,组织到一个dict中可变的关键字传参 kwargs 有可变位置参数和可变关键字参数可变位置参数在形参前使用一个*号可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple可变关键字参数收集形成一个dict混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面要在可变关键字参数之前. keyword-only 参数def fn(args, x, y, **kwargs): print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)fn(3, 5)fn(3, ,5, 7)在python3之后,新增了keyword-only参数keyword-only参数:在形参定义时,在一个星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数keyword-only参数,言下之意就是这个参数必须采取关键字传参可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.星号后所有的普通参数都成了keyword-only参数参数的混合使用参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数代码应该易读易懂, 而不是为难别人请按照书写习惯定义函数参数.参数解构:在给函数提供实参的时候,可以在可迭代对象前使用或者来进行的解构,提取出其中所有元素作为函数的实参.使用*解构成位置参数使用解构成位置 传参提取出来的元素数目要和参数的要求匹配 python函数使用return语句返回”返回值”所有函数都有返回值,如果没有return语句, 隐式调用return Nonereturn语句并不一定是函数的语句块的最后一条语句一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None如果有必要,可以显示调用return None ,可以简写return如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行返回值的作用: 结束函数调用,返回返回值函数不能同时返回多个值. 作用域一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域注意:每一个函数都会开辟一个作用域分类:全局作用域:在整个程序运行环境中都可见全局作用域中的变量称为全局变量局部作用域:在函数 ,类等内部可见局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域函数嵌套在一个函数中定义了另一个函数内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见 global语句使用global关键字的变量,将声明为外部的全局作用域中定义的使用了global 不再是局部变量,它是全局变量global使用原则外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决一句话:不要global,学习他就是深入理解变量作用域 闭包自由变量:未在本地作用域中定义的变量闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript nonlocal语句将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义代码中内层函数引到外部局部作用域中的自由变量,形成闭包 函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期查看default属性,他是个元组 变量名解析原则LEGB***local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡所以一个名词的查找顺序就是LEGB. |]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门笔记]]></title>
    <url>%2Fbook%2Fpython%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机基础程序是一组让计算机识别和执行的指令电子计算机:能够执行程序的机器计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.即8位 2**8=256种状态 内存 掉电易失 与晶振频率有关 临时数据 mermorycpu与内存速度差几个数量级cpu 只认内存 io设备最慢CPU 缓存 cache bus 总线先写源程序 通过编译程序把源程序转换成机器指令的程序python是跑在虚拟机上的 动态语言 做节点 集群优化编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样 机器语言: 是一定位数组成的0 1序列 称为机器指令 机器指令的集合就是机器语言汇编: 是用助记符替代机器指令静态语言: 是声明变量类型,不能再改变,编译需要检查动态语言: 不用声明类型 随时可以赋值为其他类型强类型: 不同类型之间操作 必须强制类型转换为同一类型弱类型: 不同类型之间操作 自动隐式转换 python基础介绍python 的源代码需要被解释器编译成中间代码,在虚拟机上运行*`程序 = 算法 +数据结构`*数据一切程序的核心数据结构是数据在计算机中的类型和组织方式算法是处理数据的方式,算法有优劣之分.python自带了一个IDLE的程序,全称是交互式开发环境.注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要. import math #对角线的长度i = 4w = 10d = math.sqrt(12 + w2)即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的编写尽量用pep8风格 数据类型:python将数据划分为不同的类别,即数据类型.每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.对象的数据类型是对象所属的数据类别.“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号数据类型为bool的对象被称为布尔值.数据类型为nonetype的对象,其值永远我none 用来表示数据缺失. 系统编程python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展此外很多python的系统工具设计都考虑了其可移植性. python解释器python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行. python变量和内存变量在python是表示内存的地址.可以用id()函数获取内存地址 a=5id(a)id(5)会发现这两个地址一样,都输出140720362218448 即python的编程哲学 :一切皆对象,一切皆指针只有指针,要说变量也是指针变量variable 变量是改变的值.变量由一个或多个字符组成的名称构成并使用赋值符 等号赋予了这个名称一个值变量是记住内存中 0 1数字 开始和结束的一串 指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。对于C和C++这样的没有Garbage Collection 的语言来讲我们主要关注两种类型的内存泄漏： 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 python虚拟机原理python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.pycodeobject保存字节码以及进程上下文信息. 过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象.pyc文件字节码在磁盘上的表现形式pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,从技术上将,他才是所谓python解释器的最后一步.代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式. 开发环境 —-pyenvpython多版本管理工具pip包管理器pip install xxxpip listpip search keyword 或者 pypipip help installpip install redis ipythonpip install jupyterpip -Vpip freeze &gt; requirementpip install-r requirement 原码补码反码原码是给人看的,补码是给计算机用的127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。因为它是用补码的编码方式。正数的补码就是它的原码，也就是单纯的二进制数。负数的话，1111 1111这个二进制串，首先它最高位是1，明确他是个负数。那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001也就是1，再加上符号位。最终结果是-1 补码 从小到大 二进制1000 0000—-0000 0000—-0111 1111首尾相连，刚好连个时钟，最大的加一到最小的 字符串使用单双三引号括起来的序列叫字符串 r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理f前缀:3.6版本开始,新增f前缀,格式化字符串转义序列\ \t \r \n \’ \”缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系约定使用4个空格缩进续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\extend 魔术方法add() 标识符一个名字,用来指代一个值只能是字母,下划线和数字只能以字母或下划线开头不能是python的关键字,例如def,class等python是大小写敏感的约定:不允许使用中文不要使用歧义单词,例如class_在python中不要随便使用下划线开头的标识符 运算符 算术运算符 +-*/%**自然除/结果是浮点数,整除// 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 比较运算符 == != &gt; &lt; &gt;= &lt;=返回一个bool值 逻辑运算符 与或非 and or not短路运算符 赋值运算符0 *? =0短路1+? =1短路运算 可以提高效率 可以提前算完了赋值运算 先算右边 和左边相连(映射) a=min(3,5) 运算符优先级 就记住一句话 a+b&gt;c and 折半思想可以优化程序 程序控制顺序结构:按照先后顺序一条条执行分支结构:根据不同情况判断,条件满足执行某条件下的语句循环结构:条件满足就反复执行,不满足就不执行或不再执行 内置类型内置对象使程序更容易编写内置对象使扩展的组件内置对象往往比定制的数据结构更有效率内置对象使语言的标准的一部分python的核心数据类型模式匹配 循环while 语句whlie condition: block当他成立则进入循环while true: pass #死循环 冒号后要形成语句块 死循环都用这个语法例子: flag = 10while flag: print(flag) flag-= 1 在做循环时,一定要分析边界 边界最容易出错range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包 for i in range(10): print(i+1) i= i+10循环 隐含赋值 原来有什么会被冲掉for相当于遍历 不会重复拿 挨个拿如果要倒着遍历 应当在range函数内加步长-1例子:for i in range(10): if i %2 == 0: print(i) for i in range(10): if not i % 2: print(i)not 经常用for i in range (10): if i &amp;1 == 0: print(i) for i in range(10): if i &amp; 1: continue print(i) 写程序要减少循环提高效率 for i in range(10): if i % 2: continue print(i) 如果循环嵌套 continue 和break也只影响语句所在的那一层循环 迭代器和生成器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： from collections import Iterableisinstance([], Iterable)Trueisinstance({}, Iterable)Trueisinstance(‘abc’, Iterable)Trueisinstance((x for x in range(10)), Iterable)Trueisinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： L = [x x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x x for x in range(10))g &lt;generator object at 0x1022ef630&gt; 函数python 内置了很多有用的函数,我们可以直接调用要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 三大器]]></title>
    <url>%2Fbook%2Fpython%20%E4%B8%89%E5%A4%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用. 12345678def 炼丹炉(func): def 变身(*args): 火眼金睛 returrn 孙悟空 return 变身@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)def 孙悟空: return 装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper 单层的只需要function 如:注册器 双层的是返回一个全新的函数 如:打印log 迭代器迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代可迭代对象就是,实现了迭代器协议的对象.协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)使用迭代器协议访问对象.举个例子:for n in [1, 2, 3, 4]: print(n) 但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象with open (‘/etc/passwd’) as f: for line in f: print(line) def gensquares(n): for i in range(n): yield i ** 2for item in genquares(s): print(item) 生成器语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.自动实现迭代器协议:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python pep]]></title>
    <url>%2Fbook%2Fpython%20pep%2F</url>
    <content type="text"><![CDATA[PEPPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0 https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅import thisBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题） PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148 PEP8016Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识框架]]></title>
    <url>%2Fbook%2Flinux%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍操作系统os(operating system),通用目的的软件程序 硬件驱动进程管理内存管理网络管理安全管理文件管理 安装linux linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的manjaro或mint分区和启动:硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tbuefi的GPT分区:逐渐代替MBR标准主分区 一块硬盘最多4个,不能划分更小,最小单位扩展分区:一块硬盘最多一个,不能直接创建文件系统安装过程大同小异 详细步骤需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌./dev/sda 100g/dev/sda1 /boot mountpoint 1g/dev/sda2 / 50g/dev/sda3 /data 20g/dev/sda5 /swap 2g 开发接口标准 ABI:application binary interface ABI描述了程序与os之间的底层接口API:application programming interface开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit 用户和内核空间 username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响内核空间:kernel space linux哲学思想在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的 文件操作文件和目录被组织成单根倒置树结构文件系统从根目录下开始,用”/“表示proc虚拟的,在硬盘上不存在文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)以.开头的文件为隐藏文件元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.数据:data(内容在硬盘上)文件系统分成结构:LSB文件名最长255个字节,文件系统不一样大小不一样包括路径在内文件名称最长4095个字节蓝色—目录 绿色—可执行文件 红色—压缩文件浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递管道文件 p开头(pipe)单工传输 文件系统结构元素/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64：专用于x86_64系统上的辅助共享库文件存放位置/etc：配置文件目录/home/USERNAME：普通用户家目录/root：管理员的家目录/media：便携式移动设备挂载点/mnt：临时文件系统挂载点/dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问/opt：第三方应用程序的安装位置/srv：系统上运行的服务用到的数据/tmp：临时文件存储位置/proc: 用于输出内核与进程信息相关的虚拟文件系统/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文/usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序sbin: lib：32位使用 lib64：只存在64位系统include: C程序的头文件(header files)share：结构化独立的数据，例如doc, man等local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文 /var: variable data files cache: 应用程序缓存数据目录lib: 应用程序状态信息数据local：专用于为/usr/local下的应用程序存储可变数据lock: 锁文件 log: 日志目录及文件opt: 专用于为/opt下的应用程序存储可变数据run: 运行中的进程相关数据,通常用于存储进程pid文件spool: 应用程序数据池tmp: 保存系统两次重启之间产生的临时数据 Linux下的文件类型-：普通文件d: 目录文件b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)c: 字符设备(设备主要以字符为单位,键盘为主)l: 符号链接文件p: 管道文件pipes: 套接字文件socket 显示当前工作目录每个shell和系统进程都有一个当前的工作目录CWD:current work directory显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 更改目录cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -选项：-P相关的环境变量： PWD：当前目录路径 OLDPWD：上一次目录路径 列出目录内容列出当前目录的内容或指定目录用法：ls [options] [ files_or_dirs ]示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R 目录递归通过 ls -ld 目录和符号链接信息 ls -1 文件分行显示 ls –S 按从大到小排序 ls –t 按mtime排序 ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示 ls –X 按文件后缀排序 [root@centos7 sysconfig]# ll /etc/motd-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd[root@centos7 sysconfig]# ll ../motd-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd-a 全部-r 递归ll 是别名 (ls -l) 查看文件状态stat文件：metadata, data三个时间戳: access time：访问时间，atime，读取文件内容modify time: 修改时间,mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变data 时间不会一直更新通配符* 任意字符二进制查看hexdump -C 创建和查看文件touch 命令是个外部命令[]表示其中一个字母[^ ]表示除去其中字符的任意字符两个大于号比 touch安全 文件统配符man 7 glob 复制和转移删除文件cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失原始命令前加\拷贝文件夹 -r(递归)cp 有可能丢失数据不能用rmdir删除 data是个挂载点cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中 基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中cp SRC… DEST SRC…：多个文件DEST必须存在，且为目录，其它情形均会出错；cp SRC DESTSRC是目录：此时使用选项：-r如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；如果DEST存在：如果DEST是文件：报错如果DEST是目录：inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 inode 唯一标识在元数据里删除其实删的元数据.删文件比建文件快多了 软和硬链接硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区语法: ln filename [linkname ]软连接一个符号文件链接指向一个文件ls -s显示链接的名称和应用的文件一个符号链接的内容是他引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数语法:ln -s 文件 链接名 i/0 重定向至文件程序:指令+数据input 和output打开的文件都有一个fd:file descrptor(文件描述符)linux 给程序提供三种i/o设备标准输入(STDIN)-0 默认接受来自键盘的输入标准输出(STDOUT) -1默认输出到终端窗口标准错误(STDERR) -2 默认输出到窗口i/o重定向:改变默认位置语法:命令 操作符号 文件名操作符&gt;把STDOUT重定向到文件2&gt; 把STDERR重定向到文件$&gt; 把所有输出重定向到文件tr 转换和删除字符 管道管道用来连接命令命令1|命令2|命令3将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDINless 一页一页地查看输入重定向到多个目标(tee)把命令1的STDOUT保存在文件中,作为命令2的输入-a追加使用:保存不同阶段的输入复杂管道的故障排除同时查看和记录输出 用户组权限用户user令牌token,identitylinux用户:username/UID管理员:root,0普通用户:1-65535系统用户:1-499,1-999对守护进程获取资源进行权限进行分配登录用户:500+,1000交互式登录nologin 是软件启动没有用户登录 组grouplinux:Groupname/GID管理员:系统 :1-499,1-999普通组:500+,1000+安全上下文:进行中的程序:程序(process)以进程发起者的身份运行:root:/bin/catmage:/bin/cat组的类别用户的主要组:用户必须属于一个且只有一个主组组名同用户名,且包含一个用户,私有组用户和组的配置文件/etc/passwd:用户及其属性信息/etc/group:组及其属性信息/etc/shadow:用户密码及其相关属性/etc/gshadow:组密码及其相关属性passwd文件格式login name:登录用名passwd:密码UID:用户身份编号GID:登录默认所在组编号GECOS:用户全名或注释home diretory:用户主目录shell:用户默认使用shellshadow文件格式useradd usermod userdel组账号维护命令:groupaddgroupmod groupdel 用户创建:useradduseradd [options]LOGIN-u UID-o 配合-u选项,不检查UID的唯一性-g GID:指明用户所属基本组,可谓组名,也可以GID-c “COMMENT”:用户的注释信息默认设置:/etc/default/useradd文件中删除用户:userdel -r删除用户目录 查看用户相关的ID信息id [OPTIONS]…[USER]-u :显示UID-g :显示GID-G :显示用户所属的组的ID-n :显示名称,需配合ugG使用 切换用户或以其他用户身份执行命令su[options] [-] [user[args…]]切换用户的方式ssh root@ipcurl wwservice network restat 设置密码passwd常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 创建组groupadd[option]…group_name-g GID:指明GID号:-r:创建系统组修改和删除组:组属性修改:groupmod组删除:groupdel组密码:gpasswdnewgrp命令:临时切换主组chown设置文件的所有者chgrp设置文件的属组信息修改文件的属主和属组chown修改文件的属组:chgrp 文件权限文件的权限主要针对三类对象进行定义owner: 属主, ugroup: 属组, gother: 其他, o每个文件针对每类访问者都定义了三种权限r: Readablew: Writablex: eXcutable 修改文件权限chmod [OPTION]… OCTAL-MODE FILE… -R: 递归修改权限chmod [OPTION]… MODE[,MODE]… FILE… MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]… –reference=RFILE FILE…参考RFILE文件的权限，将FILE的修改为同RFILE数字权限法:chmod数字 filerwx r-x r– file其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 文本工具基础文件内容:less和cat文件截取:head和tail按列抽取:cut按关键字抽取:grep文件查看:cat tac rev分页查看:more一页一页的查看:lessless 命令是man命令使用的分页器 显示文本前后或后行内容head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行tail[option]…[FILE]看文本尾tail-f 跟踪看日志cut命令取字段past 横着合并文件wc 收集文本 文本排序sort把整理过的文本显示在STDOUT,不改变原始文件sort[opiton]file(s)uniq:从输入中删除前后相接的重复的行,处理日志liunx:文本处理三剑客grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红sed:stream editor, 文本编辑工具awk:liunx上的实现gawk,文本报告生成器grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行 正则表达式匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数位置锚定:定位正则字符特殊 元字符.单个任意字符[abc]表示其中一个字符[^abc]除去abc任意字母[:lower:]小写[:upper:]大写分组方式abc{3}\搜索替代工具grep过滤特定行,sed也可以并且编辑修改文件 vim编辑器vi:visual interface 文本编辑器文本:asscii ,unicode文本编辑种类:行编辑器:sed全屏编辑器:nano,vivim -viimproved其他编辑器gedit 一个简单的图形编辑器gvim 一个vim编辑器的图形版本vi一开始是vim的别名vim有三种模式:normal(普通) insert(插入) extendcommand(命令)normal :默认模式,移动光标,剪切/粘贴文本insert :修改文本extend command:保存,退出 搜索替代/ :从当前光标所在处向文件尾部查找? :从当前光标所在处向文件首部查找n :与命令同方向N :与命令反方向处理文本的工具sedstream editor 行编辑器sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.vim不适合修改大批量文件,sed可以sed 配合管道可以使用awk 语言sed ‘’ passwd‘地址命令’地址不写代表全部文件 命令不写代表输出 软件管理包管理器rpm 打包文件 不需要考虑部署 安装路径都定义好二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件程序包管理器：debian：deb文件, dpkg包管理器redhat: rpm文件, rpm包管理器rpm: Redhat Package Manager RPM Package Manager源代码：name-VERSION.tar.gz|bz2|xz VERSION: major.minor.releaserpm包命名方式:name-VERSION-release.arch.rpm例：bash-4.2.46-19.el7.x86_64.rpm VERSION: major.minor.release release：release.OS常见的arch： x86: i386, i486, i586, i686 x86_64: x64, x86_64, amd64 powerpc: ppc 跟平台无关：noarch 包：分类和拆包Application-VERSION-ARCH.rpm: 主包Application-devel-VERSION-ARCH.rpm 开发子包 Application-utils-VERSION-ARHC.rpm 其它子包 Application-libs-VERSION-ARHC.rpm 其它子包包之间：可能存在依赖关系，甚至循环依赖解决依赖包管理工具:yum：rpm包管理器的前端工具 apt-get：deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具 查看二进制程序所依赖的库文件 ldd /PATH/TO/BINARY_FILE管理及查看本机装载的库文件 ldconfig 加载库文件 /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf 缓存文件：/etc/ld.so.cache 程序包管理器功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.包文件组成 (每个包独有)RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.安装或卸载时运行的脚本数据库(公共)：/var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息管理程序包的方式:使用包管理器：rpm 使用前端工具：yum, dnf获取程序包的途径：(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com(2) 项目官方站点程序包的来源(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/(4) 自己制作 注意：第三方包建议要检查其合法性 来源合法性,程序包的完整性 rpm包管理CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护 安装：rpm {-i|–install} [install-options] PACKAGE_FILE… -v: verbose -h: 以#显示程序包管理执行进度 rpm -ivh PACKAGE_FILE … rpm包安装[install-options]–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs | replacefiles–nosignature: 不检查来源合法性–nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre: 安装前脚本；–nopre %post: 安装后脚本；–nopost %preun: 卸载前脚本；–nopreun %postun: 卸载后脚本； –nopostun rpm包升级升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…rpm {-F|–freshen} [install-options] PACKAGE_FILE…upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装”freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE … rpm -Fvh PACKAGE_FILE …–oldpackage：降级–force: 强制安装 升级注意项注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留 包查询rpm {-q|–query} [select-options] [query-options] [select-options]-a: 所有包-f: 查看指定的文件由哪个程序包安装生成-p rpmfile：针对尚未安装的程序包文件做查询操作–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 常用查询用法： -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, … -qa包卸载： rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME … 包校验rpm {-V|–verify} [select-options] [verify-options] S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ包校验包来源合法性验正及完整性验正完整性验正：SHA256来源合法性验正：RSA 公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人 rpm数据库数据库重建： /var/lib/rpm rpm {–initdb|–rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之 否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 yumCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下） 文件服务器: http:// https:// ftp:// file:// yum配置文件yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义： [repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000 yum仓库yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号 $arch: 平台，i386,i486,i586,x86_64等 $basearch：基础平台；i386, x86_64 $YUM0-$YUM9:自定义变量 实例: http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64 http://server/centos/6/i384yum源阿里云repo文件:http://mirrors.aliyun.com/repo/CentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/EPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 yum命令yum命令的用法： yum [options] [command] [package …]显示仓库列表： yum repolist [all|enabled|disabled]显示程序包： yum list yum list [all | glob_exp1] [glob_exp2] […] yum list {available|installed|updates} [glob_exp1] […] 安装程序包： yum install package1 [package2] […] yum reinstall package1 [package2] […] (重新安装)yum命令升级程序包： yum update [package1] [package2] […] yum downgrade package1 [package2] […] (降级)检查可用升级： yum check-update卸载程序包： yum remove | erase package1 [package2] […]yum命令查看程序包information： yum info […]查看指定的特性(可以是某文件)是由哪个程序包所提供： yum provides | whatprovides feature1 [feature2] […]清理本地缓存： 清除/var/cache/yum/$basearch/$releasever缓存 yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]构建缓存： yum makecacheyum命令搜索：yum search string1 [string2] […] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilities： yum deplist package1 [package2] […]查看yum事务历史： yum history [info|list|packages-list|packages-info| summary|addon-info|redo|undo| rollback|new|sync|stats] yum history yum history info 6 yum history undo 6日志 ：/var/log/yum.log安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] …yum localupdate rpmfile1 [rpmfile2] […] (用update替代)包组管理的相关命令： yum groupinstall group1 [group2] […] groupupdate group1 [group2] […] yum grouplist [hidden] [groupwildcard] […] yum groupremove group1 [group2] […] yum groupinfo group1 […]yum命令yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件系统光盘yum仓库系统安装光盘作为本地yum仓库：(1) 挂载光盘至某目录，例如/mnt/cdrom mount /dev/cdrom /mnt/cdrom(2) 创建配置文件 [CentOS7] name= baseurl= gpgcheck= enabled= 创建yum仓库： createrepo [options] 程序包编译程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 C、C++：make 项目管理器 configure脚本 –&gt; Makefile.in –&gt; Makefile java: maven C语言源代码编译安装三步骤:1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make 根据Makefile文件，构建应用程序3、make install 复制文件到相应路径开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in注意：安装前查看INSTALL，README 开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software Foundation) mariadb.org 代码托管:SourceForge.net Github.com code.google.comc/c++编译器: gcc (GNU C Complier) 编译C源代码： 准备：提供开发工具及开发环境 开发工具：make, gcc等 开发环境：开发库，头文件 glibc：标准库 实现：通过“包组”提供开发组件 Development Tools Server Platform Development 第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项 选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译 Optional Features: 可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包 –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION 第二步：make 第三步：make install 安装后的配置：(1) 二进制程序目录导入至PATH环境变量中 编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH(2) 导入帮助手册 编辑/etc/man.config|man_db.conf文件 添加一个MANPATH shell编程基础程序：指令+数据程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 shell程序：提供了编程能力，解释执行 编程基本概念编程逻辑处理方式：顺序执行循环执行选择执行 shell编程：过程式、解释执行编程语言的基本结构：各种系统命令的组合数据存储：变量、数组表达式: a + b语句:ifshell脚本基础shell脚本:包含一些命令或声明，并符合一定格式的文本文件格式要求:首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perlshell脚本的用途有：自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 添加注释注释以#开头第二步：运行脚本给予执行权限，在命令行上指定脚本的绝对或相对路径直接运行解释器，将脚本作为解释器程序的参数运行 脚本规范脚本代码开头约定1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 脚本调试检测脚本中的语法错误bash -n /path/to/some_script调试执行bash -x /path/to/some_script 变量变量：命名的内存空间数据存储方式：字符：数值：整型，浮点型变量：变量类型作用：1、数据存储格式2、参与的运算3、表示的数据范围类型：字符数值：整型、浮点型变量命名法则：1、不能使程序中的保留字：例如 if, for2、只能使用数字、字母及下划线，且不能以数字开头3、见名知义4、统一命名规则：驼峰命名法，建议大写 bash中变量的种类根据变量的生效范围等标准划分下面变量类型：局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程， 包括当前shell的子shell进程均无效环境（全局）变量：生效范围为当前shell进程及其子进程 本地变量：生效范围为当前shell进程中某代码片断，通常指函数 位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传 递给它的参数特殊变量：$?, $0, $*, $@, $#,$$ 局部变量变量赋值：name=‘value’可以使用引用value:(1) 可以是直接字串; name=“root”(2) 变量引用：name=”$USER”(3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name“”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set删除变量：unset name 环境变量bash内建的环境变量：PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE— 只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量： readonly name declare -r name查看只读变量： readonly –p位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置$0: 命令本身$: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/nullecho $?退出状态码bash自定义退出状态码exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 运算bash中的算术运算:help let+, -, , /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如bash有内建的随机数生成器：RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数赋值 增强型赋值：+=, -=, *=, /=, %=let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1 let var++ let var-=1 let var-- 逻辑运算true, false1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! 0 = 1 短路运算 短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算 短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算 异或：^异或的两个值,相同为假，不同为真 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1 测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符bash的数值测试-v VAR变量VAR是否设置 数值测试：-gt 是否大于-ge 是否大于等于-eq 是否等于-ne 是否不等于-lt 是否小于-le 是否小于等于bash的字符串测试 字符串测试: == 是否等于ascii码是否大于ascii码&lt; 是否小于!= 是否不等于=~ 左侧字符串是否能够被右侧的PATTERN所匹配注意: 此表达式一般用于[[ ]]中；扩展的正则表达式-z “STRING“ 字符串是否为空，空为真，不空为假-n “STRING“ 字符串是否不空，不空为真，空为假注意：用于字符串比较时的用到的操作数都应该使用引号Bash的文件测试 存在性测试 -a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件Bash的文件权限测试 文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限Bash的文件属性测试 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组Bash的文件属性测试 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 使用read命令来接受输入使用read来把输入值分配给一个或多个shell变量-p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE 流程控制过程式编程语言： 顺序执行 选择执行 循环执行条件选择if语句 选择执行: 注意：if语句可嵌套单分支 if 判断条件;then 条件为真的分支代码 fi双分支 if 判断条件; then 条件为真的分支代码 else条件为假的分支代码fi 多分支 if 判断条件1; then 条件为真的分支代码 elif 判断条件2; then 条件为真的分支代码 elif 判断条件3; then 条件为真的分支代码 else 以上条件都为假的分支代码 fi 逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断：case语句 case 变量引用 in PAT1) 分支1 ;; PAT2) 分支2 ;; ... *) 默认分支 ;; esac case支持glob风格的通配符： *: 任意长度任意字符 ?: 任意单个字符 []：指定范围内的任意单个字符 a|b: a或b 循环 循环执行将某代码段重复运行多次重复运行多少次：循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, untilfor循环for 变量名 in 列表;do循环体done执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 for循环列表生成方式：(1) 直接给出列表(2) 整数列表：(a) {start..end}(b) $(seq [start [step]] end)(3) 返回列表的命令$(COMMAND)(4) 使用glob，如：.sh(5) 变量引用；$@, $while循环while CONDITION; do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为falseuntil循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true循环控制语句continue用于循环体中ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thencontinuefiCMDn…done循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thenbreakfiCMDn…done特殊用法双小括号方法，即((…))格式，也可以用于算术运算双小括号方法也可以使bash Shell实现C语言风格的变量操作I=10((I++))for循环的特殊格式：for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))do 循环体done控制变量初始化：仅在运行到循环代码段时执行一次控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于：Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改定义函数函数由两部分组成：函数名和函数体help function语法一：f_name （）{…函数体…} 语法二：function f_name {…函数体…} 语法三：function f_name （） {…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止函数返回值函数有两种返回值：函数的执行结果返回值：(1) 使用echo等命令进行输出(2) 函数体中调用命令的输出结果函数的退出状态码：(1) 默认取决于函数中执行的最后一条命令的退出状态码(2) 自定义退出状态码，其格式为：return 从函数中返回，用最后状态命令决定返回值return 0 无错误返回。return 1-255 有错误返回交互式环境下定义和使用函数 示例:dir() {ls -l}定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir在脚本中定义及使用函数函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用调用函数仅使用其函数名即可示例：cat func1!/bin/bashfunc1hello(){echo “Hello there today’s date is date +%F“}echo “now going to the function hello”helloecho “back from the function”使用函数文件可以将经常使用的函数存入函数文件，然后将函数文件载入shell文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例： cat functions.main #!/bin/bash #functions.mainfindit(){if [ $# -lt 1 ] ; thenecho “Usage:findit file”return 1fifind / -name $1 –print} 载入函数函数文件已创建好后，要将它载入shell定位函数文件并载入shell的格式：. filename 或 source filename注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径 检查载入函数使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 示例：setfindit=( ){if [ $# -lt 1 ]; thenecho “usage :findit file”;return 1fifind / -name $1 -print} 执行shell函数要执行函数，简单地键入函数名即可示例：findit groups/usr/bin/groups/usr/local/backups/groups.bak 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量在函数中定义局部变量的方法local NAME=VALUE函数递归示例 函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)!函数递归示例: 示例：fact.sh fact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi } fact $1 fork炸弹 fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现:(){ :|:&amp; };:bomb() { bomb | bomb &amp; }; bomb 实际上: 代表bomb脚本实现 cat Bomb.sh./$0|./$0&amp;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(3)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(3)%2F</url>
    <content type="text"><![CDATA[磁盘管理cdLinux cd命令用于切换当前工作目录至 dirName(目录参数)。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。 另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。 语法cd [dirName]dirName：要切换的目标目录。 dfLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 语法df [选项]… [FILE]…文件-a, –all 包含所有的具有 0 Blocks 的文件系统文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, –inodes 列出 inode 资讯，不列出已使用 block文件-k, –kilobytes 就像是 –block-size=1024文件-l, –local 限制列出的文件结构文件-m, –megabytes 就像 –block-size=1048576文件–no-sync 取得资讯前不 sync (预设值)文件-P, –portability 使用 POSIX 输出格式文件–sync 在取得资讯前 sync文件-t, –type=TYPE 限制列出文件系统的 TYPE文件-T, –print-type 显示文件系统的形式文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件–help 显示这个帮手并且离开文件–version 输出版本资讯并且离开 duLinux du命令用于显示目录或文件的大小。 du会显示指定的目录或文件所占用的磁盘空间。 语法du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]参数说明： -a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或–dereference-args 显示指定符号连接的源文件大小。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或–kilobytes 以1024 bytes为单位。-l或–count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或–megabytes 以1MB为单位。-s或–summarize 仅显示总计。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。–help 显示帮助。–version 显示版本信息。 mkdirLinux mkdir命令用于建立名称为 dirName 之子目录。 语法mkdir [-p] dirName参数说明： -p 确保目录名称存在，不存在的就建一个。 pwdLinux pwd命令用于显示工作目录。 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。 语法pwd [–help][–version]参数说明: –help 在线帮助。–version 显示版本信息。 mountLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 语法mount [-hV]mount -a [-fFnrsvw] [-t vfstype]mount [-fnrsvw] [-o options [,…]] device | dirmount [-fnrsvw] [-t vfstype] [-o options] device dir参数说明： -V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 lsLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法 ls [-alrtAFR] [name…]参数 : -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出 系统管理useraddLinux useradd命令用于建立用户帐号。 useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 语法useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ]参数说明： -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。-d&lt;登入目录&gt; 指定用户登入时的启始目录。-D 变更预设值．-e&lt;有效期限&gt; 指定帐号的有效期限。-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。-g&lt;群组&gt; 指定用户所属的群组。-G&lt;群组&gt; 指定用户所属的附加群组。-m 自动建立用户的登入目录。-M 不要自动建立用户的登入目录。-n 取消建立以用户名称为名的群组．-r 建立系统帐号。-s 指定用户登入后所使用的shell。-u 指定用户ID dataLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 时间方面： % : 印出 %%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面： %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。 使用权限：所有使用者。 当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。 当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。 语法date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]参数说明： -d datestr : 显示 datestr 中所设定的时间 (非系统时间)–help : 显示辅助讯息-s datestr : 将系统时间设为 datestr 中所设定的时间-u : 显示目前的格林威治时间–version : 显示版本编号 psLinux ps命令用于显示当前进程 (process) 的状态。 语法ps [options] [–help]参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义-A 列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程au(x) 输出格式 :USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDUSER: 行程拥有者PID: pid%CPU: 占用的 CPU 使用率%MEM: 占用的记忆体使用率VSZ: 占用的虚拟记忆体大小RSS: 占用的记忆体大小TTY: 终端的次要装置号码 (minor device number of tty)STAT: 该行程的状态:D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的行程N: 低优先序的行程L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)START: 行程开始时间TIME: 执行的时间COMMAND:所执行的指令 topLinux top命令用于实时显示 process 的动态。 使用权限：所有使用者。 语法top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]参数说明： d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 sq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来s : 安全模式，将交谈式指令取消, 避免潜在的危机i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程n : 更新的次数，完成后将会退出 topb : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 pstreeLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。 使用权限：所有使用者。 语法pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]或 pstree -V参数说明： -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） rebootLinux reboot命令用于用来重新启动计算机。 若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代 语法reboot [-n] [-w] [-d] [-f] [-i]参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 screenLinux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。 语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明： -A 将所有的视窗都调整为目前终端机的大小。-d&lt;作业名称&gt; 将指定的screen作业离线。-h&lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r&lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S&lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 shutdownLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 使用权限：系统管理者。 语法shutdown [-t seconds] [-rkhncfF] time [message]参数说明： -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。 swatchLinux swatch命令用于系统监控程序。 swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。 语法swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]参数说明： -A&lt;分隔字符&gt; 预设配置文件中，动作的分隔字符，预设为逗号。-c&lt;设置文件&gt; 指定配置文件，而不使用预设的配置文件。-f&lt;记录文件&gt; 检查指定的记录文件，检查完毕后不会继续监控该记录文件。-I&lt;分隔字符&gt; 指定输入记录的分隔字符，预设为换行字符。-P&lt;分隔字符&gt; 指定配置文件中，事件的分隔字符，预设为逗号。-r&lt;时间&gt; 在指定的时间重新启动。-t&lt;记录文件&gt; 检查指定的记录文件，并且会监控加入记录文件中的后继记录。 idLinux id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 语法id [-gGnru][–help][–version][用户名称]参数说明： -g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法free [-bkmotV][-s &lt;间隔秒数&gt;]参数说明： -b 以Byte为单位显示内存使用情况。-k 以KB为单位显示内存使用情况。-m 以MB为单位显示内存使用情况。-o 不显示缓冲区调节列。-s&lt;间隔秒数&gt; 持续观察内存使用状况。-t 显示内存总和列。-V 显示版本信息。 系统设置setupLinux setup命令设置公用程序，是一个启动图形设置系统的命令。 setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。 语法setupsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项： １.登陆认证方式２.键盘组态设置３.鼠标组态设置４.开机时所要启动的系统服务５.声卡组态设置６.时区设置７.X Windows组态设置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(2)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(2)%2F</url>
    <content type="text"><![CDATA[文档编辑grepLinux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。 语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]参数： -a 或 –text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 –count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 –fixed-regexp : 将样式视为固定字符串的列表。-G 或 –basic-regexp : 将样式视为普通的表示法来使用。-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 –ignore-case : 忽略字符大小写的差别。-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 –only-matching : 只显示匹配PATTERN 部分。-q 或 –quiet或–silent : 不显示任何信息。-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。-s 或 –no-messages : 不显示错误信息。-v 或 –revert-match : 显示不包含匹配文本的所有行。-V 或 –version : 显示版本信息。-w 或 –word-regexp : 只显示全字符合的列。-x –line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定”-i”参数相同。 sortLinux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 语法sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]参数说明： -b 忽略每行前面开始出的空格字符。-c 检查文件是否已经按照顺序排序。-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-f 排序时，将小写字母视为大写字母。-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。-m 将几个排序好的文件进行合并。-M 将前面3个字母依照月份的缩写进行排序。-n 依照数值的大小排序。-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r 以相反的顺序来排序。-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。–help 显示帮助。–version 显示版本信息。 trLinux tr 命令用于转换或删除文件中的字符。 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 语法tr [-cdst][–help][–version][第一字符集][第二字符集]tr [OPTION]…SET1[SET2]参数说明： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息字符集合的范围： \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。[CHAR] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止[CHARREPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)[:alnum:] ：所有字母字符与数字[:alpha:] ：所有字母字符[:blank:] ：所有水平空格[:cntrl:] ：所有控制字符[:digit:] ：所有数字[:graph:] ：所有可打印的字符(不包含空格符)[:lower:] ：所有小写字母[:print:] ：所有可打印的字符(包含空格符)[:punct:] ：所有标点字符[:space:] ：所有水平与垂直空格符[:upper:] ：所有大写字母[:xdigit:] ：所有 16 进位制的数字[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符) uniqLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 语法uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]参数： -c或–count 在每列旁边显示该行重复出现的次数。-d或–repeated 仅显示重复出现的行列。-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。-u或–unique 仅显示出一次的行列。-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。–help 显示帮助。–version 显示版本信息。[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 wcLinux wc命令用于计算字数。 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…]参数： -c或–bytes或–chars 只显示Bytes数。-l或–lines 只显示行数。-w或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 letlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 语法格式let arg [arg …]参数说明：arg：要执行的表达式 sedLinux sed命令是利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法sed [-hnV][-e][-f&lt;script文件&gt;][文本文件]参数说明： -e或–expression= 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或–help 显示帮助。-n或–quiet或–silent 仅显示script处理后的结果。-V或–version 显示版本信息。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(1)]]></title>
    <url>%2Fbook%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[1 文档管理cat chgrp chmod chown file find cut in less more mv tee touch which cp read2 文档编辑:grep sed tr sort uniq wc let3 磁盘管理:cd df du mkdir pwd mount stat tree ls4 网络通讯:telnet httpd ifconfig netatat ping tty write5 系统管理:useradd data adduser exit kill ps pstree top reboot sudo uname who whoami whois w id free6 系统设置:reset clear alias enable rpm set passwd time setup7 备份压缩:zip tar8 其他命令: bc tail 文档命令cat全称: concatenate files and print on the standard outputcat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0注： OUTFILE 指输出的镜像文件名. IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用制作开机磁片 chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法:chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法chmod [-cfvR] [–help] [–version] mode file…参数说明mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本实例将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r *此外chmod也可以用数字来表示权限如 : chmod 777 file语法为： chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。chmod a=rwx file和 chmod 777 file效果相同 chmod ug=rwx,o=x file和 chmod 771 file效果相同 若用chmod 4755 filename可使此程序具有root的权限 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。使用权限 : root语法chown [-cfhvR] [–help] [–version] user[:group] file…参数 :user : 新的文件拥有者的使用者 IDgroup : 新的文件拥有者的使用者组(group)-c : 显示更改的部分的信息-f : 忽略错误信息-h :修复符号链接-v : 显示详细的处理信息-R : 处理指定目录以及其子目录下的所有文件–help : 显示辅助说明–version : 显示版本 fileLinux file命令用于辨识文件类型。 通过file指令，我们得以辨识该文件的类型。 语法file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]参数： -b 列出辨识结果时，不显示文件名称。-c 详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 指定魔法数字文件。-v 显示版本信息。-z 尝试去解读压缩文件的内容。[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 findLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法find path -option [ -print ] [ -exec -ok command ] {} \;参数说明 : find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 你可以使用 ( ) 将运算式分隔，并使用下列运算。 exp1 -and exp2 ! expr -not expr exp1 -or exp2 exp1, exp2 cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 语法cut [-bn] [file]cut [-c] [file]cut [-df] [file]使用说明: cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 参数: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符。-f ：与-d一起使用，指定显示哪个区域。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 lnLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 语法 ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] [–help] [–version] [–] 命令功能 :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数必要参数： -b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数： -S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”–help 显示帮助信息–version 显示版本信息 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 语法less [参数] 文件参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 moreLinux more命令Linux 命令大全 Linux 命令大全 Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 语法more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料-s 当遇到有连续两行以上的空白行，就代换为一行的空白行-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示+num 从第 num 行开始显示fileNames 欲显示内容的文档，可为复数个数 mvLinux mv命令Linux 命令大全 Linux 命令大全 Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 语法mv [options] source destmv [options] source… directory参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果 mv 文件名 文件名 将源文件名改为目标文件名mv 文件名 目录名 将文件移动到目标目录mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名mv 目录名 文件名 出错 rmrm命令用于删除一个文件或者目录。 语法rm [options] name…参数： -i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 teeLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。 tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 语法tee [-ai][–help][–version][文件…]参数： -a或–append 附加到既有文件的后面，而非覆盖它．-i或–ignore-interrupts 忽略中断信号。–help 在线帮助。–version 显示版本信息。 touchLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录。 语法touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]参数说明：a 改变档案的读取时间记录。m 改变档案的修改时间记录。c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。f 不使用，是为了与其他 unix 系统的相容性而保留。r 使用参考档的时间记录，与 –file 的效果一样。d 设定时间与日期，可以使用各种不同的格式。t 设定档案的时间记录，格式与 date 指令相同。–no-create 不会建立新档案。–help 列出指令格式。–version 列出版本讯息。 whichLinux which命令用于查找文件。 which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法which [文件…]参数： -n&lt;文件名长度&gt; 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p&lt;文件名长度&gt; 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 cpLinux cp命令主要用于复制文件或目录。 语法cp [options] source dest或 cp [options] source… directory参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。 readLinux read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]参数说明: -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以使用命令补全功能。-n 后跟一个数字，定义输入文本的长度，很实用。-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2Fbook%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本入门算法有三个经典算法:冒泡,选择和插入算法 1.冒泡排序 冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现： 123456789101112# -*- coding:utf-8 -*-def bubble_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(1,length-index): if raw_list[i-1]&gt;raw_list[i]: raw_list[i],raw_list[i-1]=raw_list[i-1],raw_list[i] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = bubble_sort(data_test)print(sorted_list) 2.选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 12345678910111213# -*- coding:utf-8 -*-def select_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(index,length): if raw_list[index]&gt;raw_list[i]: raw_list[index],raw_list[i]=raw_list[i],raw_list[index] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = select_sort(data_test)print(sorted_list) 3.插入排序 每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 代码实现： 1234567891011121314151617# -*- coding:utf-8 -*-def insert_sort(raw_list): length = len(raw_list) for i in range(1, length): temp = raw_list[i] #j从i-1 到 0倒序 for j in range(i-1,-1,-1): if(raw_list[j]&lt;=temp): break if(raw_list[j]&gt;temp): raw_list[j],raw_list[j+1] = temp,raw_list[j] j -= 1 return raw_list#测试data_test = [10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = insert_sort(data_test)print(sorted_list) 4.希尔排序 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 即所有记录放在同一组中进行直接插入排序为止。 123456789101112131415161718# -*- coding:utf-8 -*-def shell_sort(list): length=len(list) dist=length/2 while dist&gt;0: for i in range(dist,length): temp=list[i] j=i while j&gt;=dist and temp&lt;list[j-dist]: list[j]=list[j-dist] j-=dist list[j]=temp dist/=2 return list#测试list=[10,23,1,53,654,54,16,646,65,3155,546,31]print shell_sort(list) 5.归并排序 归并排序，就是把两个已经排列好的序列合并为一个序列。 代码实现： 1234567891011121314151617181920# -*- coding:utf-8 -*-#算法逻辑比较简单，以第一个list为基准，第二个向第一个插空def merge_sort(list1,list2): length_list1=len(list1) length_list2=len(list2) list3=[] j=0 for i in range(length_list1): while list2[j]&lt;list1[i] and j&lt;length_list2: list3.append(list2[j]) j=j+1 list3.append(list1[i]) if j&lt;(length_list2-1): for k in range(j,length_list2): list3.append(list2[k]) return list3#测试list1=[1,3,5,10]list2=[2,4,6,8,9,11,12,13,14]print merge_sort(list1,list2) 6.快速排序 123456789101112131415161718192021222324随意选择一个数字作为基准，比基准数字大的在右，比基准数字小的在左。# -*- coding:utf-8 -*-def kp(arr,i,j):#快排总函数 #制定从哪开始快排 if i&lt;j: base=kpgc(arr,i,j) kp(arr,i,base) kp(arr,base+1,j)def kpgc(arr,i,j):#快排排序过程 base=arr[i] while i&lt;j: while i&lt;j and arr[j]&gt;=base: j-=1 while i&lt;j and arr[j]&lt;base: arr[i]=arr[j] i+=1 arr[j]=arr[i] arr[i]=base return iww=[3,2,4,1,59,23,13,1,3]print wwkp(ww,0,len(ww)-1)print ww 7.堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤： 创建最大堆:将堆所有数据重新排序，使其成为最大堆 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算 代码实现： 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-def head_sort(list): length_list = len(list) first=int(length_list/2-1) for start in range(first,-1,-1): max_heapify(list,start,length_list-1) for end in range(length_list-1,0,-1): list[end],list[0]=list[0],list[end] max_heapify(list,0,end-1) return listdef max_heapify(ary,start,end): root = start while True: child = root*2 + 1 if child &gt; end: break if child + 1 &lt;= end and ary[child]&lt;ary[child+1]: child = child + 1 if ary[root]&lt;ary[child]: ary[root],ary[child]=ary[child],ary[root] root=child else: break#测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print head_sort(list) 8.计数排序 12345678910111213141516171819202122# -*- coding:utf-8 -*-def count_sort(list): max=min=0 for i in list: if i &lt; min: min = i if i &gt; max: max = i count = [0] * (max - min +1) for j in range(max-min+1): count[j]=0 for index in list: count[index-min]+=1 index=0 for a in range(max-min+1): for c in range(count[a]): list[index]=a+min index+=1 return list #测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print count_sort(list)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2Fbook%2F%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[前端风云录 前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 html html(hypertext markup language)超文本标记语言,它不同于编程语言 超文本就是超出纯文本的范畴, 例如描述文本的颜色、大小、字体等信息、 或使用图片音频、 视屏等非文本内容. 12345html定义了网页的内容css描述了网页的布局javascript网页的行为 cs原理client客户端向server发起请求 通过资源定位符, 找到映射文件, server端读取文件后, 一个个字节又通过管道发回到客户端, 客户端收到之后save下来, 打开html 文本流就是字节流(区别是字节流没有编码) . 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Web 2.0Ajax 技术促成了 Web 2.0 的诞生。 Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 12345678var AppView = Backbone.View.extend(&#123; // ... events: &#123; "keypress #new-todo": "createOnEnter", "click #clear-completed": "clearCompleted", "click #toggle-all": "toggleAllComplete" &#125;,&#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123; '': 'index', 'show': 'show' &#125;, index: function () &#123; $(document.body).append("调用了 Index 路由"); &#125;, show: function () &#123; $(document.body).append("调用了 Show 路由"); &#125;,&#125;); 示例：Backbone Router打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。 MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。 传统的架构 单页应用的架构 多了一个前端 MVC 层 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 1234567891011&lt;div ng-app=""&gt; &lt;p&gt; 姓名 : &lt;input type="text" ng-model="name" placeholder="在这里输入您的大名" &gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id="journal"&gt; &lt;input type="text" v-model="message"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端 现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师]]></content>
      <categories>
        <category>前端</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
</search>
