<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[算素数和杨辉三角]]></title>
    <url>%2F10%2F</url>
    <content type="text"><![CDATA[求素数算法剖析 简单解法n = 100for i in range(2,n): for x in range(2 ,int(i**0.5)+1): if i % x == 0: break else: count +=1 print(x) for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码. 使用奇数 n = 100count = 1for x in range(3,n,2): for i in range(3,int(x**0.5)+1,2): if x % i ==0: break else: count += 1print (count) 储存质素 合数一定可以分解为几个质数的乘积,2是质数质数一定不能整除1和本身之内的整数n = 100count = 1prefor x in range(3,n,2): for i in primenumbers: if x % i == 0: break else: premenumber.append(x) count +=1print(count) 杨辉三角预先构成前两行 从而推到后面的所有行triandle = [[1],[1,1]]for i in range(2,6): cur = [1] pre = triandle[i -1] for j in range(i-1): cur.append(pre[j] + pre[j + 1]) cur.append(1) triandle.append(cur)print(triandle) 变形triandle = []n = 6for i in range(n): cur = [1] triandle.append(cur) if i==0:continue pre = triandle[i -1] for j in range(i -1): cur.append(pre[j] + pre[j + 1]) cur.append(1) print(triandle) 补零法n = 6newline = [1]print(newline) for i in range(1,n): oldline = newline.copy() oldline.append(0) newline.clear() for j in range(i+1): newline.append(oldline[j -1] + oldline[j]) print(newline) 对称性一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称. triandle = []n = 6for i in range(n): row = [1] * (i + 1) triandle.append(row) for j in range(1,i//2+1): val = triandle[i-1][j-1] + triandle[i -1][j] row[j] = val row[-j-1] = val print(triandle)triangle = []n = 6for i in range(n): row = [1] (i +1) triangle.append(row) for j in range(i,i//2+1): val = triangle[i-1][j-1] + triangle[i -1][j] row[j] = val if i != 2j: row[-j-i] = valprint(triangle) 单行覆盖法n = 6row = [1] nprint(row)print(‘_’ 30) for i in range(n): for j in range(i//2): val = row[j] + row[j+1] row[j+1]=val if i != 2* (j+1): row[i-(j+1)] =val print(row[:i+1])]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识框架]]></title>
    <url>%2F6%2F</url>
    <content type="text"><![CDATA[python基础python是一种动态的强类型语言,底层是用C语言开发的. 平台：*nix平台系统：线程、进程、Shell编程网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个中间件：消息队列原理和应用，例如8曲bitMQWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一可视化：WEB的前端开发多一些HTML、jS要会数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用 python学习路线:基础：操作系统、网络基础、数据库基础、python语言基础..进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).新前端开发(ES6、React、Antd）…实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..高端：数据清洗、企业数据分析、预测准荐、机器视觉． 数据类型python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none 字符串因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节. 字符串的格式化format函数或 格式符 编码字符串与bytes字符串是字符组成的有序序列，字符可以使用编码来理解bytes是字节组成的有序的不可变序列bytearray是字节组成的有序的可变序列 编码与解码：字符串按照不同的字符集编码encode返回字节序列bytesencode（encoding=‘utf-8’，errors=‘strict’）字节序列按照不同的字符集解码decode返回字符串bytes.decode（encoding=“utf-8”，errors=“strict”）ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统 要熟记31 41 61 的ascii表 字节序：大端模式，big-endian；小端模式，little-endianintel x86cpu使用小端 模式网络传输更多使用大端模式windows，linux 使用小端模式mac os使用大端模式java 虚拟机是大端模式 数字有整数 浮点数 复数等 true false主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。 None：Python里面特殊的空值，不能理解为0。 容器list（列表） tuple（元组） set（集合） dictionary（字典）这些都是可以迭代的 list创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。 tuple元组和列表类似，但是不同的是元组不能修改，元组使用小括号。 dict判断结构ifif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。 elif 语句 elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。 if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。 forfor循环可以遍历任何序列的项目： whilewhile循环，只要条件满足，就不断循环，条件不满足时退出循环： break和continue语句： break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。 continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[99乘法表的不同解法]]></title>
    <url>%2F7%2F</url>
    <content type="text"><![CDATA[第一种方法：用先打印正方形之后打印下三角 for i in range (1,10): line = ‘’ for j in range (1,10): if i &gt;=j: line += str (j) +&apos;*&apos;+str(i) +&apos;=&apos;+ str(i*j) + &apos; &apos; print(line)第二种用format 格式化字符串for i range(1,10): line =’’ for j in range(1,10): line += “{}{}={} “.foramt(j,i,(ji)) print(line)第三种 j的取值范围是（1，i+1）for i in range(1,10): line =’’ for j in range(1,i+1): line += ‘{}{}={} ‘.format(j,i,(ij)) print(line,end=’\n’)range 函数可以控制语句 可以当if变形for i in range(1,10): for j in range(1,i+1): line = ‘{}{}={} ‘.format(j,i,(ij)) print(line, end=’’) print()row 是行 column 是列for i in range(1,10): for j in range(1,i+1): line = ‘{}{}={} ‘.format(j,i,(ij)) print(line, end=’’) if i==j: print()再变形for i in range(1,10): for j in range(1,i+1): if i==j: endchar = ‘\n’ else: endchar = ‘’ line = &apos;{}*{}={} &apos;.format(j,i,(i*j) ,end = endchar) print(line, end=&apos;&apos;) 三元表达式 写法endchar = ‘\n’ if i==j else ‘’三行 代码写出程序for i in range (1,10): for j in range(1,i+1): print(“{}{}={} “.format(j,i,ij) ,end = ‘\n’ if i ==j else ‘’)用列表方式来写 ,最后再解构for i in range(1,10): line = [] for j in range(1,i+1): line.append(“{}{}={} “.format(j,i,ij)) print(line,sep=’ ‘)tip：再括号内换行不用换行符for i in range(1,10): for j in range(1,i+1): print(“{}{}={}{}”.format(j,i,ji, ‘’ if j==2 and i&lt;5 else ‘’), end= ‘\n’ if i==j else ‘ ‘)用格式符对齐方式 写for i in range(1,10): for j in range(1,i+1): print(“{}{}={:&lt;2}”.format(j,i,i*j), end=’\n’ if i == j else ‘\t’)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识框架]]></title>
    <url>%2F1%2F</url>
    <content type="text"><![CDATA[介绍操作系统os(operating system),通用目的的软件程序 硬件驱动进程管理内存管理网络管理安全管理文件管理 安装linux linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的manjaro或mint分区和启动:硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tbuefi的GPT分区:逐渐代替MBR标准主分区 一块硬盘最多4个,不能划分更小,最小单位扩展分区:一块硬盘最多一个,不能直接创建文件系统安装过程大同小异 详细步骤需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌./dev/sda 100g/dev/sda1 /boot mountpoint 1g/dev/sda2 / 50g/dev/sda3 /data 20g/dev/sda5 /swap 2g 开发接口标准 ABI:application binary interface ABI描述了程序与os之间的底层接口API:application programming interface开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit 用户和内核空间 username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响内核空间:kernel space linux哲学思想在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的 文件操作文件和目录被组织成单根倒置树结构文件系统从根目录下开始,用”/“表示proc虚拟的,在硬盘上不存在文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)以.开头的文件为隐藏文件元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.数据:data(内容在硬盘上)文件系统分成结构:LSB文件名最长255个字节,文件系统不一样大小不一样包括路径在内文件名称最长4095个字节蓝色—目录 绿色—可执行文件 红色—压缩文件浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递管道文件 p开头(pipe)单工传输 文件系统结构元素/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64：专用于x86_64系统上的辅助共享库文件存放位置/etc：配置文件目录/home/USERNAME：普通用户家目录/root：管理员的家目录/media：便携式移动设备挂载点/mnt：临时文件系统挂载点/dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问/opt：第三方应用程序的安装位置/srv：系统上运行的服务用到的数据/tmp：临时文件存储位置/proc: 用于输出内核与进程信息相关的虚拟文件系统/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文/usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序sbin: lib：32位使用 lib64：只存在64位系统include: C程序的头文件(header files)share：结构化独立的数据，例如doc, man等local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文 /var: variable data files cache: 应用程序缓存数据目录lib: 应用程序状态信息数据local：专用于为/usr/local下的应用程序存储可变数据lock: 锁文件 log: 日志目录及文件opt: 专用于为/opt下的应用程序存储可变数据run: 运行中的进程相关数据,通常用于存储进程pid文件spool: 应用程序数据池tmp: 保存系统两次重启之间产生的临时数据 Linux下的文件类型-：普通文件d: 目录文件b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)c: 字符设备(设备主要以字符为单位,键盘为主)l: 符号链接文件p: 管道文件pipes: 套接字文件socket 显示当前工作目录每个shell和系统进程都有一个当前的工作目录CWD:current work directory显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 更改目录cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -选项：-P相关的环境变量： PWD：当前目录路径 OLDPWD：上一次目录路径 列出目录内容列出当前目录的内容或指定目录用法：ls [options] [ files_or_dirs ]示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R 目录递归通过 ls -ld 目录和符号链接信息 ls -1 文件分行显示 ls –S 按从大到小排序 ls –t 按mtime排序 ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示 ls –X 按文件后缀排序 [root@centos7 sysconfig]# ll /etc/motd-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd[root@centos7 sysconfig]# ll ../motd-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd-a 全部-r 递归ll 是别名 (ls -l) 查看文件状态stat文件：metadata, data三个时间戳: access time：访问时间，atime，读取文件内容modify time: 修改时间,mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变data 时间不会一直更新通配符* 任意字符二进制查看hexdump -C 创建和查看文件touch 命令是个外部命令[]表示其中一个字母[^ ]表示除去其中字符的任意字符两个大于号比 touch安全 文件统配符man 7 glob 复制和转移删除文件cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失原始命令前加\拷贝文件夹 -r(递归)cp 有可能丢失数据不能用rmdir删除 data是个挂载点cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中 基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中cp SRC… DEST SRC…：多个文件DEST必须存在，且为目录，其它情形均会出错；cp SRC DESTSRC是目录：此时使用选项：-r如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；如果DEST存在：如果DEST是文件：报错如果DEST是目录：inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 inode 唯一标识在元数据里删除其实删的元数据.删文件比建文件快多了 软和硬链接硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区语法: ln filename [linkname ]软连接一个符号文件链接指向一个文件ls -s显示链接的名称和应用的文件一个符号链接的内容是他引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数语法:ln -s 文件 链接名 i/0 重定向至文件程序:指令+数据input 和output打开的文件都有一个fd:file descrptor(文件描述符)linux 给程序提供三种i/o设备标准输入(STDIN)-0 默认接受来自键盘的输入标准输出(STDOUT) -1默认输出到终端窗口标准错误(STDERR) -2 默认输出到窗口i/o重定向:改变默认位置语法:命令 操作符号 文件名操作符&gt;把STDOUT重定向到文件2&gt; 把STDERR重定向到文件$&gt; 把所有输出重定向到文件tr 转换和删除字符 管道管道用来连接命令命令1|命令2|命令3将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDINless 一页一页地查看输入重定向到多个目标(tee)把命令1的STDOUT保存在文件中,作为命令2的输入-a追加使用:保存不同阶段的输入复杂管道的故障排除同时查看和记录输出 用户组权限用户user令牌token,identitylinux用户:username/UID管理员:root,0普通用户:1-65535系统用户:1-499,1-999对守护进程获取资源进行权限进行分配登录用户:500+,1000交互式登录nologin 是软件启动没有用户登录 组grouplinux:Groupname/GID管理员:系统 :1-499,1-999普通组:500+,1000+安全上下文:进行中的程序:程序(process)以进程发起者的身份运行:root:/bin/catmage:/bin/cat组的类别用户的主要组:用户必须属于一个且只有一个主组组名同用户名,且包含一个用户,私有组用户和组的配置文件/etc/passwd:用户及其属性信息/etc/group:组及其属性信息/etc/shadow:用户密码及其相关属性/etc/gshadow:组密码及其相关属性passwd文件格式login name:登录用名passwd:密码UID:用户身份编号GID:登录默认所在组编号GECOS:用户全名或注释home diretory:用户主目录shell:用户默认使用shellshadow文件格式useradd usermod userdel组账号维护命令:groupaddgroupmod groupdel 用户创建:useradduseradd [options]LOGIN-u UID-o 配合-u选项,不检查UID的唯一性-g GID:指明用户所属基本组,可谓组名,也可以GID-c “COMMENT”:用户的注释信息默认设置:/etc/default/useradd文件中删除用户:userdel -r删除用户目录 查看用户相关的ID信息id [OPTIONS]…[USER]-u :显示UID-g :显示GID-G :显示用户所属的组的ID-n :显示名称,需配合ugG使用 切换用户或以其他用户身份执行命令su[options] [-] [user[args…]]切换用户的方式ssh root@ipcurl wwservice network restat 设置密码passwd常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 创建组groupadd[option]…group_name-g GID:指明GID号:-r:创建系统组修改和删除组:组属性修改:groupmod组删除:groupdel组密码:gpasswdnewgrp命令:临时切换主组chown设置文件的所有者chgrp设置文件的属组信息修改文件的属主和属组chown修改文件的属组:chgrp 文件权限文件的权限主要针对三类对象进行定义owner: 属主, ugroup: 属组, gother: 其他, o每个文件针对每类访问者都定义了三种权限r: Readablew: Writablex: eXcutable 修改文件权限chmod [OPTION]… OCTAL-MODE FILE… -R: 递归修改权限chmod [OPTION]… MODE[,MODE]… FILE… MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]… –reference=RFILE FILE…参考RFILE文件的权限，将FILE的修改为同RFILE数字权限法:chmod数字 filerwx r-x r– file其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 文本工具基础文件内容:less和cat文件截取:head和tail按列抽取:cut按关键字抽取:grep文件查看:cat tac rev分页查看:more一页一页的查看:lessless 命令是man命令使用的分页器 显示文本前后或后行内容head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行tail[option]…[FILE]看文本尾tail-f 跟踪看日志cut命令取字段past 横着合并文件wc 收集文本 文本排序sort把整理过的文本显示在STDOUT,不改变原始文件sort[opiton]file(s)uniq:从输入中删除前后相接的重复的行,处理日志liunx:文本处理三剑客grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红sed:stream editor, 文本编辑工具awk:liunx上的实现gawk,文本报告生成器grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行 正则表达式匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数位置锚定:定位正则字符特殊 元字符.单个任意字符[abc]表示其中一个字符[^abc]除去abc任意字母[:lower:]小写[:upper:]大写分组方式abc{3}\搜索替代工具grep过滤特定行,sed也可以并且编辑修改文件 vim编辑器vi:visual interface 文本编辑器文本:asscii ,unicode文本编辑种类:行编辑器:sed全屏编辑器:nano,vivim -viimproved其他编辑器gedit 一个简单的图形编辑器gvim 一个vim编辑器的图形版本vi一开始是vim的别名vim有三种模式:normal(普通) insert(插入) extendcommand(命令)normal :默认模式,移动光标,剪切/粘贴文本insert :修改文本extend command:保存,退出 搜索替代/ :从当前光标所在处向文件尾部查找? :从当前光标所在处向文件首部查找n :与命令同方向N :与命令反方向处理文本的工具sedstream editor 行编辑器sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.vim不适合修改大批量文件,sed可以sed 配合管道可以使用awk 语言sed ‘’ passwd‘地址命令’地址不写代表全部文件 命令不写代表输出 软件管理包管理器rpm 打包文件 不需要考虑部署 安装路径都定义好二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件程序包管理器：debian：deb文件, dpkg包管理器redhat: rpm文件, rpm包管理器rpm: Redhat Package Manager RPM Package Manager源代码：name-VERSION.tar.gz|bz2|xz VERSION: major.minor.releaserpm包命名方式:name-VERSION-release.arch.rpm例：bash-4.2.46-19.el7.x86_64.rpm VERSION: major.minor.release release：release.OS常见的arch： x86: i386, i486, i586, i686 x86_64: x64, x86_64, amd64 powerpc: ppc 跟平台无关：noarch 包：分类和拆包Application-VERSION-ARCH.rpm: 主包Application-devel-VERSION-ARCH.rpm 开发子包 Application-utils-VERSION-ARHC.rpm 其它子包 Application-libs-VERSION-ARHC.rpm 其它子包包之间：可能存在依赖关系，甚至循环依赖解决依赖包管理工具:yum：rpm包管理器的前端工具 apt-get：deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具 查看二进制程序所依赖的库文件 ldd /PATH/TO/BINARY_FILE管理及查看本机装载的库文件 ldconfig 加载库文件 /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf 缓存文件：/etc/ld.so.cache 程序包管理器功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.包文件组成 (每个包独有)RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.安装或卸载时运行的脚本数据库(公共)：/var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息管理程序包的方式:使用包管理器：rpm 使用前端工具：yum, dnf获取程序包的途径：(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com(2) 项目官方站点程序包的来源(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/(4) 自己制作 注意：第三方包建议要检查其合法性 来源合法性,程序包的完整性 rpm包管理CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护 安装：rpm {-i|–install} [install-options] PACKAGE_FILE… -v: verbose -h: 以#显示程序包管理执行进度 rpm -ivh PACKAGE_FILE … rpm包安装[install-options]–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs | replacefiles–nosignature: 不检查来源合法性–nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre: 安装前脚本；–nopre %post: 安装后脚本；–nopost %preun: 卸载前脚本；–nopreun %postun: 卸载后脚本； –nopostun rpm包升级升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…rpm {-F|–freshen} [install-options] PACKAGE_FILE…upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装”freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE … rpm -Fvh PACKAGE_FILE …–oldpackage：降级–force: 强制安装 升级注意项注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留 包查询rpm {-q|–query} [select-options] [query-options] [select-options]-a: 所有包-f: 查看指定的文件由哪个程序包安装生成-p rpmfile：针对尚未安装的程序包文件做查询操作–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 常用查询用法： -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, … -qa包卸载： rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME … 包校验rpm {-V|–verify} [select-options] [verify-options] S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ包校验包来源合法性验正及完整性验正完整性验正：SHA256来源合法性验正：RSA 公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人 rpm数据库数据库重建： /var/lib/rpm rpm {–initdb|–rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之 否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 yumCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下） 文件服务器: http:// https:// ftp:// file:// yum配置文件yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义： [repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000 yum仓库yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号 $arch: 平台，i386,i486,i586,x86_64等 $basearch：基础平台；i386, x86_64 $YUM0-$YUM9:自定义变量 实例: http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64 http://server/centos/6/i384yum源阿里云repo文件:http://mirrors.aliyun.com/repo/CentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/EPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 yum命令yum命令的用法： yum [options] [command] [package …]显示仓库列表： yum repolist [all|enabled|disabled]显示程序包： yum list yum list [all | glob_exp1] [glob_exp2] […] yum list {available|installed|updates} [glob_exp1] […] 安装程序包： yum install package1 [package2] […] yum reinstall package1 [package2] […] (重新安装)yum命令升级程序包： yum update [package1] [package2] […] yum downgrade package1 [package2] […] (降级)检查可用升级： yum check-update卸载程序包： yum remove | erase package1 [package2] […]yum命令查看程序包information： yum info […]查看指定的特性(可以是某文件)是由哪个程序包所提供： yum provides | whatprovides feature1 [feature2] […]清理本地缓存： 清除/var/cache/yum/$basearch/$releasever缓存 yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]构建缓存： yum makecacheyum命令搜索：yum search string1 [string2] […] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilities： yum deplist package1 [package2] […]查看yum事务历史： yum history [info|list|packages-list|packages-info| summary|addon-info|redo|undo| rollback|new|sync|stats] yum history yum history info 6 yum history undo 6日志 ：/var/log/yum.log安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] …yum localupdate rpmfile1 [rpmfile2] […] (用update替代)包组管理的相关命令： yum groupinstall group1 [group2] […] groupupdate group1 [group2] […] yum grouplist [hidden] [groupwildcard] […] yum groupremove group1 [group2] […] yum groupinfo group1 […]yum命令yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件系统光盘yum仓库系统安装光盘作为本地yum仓库：(1) 挂载光盘至某目录，例如/mnt/cdrom mount /dev/cdrom /mnt/cdrom(2) 创建配置文件 [CentOS7] name= baseurl= gpgcheck= enabled= 创建yum仓库： createrepo [options] 程序包编译程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 C、C++：make 项目管理器 configure脚本 –&gt; Makefile.in –&gt; Makefile java: maven C语言源代码编译安装三步骤:1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make 根据Makefile文件，构建应用程序3、make install 复制文件到相应路径开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in注意：安装前查看INSTALL，README 开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software Foundation) mariadb.org 代码托管:SourceForge.net Github.com code.google.comc/c++编译器: gcc (GNU C Complier) 编译C源代码： 准备：提供开发工具及开发环境 开发工具：make, gcc等 开发环境：开发库，头文件 glibc：标准库 实现：通过“包组”提供开发组件 Development Tools Server Platform Development 第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项 选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译 Optional Features: 可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包 –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION 第二步：make 第三步：make install 安装后的配置：(1) 二进制程序目录导入至PATH环境变量中 编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH(2) 导入帮助手册 编辑/etc/man.config|man_db.conf文件 添加一个MANPATH shell编程基础程序：指令+数据程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 shell程序：提供了编程能力，解释执行 编程基本概念编程逻辑处理方式：顺序执行循环执行选择执行 shell编程：过程式、解释执行编程语言的基本结构：各种系统命令的组合数据存储：变量、数组表达式: a + b语句:ifshell脚本基础shell脚本:包含一些命令或声明，并符合一定格式的文本文件格式要求:首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perlshell脚本的用途有：自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 添加注释注释以#开头第二步：运行脚本给予执行权限，在命令行上指定脚本的绝对或相对路径直接运行解释器，将脚本作为解释器程序的参数运行 脚本规范脚本代码开头约定1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 脚本调试检测脚本中的语法错误bash -n /path/to/some_script调试执行bash -x /path/to/some_script 变量变量：命名的内存空间数据存储方式：字符：数值：整型，浮点型变量：变量类型作用：1、数据存储格式2、参与的运算3、表示的数据范围类型：字符数值：整型、浮点型变量命名法则：1、不能使程序中的保留字：例如 if, for2、只能使用数字、字母及下划线，且不能以数字开头3、见名知义4、统一命名规则：驼峰命名法，建议大写 bash中变量的种类根据变量的生效范围等标准划分下面变量类型：局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程， 包括当前shell的子shell进程均无效环境（全局）变量：生效范围为当前shell进程及其子进程 本地变量：生效范围为当前shell进程中某代码片断，通常指函数 位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传 递给它的参数特殊变量：$?, $0, $*, $@, $#,$$ 局部变量变量赋值：name=‘value’可以使用引用value:(1) 可以是直接字串; name=“root”(2) 变量引用：name=”$USER”(3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name“”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set删除变量：unset name 环境变量bash内建的环境变量：PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE— 只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量： readonly name declare -r name查看只读变量： readonly –p位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置$0: 命令本身$: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/nullecho $?退出状态码bash自定义退出状态码exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 运算bash中的算术运算:help let+, -, , /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如bash有内建的随机数生成器：RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数赋值 增强型赋值：+=, -=, *=, /=, %=let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1 let var++ let var-=1 let var-- 逻辑运算true, false1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! 0 = 1 短路运算 短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算 短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算 异或：^异或的两个值,相同为假，不同为真 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1 测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符bash的数值测试-v VAR变量VAR是否设置 数值测试：-gt 是否大于-ge 是否大于等于-eq 是否等于-ne 是否不等于-lt 是否小于-le 是否小于等于bash的字符串测试 字符串测试: == 是否等于ascii码是否大于ascii码&lt; 是否小于!= 是否不等于=~ 左侧字符串是否能够被右侧的PATTERN所匹配注意: 此表达式一般用于[[ ]]中；扩展的正则表达式-z “STRING“ 字符串是否为空，空为真，不空为假-n “STRING“ 字符串是否不空，不空为真，空为假注意：用于字符串比较时的用到的操作数都应该使用引号Bash的文件测试 存在性测试 -a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件Bash的文件权限测试 文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限Bash的文件属性测试 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组Bash的文件属性测试 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 使用read命令来接受输入使用read来把输入值分配给一个或多个shell变量-p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE 流程控制过程式编程语言： 顺序执行 选择执行 循环执行条件选择if语句 选择执行: 注意：if语句可嵌套单分支 if 判断条件;then 条件为真的分支代码 fi双分支 if 判断条件; then 条件为真的分支代码 else条件为假的分支代码fi 多分支 if 判断条件1; then 条件为真的分支代码 elif 判断条件2; then 条件为真的分支代码 elif 判断条件3; then 条件为真的分支代码 else 以上条件都为假的分支代码 fi 逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断：case语句 case 变量引用 in PAT1) 分支1 ;; PAT2) 分支2 ;; ... *) 默认分支 ;; esac case支持glob风格的通配符： *: 任意长度任意字符 ?: 任意单个字符 []：指定范围内的任意单个字符 a|b: a或b 循环 循环执行将某代码段重复运行多次重复运行多少次：循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, untilfor循环for 变量名 in 列表;do循环体done执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 for循环列表生成方式：(1) 直接给出列表(2) 整数列表：(a) {start..end}(b) $(seq [start [step]] end)(3) 返回列表的命令$(COMMAND)(4) 使用glob，如：.sh(5) 变量引用；$@, $while循环while CONDITION; do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为falseuntil循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true循环控制语句continue用于循环体中ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thencontinuefiCMDn…done循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thenbreakfiCMDn…done特殊用法双小括号方法，即((…))格式，也可以用于算术运算双小括号方法也可以使bash Shell实现C语言风格的变量操作I=10((I++))for循环的特殊格式：for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))do 循环体done控制变量初始化：仅在运行到循环代码段时执行一次控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于：Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改定义函数函数由两部分组成：函数名和函数体help function语法一：f_name （）{…函数体…} 语法二：function f_name {…函数体…} 语法三：function f_name （） {…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止函数返回值函数有两种返回值：函数的执行结果返回值：(1) 使用echo等命令进行输出(2) 函数体中调用命令的输出结果函数的退出状态码：(1) 默认取决于函数中执行的最后一条命令的退出状态码(2) 自定义退出状态码，其格式为：return 从函数中返回，用最后状态命令决定返回值return 0 无错误返回。return 1-255 有错误返回交互式环境下定义和使用函数 示例:dir() {ls -l}定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir在脚本中定义及使用函数函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用调用函数仅使用其函数名即可示例：cat func1!/bin/bashfunc1hello(){echo “Hello there today’s date is date +%F“}echo “now going to the function hello”helloecho “back from the function”使用函数文件可以将经常使用的函数存入函数文件，然后将函数文件载入shell文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例： cat functions.main #!/bin/bash #functions.mainfindit(){if [ $# -lt 1 ] ; thenecho “Usage:findit file”return 1fifind / -name $1 –print} 载入函数函数文件已创建好后，要将它载入shell定位函数文件并载入shell的格式：. filename 或 source filename注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径 检查载入函数使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 示例：setfindit=( ){if [ $# -lt 1 ]; thenecho “usage :findit file”;return 1fifind / -name $1 -print} 执行shell函数要执行函数，简单地键入函数名即可示例：findit groups/usr/bin/groups/usr/local/backups/groups.bak 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量在函数中定义局部变量的方法local NAME=VALUE函数递归示例 函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)!函数递归示例: 示例：fact.sh fact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi } fact $1 fork炸弹 fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现:(){ :|:&amp; };:bomb() { bomb | bomb &amp; }; bomb 实际上: 代表bomb脚本实现 cat Bomb.sh./$0|./$0&amp;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构和算法]]></title>
    <url>%2F4%2F</url>
    <content type="text"></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构和算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(2)]]></title>
    <url>%2F8%2F</url>
    <content type="text"><![CDATA[文档编辑grepLinux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。 语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]参数： -a 或 –text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 –count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 –fixed-regexp : 将样式视为固定字符串的列表。-G 或 –basic-regexp : 将样式视为普通的表示法来使用。-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 –ignore-case : 忽略字符大小写的差别。-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 –only-matching : 只显示匹配PATTERN 部分。-q 或 –quiet或–silent : 不显示任何信息。-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。-s 或 –no-messages : 不显示错误信息。-v 或 –revert-match : 显示不包含匹配文本的所有行。-V 或 –version : 显示版本信息。-w 或 –word-regexp : 只显示全字符合的列。-x –line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定”-i”参数相同。 sortLinux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 语法sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]参数说明： -b 忽略每行前面开始出的空格字符。-c 检查文件是否已经按照顺序排序。-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-f 排序时，将小写字母视为大写字母。-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。-m 将几个排序好的文件进行合并。-M 将前面3个字母依照月份的缩写进行排序。-n 依照数值的大小排序。-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r 以相反的顺序来排序。-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。–help 显示帮助。–version 显示版本信息。 trLinux tr 命令用于转换或删除文件中的字符。 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 语法tr [-cdst][–help][–version][第一字符集][第二字符集]tr [OPTION]…SET1[SET2]参数说明： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息字符集合的范围： \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。[CHAR] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止[CHARREPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)[:alnum:] ：所有字母字符与数字[:alpha:] ：所有字母字符[:blank:] ：所有水平空格[:cntrl:] ：所有控制字符[:digit:] ：所有数字[:graph:] ：所有可打印的字符(不包含空格符)[:lower:] ：所有小写字母[:print:] ：所有可打印的字符(包含空格符)[:punct:] ：所有标点字符[:space:] ：所有水平与垂直空格符[:upper:] ：所有大写字母[:xdigit:] ：所有 16 进位制的数字[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符) uniqLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 语法uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]参数： -c或–count 在每列旁边显示该行重复出现的次数。-d或–repeated 仅显示重复出现的行列。-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。-u或–unique 仅显示出一次的行列。-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。–help 显示帮助。–version 显示版本信息。[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 wcLinux wc命令用于计算字数。 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…]参数： -c或–bytes或–chars 只显示Bytes数。-l或–lines 只显示行数。-w或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 letlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 语法格式let arg [arg …]参数说明：arg：要执行的表达式 sedLinux sed命令是利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法sed [-hnV][-e][-f&lt;script文件&gt;][文本文件]参数说明： -e或–expression= 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或–help 显示帮助。-n或–quiet或–silent 仅显示script处理后的结果。-V或–version 显示版本信息。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(1)]]></title>
    <url>%2F3%2F</url>
    <content type="text"><![CDATA[1 文档管理cat chgrp chmod chown file find cut in less more mv tee touch which cp read2 文档编辑:grep sed tr sort uniq wc let3 磁盘管理:cd df du mkdir pwd mount stat tree ls4 网络通讯:telnet httpd ifconfig netatat ping tty write5 系统管理:useradd data adduser exit kill ps pstree top reboot sudo uname who whoami whois w id free6 系统设置:reset clear alias enable rpm set passwd time setup7 备份压缩:zip tar8 其他命令: bc tail 文档命令cat全称: concatenate files and print on the standard outputcat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0注： OUTFILE 指输出的镜像文件名. IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用制作开机磁片 chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法:chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法chmod [-cfvR] [–help] [–version] mode file…参数说明mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本实例将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r *此外chmod也可以用数字来表示权限如 : chmod 777 file语法为： chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。chmod a=rwx file和 chmod 777 file效果相同 chmod ug=rwx,o=x file和 chmod 771 file效果相同 若用chmod 4755 filename可使此程序具有root的权限 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。使用权限 : root语法chown [-cfhvR] [–help] [–version] user[:group] file…参数 :user : 新的文件拥有者的使用者 IDgroup : 新的文件拥有者的使用者组(group)-c : 显示更改的部分的信息-f : 忽略错误信息-h :修复符号链接-v : 显示详细的处理信息-R : 处理指定目录以及其子目录下的所有文件–help : 显示辅助说明–version : 显示版本 fileLinux file命令用于辨识文件类型。 通过file指令，我们得以辨识该文件的类型。 语法file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]参数： -b 列出辨识结果时，不显示文件名称。-c 详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 指定魔法数字文件。-v 显示版本信息。-z 尝试去解读压缩文件的内容。[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 findLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法find path -option [ -print ] [ -exec -ok command ] {} \;参数说明 : find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 你可以使用 ( ) 将运算式分隔，并使用下列运算。 exp1 -and exp2 ! expr -not expr exp1 -or exp2 exp1, exp2 cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 语法cut [-bn] [file]cut [-c] [file]cut [-df] [file]使用说明: cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 参数: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符。-f ：与-d一起使用，指定显示哪个区域。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 lnLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 语法 ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] [–help] [–version] [–] 命令功能 :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数必要参数： -b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数： -S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”–help 显示帮助信息–version 显示版本信息 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 语法less [参数] 文件参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 moreLinux more命令Linux 命令大全 Linux 命令大全 Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 语法more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料-s 当遇到有连续两行以上的空白行，就代换为一行的空白行-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示+num 从第 num 行开始显示fileNames 欲显示内容的文档，可为复数个数 mvLinux mv命令Linux 命令大全 Linux 命令大全 Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 语法mv [options] source destmv [options] source… directory参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果 mv 文件名 文件名 将源文件名改为目标文件名mv 文件名 目录名 将文件移动到目标目录mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名mv 目录名 文件名 出错 rmrm命令用于删除一个文件或者目录。 语法rm [options] name…参数： -i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 teeLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。 tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 语法tee [-ai][–help][–version][文件…]参数： -a或–append 附加到既有文件的后面，而非覆盖它．-i或–ignore-interrupts 忽略中断信号。–help 在线帮助。–version 显示版本信息。 touchLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录。 语法touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]参数说明：a 改变档案的读取时间记录。m 改变档案的修改时间记录。c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。f 不使用，是为了与其他 unix 系统的相容性而保留。r 使用参考档的时间记录，与 –file 的效果一样。d 设定时间与日期，可以使用各种不同的格式。t 设定档案的时间记录，格式与 date 指令相同。–no-create 不会建立新档案。–help 列出指令格式。–version 列出版本讯息。 whichLinux which命令用于查找文件。 which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法which [文件…]参数： -n&lt;文件名长度&gt; 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p&lt;文件名长度&gt; 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 cpLinux cp命令主要用于复制文件或目录。 语法cp [options] source dest或 cp [options] source… directory参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。 readLinux read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]参数说明: -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以使用命令补全功能。-n 后跟一个数字，定义输入文本的长度，很实用。-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(3)]]></title>
    <url>%2F9%2F</url>
    <content type="text"><![CDATA[磁盘管理cdLinux cd命令用于切换当前工作目录至 dirName(目录参数)。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。 另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。 语法cd [dirName]dirName：要切换的目标目录。 dfLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 语法df [选项]… [FILE]…文件-a, –all 包含所有的具有 0 Blocks 的文件系统文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, –inodes 列出 inode 资讯，不列出已使用 block文件-k, –kilobytes 就像是 –block-size=1024文件-l, –local 限制列出的文件结构文件-m, –megabytes 就像 –block-size=1048576文件–no-sync 取得资讯前不 sync (预设值)文件-P, –portability 使用 POSIX 输出格式文件–sync 在取得资讯前 sync文件-t, –type=TYPE 限制列出文件系统的 TYPE文件-T, –print-type 显示文件系统的形式文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件–help 显示这个帮手并且离开文件–version 输出版本资讯并且离开 duLinux du命令用于显示目录或文件的大小。 du会显示指定的目录或文件所占用的磁盘空间。 语法du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]参数说明： -a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或–dereference-args 显示指定符号连接的源文件大小。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或–kilobytes 以1024 bytes为单位。-l或–count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或–megabytes 以1MB为单位。-s或–summarize 仅显示总计。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。–help 显示帮助。–version 显示版本信息。 mkdirLinux mkdir命令用于建立名称为 dirName 之子目录。 语法mkdir [-p] dirName参数说明： -p 确保目录名称存在，不存在的就建一个。 pwdLinux pwd命令用于显示工作目录。 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。 语法pwd [–help][–version]参数说明: –help 在线帮助。–version 显示版本信息。 mountLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 语法mount [-hV]mount -a [-fFnrsvw] [-t vfstype]mount [-fnrsvw] [-o options [,…]] device | dirmount [-fnrsvw] [-t vfstype] [-o options] device dir参数说明： -V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 lsLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法 ls [-alrtAFR] [name…]参数 : -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出 系统管理useraddLinux useradd命令用于建立用户帐号。 useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 语法useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ]参数说明： -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。-d&lt;登入目录&gt; 指定用户登入时的启始目录。-D 变更预设值．-e&lt;有效期限&gt; 指定帐号的有效期限。-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。-g&lt;群组&gt; 指定用户所属的群组。-G&lt;群组&gt; 指定用户所属的附加群组。-m 自动建立用户的登入目录。-M 不要自动建立用户的登入目录。-n 取消建立以用户名称为名的群组．-r 建立系统帐号。-s 指定用户登入后所使用的shell。-u 指定用户ID dataLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 时间方面： % : 印出 %%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面： %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。 使用权限：所有使用者。 当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。 当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。 语法date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]参数说明： -d datestr : 显示 datestr 中所设定的时间 (非系统时间)–help : 显示辅助讯息-s datestr : 将系统时间设为 datestr 中所设定的时间-u : 显示目前的格林威治时间–version : 显示版本编号 psLinux ps命令用于显示当前进程 (process) 的状态。 语法ps [options] [–help]参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义-A 列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程au(x) 输出格式 :USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDUSER: 行程拥有者PID: pid%CPU: 占用的 CPU 使用率%MEM: 占用的记忆体使用率VSZ: 占用的虚拟记忆体大小RSS: 占用的记忆体大小TTY: 终端的次要装置号码 (minor device number of tty)STAT: 该行程的状态:D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的行程N: 低优先序的行程L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)START: 行程开始时间TIME: 执行的时间COMMAND:所执行的指令 topLinux top命令用于实时显示 process 的动态。 使用权限：所有使用者。 语法top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]参数说明： d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 sq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来s : 安全模式，将交谈式指令取消, 避免潜在的危机i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程n : 更新的次数，完成后将会退出 topb : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 pstreeLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。 使用权限：所有使用者。 语法pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]或 pstree -V参数说明： -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） rebootLinux reboot命令用于用来重新启动计算机。 若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代 语法reboot [-n] [-w] [-d] [-f] [-i]参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 screenLinux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。 语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明： -A 将所有的视窗都调整为目前终端机的大小。-d&lt;作业名称&gt; 将指定的screen作业离线。-h&lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r&lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S&lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 shutdownLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 使用权限：系统管理者。 语法shutdown [-t seconds] [-rkhncfF] time [message]参数说明： -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。 swatchLinux swatch命令用于系统监控程序。 swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。 语法swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]参数说明： -A&lt;分隔字符&gt; 预设配置文件中，动作的分隔字符，预设为逗号。-c&lt;设置文件&gt; 指定配置文件，而不使用预设的配置文件。-f&lt;记录文件&gt; 检查指定的记录文件，检查完毕后不会继续监控该记录文件。-I&lt;分隔字符&gt; 指定输入记录的分隔字符，预设为换行字符。-P&lt;分隔字符&gt; 指定配置文件中，事件的分隔字符，预设为逗号。-r&lt;时间&gt; 在指定的时间重新启动。-t&lt;记录文件&gt; 检查指定的记录文件，并且会监控加入记录文件中的后继记录。 idLinux id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 语法id [-gGnru][–help][–version][用户名称]参数说明： -g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法free [-bkmotV][-s &lt;间隔秒数&gt;]参数说明： -b 以Byte为单位显示内存使用情况。-k 以KB为单位显示内存使用情况。-m 以MB为单位显示内存使用情况。-o 不显示缓冲区调节列。-s&lt;间隔秒数&gt; 持续观察内存使用状况。-t 显示内存总和列。-V 显示版本信息。 系统设置setupLinux setup命令设置公用程序，是一个启动图形设置系统的命令。 setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。 语法setupsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项： １.登陆认证方式２.键盘组态设置３.鼠标组态设置４.开机时所要启动的系统服务５.声卡组态设置６.时区设置７.X Windows组态设置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F5%2F</url>
    <content type="text"><![CDATA[在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当 你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它并不真正构造列表。我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代器。list() 函数是另外一个（ 迭代器 ），它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，它能够用来遍历标准模板库容器中的部分或全部元素，每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。 整理:3.29 回顾: 整型分长短,但在python3中已经没有了bool 是整型的子类math.sqrt 看帮助 官方文档bin() 返回的字符串type isinstancelist 是可迭代对象index 匹配 count 匹配的次数extend 魔术方法“{},{}”.format(1.2) 随机数instantiate 实例fields领域random模块import randomrandom.randint(1.2)random.choice随机取数字 不均匀for i in range(10):sample 取样元组: 不可变命令元组namedtuple attribute属性特性例子:Point = namedtuple(‘Point’,[‘x’,’y’])p = Point(11,y=22)namespaceexec 当python语句执行命名元组,返回一个元组的子类,并定义了字段冒泡法 重点map高阶函数 映射aplit 默认使用空白字符分隔maxsplitreplacestrip 默认去掉字符两端的空白字符find 时间复杂度和index一样遍历format 函数格式字符串语法“{}”.format()参数解构“{}”.format(3**0.5)序列都可以用in内置函数 514 itertor迭代器 冒泡法:经典排序算法 for i in range(n): for j in range(n-i): num[j],num[j+1] = num[j+1],num[j]print()内置函数说明len(s)返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）zip()创建一个聚合来自每个可迭代对象中元素的迭代器返回一个元组的迭代器,其中我们已经知道,可以直接作用于for循环的数据类型有以下几种:一类是集合数据类型,如list tuple dictionary set str一类是generator ,包括生成器和带yield的generator function这些可以直接作用于for循环的对象统称为可迭代对象:iterable而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值. pythonnicPython的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如: 不够Pythonicif a &lt; b and a &gt; c: pass python里却可以这么写if c &lt; a &lt; b: pass badi = 0while i &lt; mylist_length: do_something(mylist[i]) i += 1 goodfor element in mylist: do_something(element) bad, 不要使用默认可变对象作为默认参数def f(a, b=[]) pass good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题def f(a, b=None): if b is None: b = []Python有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。 列表生成式:list comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环： L = []for x in range(1, 11):… L.append(x * x)…L[1, 4, 9, 16, 25, 36, 49, 64, 81, 100] c 程序主要包括以下部分预处理指令函数变量语句注释 include &lt;stdio.h&gt;int main(){ print(“hello world”); return 0;} python 中的对象对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.Python对象的多态性 面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？ 在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject 变量来保存和维护这个对象，而是通过PyObject ，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。]]></content>
  </entry>
  <entry>
    <title><![CDATA[python入门笔记]]></title>
    <url>%2F2%2F</url>
    <content type="text"><![CDATA[计算机基础程序是一组让计算机识别和执行的指令电子计算机:能够执行程序的机器计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.即8位 2**8=256种状态 内存 掉电易失 与晶振频率有关 临时数据 mermorycpu与内存速度差几个数量级cpu 只认内存 io设备最慢CPU 缓存 cache bus 总线先写源程序 通过编译程序把源程序转换成机器指令的程序python是跑在虚拟机上的 动态语言 做节点 集群优化编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样 机器语言: 是一定位数组成的0 1序列 称为机器指令 机器指令的集合就是机器语言汇编: 是用助记符替代机器指令静态语言: 是声明变量类型,不能再改变,编译需要检查动态语言: 不用声明类型 随时可以赋值为其他类型强类型: 不同类型之间操作 必须强制类型转换为同一类型弱类型: 不同类型之间操作 自动隐式转换 python基础介绍python 的源代码需要被解释器编译成中间代码,在虚拟机上运行程序 = 算法 +数据结构数据一切程序的核心数据结构是数据在计算机中的类型和组织方式算法是处理数据的方式,算法有优劣之分.python自带了一个IDLE的程序,全称是交互式开发环境.注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要. import math #对角线的长度i = 4w = 10d = math.sqrt(12 + w2)即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的编写尽量用pep8风格 数据类型:python将数据划分为不同的类别,即数据类型.每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.对象的数据类型是对象所属的数据类别.“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号数据类型为bool的对象被称为布尔值.数据类型为nonetype的对象,其值永远我none 用来表示数据缺失. 系统编程python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展此外很多python的系统工具设计都考虑了其可移植性. python解释器python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行. python变量和内存变量在python是表示内存的地址.可以用id()函数获取内存地址 a=5id(a)id(5)会发现这两个地址一样,都输出140720362218448 即python的编程哲学 :一切皆对象,一切皆指针只有指针,要说变量也是指针变量variable 变量是改变的值.变量由一个或多个字符组成的名称构成并使用赋值符 等号赋予了这个名称一个值变量是记住内存中 0 1数字 开始和结束的一串 指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。对于C和C++这样的没有Garbage Collection 的语言来讲我们主要关注两种类型的内存泄漏： 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 python虚拟机原理python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.pycodeobject保存字节码以及进程上下文信息. 过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象.pyc文件字节码在磁盘上的表现形式pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,从技术上将,他才是所谓python解释器的最后一步.代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式. 开发环境 —-pyenvpython多版本管理工具pip包管理器pip install xxxpip listpip search keyword 或者 pypipip help installpip install redis ipythonpip install jupyterpip -Vpip freeze &gt; requirementpip install-r requirement 原码补码反码原码是给人看的,补码是给计算机用的127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。因为它是用补码的编码方式。正数的补码就是它的原码，也就是单纯的二进制数。负数的话，1111 1111这个二进制串，首先它最高位是1，明确他是个负数。那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001也就是1，再加上符号位。最终结果是-1 补码 从小到大 二进制1000 0000—-0000 0000—-0111 1111首尾相连，刚好连个时钟，最大的加一到最小的 基础语法字符串使用单双三引号括起来的序列叫字符串 r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理f前缀:3.6版本开始,新增f前缀,格式化字符串转义序列\ \t \r \n \’ \”缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系约定使用4个空格缩进续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\extend 魔术方法add() 标识符一个名字,用来指代一个值只能是字母,下划线和数字只能以字母或下划线开头不能是python的关键字,例如def,class等python是大小写敏感的约定:不允许使用中文不要使用歧义单词,例如class_在python中不要随便使用下划线开头的标识符 运算符 算术运算符 +-*/%**自然除/结果是浮点数,整除// 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 比较运算符 == != &gt; &lt; &gt;= &lt;=返回一个bool值 逻辑运算符 与或非 and or not短路运算符 赋值运算符0 *? =0短路1+? =1短路运算 可以提高效率 可以提前算完了赋值运算 先算右边 和左边相连(映射) a=min(3,5) 运算符优先级 就记住一句话 a+b&gt;c and 折半思想可以优化程序 程序控制顺序结构:按照先后顺序一条条执行分支结构:根据不同情况判断,条件满足执行某条件下的语句循环结构:条件满足就反复执行,不满足就不执行或不再执行 内置类型内置对象使程序更容易编写内置对象使扩展的组件内置对象往往比定制的数据结构更有效率内置对象使语言的标准的一部分python的核心数据类型模式匹配 循环while 语句whlie condition: block当他成立则进入循环while true: pass #死循环 冒号后要形成语句块 死循环都用这个语法例子: flag = 10while flag: print(flag) flag-= 1 在做循环时,一定要分析边界 边界最容易出错range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包 for i in range(10): print(i+1) i= i+10循环 隐含赋值 原来有什么会被冲掉for相当于遍历 不会重复拿 挨个拿如果要倒着遍历 应当在range函数内加步长-1例子:for i in range(10): if i %2 == 0: print(i) for i in range(10): if not i % 2: print(i)not 经常用for i in range (10): if i &amp;1 == 0: print(i) for i in range(10): if i &amp; 1: continue print(i) 写程序要减少循环提高效率 for i in range(10): if i % 2: continue print(i) 如果循环嵌套 continue 和break也只影响语句所在的那一层循环 迭代器和生成器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： from collections import Iterableisinstance([], Iterable)Trueisinstance({}, Iterable)Trueisinstance(‘abc’, Iterable)Trueisinstance((x for x in range(10)), Iterable)Trueisinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： L = [x x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x x for x in range(10))g &lt;generator object at 0x1022ef630&gt; 函数python 内置了很多有用的函数,我们可以直接调用要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python基础</tag>
      </tags>
  </entry>
</search>
