<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[理解IO]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2FIO%E5%A4%9A%E7%A7%8D%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[重要概念同步、异步函数或方法被调用的时候，调用者是否得到最终结果的 直接得到最终结果的，就是同步调用 不直接得到最终结果的，就是异步调用阻塞、非阻塞函数或方法调用的时候，是否立刻返回 立即返回就是非阻塞调用 不立即返回就是阻塞调用区别同步、异步，与阻塞、非阻塞不相关同步、异步强调的是，是否得到（最终的）结果阻塞、非阻塞强调是时间，是否等待 同步与异步区别在于：调用者是否得到了想要的最终结果同步就是一直要执行到返回最终结果异步就是直接返回了，但是返回的不是最终结果。调用者不能通过这种调用得到结果，以后可以通过被调用者提供的某种方式（被调用着通知调用者、调用者反复查询、回调），来取回最终结果 阻塞与非阻塞的区别在于，调用者是否还能干其他事阻塞，调用者就只能干等非阻塞，调用者可以先去忙会别的，不用一直等 联系同步阻塞，我啥事不干，就等你打饭打给我。打到饭是结果，而且我啥事不干一直等，同步加阻塞同步非阻塞，我等着你打饭给我，但我可以玩会手机、看看电视。打饭是结果，但是我不一直等 异步阻塞，我要打饭，你说等叫号，并没有返回饭给我，我啥事不干，就干等着饭好了你叫我。例如，取了号什么不干就等叫自己的号异步非阻塞，我要打饭，你给我号，你说等叫号，并没有返回饭给我，我在旁边看电视、玩手机，饭打好了叫我 操作系统知识在386之前，CPU工作在实模式下，之后，开始支持保护模式，对内存进行了划分X86 CPU有4种工作级别： Ring0级，可以执行特权指令，可以访问所有级别数据，可以访问IO设备等 Ring3级，级别最低，只能访问本级别数据 内核代码运行在Ring0，用户代码运行在Ring3 现代操作系统采用虚拟存储器，理论上，对于32位系统来说，进程对虚拟内存地址的内存寻址空间为4G（2^32)64位操作系统理论上最大内存寻址空间（2^64）操作系统中，内核程序独立且运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，这部分内存称为内核空间（内核态，最高地址1G） 普通应用程序运行在用户空间（用户态） 应用程序想访问某些硬件资源就需要通过操作系统提供的系统调用，系统调用可以使用特权指令运行在内核空间，此时进程陷入内核态运行。系统调用完成，进程将回到用户态执行用户空间代码 同步IO、异步IO、IO多路复用IO两个阶段IO过程分两阶段： 数据准备阶段 内核空间复制回用户空间进程缓冲区阶段 发生IO的时候： 内核从IO设备读、写数据（淘米，把米放饭锅里煮饭） 进程从内核复制数据（盛饭，从内核这个饭锅里面把饭装到碗里来） 系统调用——read函数 IO模型同步IO 同步IO模型包括 阻塞IO、非阻塞IO、IO多路复用、信号驱动IO阻塞IO 进程等待（阻塞），直到读写完成。（全程等待） 非阻塞IO进程调用read操作，如果IO设备没有准备好，立即返回ERROR，进程不阻塞。用户可以再次发起系统调用，如果内核已经准备好，就阻塞，然后复制数据到用户空间 第一阶段数据没有准备好，就先忙别的，等会再来看看。检查数据是否准备好了的过程是非阻塞的 第二阶段是阻塞的，即内核空间和用户空间之间复制数据是阻塞的 例：淘米、蒸饭我不等，我去玩会，盛饭过程我等着你装好饭，但是要等到盛好饭才算完事，这是同步的，结果就是盛好饭 IO多路复用所谓IO多路复用，就是同时监控多个IO，有一个准备好了，就不需要等了开始处理，提高了同时处理IO的能力 select几乎所有操作系统平台都支持，poll是对的select的升级 epoll，Linux系统内核2.5+开始支持，对select和poll的增强，在监视的基础上，增加回调机制。BSD、Mac平台有kqueue，Windows有iocp 以select为例 将关注的IO操作告诉select函数并调用，进程阻塞，内核“监视”select关注的文件描述符fd，被关注的任何一个fd对应的IO准备好了数据，select返回。再使用read将数据复制到用户进程 select举例 食堂供应很多菜（众多的IO），你需要吃某三菜一汤，大师傅（操作系统）说要现做，需要等，你只好等待大师傅叫。其中一样菜好了，大师傅叫你，说你点的菜有好的了，你得自己遍历找找看哪一样才好了，请服务员把做好的菜打给你 epoll是有菜准备好了，大师傅喊你去几号窗口直接打菜，不用自己找菜了 一般情况下，select最多能监听1024个fd（可以修改，但不建议改），但是由于select采用轮询的方式，当管理的IO多了，每次都要遍历全部fd，效率低下epoll没有管理的fd的上限，且是回调机制，不需遍历，效率很高 信号驱动IO进程在IO访问时，先通过sigaction系统调用，提交一个信号处理函数，立即返回。进程不阻塞当内核准备好数据后，产生一个SIGIO信号并投递给信号处理函数。可以在此函数中调用recvfrom函数操作数据从内核空间复制到用户空间，这段过程进程阻塞 异步IO 进程发起异步IO请求，立即返回。内核完成IO的两个阶段，内核给进程发一个信号。 举例 来打饭，跟大师傅说饭好了叫你，饭菜准备好了，窗口服务员把饭盛好了打电话叫你。两阶段都是异步的。在整个过程中，进程都可以忙别的，等好了才过来。 今天不想出去到饭店吃饭了，点外卖，饭菜在饭店做好了（第一阶段），快递员从饭店送到你家门口（第二阶段）。 Linux的aio的系统调用，内核从版本2.6开始支持 前4个都是同步IO，因为核心操作recv函数调用时，进程阻塞直到拿到最终结果为止。 而异步IO进程全程不阻塞]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>IO多路复用</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库事务隔离本质]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E6%9C%AC%E8%B4%A8%2F</url>
    <content type="text"><![CDATA[提到事务, 你肯定不陌生, 和数据库打交道的时候, 我们总是会用到事务, 最经典的例子就是转账, 你要给朋友小王转100块钱, 而此时你的银行卡只有100块钱.转账过程具体到程序里会有一系列的操作, 比如余额查询, 做加减法, 更新余额等, 这些操作必须保证是一体的, 不然等程序查完之后, 还没做减法之前, 你这100块钱, 完全可以借着这个时间差再查一次, 然后再给另外一个朋友转账, 如果银行这么整, 不久乱了么?, 这是就要用到”事务”这个概念了. 简单来说, 事务就是要保证一组数据库操作, 要么全部成功, 要么全部失败. 再mysql中, 事务支持是在引擎层实现的.你现在知道, mysql是一个支持多引擎的系统, 但并不是所有的引擎都支持事务.比如mysql原生的myiSAM引擎就不支持事务, 这也是MyISAM被InnoDB取代的重要原因之一. 隔离性和隔离级别提到事务, 你肯定会想到ACID(Atomicity, Consistency, isolation, DURability, 即原子性, 一致性, 隔离性, 持久化). 当数据库上游多个事务同时执行的时候, 就可能出现脏读(dirty read), 不可重复读(non-repeatable read), 幻读(phantom read)的问题, 为了解决这些问题, 就有了”隔离级别”的概念. 在谈隔离级别之前, 你首先要知道, 你隔离得越严实, 效率就会越低.因此很多时候, 我们都要在二者之间寻找一个平衡点.sql标准的事务隔离级别包括: 都未提交(read uncommitted), 读提交(read committed), 可重复读(repeatable read)和串行化(seriazable). 读未提交是指, 一个事务还没提交时, 他做的变更就能被别的事务看到. 读提交是指, 一个事务执行过程中看到的数据, 总是跟这个事务在启动时看到的数据是一致的,当然在可重复读隔离级别下, 未提交变更对其他事务也是不可见. 串行化, 顾名思义是对于同一行记录, “写”会加”写锁”, “读”会加”读锁”. 当出现读写锁冲突的时候, 后访问的事务必须等前一个事务执行完成, 才能继续执行. 其中”读提交”和”可重复读”比较难理解, 所以我用一个例子说明这几种隔离级别.假设数据表T中只有一列, 其中一行的值为1, 下面是按照时间顺序执行两个事务的行为. 12mysql&gt; create table T(c int) engine=InnoDB;insert into T(c) values(1); 我们来看看在不同的隔离级别下, 事务A会有那些不同的返回结果, 也就是图里面V1, V2,V3的返回值分别是什么.]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[restful设计]]></title>
    <url>%2Fweb%2FRestful%20API%E8%AE%BE%E8%AE%A1%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5%2F</url>
    <content type="text"><![CDATA[RestfulREST(Representational State Transfer)，表现层状态转移 它首次出现在2000年Roy Fielding的博士论文中，Roy Fielding是HTTP规范的主要编写者之一 表现层是资源的表现层，对于网络中的资源就需要URI(Uniform Resource Identiﬁer)来指向 1、协议使用HTTP或者HTTPS。对外若有安全性要求，可以使用HTTPS。但是内部服务间调用可以使用HTTP或HTTPS 2、HTTP方法HTTP请求中的方法表示执行的动作| 常用方法(动词) | 说明 ||:–|:–||GET| 获取资源||POST |创建新的资源||PUT |更新资源||PATCH| 部分更新资源||DELETE |删除资源| 3、使用名词URL指向资源，在URL路径的描述中，只需要出现名词，而不要出现动词。动词由HTTP方法提供 不要单复数混用，建议名词使用复数 Restful的核心是资源，URL应该指向资源，所以应该是使用名称表达，而不是动词表达|方法| 路径 |说明||:–|:–|:–||GET| /posts| 返回所有文章||GET| /posts/10 |返回id为10的文章||POST| /posts |创建新的文章||PUT| /posts/10 |更新id为10的文章||DELETE| /posts/10 |删除id为10的文章||PATCH| /posts/10| 部分更新id为10的文章数据|不要出现下面的访问资源的路径1234/getAllPosts /addPost/updatePost/delPost GET方法只是获取资源，而不是改变资源状态。改变资源请使用POST、PUT、DELETE等方法 例如，使用 GET /posts/10 就可以获取资源了，但是却使用 GET /posts/10/del 或 GET /posts/10?v=del ，本意 是想删除。但这样不好，GET方法请求只为获取资源，不要改变资源状态 子资源的访问 方法 路径Endpoint 说明 GET /posts/10/authors 返回id为10的文章的所有作者 GET /posts/10/authors/8 返回id为10的文章的作者中id为8的 4、集合功能 过滤 Filtering指定过滤条件 GET /posts?tag=python 排序 Sorting指定排序条件。有很多种设计风格，例如使用+表示asc，-表示desc。 GET /posts?sort=+title,-id 或 GET /posts?sort=title_asc,id_desc 分页 Pagination一般情况下，查询返回的记录数非常多，必须分页。 GET /posts?page=5&amp;size=205、状态码使用HTTP响应的状态码表示动作的成功与否。 2XX表示用户请求被服务器端成功的处理；4XX表示用户请求的错误；5XX表示服务器端出错了| Status Code | 说明 | Method| 说明 ||:–|:–| :–| :–||200| OK |GET| 成功获取资源||201| CREATED |POST、PUT、PATCH |成功创建或修改||204| NO CONTENT |DELETE |成功删除资源||400 |Bad Request| ALL（表示所有方法）|请求中有错误，例如 GET时参数有问题 PUT时提交的数据错误等||401| Unauthorized |ALL |权限未通过认证||403| Forbidden| ALL |有无权限都禁止访问该资源||404 |Not Found| ALL| 请求的资源不存在||500 |Internal Server Error |ALL |服务器端错| 详细状态码参考https://www.w3.org/Protocols/rfc2616/rfc2616-sec10.html 6、错误处理在Restful API设计中，错误处理也非常重要。单单从状态码中无法详尽描述错误的信息。 1、返回消息 123&#123; error:&quot;User Not Found&quot; &#125; 2、从错误消息中了解到错误号、错误信息、错误描述等信息。甚至更详细的信息可以通过code查阅文档 12345&#123; &quot;code&quot;:10056, &quot;message&quot;:&quot;Invalid ID&quot;, &quot;description&quot;:&quot;More details&quot;&#125; 7、版本强烈要求使用版本，版本号使用简单数字，例如v 2种风格 http://api.magedu.com/v1/posts/10 这种风格会跨域，适合较大的项目 http://www.magedu.com/api/v1/posts/10 不跨域 8、返回结果 方法 路径 说明 GET /posts 返回所有文章的列表 GET /posts/10 返回id为10的文章对象 POST /posts 创建新的文章并返回这个对象 PUT /posts/10 更新id为10的文章并返回这个对象 DELETE /posts/10 删除id为10的文章返回一个空对象 PATCH /posts/10 部分更新id为10的文章数据并返回这个对象 前后端分离，只传数据，所以数据一律采用JSON格式]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[分布式爬虫]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%982-%E5%88%86%E5%B8%83%E5%BC%8F%E5%BC%82%E6%AD%A5%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[多线程爬取博客园博客园的新闻分页地址 https://news.cnblogs.com/n/page/10/ ，多线程成批爬取新闻的标题和链接https://news.cnblogs.com/n/page/2/ ，这个url中变化的是最后的数字一直在变，它是页码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import requestsfrom bs4 import BeautifulSoupfrom bs4.element import Tagfrom queue import Queuefrom concurrent.futures import ThreadPoolExecutorBASE_URL = 'http://news.cnblogs.com'NEWS_PAGE = '/n/page/'# https://news.cnblogs.com/n/page/2/ 列表页# https://news.cnblogs.com/n/628919/ 详情页headers = &#123; 'User-agent': "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML,like Gecko)" " Version / 5.0.1Safari / 537.36"&#125;# 异步，队列，以后换成第三方队列urls = Queue()# 创建博客园的新闻urls，每页30条新闻def starts_url(start, stop, step=1): for i in range(start, stop + 1, step): url = "&#123;&#125;&#123;&#125;&#123;&#125;/".format(BASE_URL, NEWS_PAGE, i) print(url) urls.put(url) # 加入队列 print('任务链接创建完毕')# 爬取页面def crawler(): url = urls.get() # 阻塞，拿一条 with requests.get(url, headers=headers) as response: html = response.text # 解析 soup = BeautifulSoup(html, 'lxml') # h2.news_entry &gt; a # //h2[@new_entry=""]/a titles = soup.select('h2.news_entry &gt; a') for title in titles: print(title.get('href'), title.text)# starts_url(1, 1)# crawler()# 线程池executor = ThreadPoolExecutor(10)executor.submit(starts_url, 1, 1)for i in range(5): executor.submit(crawler) 解析内容是一个比较耗时的过程，不适合放在crawler中同步处理。同样使用队列解耦 现在线程都是拿一条数据，执行完就结束了。修改为可以不停的从队列中取数据123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869import requestsfrom bs4 import BeautifulSoupfrom bs4.element import Tagfrom queue import Queuefrom concurrent.futures import ThreadPoolExecutorfrom threading import EventBASE_URL = 'http://news.cnblogs.com'NEWS_PAGE = '/n/page/'# https://news.cnblogs.com/n/page/2/ 列表页# https://news.cnblogs.com/n/628919/ 详情页headers = &#123; 'User-agent': "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML,like Gecko)" " Version / 5.0.1Safari / 537.36"&#125;# 异步，队列，以后换成第三方队列urls = Queue()# 待爬取队列htmls = Queue() # 待分析队列outputs = Queue() # 待输出队列# 创建博客园的新闻urls，每页30条新闻def starts_url(start, stop, step=1): for i in range(start, stop + 1, step): url = "&#123;&#125;&#123;&#125;&#123;&#125;/".format(BASE_URL, NEWS_PAGE, i) print(url) urls.put(url) # 加入队列 print('任务链接创建完毕')# 爬取页面def crawler(e:Event): while not e.is_set(): url = urls.get() # 阻塞，拿一条 with requests.get(url, headers=headers) as response: html = response.text htmls.put(html)# 解析页面def parse(e:Event): # 解析 while not e.is_set(): html = htmls.get() soup = BeautifulSoup(html, 'lxml') # h2.news_entry &gt; a # //h2[@new_entry=""]/a titles = soup.select('h2.news_entry &gt; a') for title in titles: href = BASE_URL + title.get('href','') txt = title.text val = href, txt outputs.put(val) print(val)event = Event()# 线程池executor = ThreadPoolExecutor(10)executor.submit(starts_url, 1, 1)for i in range(5): executor.submit(crawler, event)for i in range(5): executor.submit(parse, event) html分析函数parse，分析完成后，需要将结果持久化。不要在parse中直接持久化，放入队列中，统一持久化1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980import requestsfrom bs4 import BeautifulSoupfrom bs4.element import Tagfrom queue import Queuefrom concurrent.futures import ThreadPoolExecutorfrom threading import EventBASE_URL = 'http://news.cnblogs.com'NEWS_PAGE = '/n/page/'# https://news.cnblogs.com/n/page/2/ 列表页# https://news.cnblogs.com/n/628919/ 详情页headers = &#123; 'User-agent': "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML,like Gecko)" " Version / 5.0.1Safari / 537.36"&#125;# 异步，队列，以后换成第三方队列urls = Queue()# 待爬取队列htmls = Queue() # 待分析队列outputs = Queue() # 待输出队列# 创建博客园的新闻urls，每页30条新闻def starts_url(start, stop, step=1): for i in range(start, stop + 1, step): url = "&#123;&#125;&#123;&#125;&#123;&#125;/".format(BASE_URL, NEWS_PAGE, i) print(url) urls.put(url) # 加入队列 print('任务链接创建完毕')# 爬取页面def crawler(e:Event): while not e.is_set(): url = urls.get() # 阻塞，拿一条 with requests.get(url, headers=headers) as response: html = response.text htmls.put(html)# 解析页面def parse(e:Event): # 解析 while not e.is_set(): html = htmls.get() soup = BeautifulSoup(html, 'lxml') # h2.news_entry &gt; a # //h2[@new_entry=""]/a titles = soup.select('h2.news_entry &gt; a') for title in titles: href = BASE_URL + title.get('href','') txt = title.text val = href, txt outputs.put(val) # print(val)# 持久化def persist(path, e: Event): with open(path, 'a+', encoding='utf-8') as f: while not e.is_set(): val = outputs.get() print(val) f.write("&#123;&#125;\x01&#123;&#125;\n".format(val[0], val[1])) f.flush()event = Event()# 线程池executor = ThreadPoolExecutor(10)executor.submit(starts_url, 1, 1)executor.submit(persist, 'd:/news.txt', event)for i in range(5): executor.submit(crawler, event)for i in range(4): executor.submit(parse, event) 这样一个实用的并行的爬虫就基本完成了，一般提取新的URL源源不断地注入到待爬取队列，就可以实现不间断的爬取了可以很方便的扩展成多进程等版本 进阶（消息队列）将队列换成第三方服务，本次采用较为常用RabbitMQ 选型1、队列工作模式选择 以爬虫程序的htmls队列为例，这个队列有多个生产者（爬取函数）写入，有多个消费者（解析函数）读取。每一个消息只能被消费一次。所以，采用RabbitMQ的工作队列模式 RabbitMQ生产者、消费者两端都可以创建交换机、队列 2、队列中如何如何分发 工作队列模式，说到底就是路由模式。RabbitMQ的队列和工作队列模式，交换机都工作在direct，其实都是路由模式，只不过使用了缺省交换机 我们自己使用，可以单独创建交换机，不使用缺省交换机 3、队列是否断开删除不能。如果每一条数据都要处理，不能因为某一端断开，然后队列就删除了，造成数据丢失 消息队列类1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859# 新建messagequeue.pyimport pikaclass MessageBase: def __init__(self, host, port, user, password, virtualhost, exchange, queue): self.exchange_name = exchange self.queue_name = queue url = "amqp://&#123;&#125;:&#123;&#125;@&#123;&#125;:&#123;&#125;/&#123;&#125;".format( user, password, host, port, virtualhost ) params = pika.URLParameters(url) self.connection = pika.BlockingConnection(params) self.channel = self.connection.channel() # 指定交换机使用路由模式 self.channel.exchange_declare( exchange=self.exchange_name, # 指定交换机 exchange_type='direct' # 路由 ) # 设置queue，一定要绑定，不使用缺省交换机了 self.channel.queue_declare(queue=self.queue_name, exclusive=False) # routing_key不指定使用队列名 self.channel.queue_bind(queue=self.queue_name, exchange=self.exchange_name)class Producer(MessageBase): def produce(self, message): self.channel.basic_publish( exchange=self.exchange_name, # 使用指定交换机 routing_key=self.queue_name, body=message)class Consumer(MessageBase): def consume(self): # basic_get 非阻塞拿一条不循环 method, props, body = self.channel.basic_get( queue=self.queue_name, # 去指定的queue上获取数据 auto_ack=True # 自动应答 ) # 不阻塞方法，拿不到就是(None, None, None) return body # 有可能是Noneif __name__ == '__main__': qs = ('urls', 'htmls', 'outputs') # for q in qs: # p = Producer('192.168.142.140', 5672, 'wayne', 'wayne', 'test', 'news', q) # for i in range(40): # msg = '&#123;&#125;-data-&#123;:02&#125;'.format(q, i) # p.produce(msg)c1 = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', qs[0])c2 = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', qs[1])c3 = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', qs[2])for i in range(40): print(c1.consume()) print(c2.consume()) print(c3.consume()) 重构爬虫代码123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899import requestsfrom bs4 import BeautifulSoupfrom bs4.element import Tagfrom queue import Queuefrom concurrent.futures import ThreadPoolExecutorfrom threading import Eventimport simplejsonfrom messagequeue import Producer, ConsumerBASE_URL = 'http://news.cnblogs.com'NEWS_PAGE = '/n/page/'# https://news.cnblogs.com/n/page/2/ 列表页# https://news.cnblogs.com/n/628919/ 详情页headers = &#123; 'User-agent': "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML,like Gecko)" " Version / 5.0.1Safari / 537.36"&#125;# 异步，队列，以后换成第三方队列# urls = Queue()# 待爬取队列# htmls = Queue() # 待分析队列# outputs = Queue() # 待输出队列# 创建博客园的新闻urls，每页30条新闻def starts_url(start, stop, step=1): p = Producer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') for i in range(start, stop + 1, step): url = "&#123;&#125;&#123;&#125;&#123;&#125;/".format(BASE_URL, NEWS_PAGE, i) print(url) # urls.put(url) # 加入队列 p.produce(url) print('任务链接创建完毕')# 爬取页面def crawler(e:Event): p = Producer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') c = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') while not e.wait(1): # url = urls.get() # 阻塞，拿一条 url = c.consume() if url: with requests.get(url, headers=headers) as response: if response.status_code == 200: html = response.text #htmls.put(html) p.produce(html)# 解析页面def parse(e:Event): # 解析 p = Producer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') c = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') while not e.wait(1): # html = htmls.get() html = c.consume() if html: soup = BeautifulSoup(html, 'lxml') # h2.news_entry &gt; a # //h2[@new_entry=""]/a titles = soup.select('h2.news_entry &gt; a') for title in titles: val = simplejson.dumps(&#123; 'title': title.text, 'url': BASE_URL + title.get('href','') &#125;) # outputs.put(val) p.produce(val) # print(val)# 持久化def persist(path, e: Event): # 以后持久化到数据库当中去 c = Consumer('192.168.1.5', 5672, 'lqx', 'lqx', 'test', 'news', 'urls') with open(path, 'a+', encoding='utf-8') as f: while not e.wait(1): # val = outputs.get() data = c.consume() if data: val = simplejson.loads(data) f.write("&#123;&#125;\x01&#123;&#125;\n".format(val['url'], val['title'])) f.flush()event = Event()# 线程池executor = ThreadPoolExecutor(10)executor.submit(starts_url, 1, 2)executor.submit(persist, 'd:/news.txt', event)for i in range(5): executor.submit(crawler, event)for i in range(4): executor.submit(parse, event) 爬取、解析、存储、url生成都可以完全独立，分别部署]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[模拟登录]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E7%88%AC%E8%99%AB%E5%AE%9E%E6%88%98%20-%20%E6%A8%A1%E6%8B%9F%E7%99%BB%E9%99%86oschina%2F</url>
    <content type="text"><![CDATA[模拟登陆oschina（新浪）一般登录后，用户就可以一段时间内可以使用该用户身份操作，不需要频繁登录了。这背后往往使用了Cookie技术 登录后，用户获得一个cookie值，这个值在浏览器当前会话中保存，只要不过期甚至可以保存很久 用户每次向服务器提交请求时，将这些Cookie提交到服务器，服务器经过分析Cookie中的信息，以确认用户身份，确认是信任的用户身份，就可以继续使用网站功能 Cookie网景公司发明。cookie一般是一个键值对name=value，但还可以包括expire过期时间、path路径、domain域、secure安全、httponly等信息清空oschina.net的所有cookies，重新登录，勾选”记住密码‘’登陆前需将所有cookies清除1使用 wei.xu@magedu.com/magedu.com18 登录oschina后，HTTP请求头如下 123456789Host: www.oschina.netConnection: keep-aliveUpgrade-Insecure-Requests: 1User-Agent: Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36Accept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3Referer: https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fwww.oschina.net%2F%3Fnocache%3D1564293263846Accept-Encoding: gzip, deflate, brAccept-Language: zh-CN,zh;q=0.9,en;q=0.8Cookie: aliyungf_tc=AQAAAMgC7FB9xAEADtR2e0KAzgb3hr0a; _user_behavior_=768762a3-dbce-4152-a024-264820556c9c; OSCHINA_SESSION=4DFB86BECA93B1D28BC8FEF2E1478E97; _reg_key_=EwiEfyB66X3jlOb4pNzk; oscid=ZV2oveUqo28xv80qumQtfRqukWzpKq2brNqjn0Y0a5kFTeUQUUbcPj2dwLIiVt%2FuobUFKx4%2FabVv%2BZ5n%2BrJhvE8p%2BKdiM%2FUIONcDpf9cQ%2FCwMTYxj0IZhKrEKkqVYfw%2BdNYj1bbHQEhDiqhDeFBZbsf7ouMp1Msoa4cH6mU1ZtM%3D 对比登录前后的cookie值，发现登录后有oscid 那就把这个HTTP 请求头放在代码中 注意：每次登录后要重新生成下面的headers使用Postman将请求头改为KV对形式1234567891011121314151617181920212223from bs4 import BeautifulSoupimport requestsurl = "https://www.oschina.net"headers = &#123; 'Host': "www.oschina.net", 'Connection': "keep-alive", 'Upgrade-Insecure-Requests': "1", 'User-Agent': "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/73.0.3683.75 Safari/537.36", 'Accept': "text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,image/apng,*/*;q=0.8,application/signed-exchange;v=b3", 'Referer': "https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fwww.oschina.net%2F%3Fnocache%3D1564293263846", 'Accept-Encoding': "gzip, deflate, br", 'Accept-Language': "zh-CN,zh;q=0.9,en;q=0.8", 'Cookie': "aliyungf_tc=AQAAAMgC7FB9xAEADtR2e0KAzgb3hr0a; _user_behavior_=768762a3-dbce-4152-a024-264820556c9c; OSCHINA_SESSION=4DFB86BECA93B1D28BC8FEF2E1478E97; _reg_key_=EwiEfyB66X3jlOb4pNzk; oscid=ZV2oveUqo28xv80qumQtfRqukWzpKq2brNqjn0Y0a5kFTeUQUUbcPj2dwLIiVt%2FuobUFKx4%2FabVv%2BZ5n%2BrJhvE8p%2BKdiM%2FUIONcDpf9cQ%2FCwMTYxj0IZhKrEKkqVYfw%2BdNYj1bbHQEhDiqhDeFBZbsf7ouMp1Msoa4cH6mU1ZtM%3D", 'cache-control': "no-cache" &#125;response = requests.request("GET", url, headers=headers)with response: with open('d:/osc.html', 'w', encoding='utf-8') as f: f.write(response.text) 已登录访问首页，右上角会有用户信息，如下123456789101112131415161718192021222324252627&lt;div class="right menu"&gt; &lt;a class="item" href="https://www.oschina.net/home/go?page=admin%2Fpublish"&gt;投递新闻/软件&lt;/a&gt; &lt;div class="ui icon dropdown item" id="message"&gt; &lt;i class="alarm icon"&gt;&lt;/i&gt; &lt;div class="ui red circular mini label total-count"&gt;-3&lt;/div&gt; &lt;div class="menu"&gt; &lt;div class="header message-header"&gt; 暂没有未读消息 &lt;/div&gt; &lt;a class="item " style='display: none'&gt;&lt;/a&gt; &lt;div class="message-list"&gt;&lt;/div&gt; &lt;div class="header action clearfix"&gt; &lt;span class="go-inbox"&gt;&lt;a href="https://my.oschina.net/u/3881396/admin/inbox"&gt;消息中心&lt;/a&gt;&lt;/span&gt; &lt;span class="mark-read-all"&gt;&lt;a href="javascript:;"&gt;全部标记为已读&lt;/a&gt;&lt;/span&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;a class="ui dropdown item toggle-user-sidebar"&gt; &lt;div class="osc-avatar small-portrait _28x28 ui avatar image current-user-avatar" title="magedu_wayne" data-user-id="3881396"&gt; &lt;span class="text-portrait" style="background: #16a085"&gt;m&lt;/span&gt; &lt;/div&gt; &lt;i class="caret right icon"&gt;&lt;/i&gt; &lt;/a&gt; &lt;/div&gt;&lt;/div&gt;&lt;div id="mainScreen"&gt; &lt;div class="home-container"&gt; 如果没有登录，一定不能在页面中出现用户的名称和userid的未登录访问首页，右上角显示登录、注册链接，如下1234567&lt;div class="right menu"&gt; &lt;a class="item" href="https://www.oschina.net/home/go?page=admin%2Fpublish"&gt;投递新闻/软件&lt;/a&gt; &lt;a class="item" href="https://www.oschina.net/home/login?goto_page=https%3A%2F%2Fwww.oschina.net%2F"&gt;登录&lt;/a&gt; &lt;a class="item" href="https://www.oschina.net/home/reg?goto_page=https%3A%2F%2Fwww.oschina.net%2F"&gt;注册&lt;/a&gt;&lt;/div&gt; 新浪微博等都一样，只要允许记住用户登录，就可以通过上述方法登录后爬取内容]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[爬虫概述]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E7%88%AC%E8%99%AB%2F</url>
    <content type="text"><![CDATA[概述爬虫，应该称为网络爬虫，也叫网页蜘蛛、网络机器人、网络蚂蚁等。搜索引擎，就是网络爬虫的应用者 为什么到了今天，反而这个词汇被频繁的提起呢？有搜索引擎不就够了吗？实际上，大数据时代的到了，所有的企业都希望通过海量数据发现其中的价值所以，需要爬取对特定网站、特定类别的数据，而搜索引擎不能提供这样的功能，因此，需要自己开发爬虫来解决 爬虫分类通用爬虫常见就是搜索引擎，无差别的收集数据、存储，提取关键字，构建索引库，给用户提供搜索接口 爬取一般流程 初始一批URL，将这些URL放到待爬取队列 从队列取出这些URL，通过DNS解析IP，对IP对应的站点下载HTML页面，保存到本地服务器中，爬取完的URL放到已爬取队列 分析这些网页内容，找出网页里面的其他关心的URL链接，继续执行第2步，直到爬取条件结束 搜索引擎如何获取一个新网站的URL 新网站主动提交给搜索引擎 通过其它网站页面中设置的外链 搜索引擎和DNS服务商合作，获取最新收录的网站 聚焦爬虫有针对性的编写特定领域数据的爬取程序，针对某些类别数据采集的爬虫，是面向主题的爬虫 Robots协议指定一个robots.txt文件，告诉爬虫引擎什么可以爬取 / 表示网站根目录，表示网站所有目录。Allow 允许爬取的目录Disallow 禁止爬取的目录可以使用通配符 淘宝 http://www.taobao.com/robots.txt123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263User-agent: BaiduspiderAllow: /articleAllow: /oshtmlAllow: /ershouAllow: /$Disallow: /product/Disallow: /User-Agent: GooglebotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listAllow: /ershouAllow: /$Disallow: /User-agent: BingbotAllow: /articleAllow: /oshtmlAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listAllow: /ershouAllow: /$Disallow: /User-Agent: 360SpiderAllow: /articleAllow: /oshtmlAllow: /ershouDisallow: /User-Agent: YisouspiderAllow: /articleAllow: /oshtmlAllow: /ershouDisallow: /User-Agent: SogouspiderAllow: /articleAllow: /oshtmlAllow: /productAllow: /ershouDisallow: /User-Agent: Yahoo! SlurpAllow: /productAllow: /spuAllow: /dianpuAllow: /overseaAllow: /listAllow: /ershouAllow: /$Disallow: /User-Agent: *Disallow: / 明确百度爬虫能爬取的内容123456User-agent: BaiduspiderAllow: /articleAllow: /oshtmlAllow: /ershouDisallow: /product/Disallow: / 其它爬虫，不允许爬取12User-Agent: *Disallow: / 马蜂窝 http://www.mafengwo.cn/robots.txt12345User-agent: *Disallow: /Disallow: /poi/detail.phpSitemap: http://www.mafengwo.cn/sitemapIndex.xml 这是一个君子协定，“爬亦有道” 这个协议为了让搜索引擎更有效率搜索自己内容，提供了如Sitemap这样的文件。Sitemap往往是一个XML文件，提供了网站想让大家爬取的内容的更新信息 这个文件禁止抓取的往往又是可能我们感兴趣的内容，它反而泄露了这些地址 HTTP请求和响应处理其实爬取网页就是通过HTTP协议访问网页，不过通过浏览器访问往往是人的行为，把这种行为变成使用程序来访问 urllib包urllib是标准库，它一个工具包模块，包含下面模块来处理url： urllib.request 用于打开和读写url urllib.error 包含了由 urllib.request引起的异常 urllib.parse 用于解析url urllib.robotparser 分析 robots.txt 文件 Python2中提供了urllib和urllib2。urllib提供较为底层的接口，urllib2对urllib进行了进一步封装 Python3中将urllib合并到了urllib2中，并更名为标准库urllib包 urllib.request模块模块定义了在基本和摘要式身份验证、 重定向、 cookies等应用中打开 Url (主要是 HTTP) 的函数和类 urlopen方法urlopen(url, data=None) url是链接地址字符串，或请求类的实例 data提交的数据，如果data为None发起GET请求，否则发起POST请求。见 urllib.request.Request#get_method 返回http.client.HTTPResponse类的响应对象，这是一个类文件对象12345678910111213141516from urllib.request import urlopen# 打开一个url返回一个响应对象，类文件对象# 下面的链接访问后会有跳转response = urlopen('http://www.bing.com') # GET方法print(response.closed)with response: print(1,type(response)) # http.client.HTTPResponse 类文件对象 print(2, response.status, response.reason) # 请求状态 print(3, response.geturl()) # 返回真正的URL print(4, response.info()) # headers print(5, response.read()) # 读取返回的内容print(response.closed) 执行结果1234567891011121314151617181920212223242526272829D:\python\venvs\blog01\Scripts\python.exe D:/python/blog-1.0/text.pyFalse1 &lt;class 'http.client.HTTPResponse'&gt;2 200 OK3 http://cn.bing.com/4 Cache-Control: private, max-age=0Content-Length: 114009Content-Type: text/html; charset=utf-8Vary: Accept-EncodingP3P: CP="NON UNI COM NAV STA LOC CURa DEVa PSAa PSDa OUR IND"Set-Cookie: SRCHD=AF=NOFORM; domain=.bing.com; expires=Mon, 26-Jul-2021 09:29:04 GMT; path=/Set-Cookie: SRCHUID=V=2&amp;GUID=DCAB9EC86F964A45A890787A7EF4CF93&amp;dmnchg=1; domain=.bing.com; expires=Mon, 26-Jul-2021 09:29:04 GMT; path=/Set-Cookie: SRCHUSR=DOB=20190726; domain=.bing.com; expires=Mon, 26-Jul-2021 09:29:04 GMT; path=/Set-Cookie: _SS=SID=10B11589C8FA6E3003FE182CC9D46F33; domain=.bing.com; path=/X-MSEdge-Ref: Ref A: EAB1A96DB5534F5DB9BBD28A6BD85086 Ref B: BJ1EDGE0112 Ref C: 2019-07-26T09:29:04ZSet-Cookie: _EDGE_S=F=1&amp;SID=10B11589C8FA6E3003FE182CC9D46F33; path=/; httponly; domain=bing.comSet-Cookie: _EDGE_V=1; path=/; httponly; expires=Wed, 19-Aug-2020 09:29:04 GMT; domain=bing.comSet-Cookie: MUID=2169749B8FF26D6034DC793E8EDC6CF3; path=/; expires=Wed, 19-Aug-2020 09:29:04 GMT; domain=bing.comSet-Cookie: MUIDB=2169749B8FF26D6034DC793E8EDC6CF3; path=/; httponly; expires=Wed, 19-Aug-2020 09:29:04 GMTDate: Fri, 26 Jul 2019 09:29:03 GMTConnection: close5 b'&lt;!DOCTYPE html&gt;&lt;html lang="zh"&gt;&lt;script type="text/javascript" &gt;//&lt;![CDATA[\r\nsi_ST=new Date\r\n//]]&gt;&lt;/s'······TrueProcess finished with exit code 0 上例，通过urllib.request.urlopen方法，发起一个HTTP的GET请求，WEB服务器返回了网页内容。响应的数据被封装到类文件对象中，可以通过read方法、readline方法、readlines方法获取数据，status和reason属性表示返回的状态码，info方法返回头信息，等等 User-Agent问题上例的代码非常精简，即可以获得网站的响应数据。但目前urlopen方法通过url字符串和data发起HTTP的请求 如果想修改HTTP头，例如useragent，就得借助其他方式 源码中构造的useragent如下12345# urllib.request.OpenerDirectorclass OpenerDirector: def __init__(self): client_version = "Python-urllib/%s" % __version__ self.addheaders = [('User-agent', client_version)] 当前显示为 Python-urllib/3.6有些网站是反爬虫的，所以要把爬虫伪装成浏览器。随便打开一个浏览器，复制浏览器的UA值，用来伪装 UA值获取方式：Request类Request(url, data=None, headers={}) 初始化方法，构造一个请求对象 可添加一个header的字典 data参数决定是GET还是POST请求 add_header(key, val) 为header中增加一个键值对123456789101112131415161718192021222324252627282930313233343536from urllib.request import urlopen, Requestfrom http.client import HTTPResponseimport random# 打开一个url返回一个Request请求对象# url = 'https://movie.douban.com/' # 注意尾部的斜杠一定要有url = 'http://www.bing.com/'ua_list = [ "Mozilla/5.0 (Windows NT 6.1; Win64; x64) AppleWebKit/537.36 \ (KHTML, like Gecko)Chrome / 57.0.2987.133 Safari / 537.36",# chrome" "Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36\ (KHTML, like Gecko)Version / 5.0.1 Safari / 537.36", # safafi "Mozilla/5.0 (Windows NT 6.1; Win64; x64; rv:50.0) Gecko/20100101 Firefox/50.0",# Firefox "Mozilla/5.0 (compatible; MSIE 9.0; Windows NT 6.1; Trident/5.0)" # IE]ua = random.choice(ua_list) # pick one# ua需要加到请求头中request = Request(url)request.add_header('User-Agent', ua)print(type(request))response:HTTPResponse = urlopen(request, timeout=20) # request对象或者url都可以print(type(response))with response: print(1,response.status, response.getcode(), response.reason) # 状态，getcode本质上就是返回status print(2, response.geturl()) # 返回数据的url。如果重定向，这个url和原始url不一样 # 例如原始url是http://www.bing.com/，返回http://cn.bing.com/ print(3, response.info()) # 返回响应头headers print(4, response.read()) # 读取返回的内容print(5, request.get_header('User-agent'))print(6, request.headers)print(7, 'user-agent'.capitalize()) 执行结果 urllib.parse模块该模块可以完成对url的编解码先看一段代码，进行编码1234567891011121314151617181920from urllib import parseu = parse.urlencode('https://www.bing.com/search')# 运行结果如下Traceback (most recent call last): File "C:\Users\mayn\AppData\Local\Programs\Python\Python36\Lib\urllib\parse.py", line 854, in urlencode raise TypeErrorTypeErrorDuring handling of the above exception, another exception occurred:Traceback (most recent call last): File "D:/python/blog-1.0/text.py", line 3, in &lt;module&gt; u = parse.urlencode('https://www.bing.com/search') File "C:\Users\mayn\AppData\Local\Programs\Python\Python36\Lib\urllib\parse.py", line 862, in urlencode "or mapping object").with_traceback(tb) File "C:\Users\mayn\AppData\Local\Programs\Python\Python36\Lib\urllib\parse.py", line 854, in urlencode raise TypeErrorTypeError: not a valid non-string sequence or mapping object urlencode函数第一参数要求是一个字典或者二元组序列123456789101112from urllib import parseu = parse.urlencode(&#123; 'url':'https://www.bing.com/search', 'p_url':'https://cn.bing.com/search?q=豆瓣&amp;qs=n'&#125;)print(u)# 运行结果如下url=https%3A%2F%2Fwww.bing.com%2Fsearch&amp;\p_url=https%3A%2F%2Fcn.bing.com%2Fsearch%3Fq%3D%E8%B1%86%E7%93%A3%26qs%3Dn 从运行结果来看冒号、斜杠、&amp;、等号、问号等符号全部被编码了，%之后实际上是单字节十六进制表示的值 一般来说url中的地址部分，一般不需要使用中文路径，但是参数部分，不管GET还是POST方法，提交的数据中，可能有斜杆、等号、问号等符号，这样这些字符表示数据，不表示元字符 如果直接发给服务器端，就会导致接收方无法判断谁是元字符，谁是数据了 为了安全，一般会将数据部分的字符做url编码，这样就不会有歧义了 后来可以传送中文，同样会做编码，一般先按照字符集的encoding要求转换成字节序列，每一个字节对应的十六进制字符串前加上百分号即可 12345678910from urllib import parseu = parse.urlencode(&#123;'q':'豆瓣'&#125;)url= "https://cn.bing.com/search?".format(u)print(url) # https://cn.bing.com/search?print('豆'.encode('utf-8')) # b'\xe8\xb1\x86'print(parse.unquote(u)) # q=豆瓣print(parse.unquote(url)) # https://cn.bing.com/search? 提交方法method最常用的HTTP交互数据的方法是GET、POST GET方法，数据是通过URL传递的，也就是说数据是在HTTP报文的header部分 POST方法，数据是放在HTTP报文的body部分提交的 数据都是键值对形式，多个参数之间使用&amp;符号连接。例如a=1&amp;b=abc GET方法连接 必应 搜索引擎官网，获取一个搜索的URL https://cn.bing.com/search?q=豆瓣 需求请写程序完成对关键字的bing搜索，将返回的结果保存到一个网页文件12345678910111213141516171819202122from urllib.request import Request, urlopenfrom urllib.parse import urlencodekeyword = input('&gt;&gt; 请输入搜索关键字')data = urlencode(&#123; 'q':keyword&#125;)base_url = 'http://cn.bing.com/search'url = '&#123;&#125;?&#123;&#125;'.format(base_url, data)print(url)# 伪装ua = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36"request = Request(url, headers=&#123;'User-agent':ua&#125;)response = urlopen(request)with response: with open('d:/bing.html', 'wb') as f: f.write(response.read())print('成功') 注：生成的网页不会将读取文件里的二次请求数据写入。如src=** POST方法http://httpbin.org/ 测试网站123456789101112131415161718from urllib.request import Request, urlopenfrom urllib.parse import urlencoderequest = Request('http://httpbin.org/post')request.add_header( 'User-agent', "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, \ like Gecko) Chrome/55.0.2883.75Safari / 537.36")data = urlencode(&#123;'name':'张三,@=/&amp;*', 'age':'6'&#125;)print(data)# res = urlopen(request, data='name=张三,@=/&amp;*,&amp;age=6'.encode()) # 不做url编码有风险res = urlopen(request, data=data.encode()) # POST方法，Form提交数据with res: j = res.read().decode() # json print(j) 处理JSON数据查看“豆瓣电影”，看到“最近热门电影”的“热门”通过分析，我们知道这部分内容，是通过AJAX从后台拿到的Json数据访问URL是 https://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;page_limit=50&amp;page_start=0 utf-8编码的中文“热门” 服务器返回的Json数据如下轮播组件，共需要50条数据 https://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;page_limit=50&amp;page_start=0 tag 标签“热门”，表示热门电影 type 数据类型，movie是电影 page_limit 表示返回数据的总数 page_start 表示数据偏移12345678910111213141516171819202122232425262728from urllib.request import Request, urlopenfrom urllib.parse import urlencodeurl = 'https://movie.douban.com/j/search_subjects'request = Request(url)request.add_header( 'User-agent', "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36\ (KHTML, like Gecko) Chrome/55.0.2883.75Safari / 537.36")data = urlencode(&#123; 'type': 'movie', 'tag': '热门', 'page_limit': 10, 'page_start': 10&#125;)# POST方法res = urlopen(request, data=data.encode())with res: print(res._method) print(res.read().decode())# GET方法with urlopen('&#123;&#125;?&#123;&#125;'.format(url, data)) as res: print(res._method) print(res.read().decode()) 12345678910111213POST&#123;"subjects":[&#123;"rate":"6.9","cover_x":7142,"title":"飞驰人生","url":"https:\/\/movie.douban.com\/subject\/30163509\/",\"playable":true,"cover":"https://img3.doubanio.com\/view\/photo\/s_ratio_poster\/public\/p2542973862.jpg"......# 一共10条GET&#123;"subjects":[&#123;"rate":"6.9","cover_x":7142,"title":"飞驰人生"\,"url":"https:\/\/movie.douban.com\/subject\/30163509\/","playable":true,\"cover":"https://img3.doubanio.com\/view\/photo\/s_ratio_poster\/public\/p2542973862.jpg"# 一共10条... HTTPS证书忽略HTTPS使用SSL安全套接层协议，在传输层对网络数据进行加密。HTTPS使用的时候需要证书，而证书需要CA认证 CA(Certificate Authority)是数字证书认证中心的简称，是指发放、管理、废除数字证书的机构 CA是受信任的第三方，有CA签发的证书具有可信性。如果用户由于信任了CA签发的证书导致的损失，可以追究CA的法律责任 CA是层级结构，下级CA信任上级CA，且有上级CA颁发给下级CA证书并认证 一些网站，例如淘宝，使用HTTPS加密数据更加安全1234567891011121314from urllib.request import Request, urlopen# request = Request('http://www.12306.cn/mormhweb/') # 可以访问# request = Request('https://www.baidu.com/') # 可以访问request = Request('https://www.12306.cn/mormhweb/') # 报SSL认证异常request.add_header( 'User-agent', "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 \ (KHTML, like Gecko) Chrome/55.0.2883.75Safari / 537.36")# ssl.CertificateError: hostname 'www.12306.cn' doesn't match either of ......with urlopen(request) as res: print(res._method) print(res.read()) 通过HTTPS访问12306的时候，失败的原因在于12306的证书未通过CA认证，它是自己生成的证书，不可信。而其它网站访问，如 https://www.baidu.com/ 并没有提示的原因，它的证书的发行者受信任，且早就存储在当前系统中 使用ssl模块可忽略证书不安全信息12345678910111213141516171819from urllib.request import Request, urlopenimport ssl # 导入ssl模块# request = Request('http://www.12306.cn/mormhweb/') # 可以访问# request = Request('https://www.baidu.com/') # 可以访问request = Request('https://www.12306.cn/mormhweb/') # 报SSL认证异常request.add_header( 'User-agent', "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 \ (KHTML, like Gecko) Chrome/55.0.2883.75Safari / 537.36")# 忽略不信任的证书context = ssl._create_unverified_context()res = urlopen(request, context=context)# ssl.CertificateError: hostname 'www.12306.cn' doesn't match either of ......with res: print(res._method) print(res.read()) urllib3库https://urllib3.readthedocs.io/en/latest/标准库urllib缺少了一些关键的功能，非标准库的第三方库urllib3提供了，比如说连接池管理 安装$ pip install urllib31234567891011121314151617import urllib3# 打开一个url返回一个对象url = 'https://movie.douban.com/'ua = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 \(KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36"# 连接池管理器with urllib3.PoolManager() as http: response = http.request('GET', url, headers=&#123; 'User-Agent': ua &#125;) print(type(response)) // &lt;class 'urllib3.response.HTTPResponse'&gt; print(response.status, response.reason) // 200 OK print(response.headers) print(response.data) requests库requests使用了urllib3，但是API更加友好，推荐使用 安装 $ pip install requests1234567891011121314151617181920import requestsua = "Mozilla/5.0 (Windows NT 6.1) \AppleWebKit/537.36 (KHTML, like Gecko) \Chrome/55.0.2883.75Safari / 537.36"url = 'https://movie.douban.com/'response = requests.request('GET', url, headers=&#123;'User-Agent': ua&#125;)with response: print(type(response)) print(response.url) print(response.status_code) print(response.request.headers) # 请求头 print(response.headers) # 响应头 response.encoding = 'utf-8' print(response.text[:200]) # HTML的内容 with open('d:/movie.html', 'w', encoding='utf-8') as f: f.write(response.text) # 保存文件，以后备用 requests默认使用Session对象，是为了在多次和服务器端交互中保留会话的信息，例如cookie123456789101112131415161718import requestsua = "Mozilla/5.0 (Windows NT 6.1) \AppleWebKit/537.36 (KHTML, like Gecko) \Chrome/55.0.2883.75Safari / 537.36"urls = ['https://cn.bing.com/search?q=python', 'https://cn.bing.com/search?q=python']session = requests.Session()with session: for url in urls: response = session.get(url, headers=&#123;'User-Agent': ua&#125;) # response = requests.request('GET', url, headers=&#123;'User-agent':ua&#125;) # 观察两种方式区别 with response: print(response.request.headers) # 请求头 print(response.cookies) # 响应的cookie print(response.text[:20]) # HTML的内容 print('-' * 30) 使用session访问，第二次带上了cookie]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[scrapy]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E7%88%AC%E8%99%AB%20--%20Scrapy%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[Scrapy框架Scrapy是用Python实现的一个为了爬取网站数据，提取结构性数据而编写的应用框架。 可以应用在包括数据挖掘、信息处理或存储历史数据等一系列的程序中 Scrapy使用Twisted基于事件的高效异步网络框架来处理网络通信，可以加快下载速度，不用自己去实现异步框架，并且包含了各种中间件接口，可以灵活的完成各种需求 Scrapy架构 Scrapy Engine 引擎，负责控制数据流在系统中所有组件中流动，并在相应动作发生时触发事件。 此组件相当于爬虫的“大脑”，是整个爬虫的调度中心调度器(Scheduler) 调度器接收从引擎发送过来的request，并将他们入队，以便之后引擎请求他们时提供给引擎 初始的爬取URL和后续在页面中获取的待爬取的URL将放入调度器中，等待爬取。同时调度器会自动去除重复的URL（如果特定的URL不需要去重也可以通过设置实现，如post请求的URL）下载器(Downloader) 下载器负责获取页面数据并提供给引擎，而后提供给spiderSpiders爬虫Spider是编写的类，作用如下： Scrapy用户编写用于分析response并提取item(即获取到的item) 额外跟进的URL，将额外跟进的URL提交给引擎，加入到Scheduler调度器中。将每个spider负责处理一个特定(或一些)网站Item Pipeline Item Pipeline负责处理被spider提取出来的item。典型的处理有清理、 验证及持久化(例如存取到数据库中) 当页面被爬虫解析所需的数据存入Item后，将被发送到项目管道(Pipeline)，并经过设置好次序的pipeline程序处理这些数据，最后将存入本地文件或存入数据库 类似管道 $ ls | grep test 或者类似于Django 模板中的过滤器 以下是item pipeline的一些典型应用： 清理HTML数据 验证爬取的数据(检查item包含某些字段) 查重(或丢弃) 将爬取结果保存到数据库中 下载器中间件(Downloader middlewares)简单讲就是自定义扩展下载功能的组件 下载器中间件，是在引擎和下载器之间的特定钩子(specific hook)，处理它们之间的请求request和响应response。 它提供了一个简便的机制，通过插入自定义代码来扩展Scrapy功能 通过设置下载器中间件可以实现爬虫自动更换user-agent、IP等功能 Spider中间件(Spider middlewares)Spider中间件，是在引擎和Spider之间的特定钩子(specific hook)，处理spider的输入(response)和输出(items或requests)。 也提供了同样的简便机制，通过插入自定义代码来扩展Scrapy功能 数据流(Data flow) 引擎打开一个网站(open a domain)，找到处理该网站的Spider并向该spider请求第一个（批）要爬取的URL(s) 引擎从Spider中获取到第一个要爬取的URL并加入到调度器(Scheduler)作为请求以备调度 引擎向调度器请求下一个要爬取的URL 调度器返回下一个要爬取的URL给引擎，引擎将URL通过下载中间件并转发给下载器(Downloader) 一旦页面下载完毕，下载器生成一个该页面的Response，并将其通过下载中间件发送给引擎 引擎从下载器中接收到Response，然后通过Spider中间件发送给Spider处理 Spider处理Response并返回提取到的Item及(跟进的)新的Request给引擎 引擎将Spider返回的Item交给Item Pipeline，将Spider返回的Request交给调度器 (从第二步)重复执行，直到调度器中没有待处理的request，引擎关闭 注意：只有当调度器中没有任何request了，整个程序才会停止执行。如果有下载失败的URL，会重新下载 安装scrapy 安装wheel支持$ pip install wheel 安装scrapy框架$ pip install scrapy window下，为了避免windows编译安装twisted依赖，安装下面的二进制包$ pip install Twisted-18.4.0-cp35-cp35m-win_amd64.whl windows下出现如下问题123456789101112copying src\twisted\words\xish\xpathparser.g -&gt; build\lib.win-amd64-3.5\twisted\words\xish running build_ext building &apos;twisted.test.raiser&apos; extension error: Microsoft Visual C++ 14.0 is required. Get it with &quot;Microsoft Visual C++ Build Tools&quot;: http://landinghub.visualstudio.com/visual-cpp-build-tools解决方案是，下载编译好的twisted，https://www.lfd.uci.edu/~gohlke/pythonlibs/#twistedpython3.5 下载 Twisted-18.4.0-cp35-cp35m-win_amd64.whlpython3.6 下载 Twisted-18.4.0-cp36-cp36m-win_amd64.whl安装twisted$ pip install Twisted-18.4.0-cp35-cp35m-win_amd64.whl之后在安装scrapy就没有什么问题了 安装好，使用scrapy命令看看123456789101112131415161718192021&gt; scrapyScrapy 1.5.0 - no active projectUsage: scrapy &lt;command&gt; [options] [args] Available commands: bench Run quick benchmark test check Check spider contracts crawl Run a spider edit Edit spider fetch Fetch a URL using the Scrapy downloader genspider Generate new spider using pre-defined templates list List available spiders parse Parse URL (using its spider) and print the results runspider Run a self-contained spider (without creating a project) settings Get settings values shell Interactive scraping console startproject Create new project version Print Scrapy version view Open URL in browser, as seen by Scrapy Scrapy开发项目编写流程 创建项目使用 scrapy startproject proname 创建一个scrapy项目scrapy startproject &lt;project_name&gt; [project_dir] 编写item在items.py中编写Item类，明确从response中提取的item 编写爬虫编写spiders/proname_spider.py，即爬取网站的spider并提取出item 编写item pipelineitem的处理，可以存储1 创建项目豆瓣书评爬取 标签为“编程”，第一页、第二页链接https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=Thttps://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=20&amp;type=T 随便找一个目录来创建项目，执行下面命令$ scrapy startproject first .会产生如下目录和文件12345678910first ├─ scrapy.cfg └─ first ├─ items.py ├─ middlewares.py ├─ pipelines.py ├─ settings.py ├─ __init__.py └─ spiders └─ __init__.py first：外部的first目录是整个项目目录，内部的first目录是整个项目的全局目录 scrapy.cfg：必须有的重要的项目的配置文件 first 项目目录 __init__.py 必须有，包文件 items.py 定义Item类，从scrapy.Item继承，里面定义scrapy.Field类实例 pipelines.py 重要的是process_item()方法，处理item settings.py： BOT_NAME 爬虫名 ROBOTSTXT_OBEY = True 是否遵从robots协议 USER_AGENT = &#39;&#39; 指定爬取时使用 CONCURRENT_REQEUST = 16 默认16个并行 DOWNLOAD_DELAY = 3 下载延时，一般要设置，不宜过快发起连续请求 COOKIES_ENABLED = False 缺省是启用，一般需要登录时才需要开启cookie SPIDER_MIDDLEWARES 爬虫中间件 DOWNLOADER_MIDDLEWARES 下载中间件 &#39;first.middlewares.FirstDownloaderMiddleware&#39;: 543543 越小优先级越高 ITEM_PIPELINES 管道配置 &#39;firstscrapy.pipelines.FirstscrapyPipeline&#39;: 300item交给哪一个管道处理，300 越小优先级越高 spiders目录 __init__.py 必须有，可以在这里写爬虫类，也可以写爬虫子模块123456789101112# first/settings.py参考BOT_NAME = 'first'SPIDER_MODULES = ['first.spiders']NEWSPIDER_MODULE = 'first.spiders'USER_AGENT = "Mozilla/5.0 (Windows NT 6.1)AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 Safari/537.36"ROBOTSTXT_OBEY = FalseDOWNLOAD_DELAY = 3# Disable cookies (enabled by default)COOKIES_ENABLED = False 注意一定要更改User-Agent，否则访问 https://book.douban.com/ 会返回403 2 编写Item在items.py中编写12345import scrapyclass BookItem(scrapy.Item): title = scrapy.Field() # 书名 rate = scrapy.Field() # 评分 3 编写爬虫为爬取豆瓣书评编写爬虫类，在spiders目录下 编写的爬虫类需要继承自scrapy.Spider，在这个类中定义爬虫名、爬取范围、其实地址等 在scrapy.Spider中parse方法未实现，所以子类应该实现parse方法。该方法传入response对象 1234# scrapy源码中class Spider(): def parse(self, response): # 解析返回的内容 raise NotImplementedError 爬取读书频道，tag为“编程”的书名和评分https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=20&amp;type=T使用模板创建spider， $ scrapy genspider -t basic book douban.com12345678910111213import scrapyclass BookSpider(scrapy.Spider): # BookSpider name = 'doubanbook' # 爬虫名，可修改，重要 allowed_domains = ['douban.com'] # 爬虫爬取范围 url = 'https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=T' start_urls = [url] # 起始URL # 下载器获取了WEB Server的response就行了，parse就是解析响应的内容 def parse(self, response): print(type(response), '~~~~~~~~~') #scrapy.http.response.html.HtmlResponse print(response) print('-' * 30) 使用crawl爬取子命令123456789$ scrapy list$ scrapy crawl -hscrapy crawl [options] &lt;spider&gt;指定爬虫名称开始爬取$ scrapy crawl doubanbook可以不打印日志$ scrapy crawl doubanbook --nolog 如果在windows下运行发生twisted的异常 ModuleNotFoundError: No module named &#39;win32api&#39; ，请安装 $ pip install pywin32 response是服务器端HTTP响应，它是scrapy.http.response.html.HtmlResponse类。由此，修改代码如下12345678910111213141516171819202122import scrapyfrom scrapy.http.response.html import HtmlResponseclass BookSpider(scrapy.Spider): # BookSpider name = 'doubanbook' # 爬虫名 allowed_domains = ['douban.com'] # 爬虫爬取范围 url = 'https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=T' start_urls = [url] # 起始URL # 下载器获取了WEB Server的response就行了，parse就是解析响应的内容 def parse(self, response:HtmlResponse): print(type(response)) #scrapy.http.response.html.HtmlResponse print('-'*30) print(type(response.text), type(response.body)) print('-'*30) print(response.encoding) with open('o:/testbook.html', 'w', encoding='utf-8') as f: try: f.write(response.text) f.flush() except Exception as e: print(e) 3.1 解析HTML爬虫获得的内容response对象，可以使用解析库来解析scrapy包装了lxml，父类TextResponse类也提供了xpath方法和css方法，可以混合使用这两套接口解析HTML 选择器参考 https://scrapy-chs.readthedocs.io/zh_CN/0.24/topics/selectors.html#id31234567891011121314151617181920212223242526272829303132333435363738394041424344454647import scrapyfrom scrapy.http.response.html import HtmlResponseresponse = HtmlResponse('file:///O:/testbook.html', encoding='utf-8') # 构造对象with open('o:/testbook.html', encoding='utf8') as f: response._set_body(f.read()) # 填充数据 #print(response.text) # 获取所有标题及评分 # xpath解析 subjects = response.xpath('//li[@class="subject-item"]') for subject in subjects: title = subject.xpath('.//h2/a/text()').extract() # list print(title[0].strip()) rate = subject.xpath('.//span[@class="rating_nums"]/text()').extract() print(rate[0].strip()) print('-'*30) # css解析 subjects = response.css('li.subject-item') for subject in subjects: title = subject.css('h2 a::text').extract() print(title[0].strip()) rate = subject.css('span.rating_nums::text').extract() print(rate[0].strip()) print('-'*30) # xpath和css混合使用、正则表达式匹配 subjects = response.css('li.subject-item') for subject in subjects: # 提取链接 href =subject.xpath('.//h2').css('a::attr(href)').extract() print(href[0]) # 使用正则表达式 id = subject.xpath('.//h2/a/@href').re(r'\d*99\d*') if id: print(id[0]) # 要求显示9分以上数据 rate = subject.xpath('.//span[@class="rating_nums"]/text()').re(r'^9.*') # rate = subject.css('span.rating_nums::text').re(r'^9\..*') if rate: print(rate) 3.2 item封装数据123456789101112131415161718192021222324252627282930313233# spiders/bookspider.pyimport scrapyfrom scrapy.http.response.html import HtmlResponsefrom ..items import BookItemclass BookSpider(scrapy.Spider): # BookSpider name = 'doubanbook' # 爬虫名 allowed_domains = ['douban.com'] # 爬虫爬取范围 url = 'https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=T' start_urls = [url] # 起始URL # 下载器获取了WEB Server的response就行了，parse就是解析响应的内容 def parse(self, response:HtmlResponse): items = [] # xpath解析 subjects = response.xpath('//li[@class="subject-item"]') for subject in subjects: title = subject.xpath('.//h2/a/text()').extract() rate = subject.xpath('.//span[@class="rating_nums"]/text()').extract_first() item = BookItem() item['title'] = title[0].strip() item['rate'] = rate.strip() items.append(item) print(items) return items # 一定要return，否则保存不下来 # 使用命令保存return的数据# scrapy crawl -h# --output=FILE, -o FILE dump scraped items into FILE (use - for stdout)# 文件扩展名支持'json', 'jsonlines', 'jl', 'csv', 'xml', 'marshal', 'pickle'# scrapy crawl doubanbook -o dbbooks.json 得到下图数据注意上图的数据已经是unicode字符，汉字的unicode表达 4 pipeline处理将bookspider.py中BookSpider改成生成器，只需要把 return items 改造成 yield item ，即由产生一个列表变成yield一个个item 脚手架帮我们创建了一个pipelines.py文件和一个类 4.1 开启pipeline12345# Configure item pipelines# See https://doc.scrapy.org/en/latest/topics/item-pipeline.htmlITEM_PIPELINES = &#123; 'first.pipelines.FirstPipeline': 300,&#125; 整数300表示优先级，越小越高。取值范围为0-1000 4.2 常用方法 名称 参数 process_item(self, item, spider) item爬取的一个个数据spider表示item的爬取者每一个item处理都调用返回一个Item对象，或抛出DropItem异常被丢弃的Item对象将不会被之后的pipeline组件处理 必须 open_spider(self, spider) spider表示被开启的spider 调用一次 可选 close_spider(self, spider) spider表示被关闭的spider 调用一次 可选 __init__(self) spider实例创建时调用一次 可选 常用方法12345678910111213class FirstPipeline(object): def __init__(self): # 全局设置 print('~~~~~~~~~~ init ~~~~~~~~~~~~') def open_spider(self, spider): # 当某spider开启时调用 print(spider,'~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~') def process_item(self, item, spider): # item 获取的item；spider 获取该item的spider return item def close_spider(self, spider): # 当某spider关闭时调用 print(spider,'========================================') 需求通过pipeline将爬取的数据存入json文件中123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# spider/bookspider.pyimport scrapyfrom scrapy.http.response.html import HtmlResponsefrom ..items import BookItemclass BookSpider(scrapy.Spider): # BookSpider name = 'doubanbook' # 爬虫名 allowed_domains = ['douban.com'] # 爬虫爬取范围 url = 'https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=T' start_urls = [url] # 起始URL # spider上自定义配置信息 custom_settings = &#123; 'filename' : 'o:/books.json' &#125; # 下载器获取了WEB Server的response就行了，parse就是解析响应的内容 def parse(self, response:HtmlResponse): #items = [] # xpath解析 subjects = response.xpath('//li[@class="subject-item"]') for subject in subjects: title = subject.xpath('.//h2/a/text()').extract() rate =subject.xpath('.//span[@class="rating_nums"]/text()').extract_first() item = BookItem() item['title'] = title[0].strip() item['rate'] = rate.strip() #items.append(item) yield item #return items# pipelines.pyimport simplejson as jsonclass FirstPipeline(object): def __init__(self): # 全局设置 print('~~~~~~~~~~ init ~~~~~~~~~~~~') def open_spider(self, spider): # 当某spider开启时调用 print('&#123;&#125; ~~~~~~~~~~~~~~~~~~~~'.format(spider)) print(spider.settings.get('filename')) self.file = open(spider.settings['filename'], 'w', encoding='utf-8') self.file.write('[\n') def process_item(self, item, spider): # item 获取的item；spider 获取该item的spider self.file.write(json.dumps(dict(item)) + ',\n') return item def close_spider(self, spider): # 当某spider关闭时调用 self.file.write(']') self.file.close() print('&#123;&#125; ======================='.format(spider)) print('-'*30) 5 url提取如果要爬取下一页内容，可以自己分析每一页的页码变化，也可以通过提取分页栏的链接12345678910111213141516171819202122232425262728293031323334353637383940414243# spider/bookspider.pyimport scrapyfrom scrapy.http.response.html import HtmlResponsefrom ..items import BookItemclass BookSpider(scrapy.Spider): # BookSpider name = 'doubanbook' # 爬虫名 allowed_domains = ['douban.com'] # 爬虫爬取范围 url = 'https://book.douban.com/tag/%E7%BC%96%E7%A8%8B?start=0&amp;type=T' start_urls = [url] # 起始URL # spider上自定义配置信息 custom_settings = &#123; 'filename' : 'o:/books.json' &#125; # 下载器获取了WEB Server的response就行了，parse就是解析响应的内容 def parse(self, response:HtmlResponse): #items = [] # xpath解析 # 获取下一页，只是测试，所以使用re来控制页码 print('-' * 30) urls = response.xpath('//div[@class="paginator"]/span[@class="next"]/a/@href').re( r'.*start=[24]\d[^\d].*') print(urls) print('-' * 30) yield from (scrapy.Request(response.urljoin(url)) for url in urls) print('++++++++++++++++++++++++') subjects = response.xpath('//li[@class="subject-item"]') for subject in subjects: # 解决图书副标题拼接 title = "".join(map(lambda x:x.strip(), subject.xpath('.//h2/a//text()').extract())) rate = subject.xpath('.//span[@class="rating_nums"]/text()').extract_first() #print(rate) # 有的没有评分，要注意可能返回None item = BookItem() item['title'] = title item['rate'] = rate #items.append(item) yield item #return items]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[http解析, json解析]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E7%88%AC%E8%99%AB%20--%20HTML%E8%A7%A3%E6%9E%90%E3%80%81Json%E8%A7%A3%E6%9E%90%2F</url>
    <content type="text"><![CDATA[HTML解析HTML的内容返回给浏览器，浏览器就会解析它，并对它渲染 HTML 超文本表示语言设计的初衷就是为了超越普通文本，让文本表现力更强 XML 扩展标记语言，不是为了代替HTML，而是觉得HTML的设计中包含了过多的格式，承担了一部分数据之外的任务，所以才设计了XML只用来描述数据 HTML和XML都有结构，使用标记形成树型的嵌套结构DOM（Document Object Model）来解析这种嵌套树型结构，浏览器往往都提供了对DOM操作的API，可以用面向对象的方式来操作DOM XPathhttp://www.w3school.com.cn/xpath/index.asp 中文教程XPath 是一门在 XML 文档中查找信息的语言。XPath 可用来在 XML 文档中对元素和属性进行遍历 工具XMLQuire win7+需要.NET框架4.0-4.5。测试XML、XPath 12345678910111213141516171819202122232425262728293031323334353637383940414243&lt;?xml version="1.0" encoding="utf-8"?&gt;&lt;bookstore&gt; &lt;book id="bk101"&gt; &lt;author&gt;Gambardella, Matthew&lt;/author&gt; &lt;title&gt;XML Developer's Guide&lt;/title&gt; &lt;genre&gt;Computer&lt;/genre&gt; &lt;price&gt;44.95&lt;/price&gt; &lt;publish_date&gt;2000-10-01&lt;/publish_date&gt; &lt;description&gt;An in-depth look at creating applications with XML.&lt;/description&gt; &lt;/book&gt; &lt;book id="bk102" class="bookinfo even"&gt; &lt;author&gt;Ralls, Kim&lt;/author&gt; &lt;title&gt;Midnight Rain&lt;/title&gt; &lt;genre&gt;Fantasy&lt;/genre&gt; &lt;price&gt;5.95&lt;/price&gt; &lt;publish_date&gt;2000-12-16&lt;/publish_date&gt; &lt;description&gt;A former architect battles corporate zombies, an evil sorceress, and her own childhood to become queen of the world.&lt;/description&gt; &lt;/book&gt; &lt;book id="bk103"&gt; &lt;author&gt;Corets, Eva&lt;/author&gt; &lt;title&gt;Maeve Ascendant&lt;/title&gt; &lt;genre&gt;Fantasy&lt;/genre&gt; &lt;price&gt;5.95&lt;/price&gt; &lt;publish_date&gt;2000-11-17&lt;/publish_date&gt; &lt;description&gt;After the collapse of a nanotechnology society in England, the young survivors lay the foundation for a new society.&lt;/description&gt; &lt;/book&gt; &lt;book id="bk104"&gt; &lt;author&gt;Corets, Eva&lt;/author&gt; &lt;title&gt;Oberon's Legacy&lt;/title&gt; &lt;genre&gt;Fantasy&lt;/genre&gt; &lt;price&gt;5.95&lt;/price&gt; &lt;publish_date&gt;2001-03-10&lt;/publish_date&gt; &lt;description&gt;In post-apocalypse England, the mysterious agent known only as Oberon helps to create a new life for the inhabitants of London. Sequel to Maeve Ascendant.&lt;/description&gt; &lt;/book&gt;&lt;/bookstore&gt; 节点在 XPath 中，有七种类型的节点：元素、属性、文本、命名空间、处理指令、注释以及文档（根）节点 /根结点 &lt;bookstore&gt; 元素节点 &lt;author&gt;Corets, Eva&lt;/author&gt; 元素节点 id=&quot;bk104&quot; 是属性节点，id是元素节点book的属性 节点之间的嵌套形成父子(parent、children)关系具有同一个父节点的不同节点是兄弟(sibling)关系 节点选择 操作符或表达式 含义 / 从根节点开始找 // 从当前节点开始的任意层找 . 当前节点 .. 当前节点的父节点 @ 选择属性 节点名 选取所有这个节点名的节点 * 匹配任意元素节点 @* 匹配任意属性节点 node() 匹配任意类型的节点 text() 匹配text类型节点 谓语（Predicates）谓语用来查找某个特定的节点或者包含某个指定的值的节点 谓语被嵌在方括号中 谓语就是查询的条件即在路径选择时，在中括号内指定查询条件XPath 轴（Axes）轴的意思是相对于当前节点的节点集| 轴名称| 结果 ||:–|:–||ancestor |选取当前节点的所有先辈（父、祖父等）||ancestor-or-self |选取当前节点的所有先辈（父、祖父等）以及当前节点本身||attribute |选取当前节点的所有属性@id 等价于 attribute::id||child| 选取当前节点的所有子元素title 等价于 child:title||descendant |选取当前节点的所有后代元素（子、孙等）||descendant-or-self |选取当前节点的所有后代元素（子、孙等）以及当前节点本身||following |选取文档中当前节点的结束标签之后的所有节点||namespace |选取当前节点的所有命名空间节点||parent |选取当前节点的父节点||preceding| 直到所有这个节点的父辈节点，顺序选择每个父辈节点前的所有同级节点||preceding-sibling |选取当前节点之前的所有同级节点||self |选取当前节点. 等价于 self::node()|步Step步的语法 轴名称::节点测试[谓语]| 例子| 结果 ||:–|:–||child::book |选取所有属于当前节点的子元素的 book 节点 ||attribute::lang |选取当前节点的 lang 属性 ||child::* |选取当前节点的所有子元素 ||attribute::* |选取当前节点的所有属性 ||child::text() |选取当前节点的所有文本子节点 ||child::node() |选取当前节点的所有子节点 ||descendant::book |选取当前节点的所有 book 后代 ||ancestor::book | 选择当前节点的所有 book 先辈 ||ancestor-or-self::book |选取当前节点的所有 book 先辈以及当前节点（如果此节点是 book 节点） ||child::*/child::price |选取当前节点的所有 price 孙节点 | XPATH实例以斜杠开始的称为绝对路径，表示从根开始 不以斜杆开始的称为相对路径，一般都是依照当前节点来计算。当前节点在上下文环境中，当前节点很可能已经不是根节点了 一般为了方便，往往xml如果层次很深，都会使用//来查找节点| 路径表达式| 含义 ||:–|:–||title |选取当前节点下所有title子节点||/book |从根结点找子节点是book的，找不到||book/title |当前节点下所有子节点book下的title节点||//title |从根节点向下找任意层中title的节点||book//title |当前节点下所有book子节点下任意层次的title节点||//@id |任意层下含有id的 属性，取回的是属性||//book[@id]| 任意层下含有id属性的book节点||//*[@id]| 任意层下含有id属性的节点||//book[@id=&quot;bk102&quot;]| 任意层下含有id属性且等于’bk102’的book节点||/bookstore/book[1] |根节点bookstore下第一个book节点，从1开始||/bookstore/book[1]/@id| 根节点bookstore下第一个book节点的id属性||/bookstore/book[last()-1]| 根节点bookstore下倒数第二个book节点，函数last()||/bookstore/*| 匹配根节点bookstore的所有子节点，不递归||//*| 匹配所有子孙节点||//*[@*]| 匹配所有有属性的节点||//book[@*]| 匹配所有有属性的book节点||//@*| 匹配所有属性||//book/title| //price |匹配book下的title节点或者任意层下的price||//book[position()=2]| 匹配book节点，取第二个||//book[position()&lt;last()-1] |匹配book节点，取位置小于倒数第二个||//book[price&gt;40]| 匹配price节点值大于40的book节点||//book[2]/node() |匹配位置为2的book节点下的所有类型的节点||//book[1]/text()| 匹配第一个book节点下的所有文本子节点||//book[1]//text()| 匹配第一个book节点下的所有文本节点||//*[local-name()=&#39;book&#39;]|匹配所有节点且不带限定名的节点名称为book的所有节点local-name函数取不带限定名的名称||//book/child::node()[local-name()=&#39;price&#39; and text()&lt;10]|所有book节点的子节点中名字叫做price的且其内容小于10的节点等价于 //book/price[text()&lt;10]|||//book[price&lt;6]/price //book/price[text()&lt;6] //book/child::node()[local-name()=&#39;price&#39; and text()&lt;6] 这三种等价 ||//book//*[self::title or self::price]|所有book节点下子孙节点，这些节点是title或者price等价于//book//title | //book/price 也等价于//book//*[local-name()=&#39;title&#39; or local￾name()=&#39;price&#39;]|//*[@class]| 所有有class属性的节点||//*[@class=&quot;bookinfo even&quot;]| 所有属性为&quot;bookinfo even&quot;的节点||//*[contains(@class, &#39;even&#39;)] |属性class中包含even字符串的节点||//*[contains(local-name(), &#39;book&#39;)]| 标签名包含book的节点|1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950//book/title//book//title//titletitle//div//@*//*[@id]//* 元素节点//text() 文本//node() 全部节点/bookstore//*//book[@id="bk102"]//book[2]//book[2]/title//book[2]/title/text()//book[last()]/title/text()//book[last()]//text()//book[last()-1]/title//book[last()-1]/@id//book/title | //book/price//book/title | //book/price | //book//text()//book[position()=2]//book[position()=1 or position()=3]//book[position()&gt;1 and position()&lt;4]//book[position() &lt; last()]/title//*[local-name()='book'] 等价 //book//book[price]/price/text()//book[price &gt; 40]/price//book/price/text()//book/child::node()[local-name()="price" and text() &gt; 10]//book/child::price//title/../self::node()//title/ancestor::node()//title/ancestor::node()[starts-with(local-name(), 'book')]//title/ancestor::node()[contains(local-name(), 'store')]//book//*[self::price or self::title] 等价 //book/title | //book/price//book//node()[self::price or self::title]//book//@class //book//*[@class]&lt;book id="bk102" class="bookinfo even"&gt;//*[@class]//book[@class="bookinfo even"] =表示exact//book[contains(@class, 'bookinfo')]//book[contains(@class, 'even')] lxmllxml是Python下功能丰富的XML、HTML解析库，性能非常好，是对libxml2 和 libxslt的封装 最新版支持Python 2.6+，python3支持到3.6 CentOS编译安装需要1# yum install libxml2-devel libxslt-devel 注意，不同平台不一样，参看 http://lxml.de/installation.html lxml安装$ pip install lxml123456789101112131415161718192021222324252627282930from lxml import etreeroot = etree.Element('html')print(type(root)) # &lt;class 'lxml.etree._Element'&gt;print(root.tag) # htmlbody = etree.Element('body')root.append(body)print(etree.tostring(root)) # b'&lt;html&gt;&lt;body/&gt;&lt;/html&gt;'sub = etree.SubElement(body, 'child1') # 增加子节点print(type(sub)) # &lt;class 'lxml.etree._Element'&gt;sub = etree.SubElement(body, 'child2').append(etree.Element('child21'))html = etree.tostring(root, pretty_print=True).decode()print(html)#&lt;html&gt;# &lt;body&gt;# &lt;child1/&gt;# &lt;child2&gt;# &lt;child21/&gt;# &lt;/child2&gt;# &lt;/body&gt;#&lt;/html&gt;r = etree.HTML(html)print(r.tag) # htmlprint(r.xpath('//*[contains(local-name(), "child")]'))# [&lt;Element child1 at 0x1ee49c1de08&gt;, &lt;Element child2 at 0x1ee49c1ddc8&gt;, &lt;Element child21 at 0x1ee49c1de48&gt;] etree还提供了2个有用的函数 etree.HTML(text) 解析HTML文档，返回根节点 anode.xpath(&#39;xpath路径&#39;) 对节点使用xpath语法练习：爬取“口碑榜”从豆瓣电影中提取“本周口碑榜”1234567891011121314151617181920212223242526from lxml import etreeimport requestsurl = 'https://movie.douban.com'ua = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) " \ "Chrome/55.0.2883.75 Safari/537.36"with requests.get(url, headers=&#123;'User-agent':ua&#125;) as response: content = response.text # HTML内容 html = etree.HTML(content) # 分析HTML，返回DOM根节点 titles = html.xpath("//div[@class='billboard-bd']//tr/td/a/text()") # 返回文本列表 for t in titles: # 豆瓣电影之 本周口碑榜 print(t)# 执行结果 哪吒之魔童降世痛苦与荣耀疾速备战老男孩策马狂奔1988年的妮可尤利了不起的巴斯特铁道：家色惊慌妈妈 BeautifulSoup4BeautifulSoup可以从HTML、XML中提取数据。目前BS4在持续开发 官方中文文档https://www.crummy.com/software/BeautifulSoup/bs4/doc.zh/ 安装$ pip install beautifulsoup4 导入from bs4 import BeautifulSoup 初始化BeautifulSoup(markup=&quot;&quot;, features=None) markup，被解析对象，可以是文件对象或者html字符串 features指定解析器 返回一个文档对象 1234567from bs4 import BeautifulSoup# 文件对象soup = BeautifulSoup(open("test.html"))# 标记字符串soup = BeautifulSoup("&lt;html&gt;data&lt;/html&gt;") 可以不指定解析器，就依赖系统已经安装的解析器库了 BeautifulSoup(markup, &quot;html.parser&quot;) 使用Python标准库，容错差且性能一般 BeautifulSoup(markup, &quot;lxml&quot;) 容错能力强，速度快。需要安装系统C库 推荐使用lxml作为解析器，效率高 请手动指定解析器，以保证代码在所有运行环境中解析器一致 使用下面内容构建test.html使用bs4解析它12345678910111213141516171819202122&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;helloworld&lt;/h1&gt;&lt;div id="main"&gt; &lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt; &lt;div class="content"&gt; &lt;p id='first'&gt;字典&lt;/p&gt; &lt;p id='second'&gt;列表&lt;/p&gt; &lt;input type="hidden" name="_csrf" value="7139e401481ef2f46ce98b22af4f4bed"&gt; &lt;!-- comment --&gt; &lt;img id="bg1" src="http://www.bing.cn/"&gt; &lt;img id="bg2" src="http://httpbin.org/"&gt; &lt;/div&gt;&lt;/div&gt;&lt;p&gt;bottom&lt;/p&gt;&lt;/body&gt;&lt;/html&gt; 四种对象BeautifulSoup将HTML文档解析成复杂的树型结构，每个节点都是Python的对象，可分为4种： BeautifulSoup、Tag、NavigableString、Comment BeautifulSoup对象BeautifulSoup对象代表整个文档 Tag对象它对应着HTML中的标签。有2个常用的属性： name：Tag对象的名称，就是标签名称 attrs：标签的属性字典 多值属性，对于class属性可能是下面的形式， &lt;h3 class=&quot;title highlight&quot;&gt;python高级班&lt;/h3&gt; ，这个属性就是多值({&#39;class&#39;: [&#39;title&#39;, &#39;highlight&#39;]}) 属性可以被修改、删除123456789101112131415161718192021from bs4 import BeautifulSoupwith open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') print(soup.builder) # &lt;bs4.builder._lxml.LXMLTreeBuilder object at 0x000001D75A2D5C88&gt; print(soup) # 输出整个解析的文档对象 print(soup.prettify()) # # 格式输出 print(soup.div, type(soup.div)) # bs4.element.Tag, Tag对象 print(soup.div.name, soup.div.attrs) # div &#123;'id': 'main'&#125; print(soup.div['class']) # KeyError: div没有class属性 print(soup.div.get('class')) # None print(soup.h3['class']) # 多值属性 ['title', 'highlight'] print(soup.h3.get('class')) # ['title', 'highlight'] print(soup.h3.attrs.get('class')) # ['title', 'highlight'] print(soup.img.get('src')) # http://www.bing.cn/ soup.img['src'] = 'http://www.python.org/'# 修改属性 print(soup.img['src']) # http://www.python.org/ print(soup.a) # 找不到返回None del soup.h3['class'] # 删除属性 print(soup.h3.get('class')) # None 注意，一般不使用上面这种方式来操作HTML，此代码是为了熟悉对象类型 NavigableString如果只想输出标记内的文本，而不关心标记的话，就要使用NavigableString12print(soup.div.p.string) # 第一个div下第一个p的字符串print(soup.p.string) # 同上 注释对象这就是HTML中的注释，它被BeautifulSoup解析后对应Comment对象 遍历文档树在文档树中找到关心的内容才是日常的工作，也就是说如何遍历树中的节点。使用上面的test.html来测试 使用Tag soup.div 可以找到从根节点开始查找第一个div节点 soup.div.p 说明从根节点开始找到第一个div后返回一个Tag对象，这个Tag对象下继续找第一个p，找到返回Tag对象 soup.p 说明遍历是深度优先，返回了文字“字典”，而不是文字“bottom” 遍历直接子节点 print(soup.div.contents) # 将对象的所有类型直接子节点以列表方式输出 print(soup.div.children) # 返回子节点的迭代器 print(list(soup.div.children)) # 等价于soup.div.contents 遍历所有子孙节点print(list(soup.div.descendants)) # 返回第一个div节点的所有类型子孙节点，可以看出迭代次序是深度优先1234567891011121314151617181920212223242526272829303132333435from bs4 import BeautifulSoupfrom bs4.element import Tagwith open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') print(soup.p.string) # 字典 print('-' * 30) print(soup.div.contents) print('=' * 30) for c in soup.div.children: print(c.name) print('~' * 30) print(list(map( lambda x:x.name if x.name else x, soup.div.descendants)))# 执行结果字典------------------------------['\n', &lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;, '\n', &lt;div class="content"&gt;&lt;p id="first"&gt;字典&lt;/p&gt;&lt;p id="second"&gt;列表&lt;/p&gt;&lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;&lt;!-- comment --&gt;&lt;img id="bg1" src="http://www.bing.cn/"/&gt;&lt;img id="bg2" src="http://httpbin.org/"/&gt;&lt;/div&gt;, '\n']==============================Noneh3NonedivNone~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~['\n', 'h3', 'python高级班', '\n', 'div', '\n', 'p', '字典', '\n', 'p', '列表', '\n', 'input', '\n', ' comment ', '\n', 'img', '\n', 'img', '\n', '\n'] 遍历字符串在前面的例子中，soup.div.string返回None，是因为string要求soup.div只能有一个NavigableString类型子节点，也就是如这样 &lt;div&gt;only string&lt;/div&gt; 如果div有很多子孙节点，如何提取字符串123print(soup.div.string) # 返回None，因为多于1个子节点print("".join(soup.div.strings)) # 返回迭代器，带多余的空白字符print("".join(soup.div.stripped_strings)) # 返回迭代器，去除多余空白符 遍历祖先节点1234print(soup.parent) # None 根节点没有父节点print(soup.div.parent.name) # body，第一个div的父节点print(soup.p.parent.parent.get('id')) # 取id属性，mainprint(list(map(lambda x: x.name, soup.p.parents))) # 父迭代器，由近及远 遍历兄弟节点123print('&#123;&#125; [&#123;&#125;]'.format(1, soup.p.next_sibling)) # 第一个p元素的下一个兄弟节点，注意可能是一个文本节点print('&#123;&#125; [&#123;&#125;]'.format(2, soup.p.previous_sibling))print(list(soup.p.next_siblings)) # previous_siblings 遍历其他元素next_element是下一个可被解析的对象（字符串或tag），和下一个兄弟节点next_sibling不一样123print(soup.p.next_element) # 返回"字典"2个字print(soup.p.next_element.next_element.next_element)print(list(soup.p.next_elements)) 12345678910111213141516171819202122232425262728293031323334from bs4 import BeautifulSoupfrom bs4.element import Tagwith open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') # 字典 print(soup.p.next_element) print('-' * 30) print(soup.p.next_element.next_element.next_element) print('=' * 30) print(soup.p.next_sibling.next_sibling.next_sibling) print('~' * 30) # 对比下面的差异 print(list(soup.p.next_elements)) print('*' * 30) print(list(soup.p.next_siblings))# 执行结果字典------------------------------&lt;p id="second"&gt;列表&lt;/p&gt;==============================~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~['字典', '\n', &lt;p id="second"&gt;列表&lt;/p&gt;, '列表', '\n',\ &lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;, \ '\n', ' comment ', '\n', &lt;img id="bg1" src="http://www.bing.cn/"/&gt;, \ '\n', &lt;img id="bg2" src="http://httpbin.org/"/&gt;, '\n', '\n', '\n', &lt;p&gt;bottom&lt;/p&gt;, 'bottom', '\n', '\n']******************************['\n', &lt;p id="second"&gt;列表&lt;/p&gt;, '\n', &lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;, \'\n', ' comment ', '\n', &lt;img id="bg1" src="http://www.bing.cn/"/&gt;, '\n', \&lt;img id="bg2" src="http://httpbin.org/"/&gt;, '\n'] 搜索文档树find系有很多方法，请自行查帮助 find_all方法，立即返回一个列表find_all(name=None, attrs={}, recursive=True, text=None, limit=None, **kwargs) name官方称为filter过滤器，这个参数可以是以下类型： 字符串一个标签名称的字符串，会按照这个字符串全长匹配标签名 1print(soup.find_all('p')) # 返回文档中所有p标签 正则表达式对象按照“正则表达式对象”的模式匹配标签名 1import reprint(soup.find_all(re.compile('^h\d'))) # 标签名以h开头后接数字 列表 12print(soup.find_all(['p', 'h1', 'h3'])) # 或关系，找出列表所有的标签print(soup.find_all(re.compile(r'^(p|h\d)$'))) # 使用正则完成 True或NoneTrue或None，则find_all返回全部非字符串节点、非注释节点，就是Tag标签类型 123print(list(map(lambda x:x.name, soup.find_all(True))))print(list(map(lambda x:x.name, soup.find_all(None))))print(list(map(lambda x:x.name, soup.find_all()))) 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071from bs4 import BeautifulSoupfrom bs4.element import Tagwith open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') values = [True, None, False] for value in values: all = soup.find_all(value) print(type(all[0])) print(len(all)) print('-' * 30) count = 0 for i,t in enumerate(soup.descendants): print(i, type(t), t.name) if isinstance(t, Tag):# 只对Tag类型计数 count +=1 print(count)# 执行结果&lt;class 'bs4.element.Tag'&gt;15&lt;class 'bs4.element.Tag'&gt;15&lt;class 'bs4.element.Tag'&gt;15------------------------------0 &lt;class 'bs4.element.Doctype'&gt; None1 &lt;class 'bs4.element.Tag'&gt; html2 &lt;class 'bs4.element.NavigableString'&gt; None3 &lt;class 'bs4.element.Tag'&gt; head4 &lt;class 'bs4.element.NavigableString'&gt; None5 &lt;class 'bs4.element.Tag'&gt; meta6 &lt;class 'bs4.element.NavigableString'&gt; None7 &lt;class 'bs4.element.Tag'&gt; title8 &lt;class 'bs4.element.NavigableString'&gt; None9 &lt;class 'bs4.element.NavigableString'&gt; None10 &lt;class 'bs4.element.NavigableString'&gt; None11 &lt;class 'bs4.element.Tag'&gt; body12 &lt;class 'bs4.element.NavigableString'&gt; None13 &lt;class 'bs4.element.Tag'&gt; h114 &lt;class 'bs4.element.NavigableString'&gt; None15 &lt;class 'bs4.element.NavigableString'&gt; None16 &lt;class 'bs4.element.Tag'&gt; div17 &lt;class 'bs4.element.NavigableString'&gt; None18 &lt;class 'bs4.element.Tag'&gt; h319 &lt;class 'bs4.element.NavigableString'&gt; None20 &lt;class 'bs4.element.NavigableString'&gt; None21 &lt;class 'bs4.element.Tag'&gt; div22 &lt;class 'bs4.element.NavigableString'&gt; None23 &lt;class 'bs4.element.Tag'&gt; p24 &lt;class 'bs4.element.NavigableString'&gt; None25 &lt;class 'bs4.element.NavigableString'&gt; None26 &lt;class 'bs4.element.Tag'&gt; p27 &lt;class 'bs4.element.NavigableString'&gt; None28 &lt;class 'bs4.element.NavigableString'&gt; None29 &lt;class 'bs4.element.Tag'&gt; input30 &lt;class 'bs4.element.NavigableString'&gt; None31 &lt;class 'bs4.element.Comment'&gt; None32 &lt;class 'bs4.element.NavigableString'&gt; None33 &lt;class 'bs4.element.Tag'&gt; img34 &lt;class 'bs4.element.NavigableString'&gt; None35 &lt;class 'bs4.element.Tag'&gt; img36 &lt;class 'bs4.element.NavigableString'&gt; None37 &lt;class 'bs4.element.NavigableString'&gt; None38 &lt;class 'bs4.element.NavigableString'&gt; None39 &lt;class 'bs4.element.Tag'&gt; p40 &lt;class 'bs4.element.NavigableString'&gt; None41 &lt;class 'bs4.element.NavigableString'&gt; None42 &lt;class 'bs4.element.NavigableString'&gt; None15 数目一致，所以返回的是Tag类型的节点，源码中确实返回的Tag类型 5. 函数 如果使用以上过滤器还不能提取出想要的节点，可以使用函数，此函数仅只能接收一个参数 如果这个函数返回True，表示当前节点匹配；返回False则是不匹配 练习：找出所有有class属性且有多个值的节点符合这个要求只有h3标签12345678910111213from bs4 import BeautifulSoupdef many_classes(tag): # print(type(tag)) # print(tag.attrs) return len(tag.attrs.get('class', [])) &gt; 1with open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') print(soup.find_all(many_classes))# 执行结果[&lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;] keyword传参使用关键字传参，如果参数名不是find系函数已定义的位置参数名，参数会被kwargs收集并被当做标签的属性来搜索属性的传参可以是字符串、正则表达式对象、True、列表123456print(soup.find_all(id='first')) # id为first的所有节点列表print(soup.find_all(id=re.compile('\w+'))) # 相当于找有id的所有节点print(soup.find_all(id=True)) # 所有有id的节点print(list(map(lambda x:x['id'], soup.find_all(id=True))))print(soup.find_all(id=['first', re.compile(r'^sec')])) # 指定id的名称列表print(soup.find_all(id=True, src=True)) # 相当于条件and，既有id又有src属性的节点列表 css的class的特殊处理class是Python关键字，所以使用 class_ 。class是多值属性，可以匹配其中任意一个，也可以可以完全匹配12345print(soup.find_all(class_="content"))print(soup.find_all(class_="title")) # 可以使用任意一个css类print(soup.find_all(class_="highlight")) # 可以使用任意一个css类print(soup.find_all(class_="highlight title")) # 顺序错了，找不到print(soup.find_all(class_="title highlight")) # 顺序一致，找到，就是字符串完全匹配 attrs参数attrs接收一个字典，字典的key为属性名，value可以是字符串、正则表达式对象、True、列表。可以多个属性123456print(soup.find_all(attrs=&#123;'class':'title'&#125;))print(soup.find_all(attrs=&#123;'class':'highlight'&#125;))print(soup.find_all(attrs=&#123;'class':'title highlight'&#125;))print(soup.find_all(attrs=&#123;'id':True&#125;))print(soup.find_all(attrs=&#123;'id':re.compile(r'\d$')&#125;))print(list(map(lambda x:x.name, soup.find_all(attrs=&#123;'id':True, 'src':True&#125;)))) text参数可以通过text参数搜索文档中的字符串内容，接受字符串、正则表达式对象、True、列表123print(list(map(lambda x: (type(x), x),soup.find_all(text=re.compile('\w+')))))# 返回文本类节点print(list(map(lambda x: (type(x), x),soup.find_all(text=re.compile('[a-z]+')))))print(soup.find_all(re.compile(r'^(h|p)'),text=re.compile('[a-z]+')))# 相当于过滤出Tag对象，并看它的string是否符合text参数的要求，返回Tag对象 limit参数限制返回结果的数量1print(soup.find_all(id=True, limit=3)) # 返回列表中有3个结果 recursive 参数默认是递归搜索所有子孙节点，如果不需要请设置为False 简化写法find_all()是非常常用的方法，可以简化省略掉12345678910print(soup('img')) # 所有img标签对象的列表，不等价于soup.imgprint(soup.img) # 深度优先第一个imgprint(soup.a.find_all(text=True)) # 返回文本print(soup.a(text=True)) # 返回文本，和上面等价print(soup('a', text=True)) # 返回a标签对象print(soup.find_all('img', attrs=&#123;'id':'bg1'&#125;))print(soup('img', attrs=&#123;'id':'bg1'&#125;)) # find_all的省略print(soup('img', attrs=&#123;'id':re.compile('1')&#125;)) find方法find( name , attrs , recursive , text , **kwargs )参数几乎和find_all一样 找到了，find_all返回一个列表，而find返回一个单值，元素对象 找不到，find_all返回一个空列表，而find返回一个None123print(soup.find('img', attrs=&#123;'id':'bg1'&#125;).attrs.get('src', 'magedu'))print(soup.find('img', attrs=&#123;'id':'bg1'&#125;).get('src')) # 简化了attrsprint(soup.find('img', attrs=&#123;'id':'bg1'&#125;)['src']) CSS选择器和JQuery一样，可以使用CSS选择器来查找节点 使用soup.select()方法，select方法支持大部分CSS选择器，返回列表 CSS中，标签名直接使用，类名前加.点号，id名前加#井号 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475from bs4 import BeautifulSoupdef many_classes(tag): # print(type(tag)) # print(tag.attrs) return len(tag.attrs.get('class', [])) &gt; 1with open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') # 元素选择器 print(1, soup.select('p')) # 所有的p标签 # 类选择器 print(2, soup.select('.title')) # 使用了伪类 # 直接子标签是p的同类型的所有p标签中的第二个 # （同类型）同标签名p的第2个，伪类只实现了nth-of-type，且要求是数字 print(3, soup.select('div.content &gt; p:nth-of-type(2)')) # 只实现了这个伪类 # id选择器 print(4, soup.select('p#second')) print(5, soup.select('#bg1')) # 后代选择器 print(6, soup.select('div p')) # div下逐层找p print(7, soup.select('div div p')) # div下逐层找div下逐层找p # 子选择器，直接后代 print(8, soup.select('div &gt; p')) # div下直接子标签的p，有2个 # 相邻兄弟选择器 print(9, soup.select('div p:nth-of-type(1) + [src]')) # 返回[] print(9, soup.select('div p:nth-of-type(1) + p')) # 返回[] print(9, soup.select('div &gt; p:nth-of-type(2) + input')) # 返回input Tag print(9, soup.select('div &gt; p:nth-of-type(2) + [type]')) # 同上 # 普通兄弟选择器 print(10, soup.select('div p:nth-of-type(1) ~ [src]')) # 返回2个img # 属性选择器 print(11, soup.select('[src]')) # 有属性src print(12, soup.select('[src="/"]')) # 属性src等于/ print(13, soup.select('[src="http://www.magedu.com/"]')) # 完全匹配 print(14, soup.select('[src^="http://www"]')) # 以http://www开头 print(15, soup.select('[src$="cn/"]')) # 以cn/结尾 print(16, soup.select('img[src*="bin"]')) # 包含bin print(17, soup.select('img[src*=".cn"]')) # 包含.cn print(18, soup.select('[class="title highlight"]')) print(19, soup.select('[class~=title]')) # 多值属性中有一个title# 执行结果1 [&lt;p id="first"&gt;字典&lt;/p&gt;, &lt;p id="second"&gt;列表&lt;/p&gt;, &lt;p&gt;bottom&lt;/p&gt;]2 [&lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;]3 [&lt;p id="second"&gt;列表&lt;/p&gt;]4 [&lt;p id="second"&gt;列表&lt;/p&gt;]5 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;]6 [&lt;p id="first"&gt;字典&lt;/p&gt;, &lt;p id="second"&gt;列表&lt;/p&gt;]7 [&lt;p id="first"&gt;字典&lt;/p&gt;, &lt;p id="second"&gt;列表&lt;/p&gt;]8 [&lt;p id="first"&gt;字典&lt;/p&gt;, &lt;p id="second"&gt;列表&lt;/p&gt;]9 []9 [&lt;p id="second"&gt;列表&lt;/p&gt;]9 [&lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;]9 [&lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;]10 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;, &lt;img id="bg2" src="http://httpbin.org/"/&gt;]11 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;, &lt;img id="bg2" src="http://httpbin.org/"/&gt;]12 []13 []14 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;]15 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;]16 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;, &lt;img id="bg2" src="http://httpbin.org/"/&gt;]17 [&lt;img id="bg1" src="http://www.bing.cn/"/&gt;]18 [&lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;]19 [&lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;] 获取文本内容搜索节点的目的往往是为了提取该节点的文本内容，一般不需要HTML标记，只需要文字123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263from bs4 import BeautifulSoupdef many_classes(tag): # print(type(tag)) # print(tag.attrs) return len(tag.attrs.get('class', [])) &gt; 1with open('d:/test.html', encoding='utf-8') as f: soup = BeautifulSoup(f, 'lxml') # 元素选择器 ele = soup.select('div') # 所有的div标签 print(1, ele[0].string, end='\n------------\n') # 内容仅仅只能是文本类型，否则返回None print(2, list(ele[0].strings), end='\n------------\n') # 迭代保留空白字符 print(3, list(ele[0].stripped_strings), end='\n------------\n') # 迭代不保留空白字符 print(4, ele[0], end='\n------------\n') print(5, ele[0].text, end='\n------------\n') # 本质上就是get_text()，保留空白字符的strings print(6, ele[0].get_text(), end='\n------------\n') # 迭代并join，保留空白字符，strip默认为False print(7, ele[0].get_text(strip=True)) # 迭代并join，不保留空白字符# 执行结果1 None------------2 ['\n', 'python高级班', '\n', '\n', '字典', '\n', '列表', '\n', '\n', '\n', '\n', '\n', '\n']------------3 ['python高级班', '字典', '列表']------------4 &lt;div id="main"&gt;&lt;h3 class="title highlight"&gt;python高级班&lt;/h3&gt;&lt;div class="content"&gt;&lt;p id="first"&gt;字典&lt;/p&gt;&lt;p id="second"&gt;列表&lt;/p&gt;&lt;input name="_csrf" type="hidden" value="7139e401481ef2f46ce98b22af4f4bed"/&gt;&lt;!-- comment --&gt;&lt;img id="bg1" src="http://www.bing.cn/"/&gt;&lt;img id="bg2" src="http://httpbin.org/"/&gt;&lt;/div&gt;&lt;/div&gt;------------5 python高级班字典列表------------6 python高级班字典列表------------7 python高级班字典列表 123456789101112131415161718192021222324252627282930313233343536373839404142# bs4.element.Tag#stringclass Tag(PageElement): @property def string(self): if len(self.contents) != 1: return None child = self.contents[0] if isinstance(child, NavigableString): return child return child.string def _all_strings(self, strip=False, types=(NavigableString, CData)): for descendant in self.descendants: if ( (types is None and not isinstance(descendant, NavigableString)) or (types is not None and type(descendant) not in types)): continue if strip: descendant = descendant.strip() if len(descendant) == 0: continue yield descendant strings = property(_all_strings) @property def stripped_strings(self): for string in self._all_strings(True): yield string def get_text(self, separator="", strip=False, types=(NavigableString, CData)): """ Get all child strings, concatenated using the given separator. """ return separator.join([s for s in self._all_strings( strip, types=types)]) getText = get_text text = property(get_text) Json解析拿到一个Json字符串，如果想提取其中的部分内容，就需要遍历了。在遍历过程中进行判断还有一种方式，类似于XPath，叫做JsonPath 安装$ pip install jsonpath官网 http://goessner.net/articles/JsonPath/|XPath | Json | 说明 ||:–|:–|:–||/ |$ |根元素||. |@| 当前节点||/ |. or [ ] |获取子节点||..| 不支持 |父节点||// |.. |任意层次||* |* |通配符，匹配任意节点||@| 不支持| Json中没有属性||[ ] | [ ] |下标操作XPath从1开始JsonPath从0开始|| | | [,] |XPath是或操作. JSONPath allows alternate names or array indices as a set.||不支持 |[start:stop:step] |切片||[ ] |?( )| 过滤操作||不支持 |( )| 表达式计算||( ) |不支持 |分组| 依然用豆瓣电影的热门电影的Jsonhttps://movie.douban.com/j/search_subjects?type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;page_limit=10&amp;page_start=0找到得分高于8分的1234567891011121314151617181920212223242526272829&#123; subjects: [ &#123; rate: &quot;8.3&quot;, cover_x: 2309, title: &quot;爱你，西蒙&quot;, url: &quot;https://movie.douban.com/subject/26654498/&quot;, playable: false, cover:&quot;https://img1.doubanio.com/view/photo/s_ratio_poster/public/p2523592367.webp&quot;, id: &quot;26654498&quot;, cover_y: 3464, is_new: false &#125;, &#123; rate: &quot;8.3&quot;, cover_x: 3578, title: &quot;暴裂无声&quot;, url: &quot;https://movie.douban.com/subject/26647117/&quot;, playable: true, cover:&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p2517333671.webp&quot;, id: &quot;26647117&quot;, cover_y: 5078, is_new: false &#125; ]&#125; 思路找到title非常容易，但是要用其兄弟节点rate判断是否大于8分，就不好做了能够从父节点下手，subjects的多个子节点中，要用 [ ] ，某一个当前节点的rate和字符串8比较来过滤的得到符合要求的subjects的子节点，取这个子节点的title1234567891011121314151617181920212223242526272829303132333435from jsonpath import jsonpathimport requestsimport jsonua = "Mozilla/5.0 (Windows NT 6.1) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/55.0.2883.75 " \ "Safari/537.36"url = 'https://movie.douban.com/j/search_subjects?' \ 'type=movie&amp;tag=%E7%83%AD%E9%97%A8&amp;page_limit=10&amp;page_start=0'with requests.get(url, headers=&#123;'User-agent':ua&#125;) as response: text = response.text print(text) # str类型的json数据 js = json.loads(text) print(js) # Json转为Python数据结构 # 找到所有电影的名称 rs1 = jsonpath(js, '$..title') print(rs1) # 找到所有subjects rs2 = jsonpath(js, '$..subjects') print(rs2) # 找打所有得分高于8分的电影名称 # 根下任意层的subjects的子节点rate大于字符串8 rs3 = jsonpath(js, '$..subjects[?(@.rate &gt; "8")]') print(rs3) # 根下任意层的subjects的子节点rate大于字符串8的节点的子节点title rs4 = jsonpath(js, '$..subjects[?(@.rate &gt; "8")].title') print(rs4) # ['疾速备战', '绿皮书', '痛苦与荣耀', '孟买酒店'] # 切片 rs5 = jsonpath(js, '$..subjects[?(@.rate &gt; "8")].title') print(rs5[:2]) # ['疾速备战', '绿皮书']]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[动态网页处理]]></title>
    <url>%2F%E7%88%AC%E8%99%AB%2F%E5%8A%A8%E6%80%81%E7%BD%91%E9%A1%B5%E5%A4%84%E7%90%86%20--%20Selenium%E5%92%8CPhantomJS%2F</url>
    <content type="text"><![CDATA[动态网页处理 很多网站都采用A JAX技术、SPA技术，部分内容都是异步动态加载的。可以提高用户体验，减少不必要的流量，方便CDN加速等 但是，对于爬虫程序爬取到的HTML页面相当于页面模板了，动态内容不在其中 解决办法之一，如果能构造一个包含JS引擎的浏览器，让它加载网页并和网站交互，我们编程从这个浏览器获取内容包括动态内容。这个浏览器不需要和用户交互的界面，只要能支持HTTP、HTTPS协议和服务器端交互，能解析HTML、CSS、JS就行 PhantomJS它是一个headless无头浏览器，支持Javascript。可以运行在Windows、Linux、Mac OS等 所谓无头浏览器，就是包含Js引擎、浏览器排版引擎等核心组件，但是没有和用户交互的界面的浏览器 官网http://phantomjs.org/ 官方文档http://phantomjs.org/documentation/ 下载http://phantomjs.org/download.html下载对应操作系统的PhantomJS，解压缩就可以使用 测试编写test.js，运行命令 $ phantomjs/bin/phantomjs.exe test.js123"use strict";console.log('hello world');phantom.exit(); Selenium它是一个WEB自动化测试工具。它可以直接运行在浏览器中，支持主流的浏览器，包括PhantomJS（无头浏览器） 安装$ pip install selenium 官网https://www.seleniumhq.org/ 开发实战 不同浏览器都会提供操作的接口，Selenium就是使用这些接口来操作浏览器 Selenium最核心的对象就是webdriver，通过它就可以操作浏览器、截图、HTTP访问、解析HTML等 处理异步请求bing的查询结果是通过异步请求返回结果，所以，直接访问页面不能直接获取到搜索结果1234567891011121314151617181920212223242526272829303132333435363738394041424344454647# 获取bing查询数据from selenium import webdriver # 核心对象import datetimeimport randomimport timefrom urllib import parse# 指定PhantomJS的执行文件路径driver = webdriver.PhantomJS('d:/python/phantomjs/bin/phantomjs.exe')# 设置窗口大小driver.set_window_size(1280, 1024)# 打开网页GET方法，模拟浏览器地址栏输入网址url = 'http://cn.bing.com/search?' + parse.urlencode(&#123; 'q': 'python'&#125;)driver.get(url)# 保存图片def savepic(): base_dir = 'd:/' filename = '&#123;&#125;&#123;:%Y%m%d%H%M%S&#125;&#123;:03&#125;.png'.format( base_dir, datetime.datetime.now(), random.randint(1, 100) ) driver.save_screenshot(filename)#time.sleep(10) # 等等截图就能看到内容savepic()MAXRETRIES = 5 # 最大重试次数for i in range(MAXRETRIES): # 循环测试 time.sleep(1) try: ele = driver.find_element_by_id('b_results') # 如果查询结果来了，就会有这个id的标签 if not ele.is_displayed(): # 等待数据显示出来 print('diplay none') continue print('ok') savepic() break except Exception as e: print(e)driver.quit() 可能结果未必能看到，说明数据回来了，而且组织好了，但是没有显示出来 可以增加判断元素是否显示的代码，直到等待的数据呈现在页面上 下拉框处理Selenium专门提供了Select类来处理网页中的下拉框不过下拉框用的页面越来越少了,本次使用 https://www.oschina.net/search?scope=project&amp;q=python12345678910111213141516171819# oschina软件搜索&lt;select name='tag1' onchange="submit();"&gt; &lt;option value='0'&gt;所有分类&lt;/option&gt; &lt;option value='309' &gt;Web应用开发&lt;/option&gt; &lt;option value='331' &gt;手机/移动开发&lt;/option&gt; &lt;option value='364' &gt;iOS代码库&lt;/option&gt; &lt;option value='12' &gt;程序开发&lt;/option&gt; &lt;option value='11' &gt;开发工具&lt;/option&gt; &lt;option value='273' &gt;jQuery 插件&lt;/option&gt; &lt;option value='256' &gt;建站系统&lt;/option&gt; &lt;option value='5' &gt;企业应用&lt;/option&gt; &lt;option value='10' &gt;服务器软件&lt;/option&gt; &lt;option value='6' &gt;数据库相关&lt;/option&gt; &lt;option value='8' &gt;应用工具&lt;/option&gt; &lt;option value='18' &gt;插件和扩展&lt;/option&gt; &lt;option value='7' &gt;游戏/娱乐&lt;/option&gt; &lt;option value='14' &gt;管理和监控&lt;/option&gt; &lt;option value='9' &gt;其他开源&lt;/option&gt;&lt;/select&gt; 这个下拉框影响下一个下拉框“所有子类”。下面就模拟来操作下拉框，需要使用selenium.webdriver.support.select.Select12345678910111213141516171819202122232425262728293031323334353637from selenium import webdriver # 核心对象import datetimeimport randomfrom selenium.webdriver.support.ui import Select# 指定PhantomJS的执行文件路径driver = webdriver.PhantomJS('d:/python/phantomjs/bin/phantomjs.exe')# 设置窗口大小driver.set_window_size(1280, 1024)# 保存图片def savepic(): base_dir = 'd:/' filename = '&#123;&#125;&#123;:%Y%m%d%H%M%S&#125;&#123;:03&#125;.png'.format( base_dir, datetime.datetime.now(), random.randint(1, 100) ) driver.save_screenshot(filename)# 打开网页GET方法，模拟浏览器地址栏输入网址url = 'https://www.oschina.net/search?q=python&amp;scope=project'driver.get(url)ele = driver.find_element_by_name('tag1') # 获取元素print(ele.tag_name) # 标签名print(driver.current_url) # 当前urlsavepic()s = Select(ele)#s.select_by_index(1)s.select_by_value('309')print(driver.current_url) # 新页面savepic()driver.quit() 由于该网页改版，舍弃了select，无法测试 模拟键盘操作（模拟登录）webdriver提供了一些列find方法，用户获取一个网页中的元素。元素对象可以使用send_keys模拟键盘输入 oschina的登录页，登录成功后会跳转到首页，首页右上角会显示会员信息，如果未登录，无此信息123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687# 模拟开源中国登陆from selenium import webdriver # 核心对象import datetimeimport randomimport timefrom selenium.webdriver.common.keys import Keys# 指定PhantomJS的执行文件路径driver = webdriver.PhantomJS('d:/python/phantomjs/bin/phantomjs.exe')# 设置窗口大小driver.set_window_size(1280, 1024)# 保存图片def savepic(): base_dir = 'd:/' filename = '&#123;&#125;&#123;:%Y%m%d%H%M%S&#125;&#123;:03&#125;.png'.format( base_dir, datetime.datetime.now(), random.randint(1, 100) ) driver.save_screenshot(filename)# 打开网页GET方法，模拟浏览器地址栏输入网址url = 'https://www.oschina.net/home/login'driver.get(url)print(driver.current_url) # 当前urlsavepic()# 模拟输入用户名密码username = driver.find_element_by_id('userMail') # 获取元素username.send_keys('wei.xu@magedu.com')password = driver.find_element_by_id('userPassword') # 获取元素password.send_keys('magedu.com18')savepic()password.send_keys(Keys.ENTER)print('-' * 30)for i in range(5): time.sleep(1) try: # xpath定位数据 ele = driver.find_element_by_xpath('//div[@title="magedu_wayne"]') print(ele.tag_name, '!~~~~~~') print(ele.get_attribute('data-user-id')) savepic() break except Exception as e: print(e)# 模拟登录后获得cookiescookies = driver.get_cookies()print(cookies)for c in cookies: print(type(c)) print(c)print('-' * 30)import requestsfrom requests.cookies import RequestsCookieJarjar = RequestsCookieJar()for c in cookies: jar.set(c.get('name'), c.get('value'))print(jar)headers = &#123;'User-agent': "Mozilla/5.0 (Windows; U; ""Windows NT 6.1; zh-CN) AppleWebKit/537.36(KHTML, like Gecko) Version / 5.0.1Safari / 537.36"&#125;print('========== 不带cookie ==========')response = requests.get(url, headers=headers)with response: print(10, response.url) # 这就是登录页 with open('d:/nocookie.html', 'w', encoding='utf-8') as f: f.write(response.text)print('========== 带cookie ==========')response = requests.get(url, headers=headers, cookies=jar)with response: print(11, response.url) with open('d:/withcookie.html', 'w', encoding='utf-8') as f: f.write(response.text)driver.quit() 页面等待越来越多的页面使用Ajax这样的异步加载技术，这就会导致代码中要访问的页面元素，还没有被加载就被访问了，抛出异常 方法1 线程休眠使用time.sleep(n)来等待数据加载 配合循环一直等到数据被加载完成，可以解决很多页面动态加载或加载慢的问题。当然可以设置一个最大重试次数，以免一直循环下去。参看本文“处理异步请求” 方法2 Selenium等待Selenium的等待分为：显示等待和隐式等待 隐式等待，等待特定的时间显式等待，指定一个条件，一直等到这个条件成立后继续执行，也可以设置超时时间，超时会抛异常参考 https://www.seleniumhq.org/docs/04_webdriver_advanced.jsp#explicit-and-implicit-waits 显示等待 expected_conditionsn内置条件 expected_conditionsn内置条件 title_is 判断当前页面的title是否精确等于预期 title_contains 判断当前页面的title是否包含预期字符串 presence_of_element_located 判断某个元素是否被加到了dom树里，并不代表该元素一定可见 visibility_of_element_located 判断某个元素是否可见。可见代表元素非隐藏，并且元素的宽和高都不等于0 visibility_of 跟上面的方法做一样的事情，只是上面的方法要传入locator，这个方法直接传定位到的element就好了 presence_of_all_elements_located 判断是否至少有1个元素存在于dom树中。举个例子，如果页面上有n个元素的class都是’column-md-3’，那么只要有1个元素存在，这个方法就返回True text_to_be_present_in_element 判断某个元素中的text是否包含了预期的字符串 text_to_be_present_in_element_value 判断某个元素中的value属性是否包含了预期的字符串 frame_to_be_available_and_switch_to_it 判断该frame是否可以switch进去，如果可以的话，返回True并且switch进去，否则返回False invisibility_of_element_located 判断某个元素中是否不存在于dom树或不可见 element_to_be_clickable 判断某个元素中是否可见并且是enable的，这样的话才叫clickable staleness_of 等某个元素从dom树中移除，注意，这个方法也是返回True或False element_to_be_selected 判断某个元素是否被选中了,一般用在下拉列表 element_selection_state_to_be 判断某个元素的选中状态是否符合预期 element_located_selection_state_to_be 跟上面的方法作用一样，只是上面的方法传入定位到的element，而这个方法传入locator alert_is_present 判断页面上是否存在alert 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354# 定位搜索框，搜索电影from selenium import webdriver # 核心对象import datetimeimport randomfrom selenium.webdriver.common.by import By# 键盘操作from selenium.webdriver.common.keys import Keys# WebDriverWait 负责循环等待from selenium.webdriver.support.wait import WebDriverWait# expected_conditions条件，负责条件触发from selenium.webdriver.support import expected_conditions as EC# 指定PhantomJS的执行文件路径driver = webdriver.PhantomJS('d:/python/phantomjs/bin/phantomjs.exe')# 设置窗口大小driver.set_window_size(1280, 1024)# 保存图片def savepic(): base_dir = 'd:/' filename = '&#123;&#125;&#123;:%Y%m%d%H%M%S&#125;&#123;:03&#125;.png'.format( base_dir, datetime.datetime.now(), random.randint(1, 100) ) driver.save_screenshot(filename)# 打开网页GET方法，模拟浏览器地址栏输入网址from selenium.webdriver.common.by import Byfrom selenium.webdriver.support.ui import WebDriverWait # available since 2.4.0from selenium.webdriver.support import expected_conditions as EC # available since 2.26.0url = 'http://cn.bing.com/search?q=douban+TRON'driver.get(url)print(url)print(driver.current_url) # 当前urltry: ele = WebDriverWait(driver, 20).until( EC.visibility_of_element_located( (By.ID, "b_results") ) ) savepic() print('-' * 30)except Exception as e: print(e)finally: driver.quit() 隐式等待如果出现No Such Element Exception，则智能的等待指定的时长。缺省值是012345678910111213141516171819202122232425262728293031323334353637383940414243444546# 定位搜索框，搜索电影from selenium import webdriver # 核心对象import datetimeimport randomfrom selenium.webdriver.common.by import By# 指定PhantomJS的执行文件路径driver = webdriver.PhantomJS('d:/python/phantomjs/bin/phantomjs.exe')# 设置窗口大小driver.set_window_size(1280, 1024)driver.implicitly_wait(10) # 统一设定隐式等待秒数# 保存图片def savepic(): base_dir = 'd:/' filename = '&#123;&#125;&#123;:%Y%m%d%H%M%S&#125;&#123;:03&#125;.png'.format( base_dir, datetime.datetime.now(), random.randint(1, 100) ) driver.save_screenshot(filename)# 打开网页GET方法，模拟浏览器地址栏输入网址url = 'http://cn.bing.com/search?q=douban+TRON'driver.get(url)print(url)print(driver.current_url) # 当前urltry: # ele = WebDriverWait(driver, 20).until( # # EC.visibility_of_element_located( # (By.ID, "b_results") # ) # ) driver.find_element_by_id('b_results') # driver.find_element_by_id('abcdefgh') savepic() print('-' * 30)except Exception as e: print(e)finally: driver.quit() 总结Selenium的WebDriver是其核心，从Selenium2开始就是最重要的编程核心对象，在Selenium3中更是如此 和浏览器交互全靠它，它可以： 打开URL，可以跟踪跳转，可以返回当前页面的实际URL 获取页面的title 处理cookie 控制浏览器的操作，例如前进、后退、刷新、关闭，最大化等 执行JS脚本 在DOM中搜索页面元素Web Element，指定的或一批，find系方法 操作网页元素 模拟下拉框操作Select(element) 在元素上模拟鼠标操作click() 在元素上模拟键盘输入send_keys() 获取元素文字 text 获取元素的属性 get_attribute() Selenium通过WebDriver来驱动浏览器工作，而浏览器是一个个独立的浏览器进程]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSGI]]></title>
    <url>%2Fweb%2FWSGI%2F</url>
    <content type="text"><![CDATA[WSGI（Web Server Gateway Interface）主要规定了服务器端和应用程序间的接口 WSGI服务器——wsgiref wsgiref是Python提供的一个WSGI参考实现库，不适合生产环境使用 wsgiref.simple_server 模块实现一个简单的WSGI HTTP服务器 123456from wsgiref.simple_server import make_server,demo_appip = '127.0.0.1'port = 9999server = make_server(ip, port, demo_app) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 查看demo_app源码 12345678910def demo_app(environ,start_response): from io import StringIO stdout = StringIO() print("Hello world!", file=stdout) print(file=stdout) h = sorted(environ.items()) for k,v in h: print(k,'=',repr(v), file=stdout) start_response("200 OK", [('Content-Type','text/plain; charset=utf-8')]) return [stdout.getvalue().encode("utf-8")] StringIO 在内存中读写str print(&quot;Hello world!&quot;, file=stdout)将Hello world!内容写入内存中 start_response 构造head getvalue 把缓冲区的内容全部读取出来，内容必须为btyesWSGI服务器作用 监听HTTP服务端口（TCPServer，默认端口80） 接收浏览器端的HTTP请求并解析封装成environ环境数据 负责调用应用程序，将environ数据和start_response方法两个实参传入给Application 将应用程序响应的正文封装成HTTP响应报文返回浏览器端 所有头和内容都是由server来封装WSGI APP应用程序端 应用程序应该是一个可调用对象Python中应该是函数、类、实现了 __call__ 方法的类的实例 这个可调用对象应该接收两个参数1. 函数实现123456789101112from wsgiref.simple_server import make_serverreturn_res = b'Hello World'def application(environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 2. 类实现1234567891011121314151617from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __init__(self, environ, start_response): self.env = environ self.sr = start_response def __iter__(self): # 对象可迭代 self.sr("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) yield return_resip = '127.0.0.1'port = 9999server = make_server(ip, port, Application) # Demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 3. 类实现，可调用对象1234567891011121314from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application(e,s)server.serve_forever() # server.handle_request() 执行一次 environ和start_response这两个参数名可以是任何合法名，但是一般默认都是这2个名字 应用程序端还有些其他的规定，暂不用关心 注意：第2、第3种实现调用时的不同 自定义 返回头一般自定义习惯用‘X’开头12345678910111213141516from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [ ('Content-Type', 'text/plain; charset=utf-8'), ('X-Server', 'MyDemo_app') ]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 environenviron是包含Http请求信息的dict字典对象| 名称 | 含义 ||:–|:–||REQUEST_METHOD |请求方法，GET、POST等||PATH_INFO| URL中的路径部分||QUERY_STRING| 查询字符串||SERVER_NAME, SERVER_PORT| 服务器名、端口||HTTP_HOST| 地址和端口||SERVER_PROTOCOL |协议||HTTP_USER_AGENT| UserAgent信息| 12345678910111213CONTENT_TYPE = &apos;text/plain&apos;HTTP_HOST = &apos;127.0.0.1:9999&apos;HTTP_USER_AGENT = &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML, like Gecko) Version/5.0.1 Safari/537.36&apos;PATH_INFO = &apos;/&apos;QUERY_STRING = &apos;&apos;REMOTE_ADDR = &apos;127.0.0.1&apos;REMOTE_HOST = &apos;&apos;REQUEST_METHOD = &apos;GET&apos;SERVER_NAME = &apos;DESKTOP-D34H5HF&apos;SERVER_PORT = &apos;9999&apos;SERVER_PROTOCOL = &apos;HTTP/1.1&apos;SERVER_SOFTWARE = &apos;WSGIServer/0.2&apos; start_response它是一个可调用对象。有3个参数，定义如下：start_response(status, response_headers, exc_info=None)|参数名称 |说明||:–|:–||status |状态码和状态描述，例如 200 OK||response_headers |一个元素为二元组的列表例如[(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;)]||exc_info |在错误处理的时候使用|start_response应该在返回可迭代对象之前调用，因为它返回的是Response Header。返回的可迭代对象是Response Body 服务器端服务器程序需要调用符合上述定义的可调用对象APP，传入environ、start_response，APP处理后，返回响应头和可迭代对象的正文，由服务器封装返回浏览器端 返回网页的例子1234567891011121314from wsgiref.simple_server import make_serverdef application(environ, start_response): status = '200 OK' headers = [('Content-Type', 'text/html;charset=utf-8')] start_response(status, headers) # 返回可迭代对象 html = '&lt;h1&gt;Hello World&lt;/h1&gt;'.encode("utf-8") return [html]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application)server.serve_forever() # server.handle_request() 执行一次 simple_server 只是参考用，不能用于生产环境 Linux 测试用命令12$ curl -I http://192.168.142.1:9999/xxx?id=5$ curl -X POST http://192.168.142.1:9999/yyy -d &apos;&#123;&quot;x&quot;:2&#125;&apos; -I 使用HEAD方法 -X 指定方法，-d传输数据 到这里就完成了一个简单的WEB 程序开发 WSGI WEB服务器 本质上就是一个TCP服务器，监听在特定端口上 支持HTTP协议，能够将HTTP请求报文进行解析，能够把响应数据进行HTTP协议的报文封装并返回浏览器端 实现了WSGI协议，该协议约定了和应用程序之间接口（参看PEP333，https://www.python.org/dev/peps/pep-0333/ ）WSGI APP应用程序 遵从WSGI协议 本身是一个可调用对象 调用start_response，返回响应头部 返回包含正文的可迭代对象 WSGI 框架库往往可以看做增强的更加复杂的Application]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[RabbitMQ]]></title>
    <url>%2F%E4%B8%AD%E9%97%B4%E4%BB%B6%2FRabbitMQ%2F</url>
    <content type="text"><![CDATA[RabbitMQRabbitMQ 是由 LShift 提供的一个 Advanced Message Queuing Protocol (AMQP) 的开源实现，由以高性能、健壮以及可伸缩性出名的 Erlang 写成，因此也是继承了这些优点 很成熟，久经考验，应用广泛文档详细，客户端丰富，几乎常用语言都有RabbitMQ的开发库 安装http://www.rabbitmq.com/install-rpm.html 选择RPM包下载，选择对应平台，本次安装在CentOS 7，其它平台类似 由于使用了erlang语言开发，所以需要erlang的包。erlang和RabbitMQ的兼容性，参考 https://www.rabbitmq.com/which-erlang.html#compatibility-matrix 下载 rabbitmq-server-3.7.16-1.el7.noarch.rpm、erlang-21.3.8.6-1.el7.x86_64.rpm。socat在CentOS中源中有1# yum install erlang-21.3.8.6-1.el7.x86_64.rpm rabbitmq-server-3.7.16-1.el7.noarch.rpm 安装成功 查看安装的文件12345678910111213# rpm -ql rabbitmq-server/etc/profile.d/rabbitmqctl-autocomplete.sh/etc/rabbitmq/usr/lib/rabbitmq/bin/rabbitmq-plugins/usr/lib/rabbitmq/bin/rabbitmq-server/usr/lib/systemd/system/rabbitmq-server.service/usr/sbin/rabbitmq-diagnostics/usr/sbin/rabbitmq-plugins/usr/sbin/rabbitmq-server/usr/sbin/rabbitmqctl/var/lib/rabbitmq/var/lib/rabbitmq/mnesia/var/log/rabbitmq 配置http://www.rabbitmq.com/configure.html#config-location 环境变量使用系统环境变量，如果没有使用rabbitmq-env.conf 中定义环境变量，否则使用缺省值RABBITMQ_NODE_IP_ADDRESS the empty string, meaning that it should bind to all network interfaces.RABBITMQ_NODE_PORT 5672RABBITMQ_DIST_PORT RABBITMQ_NODE_PORT + 20000 内部节点和客户端工具通信用RABBITMQ_CONFIG_FILE 配置文件路径默认为/etc/rabbitmq/rabbitmq环境变量文件，可以不配置 工作特性配置文件rabbitmq.config配置文件3.7支持新旧两种配置文件格式 erlang配置文件格式，为了兼容继续采用 sysctl格式，如果不需要兼容，RabbitMQ鼓励使用 这个文件也可以不配置 插件管理列出所有可用插件1# rabbitmq-plugins list 启动WEB管理插件，会依赖启用其它几个插件rabbitmq-plugins enable rabbitmq_management123456789101112131415# rabbitmq-plugins enable rabbitmq_managementEnabling plugins on node rabbit@centos7:rabbitmq_managementThe following plugins have been configured: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatchApplying plugin configuration to rabbit@centos7...The following plugins have been enabled: rabbitmq_management rabbitmq_management_agent rabbitmq_web_dispatchset 3 plugins.Offline change; changes will take effect at broker restart. 启动rabbitmq服务1# systemctl start rabbitmq-server 启动中，可能出现下面的错误Error when reading /var/lib/rabbitmq/.erlang.cookie: eacces就是这个文件的权限问题，修改属主、属组为rabbitmq即可chown rabbitmq.rabbitmq /var/lib/rabbitmq/.erlang.cookie: eacces服务启动成功1234# ss -tanl | grep 5672LISTEN 0 128 *:25672 *:* LISTEN 0 128 *:15672 *:* LISTEN 0 128 :::5672 :::* 15672 http用的端口25672 集群通信5672 按协议访问，常用 用户管理开始登录WEB界面，http://192.168.1.5:15672使用guest/guest只能本地地登录，远程登录会报错123456789101112131415rabbitmqctl [-n &lt;node&gt;][-t timeout] [-l][-q] &lt;command&gt; [&lt;command options&gt;]General options: -n node -q, --quiet -t,--timeout timeout -l longnames Commands: add_user &lt;username&gt; &lt;password&gt; 添加用户 list_users 列出用户 delete_user username 删除用户 change_password &lt;username&gt; &lt;password&gt; 修改用户名、密码 set_user_tags &lt;username&gt; &lt;tag&gt; [...] 设置用户tag list_user_permissions &lt;username&gt; 列出用户权限 创建用户 用户名和密码（只能在本地登录） 添加用户:rabbitmqctl add_user username password 删除用户:rabbitmqctl delete_user username 更改密码:rabbitmqctl change_password username newpassword 设置权限Tags，其实就是分配组rabbitmqctl set_user_tags username tag 设置lqx用户为管理员tag后登录123456789101112131415161718192021# 创建lqx用户# rabbitmqctl add_user lqx lqxAdding user &quot;lqx&quot; ...# 查看所有用户# rabbitmqctl list_usersListing users ...user tagsguest [administrator]lqx []#授权用户权限# rabbitmqctl set_user_tags lqx administratorSetting tags for user &quot;lqx&quot; to [administrator] ...# 查看所有用户# rabbitmqctl list_usersListing users ...user tagsguest [administrator]lqx [administrator] tag的意义如下 administrator 可以管理用户、权限、虚拟主机 基本信息 虚拟主机 /为缺省虚拟主机 缺省虚拟主机，默认只能是guest用户在本机连接。上图新建的用户lqx默认无法访问任何虚拟主机 Pika库Pika是纯Python实现的支持AMQP协议的库$ pip install pika RabbitMQ工作原理及应用工作模式https://www.rabbitmq.com/getstarted.html上图，列出了RabbitMQ的使用模式，学习上面的模式，对理解所有消息队列都很重要 名词解释 名词 说明 Server 服务器接收客户端连接，实现消息队列及路由功能的进程（服务），也称为 消息代理注意，客户端可以生产者，也可以是消费者，它们都需要连接到Server Connection 网络物理连接 Channel 一个连接允许多个客户端连接 Exchange 交换器。接收生产者发来的消息，决定如何路由给服务器中的队列常用的类型有：direct (point-to-point) topic (publish-subscribe) fanout (multicast) Message 消息 Message Queue 消息队列数据的存储载体 Bind 绑定建立消息队列和交换器之间的关系，也就是说交换器拿到数据，把什么样的数据送给哪个队列 Virtual Host 虚拟主机一批交换机、消息队列和相关对象的集合。为了多用户互不干扰，使用虚拟主机分组交换机、消息队列 Topic 主题、话题 Broker 可等价为Server 先链接 然后信道，然后交换机（缺省默认配置）， 然后队列 1. 队列这种模式就是最简单的 生产者消费者模型，消息队列就是一个FIFO的队列生产者send.py，消费者receive.py官方例子 https://www.rabbitmq.com/tutorials/tutorial-one-python.html参照官方例子，写一个程序1234567891011121314151617import pikaparams = pika.ConnectionParameters('192.168.1.5')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器# 队列channel.queue_declare(queue='hello')with connection: # 发消息 msg = 'Hello World!' channel.basic_publish(exchange='', # 交换机为空 routing_key='hello', # hello body=msg) print(" [x] Sent 'Hello World!'") 运行结果如下12pika.exceptions.ProbableAuthenticationError: ConnectionClosedByBroker: (403) &apos;ACCESS_REFUSED - Login was refused using authentication mechanism PLAIN. For details see the broker logfile.&apos; 访问被拒绝，还是权限问题，原因还是guest用户只能访问localhost上的 / 缺省虚拟主机 解决办法* 缺省虚拟主机，默认只能在本机访问，不要修改为远程访问，是安全的考虑 因此，在Admin中Virtual hosts中，新建一个虚拟主机test。 注意，新建的test虚拟主机的Users是谁，本次是lqx用户 生产者代码1234567891011121314151617181920import pikaqueue_name = 'hello'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器# 队列channel.queue_declare(queue=queue_name)with connection: # 发消息 for i in range(10): msg = 'data-&#123;:02&#125;'.format(i) channel.basic_publish(exchange='', # 交换机为空 routing_key=queue_name, # hello body=msg) print(" [x] Sent 'Hello World!'") 消费者代码（get方法，非阻塞）1234567891011121314151617import pikaqueue_name = 'hello'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器# 队列channel.queue_declare(queue=queue_name)with connection: # 消费 msg =channel.basic_get(queue_name, True) # get方法需要ACK method, properties, body = msg print('msg = &#123;&#125;'.format(body)) 消费者代码（consume方法，阻塞）1234567891011121314151617181920212223import pikaqueue_name = 'hello'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器# 队列channel.queue_declare(queue=queue_name)def callback(ch ,method, properties, body): print(" [x] Receivde %r" % body)with connection: # 消费者，每一个消费者使用过一个basic_consume channel.basic_consume(queue_name, auto_ack=True, on_message_callback=callback) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() 执行结果1234567891011[*] Waiting for messages. To exit press CTRL+C[x] Receivde b'data-00'[x] Receivde b'data-01'[x] Receivde b'data-02'[x] Receivde b'data-03'[x] Receivde b'data-04'[x] Receivde b'data-05'[x] Receivde b'data-06'[x] Receivde b'data-07'[x] Receivde b'data-08'[x] Receivde b'data-09' 2. 工作队列 继续使用队列模式的生产者消费者代码 一个链接里启2个消费或者启动2个链接消费 结果都是一样的 生产者代码不变，修改消费者代码123456789101112131415161718192021222324252627282930import pikaqueue_name = 'hello'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器# 队列channel.queue_declare(queue=queue_name)def callback(ch ,method, properties, body): print("mag = &#123;&#125;".format(body))def callback1(ch ,method, properties, body): print("mag1 = &#123;&#125;".format(body))with connection: # 消费者，每一个消费者使用过一个basic_consume channel.basic_consume(queue_name, auto_ack=True, on_message_callback=callback) channel.basic_consume(queue_name, auto_ack=True, on_message_callback=callback1) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() # 启动所有消费，直到所有消费结束，才能退出。阻塞的 执行结果1234567891011 [*] Waiting for messages. To exit press CTRL+Cmag = b'data-00'mag1 = b'data-01'mag = b'data-02'mag1 = b'data-03'mag = b'data-04'mag1 = b'data-05'mag = b'data-06'mag1 = b'data-07'mag = b'data-08'mag1 = b'data-09' 这种工作模式是一种竞争工作方式，对某一个消息来说，只能有一个消费者拿走它 从结果知道，使用的是轮询方式拿走数据的 观察结果，可以看到，2个消费者是交替拿到不同的消息注意：虽然上面的图中没有画出exchange，用到缺省exchange 3. 发布、订阅模式(扇出)Publish/Subscribe发布和订阅，想象一下订阅报纸，所有订阅者（消费者）订阅这个报纸（消息），都应该拿到一份同样内容的报纸 订阅者和消费者之间还有一个exchange，可以想象成邮局，消费者去邮局订阅报纸，报社发报纸到邮局，邮局决定如何投递到消费者手中 上例中工作队列模式的使用，相当于，每个人只能拿到不同的报纸。所以，不适用发布订阅模式 当前模式的exchange的type是fanout，就是一对多，即广播模式。注意，同一个queue的消息只能被消费一次，所以，这里使用了多个queue，相当于为了保证不同的消费者拿到同样的数据，每一个消费者都应该有自己的queue 12345# 生成一个交换机channel.exchange_declare( exchange='logs', # 新交换机 exchange_type='fanout' # 广播) 生产者使用广播模式。在test虚拟主机主机下构建了一个logs交换机至于queue，可以由生产者创建，也可以由消费者创建 本次采用使用消费者端创建，生产者把数据发往交换机logs，采用了fanout，然后将数据通过交换机发往已经绑定到此交换机的所有queue绑定Bingding，建立exchange和queue之间的联系 生产者代码（交换机缺省模式）12345678910111213141516171819202122import pikaqueue_name = 'hello'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器channel.exchange_declare(exchange='', exchange_type='direct')# 队列channel.queue_declare(queue=queue_name)with connection: # 发消息 for i in range(10): msg = 'data-&#123;:02&#125;'.format(i) channel.basic_publish(exchange='', # 交换机为空 routing_key=queue_name, # hello body=msg) print(" [x] Sent 'Hello World!'") 生产者代码（指定交换机）123456789101112131415161718192021import pikaqueue_name = 'hello'exchange_name = 'logs'params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器channel.exchange_declare(exchange=exchange_name, exchange_type='fanout') # 广播，扇出with connection: # 发消息 for i in range(10): msg = 'data-&#123;:02&#125;'.format(i) channel.basic_publish(exchange=exchange_name, # 指定交换机 routing_key='', body=msg) print(" [x] Sent 'Hello World!'") 消费者代码123456789101112131415161718192021import pikaqueue_name = 'hello'exchange_name = 'logs'params = pika.URLParameters('amqp://lqx:lqx@192.168.18.100:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机， 路由器channel.exchange_declare(exchange=exchange_name, exchange_type='fanout') # 广播，扇出with connection: # 发消息 for i in range(10): msg = 'data-&#123;:02&#125;'.format(i) channel.basic_publish(exchange=exchange_name, # 指定交换机 routing_key='', body=msg) print(" [x] Sent 'Hello World!'") 先启动消费者可以看到已经创建了exchange如果exchange是fanout，也就是广播了，routing_key就无所谓是什么了12q1 = channel.queue_declare(queue='', exclusive=True) q2 = channel.queue_declare(queue='', exclusive=True) 尝试先启动生产者，再启动消费者试试看。部分数据丢失，因为，exchange收到了数据，没有queue接收，所以，exchange丢弃了这些数据 4.路由Routing路由其实就是生成者的数据经过exchange的时候，通过匹配规则，决定数据的去向 生产者代码交换机类型为direct，指定路由的keyn12345678910111213141516171819202122232425import pikaimport pikaimport randomqueue_name = 'hello'exchange_name = 'color'colors = ('orange', 'red', 'green')params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()#交换机， 路由器channel.exchange_declare(exchange=exchange_name, exchange_type='direct') #with connection: # 发消息 for i in range(20): rk = random.choice(colors) msg = '&#123;&#125;: data-&#123;:02&#125;'.format(rk, i) channel.basic_publish(exchange=exchange_name, # 指定交换机 routing_key=rk, body=msg) print(" [x] Sent 'Hello World!'") 消费者代码12345678910111213141516171819202122232425262728293031323334353637383940import pikaqueue_name = 'hello'exchange_name = 'color'colors = ('orange', 'black', 'green')params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()#交换机，路由器channel.exchange_declare(exchange=exchange_name,exchange_type='direct')# 队列#channel.queue_declare(queue=queue_name)#q = channel.queue_declare(queue='') 不指定名称，queue名称会随机生成 q.method.queueq1 = channel.queue_declare(queue='', exclusive=True) #exclusive 在断开时，会queue删除q2 = channel.queue_declare(queue='', exclusive=True) #exclusive 在断开时，会queue删除q1name = q1.method.queueq2name = q2.method.queuechannel.queue_bind(exchange=exchange_name, queue=q1name, routing_key=colors[0]) # 将队列和某一个交换机关联channel.queue_bind(exchange=exchange_name, queue=q2name, routing_key=colors[1]) # 将队列和某一个交换机关联channel.queue_bind(exchange=exchange_name, queue=q2name, routing_key=colors[2]) # 将队列和某一个交换机关联def callback(ch, method, properties, body): print("msg = &#123;&#125;".format(body), method)with connection: # 消费者，每一个消费者使用一个basic_consume channel.basic_consume(queue=q1name, auto_ack=True, on_message_callback=callback) channel.basic_consume(queue=q2name, auto_ack=True, on_message_callback=callback) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() # 启动所有消费，直到道所有消费结束，才能退出，阻塞的 绑定结果如下如果routing_key设置的都一样，会怎么样？ 绑定的时候指定的routing_key=&#39;black&#39;，如上图，和fanout就类似了，都是1对多，但是不同因为fanout时，exchange不做数据过滤的，1个消息，所有绑定的queue都会拿到一个副本direct时候，要按照routing_key分配数据，上图的black有2个queue设置了，就会把1个消息分发给这2个queue 5、Topic 话题Topic就是更加高级的路由，支持模式匹配而已Topic的routing_key必须使用 . 点号分割的单词组成。最多255个字节支持使用通配符： *表示严格的一个单词 #表示0个或者多个单词 如果queue绑定的routing_key只是一个#，这个queue其实可以接收所有的消息如果没有使用任何通配符，效果类似于direct，因为只能和字符匹配生产者代码1234567891011121314151617181920212223242526272829import pikaimport randomqueue_name = 'hello'exchange_name = 'color'topics = ('phone.*', '*.red') # * 一个单词products = ('phone', 'pc', 'tv')colors = ('orange', 'black', 'red')params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机，路由器channel.exchange_declare(exchange=exchange_name, exchange_type='topic') # 话题with connection: # 发消息 for i in range(20): rk = random.choice(colors) msg = '&#123;&#125;: data-&#123;:02&#125;'.format(rk, i) channel.basic_publish(exchange=exchange_name, # 指定交换机 routing_key=rk, body=msg) print('-' * 30) print(" [x] Sent 'Hello World!'") 消费者代码1234567891011121314151617181920212223242526272829303132333435363738394041424344import pikaqueue_name = 'hello'exchange_name = 'color'topics = ('phone.*', '*.red') # * 一个单词products = ('phone', 'pc', 'tv')colors = ('orange', 'black', 'red')params = pika.URLParameters('amqp://lqx:lqx@192.168.1.5:5672/test')connection = pika.BlockingConnection(params)channel = connection.channel()# 交换机，路由器channel.exchange_declare(exchange=exchange_name, exchange_type='topic') # 话题# 队列#channel.queue_declare(queue=queue_name)#q = channel.queue_declare(queue='') 不指定名称，queue名称会随机生成 q.method.queueq1 = channel.queue_declare(queue='', exclusive=True) #exclusive 在断开时，会queue删除q2 = channel.queue_declare(queue='', exclusive=True) #exclusive 在断开时，会queue删除q1name = q1.method.queueq2name = q2.method.queuechannel.queue_bind(exchange=exchange_name, queue=q1name, routing_key=colors[0]) # 将队列和某一个交换机关联channel.queue_bind(exchange=exchange_name, queue=q2name, routing_key=colors[1]) # 将队列和某一个交换机关联def callback(ch, method, properties, body): print("msg = &#123;&#125;".format(body), method)with connection: # 消费者，每一个消费者使用一个basic_consume channel.basic_consume(queue=q1name, auto_ack=True, on_message_callback=callback) channel.basic_consume(queue=q2name, auto_ack=True, on_message_callback=callback) print(' [*] Waiting for messages. To exit press CTRL+C') channel.start_consuming() # 启动所有消费，直到道所有消费结束，才能退出，阻塞的 观察消费者拿到的数据，注意观察 phone.red 的数据出现的次数由此，可以知道 交换机在路由消息的时候，只要和queue的routing_key匹配，就把消息发给该queue RPC 远程过程调用RabbitMQ的RPC的应用场景较少，因为有更好的RPC通信框架 消息队列的作用 系统间解耦 解决生产者、消费者速度匹配 由于稍微上规模的项目都会分层、分模块开发，模块间或系统间尽量不要直接耦合，需要开放公共接口提供给别的模块或系统调用，而调用可能触发并发问题，为了缓冲和解耦，往往采用中间件技术 RabbitMQ只是消息中间件中的一种应用程序，也是较常用的消息中间件服务]]></content>
      <categories>
        <category>中间件</category>
      </categories>
      <tags>
        <tag>RabbitMQ</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmware]]></title>
    <url>%2Flinux%2FCentOS7%E4%BD%BF%E7%94%A8firewalld%E6%89%93%E5%BC%80%E5%85%B3%E9%97%AD%E9%98%B2%E7%81%AB%E5%A2%99%E4%B8%8E%E7%AB%AF%E5%8F%A3%2F</url>
    <content type="text"><![CDATA[1、firewalld的基本使用启动： systemctl start firewalld关闭： systemctl stop firewalld查看状态： systemctl status firewalld开机禁用 ： systemctl disable firewalld开机启用 ： systemctl enable firewalld 2.systemctl是CentOS7的服务管理工具中主要的工具，它融合之前service和chkconfig的功能于一体。启动一个服务：systemctl start firewalld.service关闭一个服务：systemctl stop firewalld.service重启一个服务：systemctl restart firewalld.service显示一个服务的状态：systemctl status firewalld.service在开机时启用一个服务：systemctl enable firewalld.service在开机时禁用一个服务：systemctl disable firewalld.service查看服务是否开机启动：systemctl is-enabled firewalld.service查看已启动的服务列表：systemctl list-unit-files|grep enabled查看启动失败的服务列表：systemctl –failed 3.配置firewalld-cmd查看版本： firewall-cmd –version查看帮助： firewall-cmd –help显示状态： firewall-cmd –state查看所有打开的端口： firewall-cmd –zone=public –list-ports更新防火墙规则： firewall-cmd –reload查看区域信息: firewall-cmd –get-active-zones查看指定接口所属区域： firewall-cmd –get-zone-of-interface=eth0拒绝所有包：firewall-cmd –panic-on取消拒绝状态： firewall-cmd –panic-off查看是否拒绝： firewall-cmd –query-panic 那怎么开启一个端口呢添加firewall-cmd –zone=public –add-port=80/tcp –permanent （–permanent永久生效，没有此参数重启后失效）重新载入firewall-cmd –reload查看firewall-cmd –zone= public –query-port=80/tcp删除firewall-cmd –zone= public –remove-port=80/tcp –permanent]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[vmware]]></title>
    <url>%2Flinux%2F%E6%96%B0%E6%89%8B%E5%A6%82%E4%BD%95%E5%AE%89%E8%A3%85%E5%8F%8A%E9%85%8D%E7%BD%AEVMware%20Workstation%E8%99%9A%E6%8B%9F%E6%9C%BA%E5%8F%8AXshell%E8%BF%9C%E7%A8%8B%E7%AE%A1%E7%90%86%E8%BD%AF%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[新手如何安装及配置虚拟机及远程管理软件&ensp;&ensp;&ensp;&ensp;VMware Workstation Pro &amp; Xshell 下载并安装VMware Workstation Pro及Xshell。 访问mirrors.163.com，下载镜像centos。登陆后找到镜像名centos/，点击后下载最新版（如7系版本）(CentOS-7-x86_64-Everything-1810.iso) 。 打开VMware Workstation Pro软件，需要输入密钥，可在某度寻找。 如何新建虚拟机，步骤如下： &ensp;&ensp;&ensp;&ensp;点击创建新的虚拟机，选择‘ 典型 ’；&ensp;&ensp;&ensp;&ensp;安装来源选择‘ 稍后安装操作系统 ’；&ensp;&ensp;&ensp;&ensp;客户机操作系统选择Linux，版本选择CentOS 7 64位；&ensp;&ensp;&ensp;&ensp;保存位置建议为固态硬盘；&ensp;&ensp;&ensp;&ensp;磁盘大小设置为200G，选择“将虚拟磁盘储存为单个文件”，完成。 双击设备下任意处，1弹出的对话窗口中设置如下： &ensp;&ensp;&ensp;&ensp;内存设置为2048MB；&ensp;&ensp;&ensp;&ensp;处理器数量为2；&ensp;&ensp;&ensp;&ensp;CD/DVD(IDE) 连接方式为使用ISO映像文件，选择刚才下载的镜像文件装入即可；&ensp;&ensp;&ensp;&ensp;网络适配器设置为仅主机模式。 单机菜单栏绿色三角形，启动虚拟机(Ctrl+Alt+enter为切换窗口大小) 1注：第一选项为安装，第二项为测试media并安装，第三项为修复(默认选择第二项)。 测试完毕后，选择如下 &ensp;&ensp;&ensp;&ensp;语言选择默认English，点击右下角Continue；&ensp;&ensp;&ensp;&ensp;DATE&amp;TIME 设置为上海（可直接在地图上选择位置），左下角时间修改为当前北京时间；&ensp;&ensp;&ensp;&ensp;KEYBOARD 键盘默认为美国键盘，无需修改；&ensp;&ensp;&ensp;&ensp;INSTALLATION SOURCE 默认为光盘安装，无需修改；&ensp;&ensp;&ensp;&ensp;SOFTWARE SELECTION，选择如何安装，装什么软件。工作中默认为最小安装，初学者选择GNOME Desktop(图形界面)；&ensp;&ensp;&ensp;&ensp;INSTALLATION DESTINATION安装目标即为分区，点击选择I will configure partitioning（我将自己安装分区)，点击Done；&ensp;&ensp;&ensp;&ensp; 弹出的界面默认为LVM逻辑卷，更改为Standard Partition标准分区，点击添加“+”。 选择Mount Point挂载点为 /boot，大小为1G； 添加根 ‘/‘，大小为100G； 添加‘/data’，因为data不属于操作系统自带的文件夹，所以需要手写添加。创建data的目的是为了后续方便存放临时文件，大小为50G； 添加 /swap，大小为4G，物理内存的两倍大小。注：swap的Mount Point挂载点为灰色，因为swap是模拟内存用的，不为文件夹，此File System文件系统为专有的swap。 &ensp;&ensp;&ensp;&ensp;点击Done，选择Accept changes接受上列的更改。&ensp;&ensp;&ensp;&ensp;NETWORK &amp; HOST NAME网络，设置Host name主机名，Ethernet(ens33)网卡如果为Dissonnected，需要点击右边按钮打开网卡。显示后的IP地址可以从windows中ping通（从windows中打开cmd,输入ping (为IP地址)，出现来自 的回复 ，即为连通。&ensp;&ensp;&ensp;&ensp;点击 Begin installation，弹出的选项中需要设置 ROOT PASSWORD系统管理员账户，设置 USER CREATION普通用户。安装完毕后，设置 LICENSING许可，点击 I accept the license agreement。安装完毕。 备份系统，两种方法 右击当前窗口任务栏，选择快照，拍摄快照。备份完成。 右击当前窗口任务栏，选择设置，点击选项，将右侧的工作目录文件夹直接复制一份至其他磁盘（复制前如文件中有临时文件，需先关闭当前虚拟机任务）。备份完成。 重启虚拟机。点击打开虚拟机，找到刚才存放VMX的文件夹，点击任务栏的绿色小三角 ，登陆后设置初始化。设置语言、键盘、定位（建议关闭）、在线用户（没有可忽略）。 如何打开Terminal敲命令，执行操作的窗口，简称终端。点击Applications–System Tools–Terminal，完成。 注：[wang@centos7 -]$，wang指用户名，centos7指主机最前部分名称， - 指存放的文件夹位置，但是CentOS系统默认显示的‘ - ’为wang@centos7的home目录。只要为home，都会以‘ - ’显示，提示符‘$’为普通用户。 查看当前网卡是否连接通，输入 ip a回车,如果ens33未显示IP地址，则未通。 输入 nmcli connection up ens33 , 即可在ens33下查看到IP地址。 打开Xshell，点击左上角的+，输入名称（可直接设置为IP地址，方便查看），主机IP地址（刚才查询到的IP地址） 点击用户身份验证，用户名为“root“，密码为之前CentOS设置的密码，点击确定，点击链接，选择接受并保存。 root链接的提示符‘#’为管理员意思。 &ensp;&ensp;&ensp;&ensp;以上为安装及配置虚拟机及远程管理软件详细过程，仅供参考；如有错误之处，欢迎批评指正，谢谢！]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python面试题]]></title>
    <url>%2Fpython%2Fpython%E9%9D%A2%E8%AF%95%E9%A2%98%2F</url>
    <content type="text"><![CDATA[重点知识 12]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flask]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%2Fflask%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[下载示例代码, 安装到当前目录的flasky文件夹下. 1git clone https://github.com/miguelgrinberg/flasky.git 123456git checkout 1agit reset --hardgit fetch --allgit fetch --tagsgit reset --hard orign/mastergit diff 2a 2b flask在大多数标准中, flask都算小型框架, 小到可以称为”微框架”.它具有一个包含接班服务的强健核心, 其他功能则可通过扩展实现. flask有3个主要依赖: 路由,调试, web服务网关接口(wsgi)子系统由werkzeug提供, 模板系统由jinja2提供, 命令行集成有click提供. 创建应用目录 12git clone https://github.com/miguelgrinberg/flasky.gitcd flasky 初始化 所有的Flask应用都必须创建一个应用实例.web服务器使用一种名为web服务器网关接口(wsgi)的协议.把接收自客户端的所有请求都转交给这个对象处理.应用实例是Flask类的对象.通常有下列代码创建. 12from flask import Flaskapp = Flask(__name__) 在flask中有两种上下文: 应用上下文和请求上下文. 钩子函数:有时在处理请求之前或之后执行代码会很有用. before_request 注册一个函数, 在每次请求之前运行 before_first_request 注册一个函数, 只在处理第一个请求之前运行,可以通过这个钩子函数添加服务器初始化任务. after_request注册一个函数, 如果没有未处理的异常抛出, 在每次请求之后运行. teardown_request 注册一个函数, 即使有未处理的异常抛出, 也在每次请求之后运行. 在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g,]]></content>
      <categories>
        <category>后端框架</category>
        <category>flask</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ansible]]></title>
    <url>%2Flinux%2Fandible%2F</url>
    <content type="text"><![CDATA[ansible简介安装ansibleyun install -y ansible todoansible 文档https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#foreword]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>运维</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据分析]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90%2FPandas%E8%AF%A6%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[Pandas:最流行的Python数据分析库 基于Numpy, 专用于数据预处理和数据分析的Python第三方库, 最适合处理大型结构化表格数据. Pandas两大数据类型 Series: 一维 DataFrame: 二维 Series数据类型 12a = pd.Series([3, 4, 5, 6, 7])a DataFrame数据类型 12b = pd.DataFrame([3, 4, 5], [6, ,7, 8], [9, 10, 11])b 抽象和维度 维度: 观察事物的角度 日常保存数据的数据格式: 0维: 字符串, 单值变量 1维: 列表, 字典(1成括号) 2维: Excel表格, Mysql数据库 3维或以上: JSON, MongoDB, HTML Pandas各个数据类型的关系： 0维单值变量 -&gt; 1维Series -&gt; 2维DataFrame -&gt; 3维层次化DataFrame Series列表创建Series a = pd.Series([2, 3, 5]) 字典创建Series 123# 索引就是字典字典的键d = pd.Series(&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;gander&apos;:True&#125;)d 其他方式 123# 标量创建pd.Series(5)pd.Series(5, index=[1,2, 3, 4, 5]) 12345# Numpy的序列函数创建np.arange(5)np.arange(2, 5)np.arange(9, 5, -1) 查询 1class1 = pd.Series([95, 25, 59, 61], index=[&apos;ming&apos;, &apos;hua&apos;, &apos;hong&apos;,&apos;huang&apos;, &apos;bai&apos;]) 查询数据形状 1维数据的形状就是它的值个数 1class1.shape, class1.shape[0] 查询值(values) 和索引(index) 一个Series数据是由2个ndarray数组组成的 12# 查询值class1.values 查询值 根据索引查询值 索引查询 切片插叙 根据条件反查索引 布尔查询 索引查询 索引和切片都是根据索引查询值 class1 查询单值 123# Series有两套索引：默认索引，自定义索引class1[&apos;hong&apos;] # 自定义索引class1[2] # 默认索引 查询多值 12class1[[&apos;hua&apos;, &apos;bai&apos;]]class1[[1, 4]] 切片查询 1234# 默认索引：包含起始值，不包含结束值class1[:3] class1[2:]class1[1:4] 布尔查询 根据值反查索引 根据条件反查索引 12# 布尔查询class1[[False, True, True, False, False]] 向量化运算矢量运算, 并行运算 123a = pd.Series(x)aa + 5 # 向量化运算, 不需要遍历, 速度快效率高 123# Pandas向量化方式a.sum() # Pandas方法np.sum(class1) # Numpy方法 类Numpy数组操作, 和类Python字典的操作 Pandas数据可以执行全部Numpy数据操作(因为Pandas底层基于Numpy, 所以通用) 也可以执行部分Python原生列表或字典操作(仅限于Pandas实现的操作) 类Numpy数组操作 1np.mean(class1) # Numpy方法 类Python字典操作 in关键字: 判断某索引是否存在 get方法:判断某索引是否存在, 存在则直接输出值, 不存在则输出定义值 DataFrame对象 - 创建DataFrame对象是Pandas最常用的数据类型 DataFrame对象是由多个Series增加一个索引后组成一种表格类型数据结构 DataFrame对象既有行索引, 又有列索引 行索引,表明不同行, 横向索引, 叫index, 0轴, axis=0 列索引, 表名不同列, 纵向索引, 叫colums, 1轴, axis=1 列表创建 ndarry数组创建 字典内嵌套列表：要求内部列表等长 字典内嵌套字典：内部字典不需要等长 字典内嵌套Series：等同嵌套字典 列表创建 12# 默认索引pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]]) 使用Numpy数组创建 Numpy数组类似一个高级版的Python列表 123np.arange(10)np.arange(10).reshape(2, 5) 字典创建 字典内嵌套列表 列表值需要等长, 否则报错 12345678pd.DataFrame( &#123; '姓名': ['张三', '李四', '王五'], '年龄': [18, 28, 38], '性别': [True, True, False], '分数': [85.5, 59, 78], &#125;) 字典嵌套字典字典不要求等长 12345678pd.DataFrame( &#123; 'name': &#123;1: '张三', 2: '李四', 3: '王五'&#125;, 'age': &#123;1: 18, 2: 28, 3: 38&#125;, 'gender': &#123;1: True, 2: True, 3: False&#125;, 'grade': &#123;1: 85.5, 3: 78&#125;, # 不等长也不报错 &#125;,) DataFrame整体查询 123456a.shape # 表格形状，行数 列数a.dtypes # 列数据类型a.index # 行索引a.columns # 列索引a.values # 对象值，二维ndarray数组 整体数据情况 a.info()整体信息, 查看:数据是否异常 有没有缺失值 列数据类型是否正确 a.describe()整体统计指标 a.head() 前5行 a.tail() 后5行 内容查询 类列表/字典/ndarray数组的查询方式 功能简陋, 一般仅用于查询单列 Pandas专用查询方式：经过优化，推荐 三种查询方式： 索引 切片 过滤 索引和切片查询，两种查询方式： a.loc[行,列]，标签索引，自定义索引 a.iloc[行,列]，位置索引，默认索引 参数书写顺序都是都是先行后列 索引查询用于不连续(行列有间隔)行列区块查询 查询单行 1234567# 自定义索引查询a.loc[3] # 简写a.loc[3, :] # 完整写法# 默认索引a.iloc[2]a.iloc[2, :] 查询多行 1234a.loc[[2, 4]] # 选中所有列，省略了列条件a.loc[[2, 4], :] # 完整写法a.iloc[[1, 3]] 索引查询和切片查询的区别 索引查询更适合查询不连续的行列数据 切片查询适合查询连续行和列数据 索引查询可以实现切片查询的所有功能，只是有个书写效率问题 用索引查询查连续数据，需要将每个索引都写上，效率低 切片查询连续数据，只要写起始和结束索引即可。 切片不能查询不连续数据 查询时：优先使用切片查询，无法实现功能时再使用索引查询 专用查询：过滤查询索引查询和切片查询, 都是通过索引查询值 过滤查询(布尔查询) : 通过值查询索引 过滤查询不通过索引, 而是通过值查询 用于结果索引不确定的查询 通过运算所得布尔值对查询结果进行过滤 类list/字典查询方式 专用查询方式的布尔查询 12# 布尔查询a.loc[[False, True, False, True, False], [True, True, False, False, False, True, False]] 12# 查询不及格同学的姓名、年龄和成绩a.loc[a['grade'] &lt; 60, ['name', 'age', 'grade']] where过滤（了解）另一种简洁的布尔查询写法 总结 原生的布尔查询，需要每列单独判断条件，然后用逻辑运算符组合条件，得出最终结果 where过滤过滤：先将所有需要判断条件的列抽出来，整体判断，得出最终结果 优点：写法简洁 缺点：where过滤所有列的判断条件，只能有一个，使用受限 视图模式 将一个对象整体赋值给另一个变量 修改一个变量，另一个变量值也会变 多个变量数据指向同一内存数据 副本模式 将一个对象查询的一部分值赋值给另一个变量 修改一个变量，另一个变量值不会变 当将一个对象整体赋值给另一个变量时，视图模式，两个变量对应的内存地址相同，修改一个变量，另一个变量也会改变。 当使用copy()将一个对象赋值给另一个变量时 或者使用查询赋值，查询数据的一部分并赋值给其他变量 当赋值为原数据查询的一部分时，是副本模式，修改一个变量不会影响另一个变量 变量查询一部分数据理论上是副本模式，但实际上，直接修改赋值变量时会报警告（能修改成功） 1a[['name', 'sex', 'address']] 数据操作 创建：C,Create 查询：R,Read 增加：I,Insert 修改：U,Update 删除：D,Delete pandas数据操作: 其他操作 pandas对象的命名: name pandas对象的遍历 Pandas对象的命名:name Series和Dataframe对象本身, 索引都可以命名 数据的输入和输出是Pandas的基础操作 Pandas可以存取多种介质类型数据：常见的有： 文本类数据 csv JSON 二进制磁盘数据 Excel pkl HDF5 数据库 SQL（略） Web API数据 HTML 其他 内存 12345文本类数据文件读入Pandas时会自动推断每列数据类型（类型推断）和数据编码并转化。二进制类数据文件没有编码问题，且部分文件会在格式中存储数据类型不需转化对Pandas不能直接支持或不方便使用的数据格式，可以使用支持软件将其转为csv或xlsx格式后使用Pandas读写，如SPSS文件]]></content>
      <categories>
        <category>数据分析</category>
      </categories>
      <tags>
        <tag>数据分析</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[单元测试]]></title>
    <url>%2Fpython%2FPyUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95%2F</url>
    <content type="text"><![CDATA[Pyunit(unittest) 是python 自带的单元测试框架, 用于编写和运行可重复的测试.pyunit是xunit体系的一个成员, xunit是众多测试框架的总称,pyunit主要用于进行白盒测试和回归测试. 通过Pyunit可以让测试具有持久性, 测试与开发同步进行, 测试代码与开发代码一同发布.使用PyUnit具有如下好处: 可以是测试代码与产品代码分离. 针对某一个类的测试代码只需进行较少的改动, 便可以应用于另一个类的测试. PyUnit开放源代码, 可以进行二次开发, 方便对Pyunit的扩展.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解restful]]></title>
    <url>%2Fweb%2F%E7%90%86%E8%A7%A3restful%2F</url>
    <content type="text"><![CDATA[Restful API越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件. 这种”互联网软件”采用客户端/服务器模式, 建立在分布式体系上, 通过互联网通信, 具有高延时(high latency) , 高并发等特点. 网站开发, 完全可以采用软件开发的模式, 但是传统上, 软件和网络是两个不同的领域, 很少有交集. 软件开发主要针对单机环境, 网络则主要研究系统之间的通信. RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。 但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。 resourcesrest的名称”表现层状态转化” 中, 省略了主语, “ 表现层” 其实指的是”资源”(resource) 的”表现层”. 所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。 所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。 表现层(representation)“资源”是一种信息实体, 他可以有多种外在表现形式. 我们把”资源” 具体呈现出来的形式. 叫做它的”表现层”(representation). 比如, 文本可以用txt格式表现, 也可以用html格式, xml格式,JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。 URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。 访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。 互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。 客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。 注意:资源不能是动词. 在RESTful架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表格名对应.一般来说, 数据库中的表都是同种记录的”集合”, 所以api中的名词也应该使用复数. http方法对于资源的具体操作类型, 由http动词表示. 常用的http动词有下面五个, (括号里对应的sql命令). GET（SELECT）：从服务器取出资源（一项或多项）。 POST（CREATE）：在服务器新建一个资源。 PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。 PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。 DELETE（DELETE）：从服务器删除资源。 还有两个不常用的http动词. HEAD:获取资源的元数据. OPTIONS:获取信息, 关于资源的那些属性是客户端可以改变的. 下面是一些例子: GET /zoos：列出所有动物园 POST /zoos：新建一个动物园 GET /zoos/ID：获取某个指定动物园的信息 PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息） PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息） DELETE /zoos/ID：删除某个动物园 GET /zoos/ID/animals：列出某个指定动物园的所有动物 DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物 过滤信息(filtering) 如果记录信息很多, 服务器不可能都将他们返回给用户, API应该提供参数, 过滤返回结果. 下面是一些常见的参数. ?limit=10：指定返回记录的数量 ?offset=10：指定返回记录的开始位置。 ?page=2&amp;per_page=100：指定第几页，以及每页的记录数。 ?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。 ?animal_type_id=1：指定筛选条件 参数的设计允许存在冗余, 即允许api路径和url参数偶尔有重复.比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。 api的身份认证应该使用oauth 2.0框架. 服务器返回的数据格式, 应该尽量使用json, 避免使用xml.]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>理解restful</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python部署]]></title>
    <url>%2Fpython%2F%E9%83%A8%E7%BD%B2%2F</url>
    <content type="text"><![CDATA[Django打包 构建setup.py文件 1234567useradd pythonecho python | passwd python --stdinyum install git python-devel mysql-develyum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-develcurl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash 123export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;eval &quot;$(pyenv init -)&quot;eval &quot;$(pyenv virtualenv-init -)&quot; 1234567source .bashrc [global]index-url = https://mirrors.aliyun.com/pypi/simple/[install]trusted-host=mirrors.aliyun.com python setup.py sdist –formats=gztar ln -sv blog-1.0 web /root/blog/projects/web uwsgi -d –ini blog.ini 后台启动服务, 123456789101112131415161718import &#123; resolve &#125; from &quot;url&quot;;let p = new Promise((resolve, reject) =&gt; &#123; //做一些事情 //然后再某些条件下resolve, 或者reject if(/*条件随便写*/) &#123; resolve() &#125;else&#123; reject() &#125;&#125;)p.then(() =&gt; &#123; //如果p的状态被resolve, 就进入这里&#125;), () =&gt; &#123; //如果p的状态被reject,进入这里&#125; 第一段调用了Promise构造函数, 第二段是调用了promise实例的.then方法 构造实例 构造函数接受一个参数作为参数 调用构造函数得到实例p的同时,作为参数的函数会立即执行. 参数函数接受两个回调函数参数resolve和reject 在参数函数被执行的过程中, 如果在其内部调用resolve, 会被p的状态变为fulfilled, 或者调用reject, 会将p的状态变为rejected. 调用.then 调用.then可以为实例p注册两种状态回调函数 当实例p的状态为fulfilled, 会触发第一个函数执行 当实例p的状态为rejected, 则会触发第二个函数执行. 总结 上面这样构造promise实例, 然后调用.then.then.then的编写代码方式, 就是promise. 其基本模式是: 将异步过程转换成promise对象. 对象有三种状态, 通过.then注册状态的回调. 已完成的状态能触发回调. 采用这种方式来处理编程中的异步任务, 就是在使用promise了. 所以promise就是一种异步编程模式.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>项目部署</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[理解js中的promise]]></title>
    <url>%2Fjs%2F%E7%90%86%E8%A7%A3js%20%E7%9A%84promise%2F</url>
    <content type="text"><![CDATA[概念ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示. 简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理. 12345//语法new Promise( /*下面定义的函数是executor*/ function(resolve, reject) &#123;...&#125;); executor是一个带有resolve和reject 两个参数的函数. executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败. 如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略. executor中, resolve或reject只能执行其中一个函数. promise的状态 fulfilled:意味着操作成功完成 pending:初始状态,不是成功或失败状态 rejected: 意味着操作失败. Promise.then(onfilled, onRejected) 参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉. catch(onRejected) 为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象. Promise提供2个方法: Promise.resolve(value)返回 状态为fulfilled的Promise对象 Promise.reject(reason)返回 状态为rejected状态的Promise对象. catch其实是then(undefined, () =&gt; {})的语法糖,如下: 1234let p = Promise.reject('error');p.catch(err =&gt; &#123; console.log('catch' + err);&#125;) Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调. 实例 1234567891011121314151617181920212223242526272829function runAsync()&#123; return new Promise(function(resolve, reject)&#123; setInterval(function()&#123; console.log('do sth ----') resolve('ok----') &#125;, 3000); &#125;);&#125;//调用runAsync().then( value =&gt; &#123; console.log(value); return Promise.reject(value + '*'); &#125;).catch( reason =&gt; &#123; console.log(reason); return Promise.resolve(reason + '*'); &#125;).then( value =&gt; &#123; console.log(value); console.log('Promise end') &#125;)console.log('=========')]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[序列化与json]]></title>
    <url>%2Fweb%2F%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson%2F</url>
    <content type="text"><![CDATA[序列化与反序列化内存中的字典,列表,集合以及各种对象,如何保存到一个文件中. 如果是自己定义的类的实例, 如何保存到一个文件中. 如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例. 要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化. 定义serialization 序列化 将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制 deserialization 反序列化 将文件的一个个字节恢复成内存中对象 &lt;-二进制 序列化保存到文件就是持久化. 可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化. jsonJSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。 json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。 1、JSON语法规则JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。 （1）简单值 简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。 12345678910111213// 简单值"Hello World!" // 字符串99 // 数值true // 布尔型false // 布尔型null// 在JSON中不能使用的值NaN // 数值不能是NaNInfinity // 数值不能是Infinityundefined // 在JSON也不可以使用JavaScript中的undefined'Hello World!' // 字符串必须使用双引号表示，不能使用单引号0x1 // 数值必须以十进制表示，不能使用十六进制 （2）对象 对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。 123456789101112// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号&#123; "name": "Andy", "age": 18, "isStudent": true, "isLeader": false, "mark": null, "school": &#123; "name": "BIT", "region": "Beijing" // 这个地方不能有逗号，因为是对象的最后一个属性成员 &#125; // 这个地方也不可以有逗号，因为也是对象的最后一个属性成员&#125; （3）数组 数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。 12345678910111213141516// 示例一["Andy", "Ruby", "Danny", "Peter", "Lisa"]// 示例二[1, 2, 3, 4, 5, 6, 7, 8, 9, 0]// 示例三[ &#123;"name": "Andy", "age": 18&#125;, &#123;"name": "Ruby", "age": 18&#125;, &#123;"name": "Danny", "age": 20&#125;]// 示例四[ [0, 1, 2], [3, 4, 5], [6, 7, 8]] 2、JSON字符串和JSON对象（1）JSON字符串 JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。 1234//JSON字符串var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string （2）JSON对象 JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。 12345678// JSON对象var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object （3）JSON字符串和JSON对象互相转换 JavaScript中有一个全局的对象，JSON。JSON中有两个方法 stringify() 和 parse()。 JSON.parse() 把JSON字符串解析为JSON对象 12345//JSON字符串通过parse转化为JSON对象var p ='&#123;"name":"Andy","gender":"男","age":"18"&#125;';person = JSON.parse(p)console.log(person.name);// 在控制台输出Andy，可以通过点运算直接访问对象属性alert(typeof(person));// object JSON.stringify() 用于把JSON对象序列化为JSON字符串。 123456789//JSON对象通过stringify转化为JSON字符串var person=&#123; "name":"Andy", "gender":"男", "age":"18"&#125;var p = JSON.stringify(person)console.log(p); // &#123;"name":"Andy","gender":"男","age":"18"&#125;alert(typeof(p));// string]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>序列化</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[编程的4门功课]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91%2F</url>
    <content type="text"><![CDATA[计算机组成原理首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。 操作系统原理综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。 现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！我希望我写过的程序能在任何一台机上运行。我希望我能边听音乐边干活——即同一时间可以运行多个程序。我希望别人写的傻×东西不要影响到我的工作——即多任务控制。我希望计算机里面的各种资源都能得到良好的组织，更快的访问。我希望我的用户界面更好看，使用更方便，功能更强大！我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。 而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。 既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。 至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。 数据结构数据结构的作用, 就是为了提高硬件利用率. 比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。 数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。 计算机网络计算机网络分为3块： 硬件网卡，网线，交换机这些，用来处理数据的。 协议数据在网络中通信如何组织？如何识别？如何保证数据的正确性？这2块我就不多说了。 操作系统这就是如何把计算机网络和操作系统结合起来的问题了。对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。 网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>计算机</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web路由]]></title>
    <url>%2Fweb%2Fweb%E8%B7%AF%E7%94%B1%2F</url>
    <content type="text"><![CDATA[web开发中路由route和路由器router到底是什么 1. 什么是路由在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。 2. router和route的区别route就是一条路由，它将一个URL路径和一个函数进行映射，例如： /users -&gt; getAllUsers() /users/count -&gt; getUsersCount() 这就是两条路由，当访问/users的时候，会执行getAllUsers()函数；当访问/users/count的时候，会执行getUsersCount()函数。 而router可以理解为一个容器，或者说一种机制，它管理了一组route。简单来说，route只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由router来处理的。一句话概括就是 “The router routes you to a route”。 3. 服务器端路由对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。 以Express为例， 12345678app.get(&apos;/&apos;, (req, res) =&gt; &#123; res.sendFile(&apos;index&apos;)&#125;)app.get(&apos;/users&apos;, (req, res) =&gt; &#123; db.queryAllUsers() .then(data =&gt; res.send(data))&#125;) 这里定义了两条路由： 当访问/的时候，会返回index页面 当访问/users的时候，会从数据库中取出所有用户数据并返回 不仅仅是URL 在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。 4. 客户端路由对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案： 基于Hash 基于History API (1) 基于Hash我们知道，URL中#及其后面的部分为hash。例如： 1234const url = require(&apos;url&apos;)var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)console.log(a.hash)// =&gt; #/foo/bar hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。 通过监听window对象的hashChange事件，可以实现简单的路由。例如： 123456789101112131415window.onhashchange = function() &#123; var hash = window.location.hash var path = hash.substring(1) switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; (2) 基于History API通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考： Manipulating the browser historyUsing the HTML5 History API我们可以通过监听window对象的popstate事件，来实现简单的路由： 1234567891011121314window.onpopstate = function() &#123; var path = window.location.pathname switch (path) &#123; case &apos;/&apos;: showHome() break case &apos;/users&apos;: showUsersList() break default: show404NotFound() &#125;&#125; 但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如： 1234567var pushState = history.pushStatehistory.pushState = function() &#123; pushState.apply(history, arguments) // emit a event or just run a callback emitEventOrRunCallback()&#125; 不过，最好的方法还是使用实现好的history库。 (3) 两种实现的比较总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。 但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。 假设服务器只有如下文件（script.js被index.html所引用）： 123/- |- index.html |- script.js 基于Hash的路径有： 12http://example.com/http://example.com/#/foobar 基于History API的路径有： 12http://example.com/http://example.com/foobar 当直接访问http://example.com/的时候，两者的行为是一致的，都是返回了index.html文件。 当从http://example.com/跳转到http://example.com/#/foobar或者http://example.com/foobar的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。 当直接访问http://example.com/#/foobar的时候，实际上向服务器发起的请求是http://example.com/，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。 当直接访问http://example.com/foobar的时候，实际上向服务器发起的请求也是http://example.com/foobar，然而服务器端只能匹配/而无法匹配/foobar，因此会出现404错误。 因此如果使用了基于History API的路由，需要改造服务器端，使得访问/foobar的时候也能返回index.html文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。 5. 动态路由上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。 例如在Express中： 12345678app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123; // ... ...&#125;)在Flask中：@app.route(&apos;/user/&lt;user_id&gt;&apos;)def get_user_info(user_id): pass 6. 严格路由在很多情况下，会遇到/foobar和/foobar/的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。 在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到/foobar/，而反过来则不会。 如果使用的是Express，默认这两者是一样的，也可以通过app.set来设置strict routing，来区别对待这两种情况。]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[yaml语言]]></title>
    <url>%2F%E5%85%B6%E4%BB%96%2FYaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Yaml语言编程Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便. 一、简介YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。 它的基本语法规则如下。 大小写敏感 使用缩进表示层级关系 缩进时不允许使用Tab键，只允许使用空格。 缩进的空格数目不重要，只要相同层级的元素左侧对齐即可 # 表示注释，从这个字符一直到行尾，都会被解析器忽略。 YAML 支持的数据结构有三种。 对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary） 数组：一组按次序排列的值，又称为序列（sequence） / 列表（list） 纯量（scalars）：单个的、不可再分的值 以下分别介绍这三种数据结构。 二、对象对象的一组键值对，使用冒号结构表示。 12&gt; animal: pets&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: 'pets' &#125;&gt; Yaml 也允许另一种写法，将所有键值对写成一个行内对象。 12&gt; hash: &#123; name: Steve, foo: bar &#125; &gt; 转为 JavaScript 如下。 12&gt; &#123; hash: &#123; name: 'Steve', foo: 'bar' &#125; &#125;&gt; 三、数组一组连词线开头的行，构成一个数组。 1234&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ 'Cat', 'Dog', 'Goldfish' ]&gt; 数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。 12345&gt; -&gt; - Cat&gt; - Dog&gt; - Goldfish&gt; 转为 JavaScript 如下。 12&gt; [ [ 'Cat', 'Dog', 'Goldfish' ] ]&gt; 数组也可以采用行内表示法。 12&gt; animal: [Cat, Dog]&gt; 转为 JavaScript 如下。 12&gt; &#123; animal: [ 'Cat', 'Dog' ] &#125;&gt; 四、复合结构对象和数组可以结合使用，形成复合结构。 12345678910&gt; languages:&gt; - Ruby&gt; - Perl&gt; - Python &gt; websites:&gt; YAML: yaml.org &gt; Ruby: ruby-lang.org &gt; Python: python.org &gt; Perl: use.perl.org &gt; 转为 JavaScript 如下。 1234567&gt; &#123; languages: [ 'Ruby', 'Perl', 'Python' ],&gt; websites: &gt; &#123; YAML: 'yaml.org',&gt; Ruby: 'ruby-lang.org',&gt; Python: 'python.org',&gt; Perl: 'use.perl.org' &#125; &#125;&gt; 五、纯量纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。 字符串 布尔值 整数 浮点数 Null 时间 日期 数值直接以字面量的形式表示。 12&gt; number: 12.30&gt; 转为 JavaScript 如下。 12&gt; &#123; number: 12.30 &#125;&gt; 布尔值用true和false表示。 12&gt; isSet: true&gt; 转为 JavaScript 如下。 12&gt; &#123; isSet: true &#125;&gt; null用~表示。 12&gt; parent: ~ &gt; 转为 JavaScript 如下。 12&gt; &#123; parent: null &#125;&gt; 时间采用 ISO8601 格式。 12&gt; iso8601: 2001-12-14t21:59:43.10-05:00 &gt; 转为 JavaScript 如下。 12&gt; &#123; iso8601: new Date('2001-12-14t21:59:43.10-05:00') &#125;&gt; 日期采用复合 iso8601 格式的年、月、日表示。 12&gt; date: 1976-07-31&gt; 转为 JavaScript 如下。 12&gt; &#123; date: new Date('1976-07-31') &#125;&gt; YAML 允许使用两个感叹号，强制转换数据类型。 123&gt; e: !!str 123&gt; f: !!str true&gt; 转为 JavaScript 如下。 12&gt; &#123; e: '123', f: 'true' &#125;&gt; 六、字符串字符串是最常见，也是最复杂的一种数据类型。 字符串默认不使用引号表示。 12&gt; str: 这是一行字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一行字符串' &#125;&gt; 如果字符串之中包含空格或特殊字符，需要放在引号之中。 12&gt; str: '内容： 字符串'&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '内容: 字符串' &#125;&gt; 单引号和双引号都可以使用，双引号不会对特殊字符转义。 123&gt; s1: '内容\n字符串'&gt; s2: "内容\n字符串"&gt; 转为 JavaScript 如下。 12&gt; &#123; s1: '内容\\n字符串', s2: '内容\n字符串' &#125;&gt; 单引号之中如果还有单引号，必须连续使用两个单引号转义。 12&gt; str: 'labor''s day' &gt; 转为 JavaScript 如下。 12&gt; &#123; str: 'labor\'s day' &#125;&gt; 字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。 1234&gt; str: 这是一段&gt; 多行&gt; 字符串&gt; 转为 JavaScript 如下。 12&gt; &#123; str: '这是一段 多行 字符串' &#125;&gt; 多行字符串可以使用|保留换行符，也可以使用&gt;折叠换行。 1234567&gt; this: |&gt; Foo&gt; Bar&gt; that: &gt;&gt; Foo&gt; Bar&gt; 转为 JavaScript 代码如下。 12&gt; &#123; this: 'Foo\nBar\n', that: 'Foo Bar\n' &#125;&gt; +表示保留文字块末尾的换行，-表示删除字符串末尾的换行。 12345678910&gt; s1: |&gt; Foo&gt; &gt; s2: |+&gt; Foo&gt; &gt; &gt; s3: |-&gt; Foo&gt; 转为 JavaScript 代码如下。 12&gt; &#123; s1: 'Foo\n', s2: 'Foo\n\n\n', s3: 'Foo' &#125;&gt; 字符串之中可以插入 HTML 标记。 123456&gt; message: |&gt; &gt; &lt;p style="color: red"&gt;&gt; 段落&gt; &lt;/p&gt;&gt; 转为 JavaScript 如下。 12&gt; &#123; message: '\n&lt;p style="color: red"&gt;\n 段落\n&lt;/p&gt;\n' &#125;&gt; 七、引用锚点&amp;和别名*，可以用来引用。 123456789101112&gt; defaults: &amp;defaults&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; &lt;&lt;: *defaults&gt; &gt; test:&gt; database: myapp_test&gt; &lt;&lt;: *defaults&gt; 等同于下面的代码。 1234567891011121314&gt; defaults:&gt; adapter: postgres&gt; host: localhost&gt; &gt; development:&gt; database: myapp_development&gt; adapter: postgres&gt; host: localhost&gt; &gt; test:&gt; database: myapp_test&gt; adapter: postgres&gt; host: localhost&gt; &amp;用来建立锚点（defaults），&lt;&lt;表示合并到当前数据，*用来引用锚点。 下面是另一个例子。 123456&gt; - &amp;showell Steve &gt; - Clark &gt; - Brian &gt; - Oren &gt; - *showell &gt; 转为 JavaScript 代码如下。 12&gt; [ 'Steve', 'Clark', 'Brian', 'Oren', 'Steve' ]&gt; 八、函数和正则表达式的转换这是 JS-YAML 库特有的功能，可以把函数和正则表达式转为字符串。 1234&gt; # example.yml&gt; fn: function () &#123; return 1 &#125;&gt; reg: /test/&gt; 解析上面的 yml 文件的代码如下。 123456789101112&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; try &#123;&gt; var doc = yaml.load(&gt; fs.readFileSync('./example.yml', 'utf8')&gt; );&gt; console.log(doc);&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt; 从 JavaScript 对象还原到 yaml 文件的代码如下。 123456789101112131415161718&gt; var yaml = require('js-yaml');&gt; var fs = require('fs');&gt; &gt; var obj = &#123;&gt; fn: function () &#123; return 1 &#125;,&gt; reg: /test/&gt; &#125;;&gt; &gt; try &#123;&gt; fs.writeFileSync(&gt; './example.yml',&gt; yaml.dump(obj),&gt; 'utf8'&gt; );&gt; &#125; catch (e) &#123;&gt; console.log(e);&gt; &#125;&gt;]]></content>
      <categories>
        <category>其他</category>
      </categories>
      <tags>
        <tag>yaml</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js基础]]></title>
    <url>%2Fjs%2Fjs%E5%9F%BA%E7%A1%80%2F</url>
    <content type="text"><![CDATA[js基础语法 常量和变量标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写. 声明 123456789var声明一个变量let声明一个块作用域中的局部变量const声明一个常量js中的变量声明和初始化时可以分开的.var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug. 数据类型 序号 名称 说明 1 number 数值型,包括整型和浮点型 2 boolean 布尔型,true和false 3 string 字符串 4 null 只有一个值null 5 undefined 变量声明未赋值的;对象未定义的属性 6 symbol ES6新引入类型 7 object 是以上基本类型的复合类型,是容器 弱类型,不需要强制类型转换, 会隐式类型转换. NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN 总结: 1234567遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换. 三元运算符条件表达式?真值:假值 等价于简单的if…else结构 函数, 匿名函数,函数表达式的差异 函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已. 区别在于, 函数会声明提升, 函数表达式不会 . 高阶函数: 函数作为参数或返回 一个函数. 函数12345678function 函数名(参数列表)&#123; 函数体; return 返回值;&#125;function add(x, y)&#123; return x + y;&#125;console.log(add(3, 5)); 函数, 匿名函数, 函数表达式的差异函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已. 区别在于, 函数会申明提升, 函数表达式不会. 123456789console.log(add(4, 6));// 匿名函数function add(x, y)&#123; return x + y;&#125;const sub = function (x, y)&#123; return x -y;&#125;console.log(sub(5, 6)); 高阶函数 高阶函数: 函数作为参数或返回一个函数 箭头函数箭头函数就是匿名函数,它是一种更加精简的格式. 箭头函数参数 如果一个函数没有参数,使用() 如果只有一个参数,参数列表可以省略小括号() 多个参数不能省略小括号,且使用逗号间隔. 箭头函数返回值. 如果函数体部分有多行,就需要使用{}, 如果有返回值使用return. 如果只有一行语句, 可以同时省略大括号和return. 只有return语句, 就不能省略大括号, 如果只有一条非return语句, 加上大括号, 函数就成了无返回值, 函数参数普通参数一个参数占一个位置,支持默认参数. 可变参数(rest parameters剩余参数) js使用…表示可变参数(python用*手机多个参数) 12345678const sum = function (...args)&#123; let result = 0; for (let x in args)&#123; result += args[x] &#125; return result&#125;;console.log(sum(3, 6, 9)) arguments对象函数的所有参数会被保存在一个arguments的键值对对象中. 参数解构和python类似, js提供了参数解构, 依然使用了…符号来结构. 1234const add = (x, y) =&gt;&#123;console.log(x, y); return x + y&#125;;console.log(add(...[100, 200]))console.log(add(...[100, 200, 300]))console.log(add(...[100])) 函数返回值python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组. 表达式的值 类c的语言,都有一个概念 – 表达式的值 赋值表达式的值: 等号右边的值 逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值. 异常抛出异常 js的异常语法和java相同, 使用throw关键字抛出. 使用throw关键字可以抛出任意对象的异常. 1234throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok'; 捕获异常try…catch语句捕获异常 try …catch…finally 语句捕获异常, finally保证最终一定执行. 问题: null和undefined的异同1.undefined：是所有没有赋值变量的默认值，自动赋值。 2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。 当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。 共同点：都是原始类型，保存在栈中变量本地。 不同点： undefined——表示变量声明过但并未赋过值。 它是所有未赋值变量默认值，例如： 1var a; // a 自动被赋值为 undefined null——表示一个变量将来可能指向一个对象。 一般用于主动释放指向对象的引用，例如： 12var emps = [&apos;ss&apos;,&apos;nn&apos;]; emps = null; // 释放指向数组的引用 它是专门释放对象内存的一个程序。 在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期； 总有一个对象不再被任何变量引用时，才释放]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>JavaScrript</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fpython%2F%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[特殊属性 属性 含义 __name__ 类,函数,方法等名字 __module__ 类定义所在的模块名 __class__ 对象或类所属的类 __base__ 类的基类的元组,顺序为他们在基类中出现的顺序 __doc__ 类, 函数的文档字符串, 如果没有定义则为None __mro__ 类的mro, class.mro()返回的结果的保存在__mro__ 中 __dict__ 类或实例的属性, 可写的字典 查看属性__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它. 如果dir()参数obj包括方法_dir__(), 该方法将被调用.如果参数obj不包含\_dir__(), 该方法将最大限度地收集属性信息. dir(obj)对于不同类型的对象obj具有不同的行为: 如果对象是模块对象, 返回的列表包含模块的属性名和变量名 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名 如果是类的实例 有__dir__方法, 返回可迭代对象的返回值 没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名 如果obj不写, 返回列表包含内容不同 在模块中, 返回模块的属性和变量名 在函数中, 返回本地作用域的变量名 在方法中, 返回本地作用域的变量名 123456789# animal.pyclass Animal: x = 123 def __init__(self, name): self._name = name self.__age = 10 self.weight = 20 print('animal Module\ s names = &#123;&#125;'.format(dir()))# 模块的属性 ) 魔术方法*** 分类: 创建, 初始化与销毁 可视化 hash bool 运算符重载 容器和大小 可调用对象 上下文管理 反射 描述器 其他杂项 实例化 方法 意义 __new__ 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法 __new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回 可视化 方法 意义 __str__ str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息 __repr__ 内建函数repr()对一个对象获取字符串表达 __bytes__ bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 123456class A: def __init__(self, name, age = 18): self.name = name self.age = age def __repr__(self): return 'repr:&#123;&#125;&#123;&#125;'.format(self.name, self.age) hash 方法 意义 __hash__ 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash __eq__ 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了 bool 方法 意义 __bool__ 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真 上下文管理文件IO操作可以对文件对象使用上下文管理，使用with。。as语法 12with open('test') as f: pass 仿照上例写一个自己的泪，实现上下文管理 1234class Point: passwith Point as p: pass 提示属性错误，没有__exit__，看了需要这个属性 某些版本会显示没有__enter__ 上下文管理对象 当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象 __enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上 __exit__退出与此对象相关的上下文 with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作 注意,with 并不开启一个新的作用域 上下文管理是安全的 上下文应用场景 1.增强功能 在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能 2.资源管理 打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等 3.权限验证 在执行代码之前,做权限验证,在__enter__ contextilb.contextmanager他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法 对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值. 也就是这个装饰器接受一个生成器对象作为参数. 总结 如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便 反射概述 运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候 反射, reflection, 指的是运行时获取类型定义信息 一个对象能够在运行时,像照镜子一样,反射出其类型信息 简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身 具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等 反射相关的函数和方法 getattar 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. setattar object的属性存在,这覆盖, 不存在,新增 hasattat 判断对象是否有这个名字的属性,name必须为字符串 反射相关的魔术方法__getattr__(), __setattr__(), __delattr__(), 三个魔术方法 实例属性会按照继承关系找, 如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出 AttributeError异常表示找不到属性. 查找属性顺序为: instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[面向对象]]></title>
    <url>%2Fpython%2F%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[语言的分类面向机器:抽象成机器指令, 机器容易理解.代表:汇编语言面向过程:做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.问题规模小, 可以步骤化.按部就班处理.代表:c语言面向对象OOP随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.代表:C++, java, python等 面向对象类:class类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.用计算机语言来描述类,是属性和方法的集合.对象:instance, object对象是类的具象, 是一个实体.对于我们每个人这个个体, 都是抽象概念人类不同的实体. 属性:它是对象状态的抽象,用数据结构来描述.操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.哲学:一切皆对象对象是数据和操作的封装.对象是独立的,但是对象之间可以相互作用.目前OOP是最接近人类认知的编程范式. 三要素1.封装组装:将数据和操作组装到一起.隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.2.继承多复用,继承来的就不用了自己写了多继承少修改,OCP,使用继承来改变,来体现个性.3.多态面向对象编程最灵活的地方,动态绑定人类就是封装人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:多态,继承自动物类的人类,猫类的操作’吃’不同. python的类:1.必须使用class关键字2.类名必须使用大驼峰命名3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上. 类对象及类属性类对象,类的定义执行后会生成一个类对象.类的属性,类定义中的变量和类中定义的方法都是类的属性.类变量,self指代当前实例本身. 实例化a = Myclass() # 实例化使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.实例化就真正创建一个该类的对象tom = Person()jerry = Person()每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.python类实例化后, 会调用init方法,这个方法第一个形式参数必须留给self,其他参数随意.init方法 注意:init()方法不能有返回值,也就是只能是return None 实例对象instance类实例化后一定会获得一个类的实例,就是实例对象init方法的第一参数self就是指代某一个实例自身.类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上. 实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法. 总结:是类的,也就是这个类所有实例的,器实例都可以访问到:是实例的,就是这个实例自己的,通过类访问不到.类变量是属于类的变量,这个类的所有实例可以共享这个变量.对象可以动态的给自己增加一个属性.实例属性的查找顺序指的是实例使用,.点号来访问属性.会先找自己的dict,如果没有,然后通过属性class找到自家的类, 再去类的dict中找.注意:如果实例使用dict访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找. 一般来说, 类变量可使用全大写来命名. 类方法和静态方法类方法:1.在类定义中,使用@classmethod装饰器的方法2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改4.通过cls可以直接操作类的属性.静态方法:在类定义中, 使用@staticmethod装饰器的方法2在调用时, 不会隐式的传入参数.静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理. 类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,原因是第一参数必须是类的实例.总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类. 访问控制:私有属性私有属性,使用双下划线开头的属性名就是私有属性. 私有属性的本质:类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了. 保护变量:在变量名前使用一个下划线,称为保护变量这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.私有方法:参照保护变量,私有变量,使用单下划线,双下化线的命名方法, 补丁可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变猴子补丁:在运行时,对属性,方法,函数,等进行动态替换其目的往往是为了通过替换,修改来增强,扩展原有代码的能力 属性装饰器一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性. property装饰器 后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性setter装饰器可以控制是否删除属性,很少用deleter装饰器可以控制是否删除属性,很少用property装饰器必须在前,setter deleter装饰器在后,property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果. 对象的销毁类中可以定义del方法 ,称为析构函数.作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用del方法.由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.封装:将数据和操作组织到类中,即属性和方法.将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[草稿]]></title>
    <url>%2F%E8%8D%89%E7%A8%BF%2F</url>
    <content type="text"><![CDATA[none 与NUll的区别表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为0,因为0是有意义的,而none是一个特殊的空值判断的时候 均是false属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被调用.如果参数不包含dir(),该方法将最大限度地收集参数信息. 功能性函数返回都为noneNone是一个特殊的常量。None和False不同。None不是0。None不是空字符串。None和任何其他的数据类型比较永远返回False。None有自己的数据类型NoneType。你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。]]></content>
  </entry>
  <entry>
    <title><![CDATA[网络协议]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE%2F</url>
    <content type="text"><![CDATA[OSI参考模型 模型 说明 应用层 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. 表示层 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. 会话层 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. 传输层 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). 网络层 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. 链路层 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . 物理层 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. 网络协议 链路层和物理层 描述 ARP(地址解析协议) IP地址——-&gt;MAC地址 RARP MAC地址——&gt;IP地址（逆向的） PPP协议 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 MAC地址 48位全球唯一,网络设备的身份识别 网络层 描述 IP协议 IP:（分为IPV4（168….）和IPV6（16进制用：隔开）） ICMP（Internet控制管理协议） ping命令属于ICMP IGMP（Internet分组管理协议） 广播，组播 传输层 描述 TCP（传输控制协议) 面向连接，可靠,效率低，一对一的可靠数据传输的协议 UDP（用户数据报协议） 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输 SCTP 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 应用层 描述 网页访问协议 HTTP HTTPS(S是安全) 邮件发送接收协议 POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） FTP 文件传输协议 Telnet（明文传输）/SSH（安全） 远程登录 嵌入式 描述 NTP 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） SNMP(开源（SNMP.NET）) 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 RTP/RTSP 用传输音视频传输（监控等） 中继系统中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。 中继系统之集线器光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。 这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。 中继系统之交换机还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：有记忆功能。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？ 交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。 如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。 中继系统之路由器路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。 端口IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。 这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。 socketsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系. arp协议因为ip数据包是在以太网数据包里发送, 所以我们必须同时知道两个地址, 一个是对方的MAC地址, 另一个是对方的IP地址, 通常情况下, 对方的IP地址是已知的, 但是我们不知道它的mac地址.所以, 我们需要一种地址, 能够从ip地址得到mac地址.这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。 第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。 总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。 路由Routing跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络. 路由器上维护着路由表,他知道如何将数据包发往另外的网络. windows使用route print, liunx使用route -n可以查看路由表. 路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置. 静态路由:有管理员手动配置的固定的路由信息 动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络原理</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入理解计算机系统]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F%2F</url>
    <content type="text"><![CDATA[源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的. 程序结构和执行信息存储大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.一个字节包括8位,在二进制表示法中,0000000011111111 0255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.2进制 TODO]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>系统</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[深入浅出理解预处理器]]></title>
    <url>%2F%E8%AE%A1%E7%AE%97%E6%9C%BA%2F%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8%2F</url>
    <content type="text"><![CDATA[预处理器编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译. 预定义符号预处理指令 指令 描述 #include 包含一个源代码 #define 定义宏 #undef 取消已定义的宏 #ifdef 如果宏已经定义,则返回真 #ifndef 如果宏没有定义,则返回真 #if 如果给定条件为真,则编译下面代码 #else #if的替代方案 #elif 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 #endif 结束一个#if…#else 条件编译块 #error 当遇到标准错误时, 输出错误消息 #pragma 使用标准化方法, 向编译器发布特殊的命令道编译器中 typedef c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 . 动态内存分配 当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据. c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需. python对象就是 c语言结构体在堆上申请的一块内存. 在 C 语言中，字符串实际上是使用 null 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。 c中大量操作字符串的函数 函数 目的 strcpy 复制字符串s2到字符串s1 strcat 连接s2 到字符串s1的末尾 strlen 返回字符串s1的长度 strcmp 如果 s1 和 s2 是相同的，则返回 0；如果 s1s2 则返回大于 0。 strchar 返回一个指针,指向字符串s1中字符ch的第一次出现的位置 strstr 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置]]></content>
      <categories>
        <category>计算机</category>
      </categories>
      <tags>
        <tag>c语言</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[正则表达式]]></title>
    <url>%2Fpython%2F%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[正则表达式简绍概述:正则表达式正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.正则表达式 Regular Expression,缩写regex, regexp ,RE等.分类1.BRE基本正则表达式,grep,sed,vi等软件支持.vim有扩展.2.ERE扩展正则表达式,egrep, sed -r等.3.PCRE几乎所有高级语言都是PCRE的方言或者变种. 基本语法元字符 metacharacter转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.反斜杠自身,得使用\ \r \n还是转义后代表回车,换行 贪婪与非贪婪默认是贪婪模式,也就是说尽量多匹配更长的字符串,非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了. 单行模式:. 可以匹配所有的字符, 包括换行符.^ 表示整个字符串的开头, &amp;整个字符串的结尾多行模式:. 可以匹配除了换行符之外的字符,多行不影响.点号^ 表示行首, &amp;行尾, 只不过这里的行是每一行 默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n re模块re.M多行模式re.S单行模式re.I忽略大小写re.X忽略表达式中的空白字符使用 | 位或运算开启多种选项方法编译re.compile(pattern, flag=0)设定flags, 编译模式,返回正则表达式对象regexpattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.单次匹配re.match(pattern, string, flags=0)match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象. 全局搜索对整个字符串, 从左至右匹配,返回匹配项的列表.匹配替换使用pattern对字符串string进行匹配,对匹配使用repl替换.replacement可以是string, bytes, function. 分割字符串字符串的分割函数split,太难用, 不能指定多个字符进行分割.分组使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.2.如果使用了命名分组,可以使用group的方式取分组3.也可以使用group返回所有组.4.使用groupdict()返回命名的分组.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[魔术方法]]></title>
    <url>%2Fpython%2F%E6%96%B9%E6%B3%95%2F</url>
    <content type="text"><![CDATA[魔术方法 类别 方法名 可视化 __str__, __repr__, __format__, __bytes__ 数值转换 __abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__ 容器模拟 __len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__ 迭代枚举 __iter__, __reversed__, __next__ 可调用模拟 __call__ 上下文管理 __enter__, __exit__ 实例创建和销毁 __new__, __init__, __del__ 属性管理(反射) __dir__, __getattr__, __setattr__, __delattr__, __getattribute__ 属性描述符(描述器) __get__, __set__, __delete__ 特殊属性 __name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__ 比较运算符 __eq__,__lt__, __le__, __gt__, __ge__, __ne__ 算数运算符 __add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__ 增量运算符 __iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__ 反向运算符 __radd__, __rsub__ 其他 __slots__ 内置函数 内置函数名 方法名 数学运算 abs, divmod,max,min,pow, round, sum 类型转换 bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex 序列操作 all, any, filter, map,next,reversed, sorted, zip 对象操作 help,dir,id,hash, type,len, ascii,format, vars, 反射操作 __import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable 变量操作 globals, locals, 交互操作 print,input 文件操作 open 编译执行 compile, eval,exec, repr 装饰器 property,classmethod, staticmethod, 数据结构 tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object 标识符: 1234567False await else import passNone break except in raiseTrue class finally is returnand continue for lambda tryas def from nonlocal whileassert del global not withasync elif if or yield 模块常用方法 内置模块 方法名 re compile, search, match, fullmatch,split,findall, sub, string ascii_letters,ascii_lowercase.digits datetime datetime collections nametuple, deque, OrderdDict, defaultdict, bisect bisect_left,bisect_right, math ceil random randint, choice, randrange,shuffle, sample functools reduce, partial,lru_cache pathlib os shutil copyfileobj, copyfile, copymode, copystat,copy,copy2,copytree,rmtree,move, pickle csv reader time threading queue json base64 sys inspect signature(callable)获取签名, ConfigParser argparse heapq hea]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[描述器]]></title>
    <url>%2Fpython%2F%E6%8F%8F%E8%BF%B0%E5%99%A8%2F</url>
    <content type="text"><![CDATA[描述器 Descriptors描述器的表现 用到3个魔术方法: __get__() 、 __set__() 、 __delete__() 方法签名如下 object.__get__(self, instance, owner) object.__set__(self, instance, value) object.__delete__(self, instance) self 指代当前实例，调用者 instance 是owner的实例 owner 是属性的所属的类 请思考下面程序的执行流程是什么？ 1234567891011121314151617181920212223242526272829303132333435363738394041class A: def __init__(self): self.a1 = 'a1' print('A.init')class B: x = A() def __init__(self): print('B.init')print('-'*20)print(B.x.a1)print('='*20)b = B()print(b.x.a1)# 运行结果A.init--------------------a1====================B.inita1 可以看出执行的先后顺序吧？ 类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。 然后实例化并初始化B的实例b。 打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。 描述器定义Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。 仅实现了 __get__ ，就是非数据描述符 non-data descriptor 实现了 __get__ 、 __set__ 就是数据描述符 data descriptor 如果一个类的类属性设置为描述器实例，那么它被称为owner属主。 当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。 属性的访问顺序为上例中的类B增加实例属性x 12345678910111213141516171819202122232425262728293031323334353637class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return selfclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x)print(b.x.a1) # AttributeError: 'str' object has no attribute 'a1' 类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。 继续修改代码，为类A增加 __set__ 方法。 123456789101112131415161718192021222324252627282930313233343536373839404142434445class A: def __init__(self): self.a1 = 'a1' print('A.init') def __get__(self, instance, owner): print("A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;".format(self, instance, owner)) return self def __set__(self, instance, value): print('A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'.format(self, instance, value)) self.data = valueclass B: x = A() def __init__(self): print('B.init') self.x = 'b.x' # 增加实例属性xprint('-'*20)print(B.x)print(B.x.a1)print('='*20)b = B()print(b.x) # 返回什么print(b.x.a1) # 返回什么print(b.x.data) # 返回什么？ 所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。 属性查找顺序实例的 __dict__ 优先于 非数据描述器 数据描述器 优先于 实例的 __dict__ __delete__ 方法有同样的效果，有了这个方法，也是数据描述器。 尝试着增加下面的2行代码，看看字典的变化 b.x = 500 B.x = 600 b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。 B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。 ### Python中的描述器 描述器在Python中应用非常广泛。 Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。 property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。 12345678910111213141516171819202122232425262728293031323334353637class A: @classmethod def foo(cls): # 非数据描述器 pass @staticmethod # 非数据描述器 def bar(): pass @property # 数据描述器 def z(self): return 5 def getfoo(self): # 非数据描述器 return self.foo def __init__(self): # 非数据描述器 self.foo = 100 self.bar = 200 #self.z = 300a = A()print(a.__dict__)print(A.__dict__) foo、bar都可以在实例中覆盖，但是z不可以。 新增方法 3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。 12345678910111213141516171819202122class A: def init(self): print('A init') def get(self, instance, owner): print(1, self, instance, owner) return self def set_name(self, owner, name): print(2, self, owner, name) self.name = nameclass B:x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)print(B().x)]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[处理异常]]></title>
    <url>%2Fpython%2F%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[异常处理(Exception)错误Error逻辑错误:算法写错了, 例如加法写成了减法 笔误:例如变量名写错了,语法错误 函数或类使用错误, 其实这也属于逻辑错误 总之,错误是可以避免的 异常Eception本意就是意外情况 这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去. 例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况. 错误和异常在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获. 123with open('tetsabcd') as f: pass# 异常 产生异常产生: raise语句显示的抛出异常 Python解释器自己检测异常并引发它程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行) 异常的捕获1234try: 待捕获异常的代码块except [异常类型] 异常的处理代码块]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[二分法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F%E4%BA%8C%E5%88%86%E6%B3%95%2F</url>
    <content type="text"><![CDATA[练习 有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。思路排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。查找插入点，使用二分查找完成。假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。直到中点就是 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) - 1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]newlst = sorted(lst) # 升序 print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41): newlst = insert_sort(newlst, x) print(newlst) 看似上面代码不错，请测试插入100。问题来了，100插入的位置不对，为什么？ 123456789101112131415161718192021def insert_sort(orderlist, i): ret = orderlist[:] low = 0 high = len(ret) # 去掉减1 while low &lt; high: mid = (low + high) // 2 if ret[mid] &lt; i: low = mid + 1 # 说明i大，往右找，调整下限 else: high = mid # 说明i小于等于，往左找，调整上限 print(low, i) # low为插入点 ret.insert(low, i) return ret # 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51] newlst = sorted(lst) # 升序print(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] for x in (40, 20, 41, 100): newlst = insert_sort(newlst, x) print(newlst) high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。 二分二分前提是有序，否则不可以二分。二分查找算法的时间复杂度O(log n) bisect模块bisect模块提供的函数有： bisect.bisect_left(a,x, lo=0, hi=len(a))查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。 bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。 bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。函数可以分2类： bisect系，用于查找index。Insort系，用于实际插入。默认重复时从右边插入。 应用判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’ 12345678910import bisect def get_grade(score): breakpoints = [60, 70, 80, 90] grades = 'EDCBA' return grades[bisect.bisect(breakpoints, score)] for x in (91, 82, 77, 65, 50, 60, 70, 80, 90): print('&#123;&#125; =&gt; &#123;&#125;'.format(x, get_grade(x)))]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python知识框架]]></title>
    <url>%2Fpython%2Fpython%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[python基础python是一种动态的强类型语言,底层是用C语言开发的. 平台：*nix平台系统：线程、进程、Shell编程网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个中间件：消息队列原理和应用，例如8曲bitMQWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一可视化：WEB的前端开发多一些HTML、jS要会数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用 python学习路线:基础：操作系统、网络基础、数据库基础、python语言基础..进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).新前端开发(ES6、React、Antd）…实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..高端：数据清洗、企业数据分析、预测准荐、机器视觉． 数据类型python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none 字符串因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。 由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。 但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。 你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。 Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。 现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。 字母A用ASCII编码是十进制的65，二进制的01000001； 字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的； 汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。 你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。 新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。 所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节. 字符串的格式化format函数或 格式符 编码字符串与bytes字符串是字符组成的有序序列，字符可以使用编码来理解bytes是字节组成的有序的不可变序列bytearray是字节组成的有序的可变序列 编码与解码：字符串按照不同的字符集编码encode返回字节序列bytesencode（encoding=‘utf-8’，errors=‘strict’）字节序列按照不同的字符集解码decode返回字符串bytes.decode（encoding=“utf-8”，errors=“strict”）ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统 要熟记31 41 61 的ascii表 字节序：大端模式，big-endian；小端模式，little-endianintel x86cpu使用小端 模式网络传输更多使用大端模式windows，linux 使用小端模式mac os使用大端模式java 虚拟机是大端模式 数字有整数 浮点数 复数等 true false主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。 None：Python里面特殊的空值，不能理解为0。 容器list（列表） tuple（元组） set（集合） dictionary（字典）这些都是可以迭代的 list创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。 tuple元组和列表类似，但是不同的是元组不能修改，元组使用小括号。 dict判断结构ifif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。 elif 语句 elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。 if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。 forfor循环可以遍历任何序列的项目： whilewhile循环，只要条件满足，就不断循环，条件不满足时退出循环： break和continue语句： break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。 continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python特殊函数]]></title>
    <url>%2Fpython%2Fpython%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[匿名函数匿名函数 :隐藏名字,即没有名称匿名函数: 没有名字的函数lambda表达式python中,使用lambda表达式构建匿名函数使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式参数列表不需要小括号,无参就不写参数冒号用来分割参数和表达式部分不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.lambda表达式匿名函数只能写在一行上,也称为单行函数. 匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码. 递归函数函数执行流程:压栈 递归函数recursion函数直接或者间接调用自身就是递归.递归需要有边界条件,递归前进段,递归返回段.递归一定要有边界条件.当边界条件不满足的时候,递归前进当边界条件满足的时候,递归返回. 递归例子:斐波那契数列如果用循环写法:1234567a = 0b = 1n = 10for i in range(n -1): a,b=b, a+belse: print(b) 递归写法:def fib(n): return 1 if n &lt;3 else fib(n-1) +fib(n-2) 递归要求递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.递归调用的深度不宜python 对递归调用的深度做了限制,以保护解释器超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度sys.getrecursionlimit() 循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了. 递归是一种很自然的表达,符合逻辑思维递归相对效率低,每一次调用都要开辟栈帧.递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.绝大多数递归,都可以使用循环实现即使递归代码很简洁,但是能不用则不用递归. 生成器生成器generator生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.生成器对象,是一个可迭代对象,是有个迭代器.生成器对象,是延时计算,惰性求值的. 函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.普通函数调用,函数会立即执行直到执行完毕.生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑. 在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回再执行会执行到下一个yield语句又会暂停执行return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration生成器函数包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.再次调用next函数,和上一条一样的处理过程.继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常. 协程生成器的高级用法他比进程,线程轻量级,是在用户空间调度函数的一种实现.协程调度器实现思路协程是一种非抢占式调度. yield from 语法yield from就是一种简化语法的语法糖. yield 和return的区别带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return 如何生成斐波那契数列:斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数. 12345678def fab(max): a, b = 1, 1 n = 1 while n &lt; max: print(b) a, b = b, a+b n +=1fab(20) 结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.123456789def fab(max): n, a, b = 0, 0, 1 l = [] while n &lt; max: l.append(b) b = b+a a = b-a n = n+1 return l 改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要用list来保存中间结果, 而是通过iterable对象来迭代. 1234567891011121314151617class Fab(object): def __init__(self, max): self.max = max self.n, self.a, self.b = 0, 0, 1 def __iter__(self): return self def next(self): if self.n &lt; self.max: r = self.b self.b = self.a + self.b self.a = self.b - self.a self.n = self.n + 1 return r raise StopIteration() 然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:def fab(max): n, a, b = 0, 0, 1 while n &lt; max: yield b b = b+a a = b-a n = n + 1 第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果调用第四版的fab和第二版的fab完全一致: 简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法这样我们就可以清楚看到fab的执行流程. 高阶函数函数也是对象, 是可调用对象函数可以作为普通变量,也可以作为函数的参数, 返回值. 在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数接受一个或多个函数作为参数输出一个函数 排序sorted排序函数,可以接受key作为参数进行排序,不改变序列的原有值.排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素. 过滤filter对可迭代对象进行遍历,返回一个迭代器function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值function参数如果是None, 可迭代对象的每一个元素自身等效布尔值. 映射map对多个可迭代对象的元素,按照指定的函数进行映射返回一个迭代器 柯里化指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python文件io]]></title>
    <url>%2Fpython%2Fpython%E6%96%87%E4%BB%B6io%2F</url>
    <content type="text"><![CDATA[文件io常用操作一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络ioopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取seek: 文件指针操作 tell: 指针位置 打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.文件操作中,最常用的操作就是读和写.文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件a: 写入打开,如果文件存在,则追加b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力. open默认是只读模式r打开已经存在的文件. 文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOFbuffering:缓冲区0:只在二进制模式打开,表示关buffer1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush大于1:用于指定buffer的大小. 上下文管理1.异常处理当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.使用finally可以保证打开的文件可以被关闭.2.上下文管理一种特殊的语法, 交给解释器去释放文件对象.使用with … as关键字上下文管理的语句并不会开启新的作用域with语句执行的时候,自动关闭文件对象.1234f1 = open(&apos;text&apos;)with f1: f1.write(&apos;abc&apos;)f1.closed 对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题. StringIO和BytesIOStringIOio模块中的类from io import StringIO内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.当close方法被调用的时候,这个buffer被释放. 好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率. BytesIOio模块中的类from io import BytesIO内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.当close方法被调用的时候, 这个buffer会释放. file-like对象类文件对象,可以像文件一样操作socket对象,输入输出对象都是类文件对象. 路径操作from os import path3.4版本开始建议使用pathlib模块,提供path对象来操作.包括目录和文件Pathlib模块 目录操作初始化路径拼接和分解操作符分解joinpath 通配符glob通配给定的模式rglob通配给定的模式,递归目录都返回一个生成器?代表一个字符*表示任意个字符[abc]或[a-z]表示一个字符 匹配match(pattern)模式匹配,成功返回True 文件操作os模块os.name windows是nt, linux是posixos.uname() *nix支持sys.platform windows显示win32, linux 显示linuxos.listdir返回指定目录内容列表, 不递归os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似. shutil模块文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.python提供了一个方便的shutil(高级文件操作)copy复制copyfileobj(fsrc, fdst[, length]) 文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.12345import shutilwith open (&apos;text&apos;, &apos;r+&apos;) as f: f.write(&apos;abcd&apos;) with open(&apos;text1&apos;, &apos;w+&apos;) as f1: shutil.copyfileobj(f, f1) 复制文件内容,不含元数据,src,dst为文件的路径字符串. rm删除shutil.rmtree(path, ignore_errors=False, oneerror=None)递归删除,如同rm -rf一样危险,慎用.他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.shutil.retree(“text”) 类似rm -rf move移动递归移动文件,目标到目标,返回目标本身使用的是os.rename方法如果不支持rename,如果是目录则copytree再删除源目录.shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz csv文件csv是一个被行分隔符,列分割符划分成行和列的文本文件.csv不指定字符编码.行分割符为\r\n,最后一行可以没有换行符.列分割符常用逗号或者制表符.每一行称为一条记录record.字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.csv模块返回reader对象,是一个行迭代器默认使用excel方言.delimiter列分割符,逗号.lineterminator行分割符\r\n ini文件处理作为配置文件,ini文件格式的很流行. 中括号里面的部分称为section,译作节,区, 段每一个section内, 都是key=value形成的键值对,key称为option选项.注意这里的DEFAULT是缺省section的名字,必须大写.configparserconfigparser模块的configparser类就是用来操作.可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典. 序列化和反序列化为什么要序列化内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.serialization序列化将内存中对象存储下来,把他变为一个个字节.deserialization反序列化将文件的一个个字节恢复成内存中的对象序列化保存到文件就是持久化可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化python提供了pickle库 dumps 对象序列化为bytes对象dump 对象序列化到文件对象,就是存入文件loads 从bytes对象反序列化load 对象反序列化,从文件读取数据 序列化应用一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型jsonjson的数据类型 messagepackmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.他可以像json那样,在许多语言之间交换结构对象.但是他比json更快速也跟轻巧.支持python.ruby,java等众多语言,兼容json 和pickle 安装pip install msgpack 常用方法序列化对象,提供dumps来兼容pickle和jsonunpackb反序列化对象.提供了loads来兼容.pack序列化对象保存到文件对象,提供了dump来兼容.unpack反序列化对象保存到文件对象,提供了load来兼容.messagepack简单易用,高效压缩,支持语言丰富.所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据结构]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%2F</url>
    <content type="text"><![CDATA[前言程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要. 常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合. 数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型. 抽象数据类型抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.抽象的意义在于数据类型的数学抽象特性. 内存单元和地址计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,在计算机内存里表示数据元素之间的联系,只有两种技术:利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构. 数据结构是相互之间存在一种或多种特定关系的数据元素的集合.逻辑上分:集合结构, 线性结构, 树形结构, 图形结构物理结构:顺序存储结构, 链式存储结构. 算法算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.函数渐进式增长.判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.用O()来体现时间复杂度的记法, 我们称为大O记法.O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶. 线性表从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来. 线性表的顺序存储结构指的是用一段地址连续的存储单元依次存储线性表的数据元素.插入删除的时间复杂度为O(n).它比较适合元素个数不太变化,而更多存取数据的应用.优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间. 可以快速地存取表中任意位置的元素.缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量造成存储空间的”碎片”. 线性表链式存储结构线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点. 头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.头指针具有标识作用,所以常用头指针冠以链表的名字.无论链表是否为空,头指针均不为空,头指针是链表的必要元素.由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显. 若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构. 静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法 将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针. 栈与队列栈是限定仅在表尾进行插入和删除操作的线性表.对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表. 在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,栈是限定仅在表尾进行插入和删除操作的线性表.我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶. 栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.栈的删除操作,也叫出栈,或弹栈栈.特别是插入和删除操作,我们改名为push 和pop.两栈共享空间 栈的链式存储结构简称链栈顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些. 对列对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出. 串串是有零个或多个字符组成的有限序列,又名字符串.串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.串的顺序存储结构串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.在计算机中存在一个自由存储区,叫做堆. 模式匹配算法子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.一个字符的ASCII码可以看成是8位的二进制01串. 本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.所谓的回文就是一个字符串的逆转显示reverse的操作. 树树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树. 所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.树的定义其实就是我们在讲解栈提到的递归的方法.树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值. 结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.树中结点的最大层次称为树的深度或高度. 树的存储结构 树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.双亲表示法:我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行. 二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成. 二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,左子树和右子树是有顺序的,次序不能任意颠倒, 顺序存储结构一般只用于完全二叉树.二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.这里有两个关键词:访问和次序二叉树本质上,是对链表和数组的一个折中.每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据. 压缩编码方法:赫夫曼编码 图图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.图是由顶点的有穷非空集合和顶点之间边的集合组成.图不能用简单的顺序结构来表示,而是多重链表. 搜索引擎的工作原理:它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录. 查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素. python 对象特性python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值: 身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.值:对象表示的数据. python基本数据类型python的数据类型:number(数字), string(字符串), bool(布尔), None(空值) python 内建数据结构线性结构字符串在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变. 列表元组bytes非线性结构集合set字典dict]]></content>
      <categories>
        <category>数据结构</category>
      </categories>
      <tags>
        <tag>数据结构</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python小技巧]]></title>
    <url>%2Fpython%2Fpython%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[为多个变量赋值有时，有多个变量需要赋值，这时你会怎么赋值呢？常规方法：常规方法是给变量逐个赋值。123a = 0 b = 1 c = 2 优雅方法：直接按顺序对应一一赋值.a, b, c = 0, 1, 2 序列解包需要取出列表中的元素。常规方法：一般我们知道可以通过下标获取具体元素。1234567info = ['brucepk', 'man', 'python']name = info[0]sex = info[1]tech = info[2]print(name,sex,tech)结果:brucepk man python 优雅方法：给出对应变量接收所有元素。12345info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]name,sex,tech = infoprint(name,sex,tech)结果:brucepk man python 优雅你的判断语句我们用判断语句来定义一个绝对值函数。常规方法：1234567891011121314x = -6if x &lt; 0: y = -xelse: y = xprint(y)结果:6优雅方法：x = -6y = -x if x&lt;0 else xprint(y)结果6 区间判断使用 and 连续两次判断的语句，条件都符合时才执行语句。常规方法：123456score = 82if score &gt;=80 and score &lt; 90: level = 'B'print(level)结果B 优雅方法：使用链式判断。123456score = 82if 80 &lt;= score &lt; 90: level = &apos;B&apos;print(level)结果B 多个值符合条件判断多个值任意一个值符合条件即为 True 的情况。常规方法：123456num = 1if num == 1 or num == 3 or num == 5: type = &apos;奇数&apos;print(type)结果奇数 优雅方法：使用关键字 in，让你的语句更优雅。123456num = 1if num in(1,3,5): type = &apos;奇数&apos;print(type)结果奇数 判断是否为空判断元素是空还是非空。常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;if len(A) &gt; 0: print(&apos;A 为非空&apos;)if len(B) &gt; 0: print(&apos;B 为非空&apos;)if len(C) &gt; 0: print(&apos;C 为非空&apos;)结果A 为非空 优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。 123456789A,B,C =[1,3,5],&#123;&#125;,&apos;&apos; if A: print(&apos;A 为非空&apos;) if B: print(&apos;B 为非空&apos;) if C: print(&apos;C 为非空&apos;) 结果A 为非空 多条件内容判断至少一个成立常规方法：用 or 连接多个条件。12345math,English,computer =90,80,88if math&lt;60 or English&lt;60 or computer&lt;60: print(&apos;not pass&apos;)结果not pass 优雅方法：使用 any 语句。12345math,English,computer =90,59,88if any([math&lt;60,English&lt;60,computer&lt;60]): print(&apos;not pass&apos;)结果not pass 多条件内容判断全部成立常规方法：使用 and 连接条件做判断。12345math,English,computer =90,80,88if math&gt;60 and English&gt;60 and computer&gt;60: print(&apos;pass&apos;)结果pass 优雅方法：使用 all 方法。12345math,English,computer =90,80,88if all([math&gt;60,English&gt;60,computer&gt;60]): print(&apos;pass&apos;)结果pass 遍历序列的元素和元素下标常规方法：使用 for 循环进行遍历元素和下标。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for i in range(len(L)): print(i, &apos;:&apos;, L[i])结果0 : math1 : English2 : computer3 : Physics 优雅方法：使用 enumerate 函数。12345678L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]for k,v in enumerate(L): print(k, &apos;:&apos;, v)结果0 : math1 : English2 : computer3 : Physics 循环语句优化之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。常规方法：使用简单的 for 循环可以达到目的。123456L = []for i in range(1, 6): L.append(i*i)print(L) 结果：[1, 4, 9, 16, 25] 优雅方法：使用列表生成式，一行代码搞定。123print([x*x for x in range(1, 6)]) 结果：[1, 4, 9, 16, 25] 将list中的所有元素转为单个字符串12a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]print(&quot; &quot;,join(a)) 字符串倒转方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。方法二：用Python自带reversed()函数，它可被用于list倒转。方法三：第三种是通过倒转数据类型和切片倒转整数. 链式调用在python 中实现链式调用只需在函数返回对象自己就行123456def product(a, b): return a * bdef add(a, b): return a + bb = Trueprint((product if b else add)(5, 7)) 复制list在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：方法一：b=a[:]。方法二：b=list(a)。方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。方法四：使用copy.deepcopy()。 按value排序字典Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：方法一：用sorted函数排序，其中key参数是lamda表达式。方法二：用operator.itemgetter而不是lamda表达式进行排序。方法三：如果只需得到排序后的key，可用.get。 for … else语法合并字典方法一：Python 3.5可以存在重复键值，print({d1 ,d2})。方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。方法三：d1.update()。 从list中删除重复项方法一：把list转成set，去除重复项，再转回list。方法二：调用collections里的OrderedDict，和set差不多。]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python函数]]></title>
    <url>%2Fpython%2Fpython%E5%87%BD%E6%95%B0%2F</url>
    <content type="text"><![CDATA[基本概念数学定义y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)python函数:是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元完成一定的功能函数的作用结构化编程对代码的最基本的封装, 一般按照功能组织一段代码封装的目的为了复用,减少冗余代码代码更加简洁美观,可读易懂 函数的分类:内建函数,如max()库函数,如math.ceil自定义函数,使用def关键字定义 函数定义def 函数名(参数列表): 函数体(代码块) [return 返回值]函数名就是标识符,命名要求一样语句块必须缩进,约定4个空格函数名就是标识符就是变量python的函数没有return,会返回none定义中的参数列表称为形式参数,只是一种标识符占位置的函数的标识符就是指向函数对象函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参不定义会报nameERREO 传参方式: 位置传参按照参数定义顺序传入实参 关键字使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的参数缺省值缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用 可变位置参数在形参使用* 表示该形参是可变位置参数, 可以接受多个实参它将收集来的实参组织到一个tuple中tuple 有序按位置传参可变关键字参数在形参使用表示该形参是可变关键字参数,可以接受多个关键字参数它将收集来的实参的名称和值,组织到一个dict中可变的关键字传参 kwargs 有可变位置参数和可变关键字参数可变位置参数在形参前使用一个*号可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple可变关键字参数收集形成一个dict混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面要在可变关键字参数之前. keyword-only 参数def fn(args, x, y, **kwargs): print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)fn(3, 5)fn(3, ,5, 7)在python3之后,新增了keyword-only参数keyword-only参数:在形参定义时,在一个星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数keyword-only参数,言下之意就是这个参数必须采取关键字传参可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.星号后所有的普通参数都成了keyword-only参数参数的混合使用参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数代码应该易读易懂, 而不是为难别人请按照书写习惯定义函数参数.参数解构:在给函数提供实参的时候,可以在可迭代对象前使用或者来进行的解构,提取出其中所有元素作为函数的实参.使用*解构成位置参数使用解构成位置 传参提取出来的元素数目要和参数的要求匹配 python函数使用return语句返回”返回值”所有函数都有返回值,如果没有return语句, 隐式调用return Nonereturn语句并不一定是函数的语句块的最后一条语句一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None如果有必要,可以显示调用return None ,可以简写return如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行返回值的作用: 结束函数调用,返回返回值函数不能同时返回多个值. 作用域一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域注意:每一个函数都会开辟一个作用域分类:全局作用域:在整个程序运行环境中都可见全局作用域中的变量称为全局变量局部作用域:在函数 ,类等内部可见局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域函数嵌套在一个函数中定义了另一个函数内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见 global语句使用global关键字的变量,将声明为外部的全局作用域中定义的使用了global 不再是局部变量,它是全局变量global使用原则外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决一句话:不要global,学习他就是深入理解变量作用域 闭包自由变量:未在本地作用域中定义的变量闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript nonlocal语句将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义代码中内层函数引到外部局部作用域中的自由变量,形成闭包 函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期查看default属性,他是个元组 变量名解析原则LEGB***local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡所以一个名词的查找顺序就是LEGB. |]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python入门笔记]]></title>
    <url>%2Fpython%2Fpython%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[计算机基础程序是一组让计算机识别和执行的指令电子计算机:能够执行程序的机器计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.即8位 2**8=256种状态 内存 掉电易失 与晶振频率有关 临时数据 mermorycpu与内存速度差几个数量级cpu 只认内存 io设备最慢CPU 缓存 cache bus 总线先写源程序 通过编译程序把源程序转换成机器指令的程序python是跑在虚拟机上的 动态语言 做节点 集群优化编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样 机器语言: 是一定位数组成的0 1序列 称为机器指令 机器指令的集合就是机器语言汇编: 是用助记符替代机器指令静态语言: 是声明变量类型,不能再改变,编译需要检查动态语言: 不用声明类型 随时可以赋值为其他类型强类型: 不同类型之间操作 必须强制类型转换为同一类型弱类型: 不同类型之间操作 自动隐式转换 python基础介绍python 的源代码需要被解释器编译成中间代码,在虚拟机上运行*`程序 = 算法 +数据结构`*数据一切程序的核心数据结构是数据在计算机中的类型和组织方式算法是处理数据的方式,算法有优劣之分.python自带了一个IDLE的程序,全称是交互式开发环境.注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要. import math #对角线的长度i = 4w = 10d = math.sqrt(12 + w2)即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的编写尽量用pep8风格 数据类型:python将数据划分为不同的类别,即数据类型.每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.对象的数据类型是对象所属的数据类别.“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号数据类型为bool的对象被称为布尔值.数据类型为nonetype的对象,其值永远我none 用来表示数据缺失. 系统编程python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展此外很多python的系统工具设计都考虑了其可移植性. python解释器python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行. python变量和内存变量在python是表示内存的地址.可以用id()函数获取内存地址 a=5id(a)id(5)会发现这两个地址一样,都输出140720362218448 即python的编程哲学 :一切皆对象,一切皆指针只有指针,要说变量也是指针变量variable 变量是改变的值.变量由一个或多个字符组成的名称构成并使用赋值符 等号赋予了这个名称一个值变量是记住内存中 0 1数字 开始和结束的一串 指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。 内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。 内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。 内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。对于C和C++这样的没有Garbage Collection 的语言来讲我们主要关注两种类型的内存泄漏： 堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. 系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。 python虚拟机原理python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.pycodeobject保存字节码以及进程上下文信息. 过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象.pyc文件字节码在磁盘上的表现形式pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,从技术上将,他才是所谓python解释器的最后一步.代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式. 开发环境 —-pyenvpython多版本管理工具pip包管理器pip install xxxpip listpip search keyword 或者 pypipip help installpip install redis ipythonpip install jupyterpip -Vpip freeze &gt; requirementpip install-r requirement 原码补码反码原码是给人看的,补码是给计算机用的127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。因为它是用补码的编码方式。正数的补码就是它的原码，也就是单纯的二进制数。负数的话，1111 1111这个二进制串，首先它最高位是1，明确他是个负数。那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001也就是1，再加上符号位。最终结果是-1 补码 从小到大 二进制1000 0000—-0000 0000—-0111 1111首尾相连，刚好连个时钟，最大的加一到最小的 字符串使用单双三引号括起来的序列叫字符串 r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理f前缀:3.6版本开始,新增f前缀,格式化字符串转义序列\ \t \r \n \’ \”缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系约定使用4个空格缩进续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\extend 魔术方法add() 标识符一个名字,用来指代一个值只能是字母,下划线和数字只能以字母或下划线开头不能是python的关键字,例如def,class等python是大小写敏感的约定:不允许使用中文不要使用歧义单词,例如class_在python中不要随便使用下划线开头的标识符 运算符 算术运算符 +-*/%**自然除/结果是浮点数,整除// 位运算符 &amp; | ~ ^ &lt;&lt; &gt;&gt; 比较运算符 == != &gt; &lt; &gt;= &lt;=返回一个bool值 逻辑运算符 与或非 and or not短路运算符 赋值运算符0 *? =0短路1+? =1短路运算 可以提高效率 可以提前算完了赋值运算 先算右边 和左边相连(映射) a=min(3,5) 运算符优先级 就记住一句话 a+b&gt;c and 折半思想可以优化程序 程序控制顺序结构:按照先后顺序一条条执行分支结构:根据不同情况判断,条件满足执行某条件下的语句循环结构:条件满足就反复执行,不满足就不执行或不再执行 内置类型内置对象使程序更容易编写内置对象使扩展的组件内置对象往往比定制的数据结构更有效率内置对象使语言的标准的一部分python的核心数据类型模式匹配 循环while 语句whlie condition: block当他成立则进入循环while true: pass #死循环 冒号后要形成语句块 死循环都用这个语法例子: flag = 10while flag: print(flag) flag-= 1 在做循环时,一定要分析边界 边界最容易出错range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包 for i in range(10): print(i+1) i= i+10循环 隐含赋值 原来有什么会被冲掉for相当于遍历 不会重复拿 挨个拿如果要倒着遍历 应当在range函数内加步长-1例子:for i in range(10): if i %2 == 0: print(i) for i in range(10): if not i % 2: print(i)not 经常用for i in range (10): if i &amp;1 == 0: print(i) for i in range(10): if i &amp; 1: continue print(i) 写程序要减少循环提高效率 for i in range(10): if i % 2: continue print(i) 如果循环嵌套 continue 和break也只影响语句所在的那一层循环 迭代器和生成器我们已经知道，可以直接作用于for循环的数据类型有以下几种： 一类是集合数据类型，如list、tuple、dict、set、str等； 一类是generator，包括生成器和带yield的generator function。 这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。 可以使用isinstance()判断一个对象是否是Iterable对象： from collections import Iterableisinstance([], Iterable)Trueisinstance({}, Iterable)Trueisinstance(‘abc’, Iterable)Trueisinstance((x for x in range(10)), Iterable)Trueisinstance(100, Iterable)False而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。 可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator. 通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。 所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator： L = [x x for x in range(10)]L[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]g = (x x for x in range(10))g &lt;generator object at 0x1022ef630&gt; 函数python 内置了很多有用的函数,我们可以直接调用要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python 三大器]]></title>
    <url>%2Fpython%2Fpython%20%E4%B8%89%E5%A4%A7%E5%99%A8%2F</url>
    <content type="text"><![CDATA[装饰器装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用. 12345678def 炼丹炉(func): def 变身(*args): 火眼金睛 returrn 孙悟空 return 变身@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)def 孙悟空: return 装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper 单层的只需要function 如:注册器 双层的是返回一个全新的函数 如:打印log 迭代器迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代可迭代对象就是,实现了迭代器协议的对象.协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)使用迭代器协议访问对象.举个例子:for n in [1, 2, 3, 4]: print(n) 但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象with open (‘/etc/passwd’) as f: for line in f: print(line) def gensquares(n): for i in range(n): yield i ** 2for item in genquares(s): print(item) 生成器语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.自动实现迭代器协议:]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[python pep]]></title>
    <url>%2Fpython%2Fpython%20pep%2F</url>
    <content type="text"><![CDATA[PEPPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0 https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅import thisBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题） PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148 PEP8016Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。Readability counts. # 可读性很重要（优美的代码是可读的） Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上） Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码） In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测 There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法） Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido） Now is better than never. Although never is often better than right now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量） If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准） Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium]]></content>
      <categories>
        <category>python</category>
      </categories>
      <tags>
        <tag>python</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux知识框架]]></title>
    <url>%2Flinux%2Flinux%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6%2F</url>
    <content type="text"><![CDATA[介绍操作系统os(operating system),通用目的的软件程序 硬件驱动进程管理内存管理网络管理安全管理文件管理 安装linux linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的manjaro或mint分区和启动:硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tbuefi的GPT分区:逐渐代替MBR标准主分区 一块硬盘最多4个,不能划分更小,最小单位扩展分区:一块硬盘最多一个,不能直接创建文件系统安装过程大同小异 详细步骤需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌./dev/sda 100g/dev/sda1 /boot mountpoint 1g/dev/sda2 / 50g/dev/sda3 /data 20g/dev/sda5 /swap 2g 开发接口标准 ABI:application binary interface ABI描述了程序与os之间的底层接口API:application programming interface开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit 用户和内核空间 username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响内核空间:kernel space linux哲学思想在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的 文件操作文件和目录被组织成单根倒置树结构文件系统从根目录下开始,用”/“表示proc虚拟的,在硬盘上不存在文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)以.开头的文件为隐藏文件元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.数据:data(内容在硬盘上)文件系统分成结构:LSB文件名最长255个字节,文件系统不一样大小不一样包括路径在内文件名称最长4095个字节蓝色—目录 绿色—可执行文件 红色—压缩文件浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递管道文件 p开头(pipe)单工传输 文件系统结构元素/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)/lib64：专用于x86_64系统上的辅助共享库文件存放位置/etc：配置文件目录/home/USERNAME：普通用户家目录/root：管理员的家目录/media：便携式移动设备挂载点/mnt：临时文件系统挂载点/dev：设备文件及特殊文件存储位置 b: block device，随机访问 c: character device，线性访问/opt：第三方应用程序的安装位置/srv：系统上运行的服务用到的数据/tmp：临时文件存储位置/proc: 用于输出内核与进程信息相关的虚拟文件系统/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文/usr: universal shared, read-only data bin: 保证系统拥有完整功能而提供的应用程序sbin: lib：32位使用 lib64：只存在64位系统include: C程序的头文件(header files)share：结构化独立的数据，例如doc, man等local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文 /var: variable data files cache: 应用程序缓存数据目录lib: 应用程序状态信息数据local：专用于为/usr/local下的应用程序存储可变数据lock: 锁文件 log: 日志目录及文件opt: 专用于为/opt下的应用程序存储可变数据run: 运行中的进程相关数据,通常用于存储进程pid文件spool: 应用程序数据池tmp: 保存系统两次重启之间产生的临时数据 Linux下的文件类型-：普通文件d: 目录文件b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)c: 字符设备(设备主要以字符为单位,键盘为主)l: 符号链接文件p: 管道文件pipes: 套接字文件socket 显示当前工作目录每个shell和系统进程都有一个当前的工作目录CWD:current work directory显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认） 更改目录cd 改变目录 使用绝对或相对路径： cd /home/wang/ cd home/wang 切换至父目录： cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -选项：-P相关的环境变量： PWD：当前目录路径 OLDPWD：上一次目录路径 列出目录内容列出当前目录的内容或指定目录用法：ls [options] [ files_or_dirs ]示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R 目录递归通过 ls -ld 目录和符号链接信息 ls -1 文件分行显示 ls –S 按从大到小排序 ls –t 按mtime排序 ls –u 配合-t选项，显示并按atime从新到旧排序ls –U 按目录存放顺序显示 ls –X 按文件后缀排序 [root@centos7 sysconfig]# ll /etc/motd-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd[root@centos7 sysconfig]# ll ../motd-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd-a 全部-r 递归ll 是别名 (ls -l) 查看文件状态stat文件：metadata, data三个时间戳: access time：访问时间，atime，读取文件内容modify time: 修改时间,mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变data 时间不会一直更新通配符* 任意字符二进制查看hexdump -C 创建和查看文件touch 命令是个外部命令[]表示其中一个字母[^ ]表示除去其中字符的任意字符两个大于号比 touch安全 文件统配符man 7 glob 复制和转移删除文件cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失原始命令前加\拷贝文件夹 -r(递归)cp 有可能丢失数据不能用rmdir删除 data是个挂载点cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中 如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中 基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中cp SRC… DEST SRC…：多个文件DEST必须存在，且为目录，其它情形均会出错；cp SRC DESTSRC是目录：此时使用选项：-r如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；如果DEST存在：如果DEST是文件：报错如果DEST是目录：inode（index node）表中包含文件系统所有文件列表一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括： 文件类型，权限，UID，GID 链接数（指向这个文件名路径名称个数） 该文件的大小和不同的时间戳 指向磁盘上文件的数据块指针 有关文件的其他数据 inode 唯一标识在元数据里删除其实删的元数据.删文件比建文件快多了 软和硬链接硬链接创建硬链接会增加额外的记录项以引用文件对应于同一文件系统上一个物理文件每个目录引用相同的inode号创建时链接数递增删除文件时：rm命令递减计数的链接文件要存在，至少有一个链接数当链接数为零时，该文件被删除不能跨越驱动器或分区语法: ln filename [linkname ]软连接一个符号文件链接指向一个文件ls -s显示链接的名称和应用的文件一个符号链接的内容是他引用文件的名称可以对目录进行可以跨分区指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数语法:ln -s 文件 链接名 i/0 重定向至文件程序:指令+数据input 和output打开的文件都有一个fd:file descrptor(文件描述符)linux 给程序提供三种i/o设备标准输入(STDIN)-0 默认接受来自键盘的输入标准输出(STDOUT) -1默认输出到终端窗口标准错误(STDERR) -2 默认输出到窗口i/o重定向:改变默认位置语法:命令 操作符号 文件名操作符&gt;把STDOUT重定向到文件2&gt; 把STDERR重定向到文件$&gt; 把所有输出重定向到文件tr 转换和删除字符 管道管道用来连接命令命令1|命令2|命令3将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDINless 一页一页地查看输入重定向到多个目标(tee)把命令1的STDOUT保存在文件中,作为命令2的输入-a追加使用:保存不同阶段的输入复杂管道的故障排除同时查看和记录输出 用户组权限用户user令牌token,identitylinux用户:username/UID管理员:root,0普通用户:1-65535系统用户:1-499,1-999对守护进程获取资源进行权限进行分配登录用户:500+,1000交互式登录nologin 是软件启动没有用户登录 组grouplinux:Groupname/GID管理员:系统 :1-499,1-999普通组:500+,1000+安全上下文:进行中的程序:程序(process)以进程发起者的身份运行:root:/bin/catmage:/bin/cat组的类别用户的主要组:用户必须属于一个且只有一个主组组名同用户名,且包含一个用户,私有组用户和组的配置文件/etc/passwd:用户及其属性信息/etc/group:组及其属性信息/etc/shadow:用户密码及其相关属性/etc/gshadow:组密码及其相关属性passwd文件格式login name:登录用名passwd:密码UID:用户身份编号GID:登录默认所在组编号GECOS:用户全名或注释home diretory:用户主目录shell:用户默认使用shellshadow文件格式useradd usermod userdel组账号维护命令:groupaddgroupmod groupdel 用户创建:useradduseradd [options]LOGIN-u UID-o 配合-u选项,不检查UID的唯一性-g GID:指明用户所属基本组,可谓组名,也可以GID-c “COMMENT”:用户的注释信息默认设置:/etc/default/useradd文件中删除用户:userdel -r删除用户目录 查看用户相关的ID信息id [OPTIONS]…[USER]-u :显示UID-g :显示GID-G :显示用户所属的组的ID-n :显示名称,需配合ugG使用 切换用户或以其他用户身份执行命令su[options] [-] [user[args…]]切换用户的方式ssh root@ipcurl wwservice network restat 设置密码passwd常用选项： -d:删除指定用户密码 -l:锁定指定用户 -u:解锁指定用户 -e:强制用户下次登录修改密码 -f: 强制操作 -n mindays: 指定最短使用期限 -x maxdays：最大使用期限 -w warndays：提前多少天开始警告 -i inactivedays：非活动期限 –stdin：从标准输入接收用户密码 echo “PASSWORD” | passwd –stdin USERNAME 创建组groupadd[option]…group_name-g GID:指明GID号:-r:创建系统组修改和删除组:组属性修改:groupmod组删除:groupdel组密码:gpasswdnewgrp命令:临时切换主组chown设置文件的所有者chgrp设置文件的属组信息修改文件的属主和属组chown修改文件的属组:chgrp 文件权限文件的权限主要针对三类对象进行定义owner: 属主, ugroup: 属组, gother: 其他, o每个文件针对每类访问者都定义了三种权限r: Readablew: Writablex: eXcutable 修改文件权限chmod [OPTION]… OCTAL-MODE FILE… -R: 递归修改权限chmod [OPTION]… MODE[,MODE]… FILE… MODE： 修改一类用户的所有权限： u= g= o= ug= a= u=,g= 修改一类用户某位或某些位权限 u+ u- g+ g- o+ o- a+ a- + -chmod [OPTION]… –reference=RFILE FILE…参考RFILE文件的权限，将FILE的修改为同RFILE数字权限法:chmod数字 filerwx r-x r– file其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限。r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本 文本工具基础文件内容:less和cat文件截取:head和tail按列抽取:cut按关键字抽取:grep文件查看:cat tac rev分页查看:more一页一页的查看:lessless 命令是man命令使用的分页器 显示文本前后或后行内容head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行tail[option]…[FILE]看文本尾tail-f 跟踪看日志cut命令取字段past 横着合并文件wc 收集文本 文本排序sort把整理过的文本显示在STDOUT,不改变原始文件sort[opiton]file(s)uniq:从输入中删除前后相接的重复的行,处理日志liunx:文本处理三剑客grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红sed:stream editor, 文本编辑工具awk:liunx上的实现gawk,文本报告生成器grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行 正则表达式匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数位置锚定:定位正则字符特殊 元字符.单个任意字符[abc]表示其中一个字符[^abc]除去abc任意字母[:lower:]小写[:upper:]大写分组方式abc{3}\搜索替代工具grep过滤特定行,sed也可以并且编辑修改文件 vim编辑器vi:visual interface 文本编辑器文本:asscii ,unicode文本编辑种类:行编辑器:sed全屏编辑器:nano,vivim -viimproved其他编辑器gedit 一个简单的图形编辑器gvim 一个vim编辑器的图形版本vi一开始是vim的别名vim有三种模式:normal(普通) insert(插入) extendcommand(命令)normal :默认模式,移动光标,剪切/粘贴文本insert :修改文本extend command:保存,退出 搜索替代/ :从当前光标所在处向文件尾部查找? :从当前光标所在处向文件首部查找n :与命令同方向N :与命令反方向处理文本的工具sedstream editor 行编辑器sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.vim不适合修改大批量文件,sed可以sed 配合管道可以使用awk 语言sed ‘’ passwd‘地址命令’地址不写代表全部文件 命令不写代表输出 软件管理包管理器rpm 打包文件 不需要考虑部署 安装路径都定义好二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件程序包管理器：debian：deb文件, dpkg包管理器redhat: rpm文件, rpm包管理器rpm: Redhat Package Manager RPM Package Manager源代码：name-VERSION.tar.gz|bz2|xz VERSION: major.minor.releaserpm包命名方式:name-VERSION-release.arch.rpm例：bash-4.2.46-19.el7.x86_64.rpm VERSION: major.minor.release release：release.OS常见的arch： x86: i386, i486, i586, i686 x86_64: x64, x86_64, amd64 powerpc: ppc 跟平台无关：noarch 包：分类和拆包Application-VERSION-ARCH.rpm: 主包Application-devel-VERSION-ARCH.rpm 开发子包 Application-utils-VERSION-ARHC.rpm 其它子包 Application-libs-VERSION-ARHC.rpm 其它子包包之间：可能存在依赖关系，甚至循环依赖解决依赖包管理工具:yum：rpm包管理器的前端工具 apt-get：deb包管理器前端工具 zypper: suse上的rpm前端管理工具 dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具 查看二进制程序所依赖的库文件 ldd /PATH/TO/BINARY_FILE管理及查看本机装载的库文件 ldconfig 加载库文件 /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系 配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf 缓存文件：/etc/ld.so.cache 程序包管理器功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.包文件组成 (每个包独有)RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.安装或卸载时运行的脚本数据库(公共)：/var/lib/rpm 程序包名称及版本 依赖关系 功能说明 包安装后生成的各文件路径及校验码信息管理程序包的方式:使用包管理器：rpm 使用前端工具：yum, dnf获取程序包的途径：(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/ http://mirrors.aliyun.com http://mirrors.sohu.com http://mirrors.163.com(2) 项目官方站点程序包的来源(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net http://rpm.pbone.net https://sourceforge.net/(4) 自己制作 注意：第三方包建议要检查其合法性 来源合法性,程序包的完整性 rpm包管理CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护 安装：rpm {-i|–install} [install-options] PACKAGE_FILE… -v: verbose -h: 以#显示程序包管理执行进度 rpm -ivh PACKAGE_FILE … rpm包安装[install-options]–test: 测试安装，但不真正执行安装，即dry run模式–nodeps：忽略依赖关系–replacepkgs | replacefiles–nosignature: 不检查来源合法性–nodigest：不检查包完整性–noscripts：不执行程序包脚本 %pre: 安装前脚本；–nopre %post: 安装后脚本；–nopost %preun: 卸载前脚本；–nopreun %postun: 卸载后脚本； –nopostun rpm包升级升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…rpm {-F|–freshen} [install-options] PACKAGE_FILE…upgrade：安装有旧版程序包，则“升级”如果不存在旧版程序包，则“安装”freshen：安装有旧版程序包，则“升级”如果不存在旧版程序包，则不执行升级操作 rpm -Uvh PACKAGE_FILE … rpm -Fvh PACKAGE_FILE …–oldpackage：降级–force: 强制安装 升级注意项注意：(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留 包查询rpm {-q|–query} [select-options] [query-options] [select-options]-a: 所有包-f: 查看指定的文件由哪个程序包安装生成-p rpmfile：针对尚未安装的程序包文件做查询操作–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供 –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖rpm2cpio 包文件|cpio –itv 预览包内文件 rpm2cpio 包文件|cpio –id “*.conf” 释放包内文件 常用查询用法： -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, … -qa包卸载： rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME … 包校验rpm {-V|–verify} [select-options] [verify-options] S file Size differs M Mode differs (includes permissions and file type) 5 digest (formerly MD5 sum) differs D Device major/minor number mismatch L readLink(2) path mismatch U User ownership differs G Group ownership differs T mTime differs P capabilities differ包校验包来源合法性验正及完整性验正完整性验正：SHA256来源合法性验正：RSA 公钥加密对称加密：加密、解密使用同一密钥非对称加密：密钥是成对儿的public key: 公钥，公开所有人 rpm数据库数据库重建： /var/lib/rpm rpm {–initdb|–rebuilddb} initdb: 初始化 如果事先不存在数据库，则新建之 否则，不执行任何操作 rebuilddb：重建已安装的包头的数据库索引目录 yumCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具 yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下） 文件服务器: http:// https:// ftp:// file:// yum配置文件yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置 /etc/yum.repos.d/*.repo：为仓库的指向提供配置仓库指向的定义： [repositoryID] name=Some name for this repository baseurl=url://path/to/repository/ enabled={1|0} gpgcheck={1|0} gpgkey=URL enablegroups={1|0} failovermethod={roundrobin|priority} roundrobin：意为随机挑选，默认值 priority:按顺序访问 cost= 默认为1000 yum仓库yum的repo配置文件中可用的变量： $releasever: 当前OS的发行版的主版本号 $arch: 平台，i386,i486,i586,x86_64等 $basearch：基础平台；i386, x86_64 $YUM0-$YUM9:自定义变量 实例: http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64 http://server/centos/6/i384yum源阿里云repo文件:http://mirrors.aliyun.com/repo/CentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/EPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 yum命令yum命令的用法： yum [options] [command] [package …]显示仓库列表： yum repolist [all|enabled|disabled]显示程序包： yum list yum list [all | glob_exp1] [glob_exp2] […] yum list {available|installed|updates} [glob_exp1] […] 安装程序包： yum install package1 [package2] […] yum reinstall package1 [package2] […] (重新安装)yum命令升级程序包： yum update [package1] [package2] […] yum downgrade package1 [package2] […] (降级)检查可用升级： yum check-update卸载程序包： yum remove | erase package1 [package2] […]yum命令查看程序包information： yum info […]查看指定的特性(可以是某文件)是由哪个程序包所提供： yum provides | whatprovides feature1 [feature2] […]清理本地缓存： 清除/var/cache/yum/$basearch/$releasever缓存 yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]构建缓存： yum makecacheyum命令搜索：yum search string1 [string2] […] 以指定的关键字搜索程序包名及summary信息查看指定包所依赖的capabilities： yum deplist package1 [package2] […]查看yum事务历史： yum history [info|list|packages-list|packages-info| summary|addon-info|redo|undo| rollback|new|sync|stats] yum history yum history info 6 yum history undo 6日志 ：/var/log/yum.log安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] …yum localupdate rpmfile1 [rpmfile2] […] (用update替代)包组管理的相关命令： yum groupinstall group1 [group2] […] groupupdate group1 [group2] […] yum grouplist [hidden] [groupwildcard] […] yum groupremove group1 [group2] […] yum groupinfo group1 […]yum命令yum的命令行选项： –nogpgcheck：禁止进行gpg check -y: 自动回答为“yes” -q：静默模式 –disablerepo=repoidglob：临时禁用此处指定的repo –enablerepo=repoidglob：临时启用此处指定的repo –noplugins：禁用所有插件系统光盘yum仓库系统安装光盘作为本地yum仓库：(1) 挂载光盘至某目录，例如/mnt/cdrom mount /dev/cdrom /mnt/cdrom(2) 创建配置文件 [CentOS7] name= baseurl= gpgcheck= enabled= 创建yum仓库： createrepo [options] 程序包编译程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行源代码组织格式： 多文件：文件中的代码之间，很可能存在跨文件依赖关系 C、C++：make 项目管理器 configure脚本 –&gt; Makefile.in –&gt; Makefile java: maven C语言源代码编译安装三步骤:1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make 根据Makefile文件，构建应用程序3、make install 复制文件到相应路径开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in注意：安装前查看INSTALL，README 开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software Foundation) mariadb.org 代码托管:SourceForge.net Github.com code.google.comc/c++编译器: gcc (GNU C Complier) 编译C源代码： 准备：提供开发工具及开发环境 开发工具：make, gcc等 开发环境：开发库，头文件 glibc：标准库 实现：通过“包组”提供开发组件 Development Tools Server Platform Development 第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项 选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译 Optional Features: 可选特性 –disable-FEATURE –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包 –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION 第二步：make 第三步：make install 安装后的配置：(1) 二进制程序目录导入至PATH环境变量中 编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH(2) 导入帮助手册 编辑/etc/man.config|man_db.conf文件 添加一个MANPATH shell编程基础程序：指令+数据程序编程风格： 过程式：以指令为中心，数据服务于指令 对象式：以数据为中心，指令服务于数据 shell程序：提供了编程能力，解释执行 编程基本概念编程逻辑处理方式：顺序执行循环执行选择执行 shell编程：过程式、解释执行编程语言的基本结构：各种系统命令的组合数据存储：变量、数组表达式: a + b语句:ifshell脚本基础shell脚本:包含一些命令或声明，并符合一定格式的文本文件格式要求:首行shebang机制 #!/bin/bash #!/usr/bin/python #!/usr/bin/perlshell脚本的用途有：自动化常用命令 执行系统管理和故障排除 创建简单的应用程序 处理文本或文件 添加注释注释以#开头第二步：运行脚本给予执行权限，在命令行上指定脚本的绝对或相对路径直接运行解释器，将脚本作为解释器程序的参数运行 脚本规范脚本代码开头约定1、第一行一般为调用使用的语言2、程序名，避免更改文件名为无法找到正确的文件3、版本号4、更改后的时间5、作者相关信息6、该程序的作用，及注意事项7、最后是各版本的更新简要说明 脚本调试检测脚本中的语法错误bash -n /path/to/some_script调试执行bash -x /path/to/some_script 变量变量：命名的内存空间数据存储方式：字符：数值：整型，浮点型变量：变量类型作用：1、数据存储格式2、参与的运算3、表示的数据范围类型：字符数值：整型、浮点型变量命名法则：1、不能使程序中的保留字：例如 if, for2、只能使用数字、字母及下划线，且不能以数字开头3、见名知义4、统一命名规则：驼峰命名法，建议大写 bash中变量的种类根据变量的生效范围等标准划分下面变量类型：局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程， 包括当前shell的子shell进程均无效环境（全局）变量：生效范围为当前shell进程及其子进程 本地变量：生效范围为当前shell进程中某代码片断，通常指函数 位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传 递给它的参数特殊变量：$?, $0, $*, $@, $#,$$ 局部变量变量赋值：name=‘value’可以使用引用value:(1) 可以是直接字串; name=“root”(2) 变量引用：name=”$USER”(3) 命令引用：name=COMMAND name=$(COMMAND)变量引用：${name} $name“”：弱引用，其中的变量引用会被替换为变量值‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串显示已定义的所有变量：set删除变量：unset name 环境变量bash内建的环境变量：PATHSHELLUSERUIDHOMEPWDSHLVLLANGMAILHOSTNAMEHISTSIZE— 只读和位置变量只读变量：只能声明，但不能修改和删除声明只读变量： readonly name declare -r name查看只读变量： readonly –p位置变量：在脚本代码中调用通过命令行传递给脚本的参数$1, $2, …：对应第1、第2等参数，shift [n]换位置$0: 命令本身$: 传递给脚本的所有参数，全部参数合为一个字符串$@: 传递给脚本的所有参数，每个参数为独立字符串$#: 传递给脚本的参数的个数$@ $ 只在被双引号包起来的时候才会有差异set – 清空所有位置变量 退出状态进程使用退出状态来报告成功或失败• 0 代表成功，1－255代表失败• $? 变量保存最近的命令退出状态例如：ping -c1 -W1 hostdown &amp;&gt; /dev/nullecho $?退出状态码bash自定义退出状态码exit [n]：自定义退出状态码注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命令后面的数字注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执行的最后一条命令的状态码 运算bash中的算术运算:help let+, -, , /, %取模（取余）, **（乘方）实现算术运算：(1) let var=算术表达式(2) var=$[算术表达式](3) var=$((算术表达式))(4) var=$(expr arg1 arg2 arg3 …)(5) declare –i var = 数值(6) echo ‘算术表达式’ | bc乘法符号有些场景中需要转义，如bash有内建的随机数生成器：RANDOM（0-32767）echo $[$RANDOM%50] ：0-49之间随机数赋值 增强型赋值：+=, -=, *=, /=, %=let varOPERvalue例如:let count+=3自加3后自赋值自增，自减：let var+=1 let var++ let var-=1 let var-- 逻辑运算true, false1, 0 与： 1 与 1 = 1 1 与 0 = 0 0 与 1 = 0 0 与 0 = 0 或: 1 或 1 = 1 1 或 0 = 1 0 或 1 = 1 0 或 0 = 0 非：！ ! 1 = 0 ! 0 = 1 短路运算 短路与第一个为0，结果必定为0第一个为1，第二个必须要参与运算 短路或第一个为1，结果必定为1第一个为0，第二个必须要参与运算 异或：^异或的两个值,相同为假，不同为真 条件测试判断某需求是否满足，需要由测试机制来实现专用的测试表达式需要由测试命令辅助完成测试过程评估布尔声明，以便用在条件性执行中• 若真，则返回0• 若假，则返回1 测试命令：• test EXPRESSION• [ EXPRESSION ]• [[ EXPRESSION ]]注意：EXPRESSION前后必须有空白字符bash的数值测试-v VAR变量VAR是否设置 数值测试：-gt 是否大于-ge 是否大于等于-eq 是否等于-ne 是否不等于-lt 是否小于-le 是否小于等于bash的字符串测试 字符串测试: == 是否等于ascii码是否大于ascii码&lt; 是否小于!= 是否不等于=~ 左侧字符串是否能够被右侧的PATTERN所匹配注意: 此表达式一般用于[[ ]]中；扩展的正则表达式-z “STRING“ 字符串是否为空，空为真，不空为假-n “STRING“ 字符串是否不空，不空为真，空为假注意：用于字符串比较时的用到的操作数都应该使用引号Bash的文件测试 存在性测试 -a FILE：同-e-e FILE: 文件存在性测试，存在为真，否则为假存在性及类别测试-b FILE：是否存在且为块设备文件-c FILE：是否存在且为字符设备文件-d FILE：是否存在且为目录文件-f FILE：是否存在且为普通文件-h FILE 或 -L FILE：存在且为符号链接文件-p FILE：是否存在且为命名管道文件-S FILE：是否存在且为套接字文件Bash的文件权限测试 文件权限测试：-r FILE：是否存在且可读-w FILE: 是否存在且可写-x FILE: 是否存在且可执行 文件特殊权限测试：-u FILE：是否存在且拥有suid权限-g FILE：是否存在且拥有sgid权限-k FILE：是否存在且拥有sticky权限Bash的文件属性测试 文件大小测试：-s FILE: 是否存在且非空文件是否打开：-t fd: fd 文件描述符是否在某终端已经打开-N FILE：文件自从上一次被读取之后是否被修改过-O FILE：当前有效用户是否为文件属主-G FILE：当前有效用户是否为文件属组Bash的文件属性测试 双目测试：FILE1 -ef FILE2: FILE1是否是FILE2的硬链接FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）FILE1 -ot FILE2: FILE1是否旧于FILE2 使用read命令来接受输入使用read来把输入值分配给一个或多个shell变量-p 指定要显示的提示-s 静默输入，一般用于密码-n N 指定输入的字符长度N-d ‘字符’ 输入结束符-t N TIMEOUT为N秒read 从标准输入中读取值，给每个单词分配一个变量所有剩余单词都被分配给最后一个变量read -p “Enter a filename: “ FILE 流程控制过程式编程语言： 顺序执行 选择执行 循环执行条件选择if语句 选择执行: 注意：if语句可嵌套单分支 if 判断条件;then 条件为真的分支代码 fi双分支 if 判断条件; then 条件为真的分支代码 else条件为假的分支代码fi 多分支 if 判断条件1; then 条件为真的分支代码 elif 判断条件2; then 条件为真的分支代码 elif 判断条件3; then 条件为真的分支代码 else 以上条件都为假的分支代码 fi 逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句 条件判断：case语句 case 变量引用 in PAT1) 分支1 ;; PAT2) 分支2 ;; ... *) 默认分支 ;; esac case支持glob风格的通配符： *: 任意长度任意字符 ?: 任意单个字符 []：指定范围内的任意单个字符 a|b: a或b 循环 循环执行将某代码段重复运行多次重复运行多少次：循环次数事先已知循环次数事先未知有进入条件和退出条件for, while, untilfor循环for 变量名 in 列表;do循环体done执行机制：依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直到列表中的元素耗尽，循环结束 for循环列表生成方式：(1) 直接给出列表(2) 整数列表：(a) {start..end}(b) $(seq [start [step]] end)(3) 返回列表的命令$(COMMAND)(4) 使用glob，如：.sh(5) 变量引用；$@, $while循环while CONDITION; do循环体doneCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为“false”终止循环因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地被修正进入条件：CONDITION为true退出条件：CONDITION为falseuntil循环until CONDITION; do循环体done进入条件： CONDITION 为false退出条件： CONDITION 为true循环控制语句continue用于循环体中ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thencontinuefiCMDn…done循环控制语句break用于循环体中break [N]：提前结束第N层循环，最内层为第1层while CONDTIITON1; doCMD1…if CONDITION2; thenbreakfiCMDn…done特殊用法双小括号方法，即((…))格式，也可以用于算术运算双小括号方法也可以使bash Shell实现C语言风格的变量操作I=10((I++))for循环的特殊格式：for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))do 循环体done控制变量初始化：仅在运行到循环代码段时执行一次控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做条件判断 函数介绍函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运行，而是shell程序的一部分函数和shell程序比较相似，区别在于：Shell程序在子Shell中运行而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变量进行修改定义函数函数由两部分组成：函数名和函数体help function语法一：f_name （）{…函数体…} 语法二：function f_name {…函数体…} 语法三：function f_name （） {…函数体…} 函数使用函数的定义和使用：可在交互式环境下定义函数可将函数放在脚本文件中作为它的一部分可放在只包含函数的单独文件中调用：函数只有被调用才会执行调用：给定函数名函数名出现的地方，会被自动替换为函数代码函数的生命周期：被调用时创建，返回时终止函数返回值函数有两种返回值：函数的执行结果返回值：(1) 使用echo等命令进行输出(2) 函数体中调用命令的输出结果函数的退出状态码：(1) 默认取决于函数中执行的最后一条命令的退出状态码(2) 自定义退出状态码，其格式为：return 从函数中返回，用最后状态命令决定返回值return 0 无错误返回。return 1-255 有错误返回交互式环境下定义和使用函数 示例:dir() {ls -l}定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同dir该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令unset dir在脚本中定义及使用函数函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它后才能使用调用函数仅使用其函数名即可示例：cat func1!/bin/bashfunc1hello(){echo “Hello there today’s date is date +%F“}echo “now going to the function hello”helloecho “back from the function”使用函数文件可以将经常使用的函数存入函数文件，然后将函数文件载入shell文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新载入此文件 创建函数文件 函数文件示例： cat functions.main #!/bin/bash #functions.mainfindit(){if [ $# -lt 1 ] ; thenecho “Usage:findit file”return 1fifind / -name $1 –print} 载入函数函数文件已创建好后，要将它载入shell定位函数文件并载入shell的格式：. filename 或 source filename注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;这里的文件名要带正确路径 检查载入函数使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数 示例：setfindit=( ){if [ $# -lt 1 ]; thenecho “usage :findit file”;return 1fifind / -name $1 -print} 执行shell函数要执行函数，简单地键入函数名即可示例：findit groups/usr/bin/groups/usr/local/backups/groups.bak 删除shell函数现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命令完成删除函数命令格式为：unset function_name示例：unset findit再键入set命令，函数将不再显示 函数参数函数可以接受参数：传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；例如“testfunc arg1 arg2 …”在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#等特殊变量函数变量变量作用域：环境变量：当前shell和子shell有效本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数局部变量：函数的生命周期；函数结束时变量被自动销毁注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量在函数中定义局部变量的方法local NAME=VALUE函数递归示例 函数递归：函数直接或间接调用自身注意递归层数递归实例：阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的阶乘为1，自然数n的阶乘写作n!n!=1×2×3×…×n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×nn!=n(n-1)(n-2)…1n(n-1)! = n(n-1)(n-2)!函数递归示例: 示例：fact.sh fact() { if [ $1 -eq 0 -o $1 -eq 1 ]; then echo 1 else echo $[$1*$(fact $[$1-1])] fi } fact $1 fork炸弹 fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个简单的程序迅速耗尽系统里面的所有资源函数实现:(){ :|:&amp; };:bomb() { bomb | bomb &amp; }; bomb 实际上: 代表bomb脚本实现 cat Bomb.sh./$0|./$0&amp;]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(3)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(3)%2F</url>
    <content type="text"><![CDATA[磁盘管理cdLinux cd命令用于切换当前工作目录至 dirName(目录参数)。 其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。 另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。 语法cd [dirName]dirName：要切换的目标目录。 dfLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。 语法df [选项]… [FILE]…文件-a, –all 包含所有的具有 0 Blocks 的文件系统文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024文件-i, –inodes 列出 inode 资讯，不列出已使用 block文件-k, –kilobytes 就像是 –block-size=1024文件-l, –local 限制列出的文件结构文件-m, –megabytes 就像 –block-size=1048576文件–no-sync 取得资讯前不 sync (预设值)文件-P, –portability 使用 POSIX 输出格式文件–sync 在取得资讯前 sync文件-t, –type=TYPE 限制列出文件系统的 TYPE文件-T, –print-type 显示文件系统的形式文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE文件-v (忽略)文件–help 显示这个帮手并且离开文件–version 输出版本资讯并且离开 duLinux du命令用于显示目录或文件的大小。 du会显示指定的目录或文件所占用的磁盘空间。 语法du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]参数说明： -a或-all 显示目录中个别文件的大小。-b或-bytes 显示目录或文件大小时，以byte为单位。-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。-D或–dereference-args 显示指定符号连接的源文件大小。-h或–human-readable 以K，M，G为单位，提高信息的可读性。-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。-k或–kilobytes 以1024 bytes为单位。-l或–count-links 重复计算硬件连接的文件。-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。-m或–megabytes 以1MB为单位。-s或–summarize 仅显示总计。-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。–help 显示帮助。–version 显示版本信息。 mkdirLinux mkdir命令用于建立名称为 dirName 之子目录。 语法mkdir [-p] dirName参数说明： -p 确保目录名称存在，不存在的就建一个。 pwdLinux pwd命令用于显示工作目录。 执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。 语法pwd [–help][–version]参数说明: –help 在线帮助。–version 显示版本信息。 mountLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。 语法mount [-hV]mount -a [-fFnrsvw] [-t vfstype]mount [-fnrsvw] [-o options [,…]] device | dirmount [-fnrsvw] [-t vfstype] [-o options] device dir参数说明： -V：显示程序版本-h：显示辅助讯息-v：显示较讯息，通常和 -f 用来除错。-a：将 /etc/fstab 中定义的所有档案系统挂上。-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。-s-r：等于 -o ro-w：等于 -o rw-L：将含有特定标签的硬盘分割挂上。-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。-o sync：在同步模式下执行。-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。-o auto、-o noauto：打开/关闭自动挂上模式。-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.-o dev、-o nodev-o exec、-o noexec允许执行档被执行。-o suid、-o nosuid：允许执行档在 root 权限下执行。-o user、-o nouser：使用者可以执行 mount/umount 的动作。-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。-o ro：用唯读模式挂上。-o rw：用可读写模式挂上。-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。 lsLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。 语法 ls [-alrtAFR] [name…]参数 : -a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出-r 将文件以相反次序显示(原定依英文字母次序)-t 将文件依建立时间之先后次序列出-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“-R 若目录下有文件，则以下之文件亦皆依序列出 系统管理useraddLinux useradd命令用于建立用户帐号。 useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。 语法useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ][-u ][用户帐号]或 useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s ]参数说明： -c&lt;备注&gt; 加上备注文字。备注文字会保存在passwd的备注栏位中。-d&lt;登入目录&gt; 指定用户登入时的启始目录。-D 变更预设值．-e&lt;有效期限&gt; 指定帐号的有效期限。-f&lt;缓冲天数&gt; 指定在密码过期后多少天即关闭该帐号。-g&lt;群组&gt; 指定用户所属的群组。-G&lt;群组&gt; 指定用户所属的附加群组。-m 自动建立用户的登入目录。-M 不要自动建立用户的登入目录。-n 取消建立以用户名称为名的群组．-r 建立系统帐号。-s 指定用户登入后所使用的shell。-u 指定用户ID dataLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下： 时间方面： % : 印出 %%n : 下一行%t : 跳格%H : 小时(00..23)%I : 小时(01..12)%k : 小时(0..23)%l : 小时(1..12)%M : 分钟(00..59)%p : 显示本地 AM 或 PM%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数%S : 秒(00..61)%T : 直接显示时间 (24 小时制)%X : 相当于 %H:%M:%S%Z : 显示时区日期方面： %a : 星期几 (Sun..Sat)%A : 星期几 (Sunday..Saturday)%b : 月份 (Jan..Dec)%B : 月份 (January..December)%c : 直接显示日期与时间%d : 日 (01..31)%D : 直接显示日期 (mm/dd/yy)%h : 同 %b%j : 一年中的第几天 (001..366)%m : 月份 (01..12)%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)%w : 一周中的第几天 (0..6)%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)%x : 直接显示日期 (mm/dd/yy)%y : 年份的最后两位数字 (00.99)%Y : 完整年份 (0000..9999)若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。 使用权限：所有使用者。 当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。 当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。 语法date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]参数说明： -d datestr : 显示 datestr 中所设定的时间 (非系统时间)–help : 显示辅助讯息-s datestr : 将系统时间设为 datestr 中所设定的时间-u : 显示目前的格林威治时间–version : 显示版本编号 psLinux ps命令用于显示当前进程 (process) 的状态。 语法ps [options] [–help]参数： ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义-A 列出所有的行程-w 显示加宽可以显示较多的资讯-au 显示较详细的资讯-aux 显示所有包含其他使用者的行程au(x) 输出格式 :USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMANDUSER: 行程拥有者PID: pid%CPU: 占用的 CPU 使用率%MEM: 占用的记忆体使用率VSZ: 占用的虚拟记忆体大小RSS: 占用的记忆体大小TTY: 终端的次要装置号码 (minor device number of tty)STAT: 该行程的状态:D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)R: 正在执行中S: 静止状态T: 暂停执行Z: 不存在但暂时无法消除W: 没有足够的记忆体分页可分配&lt;: 高优先序的行程N: 低优先序的行程L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)START: 行程开始时间TIME: 执行的时间COMMAND:所执行的指令 topLinux top命令用于实时显示 process 的动态。 使用权限：所有使用者。 语法top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]参数说明： d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 sq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来s : 安全模式，将交谈式指令取消, 避免潜在的危机i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程n : 更新的次数，完成后将会退出 topb : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内 pstreeLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。 使用权限：所有使用者。 语法pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]或 pstree -V参数说明： -a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *） rebootLinux reboot命令用于用来重新启动计算机。 若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代 语法reboot [-n] [-w] [-d] [-f] [-i]参数： -n : 在重开机前不做将记忆体资料写回硬盘的动作-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）-f : 强迫重开机，不呼叫 shutdown 这个指令-i : 在重开机之前先把所有网络相关的装置先停止 screenLinux screen命令用于多重视窗管理程序。 screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。 语法screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s ][-S &lt;作业名称&gt;]参数说明： -A 将所有的视窗都调整为目前终端机的大小。-d&lt;作业名称&gt; 将指定的screen作业离线。-h&lt;行数&gt; 指定视窗的缓冲区行数。-m 即使目前已在作业中的screen作业，仍强制建立新的screen作业。-r&lt;作业名称&gt; 恢复离线的screen作业。-R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。-s 指定建立新视窗时，所要执行的shell。-S&lt;作业名称&gt; 指定screen作业的名称。-v 显示版本信息。-x 恢复之前离线的screen作业。-ls或–list 显示目前所有的screen作业。-wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业。 shutdownLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。 使用权限：系统管理者。 语法shutdown [-t seconds] [-rkhncfF] time [message]参数说明： -t seconds : 设定在几秒钟之后进行关机程序。-k : 并不会真的关机，只是将警告讯息传送给所有使用者。-r : 关机后重新开机。-h : 关机后停机。-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。-c : 取消目前已经进行中的关机动作。-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。-F : 关机时，强迫进行 fsck 动作。time : 设定关机的时间。message : 传送给所有使用者的警告讯息。 swatchLinux swatch命令用于系统监控程序。 swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。 语法swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]参数说明： -A&lt;分隔字符&gt; 预设配置文件中，动作的分隔字符，预设为逗号。-c&lt;设置文件&gt; 指定配置文件，而不使用预设的配置文件。-f&lt;记录文件&gt; 检查指定的记录文件，检查完毕后不会继续监控该记录文件。-I&lt;分隔字符&gt; 指定输入记录的分隔字符，预设为换行字符。-P&lt;分隔字符&gt; 指定配置文件中，事件的分隔字符，预设为逗号。-r&lt;时间&gt; 在指定的时间重新启动。-t&lt;记录文件&gt; 检查指定的记录文件，并且会监控加入记录文件中的后继记录。 idLinux id命令用于显示用户的ID，以及所属群组的ID。 id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。 语法id [-gGnru][–help][–version][用户名称]参数说明： -g或–group 显示用户所属群组的ID。-G或–groups 显示用户所属附加群组的ID。-n或–name 显示用户，所属群组或附加群组的名称。-r或–real 显示实际ID。-u或–user 显示用户ID。-help 显示帮助。-version 显示版本信息。 freeLinux free命令用于显示内存状态。 free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。 语法free [-bkmotV][-s &lt;间隔秒数&gt;]参数说明： -b 以Byte为单位显示内存使用情况。-k 以KB为单位显示内存使用情况。-m 以MB为单位显示内存使用情况。-o 不显示缓冲区调节列。-s&lt;间隔秒数&gt; 持续观察内存使用状况。-t 显示内存总和列。-V 显示版本信息。 系统设置setupLinux setup命令设置公用程序，是一个启动图形设置系统的命令。 setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。 语法setupsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项： １.登陆认证方式２.键盘组态设置３.鼠标组态设置４.开机时所要启动的系统服务５.声卡组态设置６.时区设置７.X Windows组态设置]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(2)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(2)%2F</url>
    <content type="text"><![CDATA[文档编辑grepLinux grep命令用于查找文件里符合条件的字符串。 grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。 语法grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]参数： -a 或 –text : 不要忽略二进制的数据。-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。-c 或 –count : 计算符合样式的列数。-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。-F 或 –fixed-regexp : 将样式视为固定字符串的列表。-G 或 –basic-regexp : 将样式视为普通的表示法来使用。-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。-i 或 –ignore-case : 忽略字符大小写的差别。-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。-o 或 –only-matching : 只显示匹配PATTERN 部分。-q 或 –quiet或–silent : 不显示任何信息。-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。-s 或 –no-messages : 不显示错误信息。-v 或 –revert-match : 显示不包含匹配文本的所有行。-V 或 –version : 显示版本信息。-w 或 –word-regexp : 只显示全字符合的列。-x –line-regexp : 只显示全列符合的列。-y : 此参数的效果和指定”-i”参数相同。 sortLinux sort命令用于将文本文件内容加以排序。 sort可针对文本文件的内容，以行为单位来排序。 语法sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]参数说明： -b 忽略每行前面开始出的空格字符。-c 检查文件是否已经按照顺序排序。-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。-f 排序时，将小写字母视为大写字母。-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。-m 将几个排序好的文件进行合并。-M 将前面3个字母依照月份的缩写进行排序。-n 依照数值的大小排序。-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。-r 以相反的顺序来排序。-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。–help 显示帮助。–version 显示版本信息。 trLinux tr 命令用于转换或删除文件中的字符。 tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。 语法tr [-cdst][–help][–version][第一字符集][第二字符集]tr [OPTION]…SET1[SET2]参数说明： -c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换-d, –delete：删除指令字符-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等–help：显示程序用法信息–version：显示程序本身的版本信息字符集合的范围： \NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\ 反斜杠\a Ctrl-G 铃声\b Ctrl-H 退格符\f Ctrl-L 走行换页\n Ctrl-J 新行\r Ctrl-M 回车\t Ctrl-I tab键\v Ctrl-X 水平制表符CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。[CHAR] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止[CHARREPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)[:alnum:] ：所有字母字符与数字[:alpha:] ：所有字母字符[:blank:] ：所有水平空格[:cntrl:] ：所有控制字符[:digit:] ：所有数字[:graph:] ：所有可打印的字符(不包含空格符)[:lower:] ：所有小写字母[:print:] ：所有可打印的字符(包含空格符)[:punct:] ：所有标点字符[:space:] ：所有水平与垂直空格符[:upper:] ：所有大写字母[:xdigit:] ：所有 16 进位制的数字[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符) uniqLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。 uniq 可检查文本文件中重复出现的行列。 语法uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]参数： -c或–count 在每列旁边显示该行重复出现的次数。-d或–repeated 仅显示重复出现的行列。-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。-u或–unique 仅显示出一次的行列。-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。–help 显示帮助。–version 显示版本信息。[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。 wcLinux wc命令用于计算字数。 利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。 语法wc [-clw][–help][–version][文件…]参数： -c或–bytes或–chars 只显示Bytes数。-l或–lines 只显示行数。-w或–words 只显示字数。–help 在线帮助。–version 显示版本信息。 letlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。 语法格式let arg [arg …]参数说明：arg：要执行的表达式 sedLinux sed命令是利用script来处理文本文件。 sed可依照script的指令，来处理、编辑文本文件。 Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。 语法sed [-hnV][-e][-f&lt;script文件&gt;][文本文件]参数说明： -e或–expression= 以选项中指定的script来处理输入的文本文件。-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。-h或–help 显示帮助。-n或–quiet或–silent 仅显示script处理后的结果。-V或–version 显示版本信息。动作说明： a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux命令整理(1)]]></title>
    <url>%2Flinux%2Flinux%E5%91%BD%E4%BB%A4%E6%95%B4%E7%90%86(1)%2F</url>
    <content type="text"><![CDATA[1 文档管理cat chgrp chmod chown file find cut in less more mv tee touch which cp read2 文档编辑:grep sed tr sort uniq wc let3 磁盘管理:cd df du mkdir pwd mount stat tree ls4 网络通讯:telnet httpd ifconfig netatat ping tty write5 系统管理:useradd data adduser exit kill ps pstree top reboot sudo uname who whoami whois w id free6 系统设置:reset clear alias enable rpm set passwd time setup7 备份压缩:zip tar8 其他命令: bc tail 文档命令cat全称: concatenate files and print on the standard outputcat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName参数说明：-n 或 –number：由 1 开始对所有输出的行数编号。-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。-E 或 –show-ends : 在每行结束处显示 $。-T 或 –show-tabs: 将 TAB 字符显示为 ^I。-A, –show-all：等价于 -vET。-e：等价于”-vE”选项；-t：等价于”-vT”选项； 把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：cat -n textfile1 &gt; textfile2把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：cat -b textfile1 textfile2 &gt;&gt; textfile3清空 /etc/test.txt 文档内容：cat /dev/null &gt; /etc/test.txtcat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：cat /dev/fd0 &gt; OUTFILE相反的，如果想把 image file 写到软盘，输入：cat IMG_FILE &gt; /dev/fd0注： OUTFILE 指输出的镜像文件名. IMG_FILE 指镜像文件。 若从镜像文件写回 device 时，device 容量需与相当。 通常用制作开机磁片 chgrpLinux chgrp命令用于变更文件或目录的所属群组。 在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。 语法:chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]参数说明 -c或–changes 效果类似”-v”参数，但仅回报更改的部分。 -f或–quiet或–silent 不显示错误信息。 -h或–no-dereference 只对符号连接的文件作修改，而不更动其他任何相关文件。 -R或–recursive 递归处理，将指定目录下的所有文件及子目录一并处理。 -v或–verbose 显示指令执行过程。 –help 在线帮助。 –reference=&lt;参考文件或目录&gt; 把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。 –version 显示版本信息。 chmodLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。 使用权限 : 所有使用者 语法chmod [-cfvR] [–help] [–version] mode file…参数说明mode : 权限设定字串，格式如下 : [ugoa…][[+-=][rwxX]…][,…]其中： u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。 表示增加权限、- 表示取消权限、= 表示唯一设定权限r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。其他参数说明： -c : 若该文件权限确实已经更改，才显示其更改动作-f : 若该文件权限无法被更改也不要显示错误讯息-v : 显示权限变更的详细资料-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)–help : 显示辅助说明–version : 显示版本实例将文件 file1.txt 设为所有人皆可读取 : chmod ugo+r file1.txt将文件 file1.txt 设为所有人皆可读取 : chmod a+r file1.txt将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 : chmod ug+w,o-w file1.txt file2.txt将 ex1.py 设定为只有该文件拥有者可以执行 : chmod u+x ex1.py将目前目录下的所有文件与子目录皆设为任何人可读取 : chmod -R a+r *此外chmod也可以用数字来表示权限如 : chmod 777 file语法为： chmod abc file其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。 r=4，w=2，x=1若要rwx属性则4+2+1=7；若要rw-属性则4+2=6；若要r-x属性则4+1=5。chmod a=rwx file和 chmod 777 file效果相同 chmod ug=rwx,o=x file和 chmod 771 file效果相同 若用chmod 4755 filename可使此程序具有root的权限 chownLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。使用权限 : root语法chown [-cfhvR] [–help] [–version] user[:group] file…参数 :user : 新的文件拥有者的使用者 IDgroup : 新的文件拥有者的使用者组(group)-c : 显示更改的部分的信息-f : 忽略错误信息-h :修复符号链接-v : 显示详细的处理信息-R : 处理指定目录以及其子目录下的所有文件–help : 显示辅助说明–version : 显示版本 fileLinux file命令用于辨识文件类型。 通过file指令，我们得以辨识该文件的类型。 语法file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]参数： -b 列出辨识结果时，不显示文件名称。-c 详细显示指令执行过程，便于排错或分析程序执行的情形。-f&lt;名称文件&gt; 指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。-L 直接显示符号连接所指向的文件的类别。-m&lt;魔法数字文件&gt; 指定魔法数字文件。-v 显示版本信息。-z 尝试去解读压缩文件的内容。[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。 findLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。 语法find path -option [ -print ] [ -exec -ok command ] {} \;参数说明 : find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。 expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。 -mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件 -amin n : 在过去 n 分钟内被读取过 -anewer file : 比文件 file 更晚被读取过的文件 -atime n : 在过去n天内被读取过的文件 -cmin n : 在过去 n 分钟内被修改过 -cnewer file :比文件 file 更新的文件 -ctime n : 在过去n天内被修改过的文件 -empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name -ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写 -name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写 -size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。 d: 目录 c: 字型装置文件 b: 区块装置文件 p: 具名贮列 f: 一般文件 l: 符号连结 s: socket -pid n : process id 是 n 的文件 你可以使用 ( ) 将运算式分隔，并使用下列运算。 exp1 -and exp2 ! expr -not expr exp1 -or exp2 exp1, exp2 cutLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。 语法cut [-bn] [file]cut [-c] [file]cut [-df] [file]使用说明: cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。 如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。 参数: -b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。-c ：以字符为单位进行分割。-d ：自定义分隔符，默认为制表符。-f ：与-d一起使用，指定显示哪个区域。-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的范围之内，该字符将被写出；否则，该字符将被排除 lnLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。 当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。 语法 ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}] [–help] [–version] [–] 命令功能 :Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。 不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。 软链接： 1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式2.软链接可以 跨文件系统 ，硬链接不可以3.软链接可以对一个不存在的文件名进行链接4.软链接可以对目录进行链接硬链接： 1.硬链接，以文件副本的形式存在。但不占用实际空间。2.不允许给目录创建硬链接3.硬链接只有在同一个文件系统中才能创建命令参数必要参数： -b 删除，覆盖以前建立的链接-d 允许超级用户制作目录的硬链接-f 强制执行-i 交互模式，文件存在则提示用户是否覆盖-n 把符号链接视为一般目录-s 软链接(符号链接)-v 显示详细的处理过程选择参数： -S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”–help 显示帮助信息–version 显示版本信息 lessless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。 语法less [参数] 文件参数说明： -b &lt;缓冲区大小&gt; 设置缓冲区的大小-e 当文件显示结束后，自动离开-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件-g 只标志最后搜索的关键词-i 忽略搜索时的大小写-m 显示类似more命令的百分比-N 显示每行的行号-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来-Q 不使用警告音-s 显示连续空行为一行-S 行过长时间将超出部分舍弃-x &lt;数字&gt; 将”tab”键显示为规定的数字空格/字符串：向下搜索”字符串”的功能?字符串：向上搜索”字符串”的功能n：重复前一个搜索（与 / 或 ? 有关）N：反向重复前一个搜索（与 / 或 ? 有关）b 向后翻一页d 向后翻半页h 显示帮助界面Q 退出less 命令u 向前滚动半页y 向前滚动一行空格键 滚动一页回车键 滚动一行[pagedown]： 向下翻动一页[pageup]： 向上翻动一页 moreLinux more命令Linux 命令大全 Linux 命令大全 Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。 语法more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]参数： -num 一次显示的行数-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料-s 当遇到有连续两行以上的空白行，就代换为一行的空白行-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示+num 从第 num 行开始显示fileNames 欲显示内容的文档，可为复数个数 mvLinux mv命令Linux 命令大全 Linux 命令大全 Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。 语法mv [options] source destmv [options] source… directory参数说明： -i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;mv参数设置与运行结果 mv 文件名 文件名 将源文件名改为目标文件名mv 文件名 目录名 将文件移动到目标目录mv 目录名 目录名 目标目录已存在，将源目录移动到目标目录；目标目录不存在则改名mv 目录名 文件名 出错 rmrm命令用于删除一个文件或者目录。 语法rm [options] name…参数： -i 删除前逐一询问确认。-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。-r 将目录及以下之档案亦逐一删除。 teeLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。 tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。 语法tee [-ai][–help][–version][文件…]参数： -a或–append 附加到既有文件的后面，而非覆盖它．-i或–ignore-interrupts 忽略中断信号。–help 在线帮助。–version 显示版本信息。 touchLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。 ls -l 可以显示档案的时间记录。 语法touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]参数说明：a 改变档案的读取时间记录。m 改变档案的修改时间记录。c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。f 不使用，是为了与其他 unix 系统的相容性而保留。r 使用参考档的时间记录，与 –file 的效果一样。d 设定时间与日期，可以使用各种不同的格式。t 设定档案的时间记录，格式与 date 指令相同。–no-create 不会建立新档案。–help 列出指令格式。–version 列出版本讯息。 whichLinux which命令用于查找文件。 which指令会在环境变量$PATH设置的目录里查找符合条件的文件。 语法which [文件…]参数： -n&lt;文件名长度&gt; 指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。-p&lt;文件名长度&gt; 与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。-w 指定输出时栏位的宽度。-V 显示版本信息 cpLinux cp命令主要用于复制文件或目录。 语法cp [options] source dest或 cp [options] source… directory参数说明： -a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。-f：覆盖已经存在的目标文件而不给出提示。-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。-l：不复制文件，只是生成链接文件。 readLinux read命令用于从标准输入读取数值。 read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。 语法read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]参数说明: -a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。-p 后面跟提示信息，即在输入前打印提示信息。-e 在输入的时候可以使用命令补全功能。-n 后跟一个数字，定义输入文本的长度，很实用。-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。-t 后面跟秒数，定义输入字符的等待时间。-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10大排序算法]]></title>
    <url>%2F%E7%AE%97%E6%B3%95%2F10%E5%A4%A7%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%2F</url>
    <content type="text"><![CDATA[基本入门算法有三个经典算法:冒泡,选择和插入算法 1.冒泡排序 冒泡排序重复地走访过要排序的数列，一次比较两个元素，如果他们的顺序错误就把他们交换过来。走访数列的工作是重复地进行直到没有再需要交换，也就是说该数列已经排序完成。这个算法的名字由来是因为越大的元素会经由交换慢慢“浮”到数列的顶端，故名。 步骤： 比较相邻的元素。如果第一个比第二个大，就交换他们两个。 对每一对相邻元素作同样的工作，从开始第一对到结尾的最后一对。在这一点，最后的元素应该会是最大的数。 针对所有的元素重复以上的步骤，除了最后一个。 持续每次对越来越少的元素重复上面的步骤，直到没有任何一对数字需要比较。 代码实现： 123456789101112# -*- coding:utf-8 -*-def bubble_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(1,length-index): if raw_list[i-1]&gt;raw_list[i]: raw_list[i],raw_list[i-1]=raw_list[i-1],raw_list[i] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = bubble_sort(data_test)print(sorted_list) 2.选择排序 从待排序的数据元素中选出最小（或最大）的一个元素，存放在序列的起始位置，直到全部待排序的数据元素排完。 12345678910111213# -*- coding:utf-8 -*-def select_sort(raw_list): length=len(raw_list) for index in range(length): for i in range(index,length): if raw_list[index]&gt;raw_list[i]: raw_list[index],raw_list[i]=raw_list[i],raw_list[index] return raw_list#测试data_test=[10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = select_sort(data_test)print(sorted_list) 3.插入排序 每步将一个待排序的纪录，按其关键码值的大小插入前面已经排序的文件中适当位置上，直到全部插入完为止。 步骤： 从第一个元素开始，该元素可以认为已经被排序 取出下一个元素，在已经排序的元素序列中从后向前扫描 如果该元素（已排序）大于新元素，将该元素移到下一位置 重复步骤3，直到找到已排序的元素小于或者等于新元素的位置 将新元素插入到该位置后 重复步骤2~5 代码实现： 1234567891011121314151617# -*- coding:utf-8 -*-def insert_sort(raw_list): length = len(raw_list) for i in range(1, length): temp = raw_list[i] #j从i-1 到 0倒序 for j in range(i-1,-1,-1): if(raw_list[j]&lt;=temp): break if(raw_list[j]&gt;temp): raw_list[j],raw_list[j+1] = temp,raw_list[j] j -= 1 return raw_list#测试data_test = [10,23,1,53,654,54,16,646,65,3155,546,31]sorted_list = insert_sort(data_test)print(sorted_list) 4.希尔排序 先取一个小于n的整数d1作为第一个增量，把文件的全部记录分组。所有距离为d1的倍数的记录放在同一个组中。先在各组内进行直接插入排序；然后，取第二个增量d2&lt;d1重复上述的分组和排序，直至所取的增量 即所有记录放在同一组中进行直接插入排序为止。 123456789101112131415161718# -*- coding:utf-8 -*-def shell_sort(list): length=len(list) dist=length/2 while dist&gt;0: for i in range(dist,length): temp=list[i] j=i while j&gt;=dist and temp&lt;list[j-dist]: list[j]=list[j-dist] j-=dist list[j]=temp dist/=2 return list#测试list=[10,23,1,53,654,54,16,646,65,3155,546,31]print shell_sort(list) 5.归并排序 归并排序，就是把两个已经排列好的序列合并为一个序列。 代码实现： 1234567891011121314151617181920# -*- coding:utf-8 -*-#算法逻辑比较简单，以第一个list为基准，第二个向第一个插空def merge_sort(list1,list2): length_list1=len(list1) length_list2=len(list2) list3=[] j=0 for i in range(length_list1): while list2[j]&lt;list1[i] and j&lt;length_list2: list3.append(list2[j]) j=j+1 list3.append(list1[i]) if j&lt;(length_list2-1): for k in range(j,length_list2): list3.append(list2[k]) return list3#测试list1=[1,3,5,10]list2=[2,4,6,8,9,11,12,13,14]print merge_sort(list1,list2) 6.快速排序 123456789101112131415161718192021222324随意选择一个数字作为基准，比基准数字大的在右，比基准数字小的在左。# -*- coding:utf-8 -*-def kp(arr,i,j):#快排总函数 #制定从哪开始快排 if i&lt;j: base=kpgc(arr,i,j) kp(arr,i,base) kp(arr,base+1,j)def kpgc(arr,i,j):#快排排序过程 base=arr[i] while i&lt;j: while i&lt;j and arr[j]&gt;=base: j-=1 while i&lt;j and arr[j]&lt;base: arr[i]=arr[j] i+=1 arr[j]=arr[i] arr[i]=base return iww=[3,2,4,1,59,23,13,1,3]print wwkp(ww,0,len(ww)-1)print ww 7.堆排序 堆排序（Heapsort）是指利用堆这种数据结构所设计的一种排序算法。堆积是一个近似完全二叉树的结构，并同时满足堆积的性质：即子结点的键值或索引总是小于（或者大于）它的父节点。 步骤： 创建最大堆:将堆所有数据重新排序，使其成为最大堆 最大堆调整:作用是保持最大堆的性质，是创建最大堆的核心子程序 堆排序:移除位在第一个数据的根节点，并做最大堆调整的递归运算 代码实现： 123456789101112131415161718192021222324252627# -*- coding:utf-8 -*-def head_sort(list): length_list = len(list) first=int(length_list/2-1) for start in range(first,-1,-1): max_heapify(list,start,length_list-1) for end in range(length_list-1,0,-1): list[end],list[0]=list[0],list[end] max_heapify(list,0,end-1) return listdef max_heapify(ary,start,end): root = start while True: child = root*2 + 1 if child &gt; end: break if child + 1 &lt;= end and ary[child]&lt;ary[child+1]: child = child + 1 if ary[root]&lt;ary[child]: ary[root],ary[child]=ary[child],ary[root] root=child else: break#测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print head_sort(list) 8.计数排序 12345678910111213141516171819202122# -*- coding:utf-8 -*-def count_sort(list): max=min=0 for i in list: if i &lt; min: min = i if i &gt; max: max = i count = [0] * (max - min +1) for j in range(max-min+1): count[j]=0 for index in list: count[index-min]+=1 index=0 for a in range(max-min+1): for c in range(count[a]): list[index]=a+min index+=1 return list #测试：list=[10,23,1,53,654,54,16,646,65,3155,546,31]print count_sort(list)]]></content>
      <categories>
        <category>算法</category>
      </categories>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端风云录]]></title>
    <url>%2Fjs%2F%E5%89%8D%E7%AB%AF%E6%8A%80%E6%9C%AF%E9%A3%8E%E4%BA%91%E5%BD%95%2F</url>
    <content type="text"><![CDATA[@TOC HTMLHTML（HyperText Markup Language）超文本标记语言，它不同于编程语言 超文本就是超出纯文本的范畴，例如描述文本的颜色、大小、字体等信息，或使用图片、音频、视频等非文本内容 HTML由一个个标签组成，这些标签各司其职。有的提供网页信息，有的负责图片，有的负责网页布局 12345678910&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;首页&lt;/title&gt;&lt;/head&gt;&lt;body&gt;&lt;h1&gt;你好&lt;/h1&gt;&lt;/body&gt;&lt;/html&gt; 超文本需要显示，就得有软件能够呈现超文本定义的排版格式，例如显示图片、表格，显示字体的大小、颜色，这个软件就是浏览器 超文本的诞生是为了解决纯文本不能格式显示的问题，是为了好看，但是只有通过网络才能分享超文本的内容，所以制定了HTTP协议 浏览器历史1980年代，Tim Berners-Lee为CERN（欧洲核子研究中心，当时欧洲最大的互联网节点）设计基于超文本思想的ENQUIRE项目，以促进科研人员之间的信息共享和更新。1989年他编写了《信息化管理：建议》一文，并构建基于Internet的Hypertext系统，并在CERN开发了World Wide Web项目，打造了世界上第一个网站，于1991年8月6日正式上线 Tim Berners-Lee于1990年发明了第一个浏览器，还发明了HTTP协议 1994年MIT他创建了W3C。W3C万维网联盟，负责万维网持续发展。他提出W3C的标准应该基于无专利权、无版税 Marc Andreessen于1993年发明了Mosaic浏览器，看到了这个技术的前景，不久后他成立自己的公司——网景Netscape。1994发布了Netscape Navigator浏览器，席卷全球 1995年微软发布IE，开启第一次浏览器大战，最终后来居上 由于IE的捆绑销售行为，网景的单一浏览器市场萎缩，从1990年代的90%下降至2006年的1%1999年网景被AOL收购，收购后不久，Netscape公开了浏览器代码，并创建了Mozilla组织。Mozilla组织使用Gecko引擎重写浏览器Mozilla组织使用Gecko引擎发布了几款浏览器，最终于2004年更名为Firefox浏览器2003年5月，网景被解散AOL于2007年12月宣布停止支持Netscape浏览器 Apple的Safari于2003发布第一个测试版 2008年Google的Chrome浏览器带着 V8 引擎横空出世 网景公司的技术： HTTP Cookie，解决HTTP无状态 JavaScript SSL协议 JAR格式文件，将Java的class文件打包压缩，并加上签名 2012年4月9日，微软以10亿5千6百万美元购买800项美国在线的专利或专利授权，专家们认为网景的SSL、Cookie等专利可能是微软愿意出高价的理由之一【摘自wiki百科】 浏览器技术浏览器是一种特殊的客户端，能够基于HTTP(s)、FTP等协议和WEB服务器进行交互，呈现网页内容的软件可以简单的认为浏览器软件分为2个部分： 外壳 外壳提供用户交互的界面 内核（引擎Engine） 提供HTML、CSS、图像的渲染引擎，提供DOM编程接口 提供JavaScript引擎 提供浏览器内建对象 |排版（渲染）引擎| 浏览器 | 说明||:–|:–|:–|| Gecko | Firefox | C++开发并最早开源，可以支持复杂的网页效果，提供强大的浏览器扩展接口||Trident | IE、AOL| 早期未按照W3C标准实现，兼容性很差，IE9之后内核升级以符合标准|| KHTML| | KDE，于1998年开发 ||Presto | Opera | 目前公认的网页浏览速度最快的内核，但牺牲一部分兼容性 ||WebKit | Safari、Chrome |WebKit基于KHTML开发。网页浏览速度较快，但网页容错性不高||Blink |Chrome、Opera |基于WebKit WebCore |其他国内浏览器，一般都是采用了以上的一个或两个内核加上外壳实现 JS引擎不同浏览器内核中也使用不同的JS引擎，常见的JS引擎有JScript、TraceMonkey（Firefox）、V8等这些引擎差异不小，实现ECMA标准不同，甚至有不按照标准实现的使用jQuery等框架来解决兼容性问题，抹平平台差异 JavaScriptJSJavascript 简称JS，是一种动态的弱类型脚本解释性语言，和HTML、CSS并称三大WEB核心技术，得到了几乎主流浏览器支持 1994年，网景Netscape公司成立并发布了Netscape Navigator浏览器，占据了很大的市场份额，网景意识到WEB需要动态，需要一种技术来实现 1995年9月网景浏览器2发布测试版本发布了LiveScript，随即在12月的测试版就更名为JavaScript。同时期，微软推出IE并支持JScript、VBScript，与之抗衡 1997年，网景、微软、SUN、Borland公司和其他组织在ECMA确定了ECMAScript语言标准。JS就成为ECMAScript标准的实现之一 ESES，ECMAScript是由ECMA国际（前身为欧洲计算机制造商协会,英文名称是European Computer Manufacturers Association）通过ECMA-262标准化的脚本程序设计语言。该语言被广泛的应用于互联网 JavaScript是商品名，目前商标权在Oracle公司手中。ES是标准名根据ES标准，有很多实现引擎，其中包括JavaScript、JScript等，它们都ECMA-262标准的实现和扩展 为什么之前浏览器兼容是个大问题？HTML、CSS、JS技术都在发展，标准版本很多。浏览器内嵌的引擎实现不太一致，甚至有不按照标准实现，或减少实现，或改变实现，或增加功能的实现，比如IE，这就导致了开发人员负担，很难做到一套代码可以兼容地跑在多种浏览器中，甚至都不能跑在同一种浏览器的不同版本中 1997年，制定首个版本ECMA-2621999年12月，ES 3，支持更强大的正则表达式等ES4太激进，最终放弃2009年，ES5发布，得到广泛支持。支持严格模式，支持Json2015年，ES6发布，引入非常多的新的语言特性，还兼容旧版本特性。ES6之前按照版本号命名，从ES6开始使用年份作为版本号，ES6即ECMAScript 2015 JavaScript 的标准是 ECMAScript。截至 2012 年，所有的现代浏览器都完整的支持 ECMAScript 5.1，旧式的浏览器至少支持 ECMAScript 3 标准。2015年6月17日，ECMA国际组织发布了 ECMAScript 的第六版，该版本正式名称为 ECMAScript 2015，但通常被称为 ECMAScript 6 或者 ES6。自此，ECMAScript 每年发布一次新标准。本文档目前覆盖了最新 ECMAScript 的草案，也就是 ECMAScript2019 – 摘自MDN V8 引擎就在浏览器市场一家独大的时候，Firefox、chrome异军突起2008年9月2日，Google的chrome浏览器发布，一并发布的Js引擎，就是V8引擎。V8使用BSD协议开源 V8引擎使用 C++ 开发，将JavaScript编译成了机器码，而不是字节码，还用很多优化方法提高性能，因此，V8引擎速度非常快V8引擎还可以独立运行，可以嵌入到其他任何C++程序中V8引擎的诞生，使得服务器端运行JS成为了可能且方便的事情 2009年，基于V8引擎，诞生了Nodejs，这是服务器端运行JS的运行环境 CSS（Cascading Style Sheets）层叠样式表HTML本身为了格式化显示文本，但是当网页呈现大家面前的时候，需求HTML提供更多样式能力。这使得HTML变得越来越臃肿。这促使了CSS的诞生 1994年，W3C成立，CSS设计小组所有成员加入W3C，并努力研发CSS的标准，微软最终加入1996年12月发布CSS 1.01998年5月发布CSS 2.0CSS 3采用了模块化思想，每个模块都在CSS 2基础上分别增强功能。所以，这些模块是陆续发布的 不同厂家的浏览器使用的引擎，对CSS的支持不一样，导致网页布局、样式在不同浏览器不一样。因此，想要保证不同用户使用不同浏览器看到的网页效果一直非常困难 动态网页技术JS的引入使得浏览器可以显示动态的效果，但这不是动态网页 发明WEB技术的初衷是为了分享文档，而这些内容是静态的，就是写好的不变的文件。通过URL定位到这些文档，将内容下载到浏览器上，由浏览器呈现 互联网发展，网民的需求增加，大家希望提供交互式访问。用户提交需求，服务端找到需求匹配的资源并发回浏览器端显示。这就是动态网页动态网页指的是网页的内容是动态的，URL不变，里面的内容变化。例如访问一个查询页面，提交的关键字不同，下面表格的内容变化动态网页，表现的是浏览器端内容的变化，而本质上它是一种服务端动态网页技术server-side dynamic web page。最早诞生的动态网页技术有ASP、JSP、PHP等，后来几乎所有流行的高级语言都提供了开发动态网页的能力 网页布局早期的网页只需要简单的显示标题、正文、图片，使用&lt;P&gt;标签分段后来有人大量使用表格标签，可以做到很好的内容布局，也出现结构化的布局方案。但随着页面内容的堆积，出现了成百上千个表格嵌套的情况，浏览器绘制很慢后来出现了Div + CSS布局风格，舍弃了表格布局，加上JavaScript，使得前后端开发分离，而且可以做到很好的自适应布局。例如流式瀑布一样的布局 同步和异步同步早期，网页就是一页页的文本，没什么图片、样式后来，互联网时代到来，网页内容越来越多，页面文件越来越大浏览器渲染HTML，需要先下载CSS加载，为的是准备渲染网页之后，下载网页内容，并逐步渲染。还要构建DOM树，加载JS脚本并执行，JS可能需要修改DOM，网页就要重新渲染如果JS放在网页HEAD中，还需要等待JS下载并加载图片使用 &lt;img&gt; 标签，是发起新的HTTP请求，如果图片返回，需要重新绘制网页好不容易，一张网页绘制完毕。这里面发起了很多的HTTP请求 交互式网页，用户提交了请求，就是想看到查询的结果。服务器响应到来后是一个全新的页面内容，哪怕URL不变，整个网页都需要重新渲染。例如，用户填写注册信息，只是2次密码不一致，提交后，整个注册页面重新刷新，所有填写项目重新填写（当然有办法让用户减少重填）。这种交互非常不友好从代价的角度看，就是为了注册的一点点信息，结果返回了整个网页内容，不但浪费了网络带宽，还需要浏览器重新渲染网页，太浪费资源了，影响了用户体验和感受 上面这些请求的过程，就是同步过程，用户发起请求，页面整个刷新，直到服务器端响应的数据到来并重新渲染 异步1996年微软实现了iframe标签，可以在一个网页使用iframe标签局部异步加载内容1999年微软推出异步数据传输的ActiveX插件技术，太笨重了，但是也火了很多年。有一个组件XMLHttpRequest被大多数浏览器支持 A JAX即“Asynchronous Javascript And XML”（异步JavaScript和XML），使用XMLHttpRequest组件，结合JS，数据格式采用XML（可扩展标记语言），将这三者结合，实现网页的异步请求。A JAX是一种技术的组合，技术的重新发现，而不是发明，但是它深远的影响了整个WEB开发 2005，google在Gmail和地图中应用Ajax，使它大受欢迎并推广开来 有了异步请求，就可以动态的从浏览器发起请求到服务器端，服务器端返回响应的数据封装成XML（JSON）返回给浏览器，浏览器只需要使用JS把内容加入到DOM中，局部渲染就可以了。这个过程中，整个网页不用重新刷新，只需要局部动态改变即可 前端开发早期前端开发使用网页三剑客：Dreamweaver、Firework、Flash。微软的有Frontpage 不管使用什么工具，都不能改变JS兼容、CSS兼容、浏览器版本兼容问题 2006年 jQuery库诞生，出现了JS框架，抹平了平台差异。基于它产生了众多的插件，前端开发终于轻松了些 2008年 V8引擎伴随着Chrome浏览器发布2009年 ES5标准发布2009年 Nodejs发布，服务器端也可以使用JavaScript了2009年 AngularJS诞生，之后被谷歌收购2010年 Backbone.js诞生2011年 React和ember诞生，React于2013年5月开源2014年 国人 尤雨溪 的Vue.js诞生2014年 HTML5标准发布 前端工具和框架越来越多，前端开发已经不是随便使用一个什么文本编辑器就可以完成的了。如果使用框架，需要很多工具的配合，配置好一个开发环境非常重要 硬件发展最初，网页就是简单的文本，计算机轻松胜任后来，网页对多媒体的支持，动态效果的支持，都需要使用大量的CPU、内存资源，甚至是显卡的渲染能力所以，个人PC需要不断升级，否则浏览网页很困难 移动互联网到来的早期，手机看的网页，都需要单独处理手机屏幕小、CPU弱、内存小，能看的网页纯文本加小图。这样产生的流量也小，2G时代谈不上网速2007年第一代IPhone诞生，2008年安卓手机诞生，3G的移动互联网时代到来了手机硬件水平不断提升，手机的开发平台可以让众多开发者开发APP，用户可以下载安装使用这些APP对于开发者来说，开发就是个问题了，是不是需要开发一套IPhone版本、再开发一套安卓，在开发一套网页的版本呢？2013年，中国开始进入4G时代。手机硬件水平也得到了很大的提升众多平台都在思考是否能够一套架构，解决所有前端问题。使用的还是最通用的技术网页+JS 如今的前端开发已经不是以前的几个js文件、几百行代码了。为了适应需求，新框架、新编程模式不断涌现，这些工具都大大方便了协作开发，同时解决平台兼容性问题]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>前端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[mysql事务和隔离级别]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL-%20%E4%BA%8B%E5%8A%A1%E3%80%81MySQL%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB%E4%B8%8E%E5%85%B6%E4%BB%96%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@[toc] 事务TransactionInnoDB引擎，支持事务。事务，由若干条语句组成的，指的是要做的一系列操作。 关系型数据库中支持事务，必须支持其四个属性（ACID）： 特性 描述 原子性（atomicity） 一个事务是一个不可分割的工作单位，事务中包括的所有操作要么全部做完，要么什么都不做 一致性（consistency） 事务必须是使数据库从一个一致性状态变到另一个一致性状态。一致性与原子性是密切相关的 隔离性（isolation） 一个事务的执行不能被其他事务干扰。即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发执行的各个事务之间不能互相干扰 持久性（durability） 持久性也称永久性（permanence），指一个事务一旦提交，它对数据库中数据的改变就应该是永久性的。接下来的其他操作或故障不应该对其有任何影响 原子性，要求事务中的所有操作，不可分割，不能做了一部分操作，还剩一部分操作 一致性，多个事务并行执行的结果，应该和事务排队执行的结果一致。如果事务的并行执行和多线程读写共享资源一样不可预期，就不能保证一致性 隔离性，就是指多个事务访问共同的数据了，应该互不干扰。隔离性，指的是究竟在一个事务处理期间，其他事务能不能访问的问题 持久性，比较好理解，就是事务提交后，数据不能丢失MySQL隔离级别隔离性不好，事务的操作就会互相影响，带来不同严重程度的后果首先看看隔离性不好，带来哪些问题： 更新丢失Lost Update事务A和B，更新同一个数据，它们都读取了初始值100，A要减10，B要加100，A减去10后更新为90，B加100更新为200，A的更新丢失了，就像从来没有减过10一样 脏读事务A和B，事务B读取到了事务A未提交的数据（这个数据可能是一个中间值，也可能事务A后来回滚事务）。事务A是否最后提交并不关心。只要读取到了这个被修改的数据就是脏读 不可重复读Unrepeatable read事务A在事务执行中相同查询语句，得到了不同的结果，不能保证同一条查询语句重复读相同的结果就是不可以重复读例如，事务A查询了一次后，事务B修改了数据，事务A又查询了一次，发现数据不一致了注意，脏读讲的是可以读到相同的数据的，但是读取的是一个未提交的数据，而不是提交的最终结果。 幻读Phantom read事务A中同一个查询要进行多次，事务B插入数据，导致A返回不同的结果集，如同幻觉，就是幻读数据集有记录增加了，可以看做是增加了记录的不可重复读 有了上述问题，数据库就必须要解决，提出了隔离级别。隔离级别由低到高，如下表|隔离级别| 描述 ||:–|:–|| READ UNCOMMITTED | 读取到未提交的数据|| READ COMMITTED | 读已经提交的数据，ORACLE默认隔离级别 || REPEATABLE READ |可以重复读，MySQL的 默认隔离级别 || SERIALIZABLE |可串行化。事务间完全隔离，事务不能并发，只能串行执行 |隔离级别越高，串行化越高，数据库执行效率低；隔离级别越低，并行度越高，性能越高隔离级别越高，当前事务处理的中间结果对其它事务不可见程度越高 设置会话级或者全局隔离级别 12SET [SESSION | GLOBAL] TRANSACTION ISOLATION LEVEL&#123;READ UNCOMMITTED | READ COMMITTED | REPEATABLE READ | SERIALIZABLE&#125; 查询隔离级别 12345SELECT @@global.tx_isolation;SELECT @@tx_isolation;SET SESSION TRANSACTION ISOLATION LEVEL READ COMMITTED;SET SESSION TRANSACTION ISOLATION LEVEL REPEATABLE READ; 禁用自动提交 1SET AUTOCOMMIT = 0 SERIALIZABLE，串行了，解决所有问题 REPEATABLE READ，事务A中同一条查询语句返回同样的结果，就是可以重复读数据了。例如语句为(select * from user)。解决的办法有： 对select的数据加锁，不允许其它事务删除、修改的操作 第一次select的时候，对最后一次确切提交的事务的结果做快照 解决了不可以重复读，但是有可能出现幻读。因为另一个事务可以增删数据 READ COMMITTED，在事务中，每次select可以读取到别的事务刚提交成功的新的数据。因为读到的是提交后的数据，解决了脏读，但是不能解决 不可重复读 和 幻读 的问题。因为其他事务前后修改了数据或增删了数据 READ UNCOMMITTED，能读取到别的事务还没有提交的数据，完全没有隔离性可言，出现了脏读，当前其他问题都可能出现 事务语法 START TRANSACTION或BEGIN开始一个事务，START TRANSACTION是标准SQL的语法 使用COMMIT提交事务后，变更成为永久变更 ROLLBACK可以在提交事务之前，回滚变更，事务中的操作就如同没有发生过一样（原子性） SET AUTOCOMMIT语句可以禁用或启用默认的autocommit模式，用于当前连接。SET AUTOCOMMIT = 0禁用自动提交事务。如果开启自动提交，如果有一个修改表的语句执行后，会立即把更新存储到磁盘数据仓库和数据库的区别本质上来说没有区别，都是存放数据的地方 但是数据库关注数据的持久化、数据的关系，为业务系统提供支持，事务支持 数据仓库存储数据的是为了分析或者发掘而设计的表结构，可以存储海量数据 数据库存储在线交易数据OLTP（联机事务处理OLTP，On-line Transaction Processing）；数据仓库存储历史数据用于分析OLAP（联机分析处理OLAP，On-Line Analytical Processing） 数据库支持在线业务，需要频繁增删改查；数据仓库一般囤积历史数据支持用于分析的SQL，一般不建议删改 游标Cursor 操作查询的结果集的一种方法 可以将游标当做一个指针，指向结果集中的某一行]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[IO多种概念]]></title>
    <url>%2Fweb%2FIO%E5%A4%9A%E7%A7%8D%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@toc 重要概念同步、异步函数或方法被调用的时候，调用者是否得到最终结果的 直接得到最终结果的，就是同步调用 不直接得到最终结果的，就是异步调用阻塞、非阻塞函数或方法调用的时候，是否立刻返回 立即返回就是非阻塞调用 不立即返回就是阻塞调用区别同步、异步，与阻塞、非阻塞不相关同步、异步强调的是，是否得到（最终的）结果阻塞、非阻塞强调是时间，是否等待 同步与异步区别在于：调用者是否得到了想要的最终结果同步就是一直要执行到返回最终结果异步就是直接返回了，但是返回的不是最终结果。调用者不能通过这种调用得到结果，以后可以通过被调用者提供的某种方式（被调用着通知调用者、调用者反复查询、回调），来取回最终结果 阻塞与非阻塞的区别在于，调用者是否还能干其他事阻塞，调用者就只能干等非阻塞，调用者可以先去忙会别的，不用一直等 联系同步阻塞，我啥事不干，就等你打饭打给我。打到饭是结果，而且我啥事不干一直等，同步加阻塞同步非阻塞，我等着你打饭给我，但我可以玩会手机、看看电视。打饭是结果，但是我不一直等 异步阻塞，我要打饭，你说等叫号，并没有返回饭给我，我啥事不干，就干等着饭好了你叫我。例如，取了号什么不干就等叫自己的号异步非阻塞，我要打饭，你给我号，你说等叫号，并没有返回饭给我，我在旁边看电视、玩手机，饭打好了叫我 操作系统知识在386之前，CPU工作在实模式下，之后，开始支持保护模式，对内存进行了划分X86 CPU有4种工作级别： Ring0级，可以执行特权指令，可以访问所有级别数据，可以访问IO设备等 Ring3级，级别最低，只能访问本级别数据 内核代码运行在Ring0，用户代码运行在Ring3 现代操作系统采用虚拟存储器，理论上，对于32位系统来说，进程对虚拟内存地址的内存寻址空间为4G（2^32)64位操作系统理论上最大内存寻址空间（2^64）操作系统中，内核程序独立且运行在较高的特权级别上，它们驻留在被保护的内存空间上，拥有访问硬件设备的所有权限，这部分内存称为内核空间（内核态，最高地址1G） 普通应用程序运行在用户空间（用户态） 应用程序想访问某些硬件资源就需要通过操作系统提供的系统调用，系统调用可以使用特权指令运行在内核空间，此时进程陷入内核态运行。系统调用完成，进程将回到用户态执行用户空间代码 同步IO、异步IO、IO多路复用IO两个阶段IO过程分两阶段： 数据准备阶段 内核空间复制回用户空间进程缓冲区阶段 发生IO的时候： 内核从IO设备读、写数据（淘米，把米放饭锅里煮饭） 进程从内核复制数据（盛饭，从内核这个饭锅里面把饭装到碗里来） 系统调用——read函数 IO模型同步IO 同步IO模型包括 阻塞IO、非阻塞IO、IO多路复用、信号驱动IO阻塞IO 进程等待（阻塞），直到读写完成。（全程等待） 非阻塞IO进程调用read操作，如果IO设备没有准备好，立即返回ERROR，进程不阻塞。用户可以再次发起系统调用，如果内核已经准备好，就阻塞，然后复制数据到用户空间 第一阶段数据没有准备好，就先忙别的，等会再来看看。检查数据是否准备好了的过程是非阻塞的 第二阶段是阻塞的，即内核空间和用户空间之间复制数据是阻塞的 例：淘米、蒸饭我不等，我去玩会，盛饭过程我等着你装好饭，但是要等到盛好饭才算完事，这是同步的，结果就是盛好饭 IO多路复用所谓IO多路复用，就是同时监控多个IO，有一个准备好了，就不需要等了开始处理，提高了同时处理IO的能力 select几乎所有操作系统平台都支持，poll是对的select的升级 epoll，Linux系统内核2.5+开始支持，对select和poll的增强，在监视的基础上，增加回调机制。BSD、Mac平台有kqueue，Windows有iocp 以select为例 将关注的IO操作告诉select函数并调用，进程阻塞，内核“监视”select关注的文件描述符fd，被关注的任何一个fd对应的IO准备好了数据，select返回。再使用read将数据复制到用户进程 select举例 食堂供应很多菜（众多的IO），你需要吃某三菜一汤，大师傅（操作系统）说要现做，需要等，你只好等待大师傅叫。其中一样菜好了，大师傅叫你，说你点的菜有好的了，你得自己遍历找找看哪一样才好了，请服务员把做好的菜打给你 epoll是有菜准备好了，大师傅喊你去几号窗口直接打菜，不用自己找菜了 一般情况下，select最多能监听1024个fd（可以修改，但不建议改），但是由于select采用轮询的方式，当管理的IO多了，每次都要遍历全部fd，效率低下epoll没有管理的fd的上限，且是回调机制，不需遍历，效率很高 信号驱动IO进程在IO访问时，先通过sigaction系统调用，提交一个信号处理函数，立即返回。进程不阻塞当内核准备好数据后，产生一个SIGIO信号并投递给信号处理函数。可以在此函数中调用recvfrom函数操作数据从内核空间复制到用户空间，这段过程进程阻塞 异步IO 进程发起异步IO请求，立即返回。内核完成IO的两个阶段，内核给进程发一个信号。 举例 来打饭，跟大师傅说饭好了叫你，饭菜准备好了，窗口服务员把饭盛好了打电话叫你。两阶段都是异步的。在整个过程中，进程都可以忙别的，等好了才过来。 今天不想出去到饭店吃饭了，点外卖，饭菜在饭店做好了（第一阶段），快递员从饭店送到你家门口（第二阶段）。 Linux的aio的系统调用，内核从版本2.6开始支持 前4个都是同步IO，因为核心操作recv函数调用时，进程阻塞直到拿到最终结果为止。 而异步IO进程全程不阻塞]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[web开发]]></title>
    <url>%2Fweb%2FWEB%E5%BC%80%E5%8F%91%2F</url>
    <content type="text"><![CDATA[@toc CS编程CS编程，即客户端、服务器编程 客户端、服务端之间需要使用Socket，约定协议、版本（往往使用的协议是TCP或者UDP），指定地址和端口，就可以通信 客户端、服务端传输数据，数据可以有一定的格式，双方必须先约定好 BS编程BS编程，即Browser、Server开发 Browser浏览器，一种特殊的客户端，支持HTTP(s)协议，能够通过URL向服务端发起请求，等待服务端返回HTML等数据，并在浏览器内可视化展示的程序 Server，支持HTTP(s)协议，能够接受众多客户端发起的HTTP协议请求，经过处理，将HTML等数据返回给浏览器 本质上来说，BS是一种特殊的CS，即客户端必须是一种支持HTTP协议且能解析并渲染HTML的软件，服务端必须是能够接收多客户端HTTP访问的服务器软件 HTTP协议底层基于TCP协议实现 BS开发分为两端开发 客户端开发，或称前端开发。HTML、CSS、JavaScript等 服务端开发，Python有WSGI、Django、Flask、Tornado等 HTTP协议安装httpd可以安装httpd或nginx等服务端服务程序，通过浏览器访问，观察http协议 无状态，有连接和短连接 无状态：指的是服务器无法知道2次请求之间的联系，即使是前后2次同一个浏览器也没有任何数据能够判断出是同一个浏览器的请求。后来可以通过cookie、session来判断 有连接：是因为它基于TCP协议，是面向连接的，需要3次握手、4次断开 短连接：Http 1.1之前，都是一个请求一个连接，而Tcp的连接创建销毁成本高，对服务器有很大的影响。所以，自Http 1.1开始，支持keep-alive，默认也开启，一个连接打开后，会保持一段时间（可设置），浏览器再访问该服务器就使用这个Tcp连接，减轻了服务器压力，提高了效率 协议Http协议是无状态协议 同一个客户端的两次请求之间没有任何关系，从服务器端角度来说，它不知道这两个请求来自同一个客户端URL组成 URL可以说就是地址，uniform resource locator 统一资源定位符，每一个链接指向一个资源供客户端访问schema://host[:port#]/path/.../[;url-params][?query-string][#anchor] 例如，通过下面的URL访问网页http://www.bing.com/pathon/index.html?id=5&amp;name=python 访问静态资源时，通过上面这个URL访问的是网站的某路径下的index.html文件，而这个文件对应磁盘上的真实的文件。就会从磁盘上读取这个文件，并把文件的内容发回浏览器端 scheme 模式、协议http、ftp、https、file、mailto等等 host:portwww.python.org:80 ，80端口是默认端口可以不写。域名会使用DNS解析，域名会解析成IP才能使用。实际上会对解析后返回的IP的TCP的80端口发起访问 /path/to/resourcepath，指向资源的路径 ?key1=value1&amp;key2=value2query string，查询字符串，问号用来和路径分开，后面key=value形式，且使用&amp;符号分割 HTTP消息消息分为Request请求、Response响应 Request：浏览器向服务器发起的请求Response：服务器对客户端请求的响应 请求报文由Header消息报头、Body消息正文组成（可选）请求报文第一行称为请求行 响应报文由Header消息报头、Body消息正文组成（可选）响应报头第一行称为状态行 每一行使用回车和换行符作为结尾 如果有Body部分，Header、Body之间留一行空行 请求报文 请求消息行：请求方法Method 请求路径 协议版本CRLF 请求方法Method 方法 说明 GET 请求获取URL对应的资源 POST 提交数据至服务器端 HEAD 和GET类似，不过不返回响应报文的正文 常见传递信息的方式 GET方法使用Query Stringhttp://www.bing.com/pathon/index.html?id=5&amp;name=python&amp;name=linux通过查询字符串在URL中传递参数，而URL在请求报文的头部的第一行 POST方法提交数据请求时提交的数据是在请求报文的正文Body部分 1234567请求消息如下POST /xxx/yyy?id=5&amp;name=bing HTTP/1.1HOST: 127.0.0.1:9999content-length: 26content-type: application/x-www-form-urlencodedage=5&amp;weight=80&amp;height=170 URL中本身就包含着信息http://www.bing.com/python/student/001 响应报文 响应消息行：协议版本 状态码 消息描述CRLFstatus code状态码 状态码在响应头第一行1234567891011121314151xx 提示信息，表示请求已被成功接收，继续处理2xx 表示正常响应 200 正常返回了网页内容3xx 重定向 301 页面永久性移走，永久重定向。返回新的URL，浏览器会根据返回的url发起新的request请求 302 临时重定向 304 资源未修改，浏览器使用本地缓存4xx 客户端请求错误 404 Not Found，网页找不到，客户端请求的资源有错 400 请求语法错误 401 请求要求身份验证 403 服务器拒绝请求5xx 服务器端错误 500 服务器内部错误 502 上游服务器错误，例如nginx反向代理的时候 Cookie技术 键值对信息 是一种客户端、服务器端传递数据的技术 一般来说cookie信息是在服务器端生成，返回给浏览器端的 浏览器端可以保持这些值，浏览器对同一域发起每一请求时，都会把Cookie信息发给服务器端 服务端收到浏览器端发过来的Cookie，处理这些信息，可以用来判断这次请求是否和之前的请求有关联 曾经Cookie唯一在浏览器端存储数据的手段，目前浏览器端存储数据的方案很多，Cookie正在被淘汰 当服务器收到HTTP请求时，服务器可以在响应头里面添加一个Set-Cookie键值对。浏览器收到响应后通常会保存这些Cookie，之后对该服务器每一次请求中都通过Cookie请求头部将Cookie信息发送给服务器 另外，Cookie的过期时间、域、路径、有效期、适用站点都可以根据需要来指定。可以使用 Set－Cookie: NAME=VALUE；Expires=DATE；Path=PATH；Domain=DOMAIN_NAME；SECURE 例如：12345Set-Cookie:aliyungf_tc=AQAAAJDwJ3Bu8gkAHbrHb4zlNZGw4Y; Path=/; HttpOnlyset-cookie:test_cookie=CheckForPermission; expires=Tue, 19-Mar-2018 15:53:02 GMT; path=/; domain=.doubleclick.netSet-Cookie: BD_HOME=1; path=/ key value说明 Cookie过期 Cookie可以设定过期终止时间，过期后将被浏览器清除如果缺省，Cookie不会持久化，浏览器关闭Cookie消失，称为会话级Cookie Cookie域 域确定有哪些域可以存取这个Cookie缺省设置属性值为当前主机，例如 www.python.org如果设置为 python.org 表示包含子域 Path 确定哪些目录及子目录访问可以使用该Cookie Secure 表示Cookie随着HTTPS加密过得请求发送给服务端有些浏览器已经不允许http://协议使用Secure这个Secure不能保证Cookie是安全的，Cookie中不要传输敏感信息 HttpOnly 将Cookie设置此标记，就不能被JavaScript访问，只能发给服务器端 Set-Cookie: id=a3fWa; Expires=Wed, 21 Oct 2015 07:28:00 GMT; Secure; HttpOnly告诉浏览器端设置这个Cookie的键值对，有过期时间，使用HTTPS加密传输到服务器端，且不能被浏览器中JS脚本访问该Cookie 12345678910Cookie的作用域：Domain和Path定义Cookie的作用域Domaindomain=www.baidu.com 表示只有该域的URL才能使用domain=.baidu.com 表示可以包含子域，例如www.baidu.com 、python.baidu.com 等Pathpath=/ 所有/的子路径可以使用domain=www.baidu.com; path=/webapp 表示只有www.baidu.com/webapp下的URL匹配，例如http://www.baidu.com/webapp/a.html就可以 缺点 Cookie一般明文传输（Secure是加密传输），安全性极差，不要传输敏感数据 有4kB大小限制 每次请求中都会发送Cookie，增加了流量Session技术WEB 服务器端，尤其是动态网页服务端Server，有时需要知道浏览器方是谁，但是HTTP是无状态的，怎么办？ 服务端会为每一次浏览器端第一次访问生成一个SessionID，用来唯一标识该浏览器，通过Set-Cookie发送到浏览器端 浏览器端收到之后并不永久保持这个Cookie，只是会话级的。浏览器访问服务端时，会使用Cookie，也会带上这个SessionID的Cookie值 1Set-Cookie:JSESSIONID=741248A52EEB83DF182009912A4ABD86.Tomcat1; Path=/; HttpOnly 服务端会维持这个SessionID一段时间，如果超时，会清理这些超时没有人访问的SessionID。如果浏览器端发来的SessionID无法在服务端找到，就会自动再次分配新的SessionID，并通过Set-Cookie发送到浏览器端以覆盖原有的存在浏览器中的会话级的SessionID 推荐图书《HTTP权威指南》]]></content>
      <categories>
        <category>web</category>
      </categories>
      <tags>
        <tag>web</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react高阶组件]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E4%B9%8B%E9%AB%98%E9%98%B6%E7%BB%84%E4%BB%B6%2F</url>
    <content type="text"><![CDATA[@toc 高阶组件let Root = props =&gt; &lt;div&gt;{props.schoolName}&lt;/div&gt;;如果要在上例的Root组件进行增强怎么办？例如将Root组件的div外部再加入其它div柯里化这个Wrapper函数1234567891011let Wrapper = function (Component, props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125;;let Root = props =&gt; &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;; 柯里化这个Wrapper函数123456789101112131415161718192021import React from 'react';import ReactDom from 'react-dom';let Wrapper = function (Component) &#123; function _wrapper(props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; ); &#125; return _wrapper;&#125;;let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;;let NewComp = Wrapper(Root) // 返回一个包装后的元素ReactDom.render(&lt;NewComp schoolName="Hello World"/&gt;, document.getElementById('root')); 下面代码本身就是一个无状态组件，内部包裹这一个传入的组件，可以看做增强了传入的组件 传入的组件作为返回的新组件的子组件123456789function _wrapper(props) &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125; 那么上面代码的Wrapper函数可以看做参数是一个组件，返回一个新组件，即高阶组件 简化Wrapper，箭头函数1234567891011let Wrapper = function (Component) &#123; return (props) =&gt; &#123; return ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; ); &#125;;&#125;; 再次变化12345678910let Wrapper = function (Component) &#123; return props =&gt; ( &lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt; );&#125;; 再次变化123456789101112131415import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt;);let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;;let NewComp = Wrapper(Root)ReactDom.render(&lt;NewComp schoolName="Hello World" /&gt;, document.getElementById('root')); 装饰器新版ES 2016中增加了装饰器的支持，因此可以使用装饰器来改造上面的代码12@Wrapper // 这是不对的，装饰器装饰函数或类let Root = props =&gt; &lt;div&gt;Root&lt;/div&gt;; ES 2016的装饰器只能装饰类，所以，将Root改写成类1234567891011121314151617import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component /&gt; &lt;/div&gt;);@Wrapperclass Root extends React.Component &#123; render() &#123; return &lt;div&gt;Root&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 如何让Root也显示出schoolName？1234567891011121314151617import React from 'react';import ReactDom from 'react-dom';let Wrapper = Component =&gt; props =&gt; (&lt;div&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/div&gt;);@Wrapperclass Root extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.schoolName&#125;&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 使用 &lt;Component {...props} /&gt; 相当于给组件增加了属性 带参装饰器想给装饰器函数增加一个id参数1234567891011121314151617181920import React from 'react';import ReactDom from 'react-dom';// 带参装饰器函数let Wrapper = id =&gt; Component =&gt; props =&gt; (&lt;div id=&#123;id&#125;&gt; &#123;props.schoolName&#125; &lt;hr /&gt; &lt;Component &#123;...props&#125; /&gt; &lt;/div&gt;);@Wrapper('wrapper') // 带参class Root extends React.Component &#123; render() &#123; return &lt;div&gt;&#123;this.props.schoolName&#125;&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 通过上面的改写，就得到带参装饰器如果觉得不好接受，可以先写成原始的形式，熟悉了箭头函数语法后，再改成精简的形式]]></content>
      <categories>
        <category>前端框架</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react项目构建]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E9%A1%B9%E7%9B%AE%E6%9E%84%E5%BB%BA%2F</url>
    <content type="text"><![CDATA[@toc 项目依赖安装将项目开发基础文件 react-mobx-starter-master.zip 解压缩，并用这个目录作为项目根目录。在项目根目录中，执行下面的命令，就会自动按照package.json的配置安装依赖模块。$ npm install 或者 $ npm i安装完成后，会生成一个目录 node_modules ，里面是安装的所有依赖的模块 项目整体说明12345678910111213141516171819项目目录结构.├── .babelrc├── .gitignore├── index.html├── jsconfig.json├── LICENSE├── .npmrc├── package.json├── README.md├── src│ ├── App.js│ ├── AppState.js│ ├── index.html│ └── index.js├── node_modules│ ├── ...├── webpack.config.dev.js└── webpack.config.prod.js 配置文件详解package.json$ npm init 产生的文件，里面记录项目信息，所有项目依赖 版本管理可指定到对应的git仓库1234"repository": &#123; "type": "git", "url": "https://192.168.124.135/react-mobx/react-mobx-starter.git"&#125; 项目管理12345"scripts": &#123; "test": "jest", "start": "webpack-dev-server --config webpack.config.dev.js --hot --inline", "build": "rimraf dist &amp;&amp; webpack -p --config webpack.config.prod.js"&#125; start 指定启动webpack的dev server开发用WEB Server主要提供2个功能：静态文件支持、自动刷新和热替换HMR(Hot Module replacement) --hot 启动HMRHRM可以在应用程序运行中替换、添加、删除模块，而无需重载页面，只把变化部分替换掉。不使用HMR则自动刷新会导致这个页面刷新 --inline 默认模式使用HMR的时候建议开启inline模式。热替换时会有消息显示在控制台 build 使用webpack构建打包。对应 $ npm run build 项目依赖 devDependencies 开发时依赖，不会打包到目标文件中。对应 npm install xxx --save-dev例如babel的一些依赖，只是为了帮我们转译代码，没有必要发布到生产环境中 dependencies 运行时依赖，会打包到项目中。对应 npm install xxx --save 开发是依赖1234567891011121314151617181920212223"devDependencies": &#123; "babel-core": "^6.24.1", "babel-jest": "^19.0.0", "babel-loader": "^6.4.1", "babel-plugin-transform-decorators-legacy": "^1.3.4", "babel-plugin-transform-runtime": "^6.23.0", "babel-preset-env": "^1.4.0", "babel-preset-react": "^6.24.1", "babel-preset-stage-0": "^6.24.1", "css-loader": "^0.28.0", "html-webpack-plugin": "^2.28.0", "jest": "^19.0.2", "less": "^2.7.2", "less-loader": "^4.0.3", "react-hot-loader": "^4.3.12", "rimraf": "^2.6.2", "source-map": "^0.5.6", "source-map-loader": "^0.2.1", "style-loader": "^0.16.1", "uglify-js": "^2.8.22", "webpack": "^2.4.1", "webpack-dev-server": "^2.4.2"&#125; 版本号指定 版本号 ，只安装指定版本号的 ~版本号 ，例如 ~1.2.3 表示安装1.2.x中最新版本，不低于1.2.3，但不能安装1.3.x ^版本号 ，例如 ^2.4.1 表示安装2.x.x最新版本不低于2.4.1 latest ，安装最新版本 babel 转译，因为开发用了很多ES6语法。从6.x开始babel拆分成很多插件，需要什么引入什么 babel-core 核心 babel-loader webpack的loader，webpack是基于loader装载器的 babel-preset-xxx 预设的转换插件 babel-plugin-transform-decorators-legacy 下面的课程用到了装饰器，这个插件就是转换装饰器用的 css样式相关的包括： css-loader、less、less-loader、style-loader react-hot-loader react热加载插件，希望改动保存后，直接在页面上直接反馈出来，不需要手动刷新 source-map 文件打包，js会合并或者压缩，没法调试，用它来看js原文件是什么 source-map-loader也需 webpack的 loader webpack 打包工具，2.4.1 发布于2017年4月，当前2.7.0发布于2017年7月 webpack-dev-server 启动一个开发时用的server运行时依赖123456789101112"dependencies": &#123; "antd": "^3.10.9", "axios": "^0.16.1", "babel-polyfill": "^6.23.0", "babel-runtime": "^6.23.0", "mobx": "^4.6.0", "mobx-react": "^5.4.2", "react": "^16.6.3", "react-dom": "^16.6.3", "react-router": "^4.3.1", "react-router-dom": "^4.3.1"&#125; antd 即 ant design，基于react实现，蚂蚁金服开源的react的UI库。做中后台管理非常方便 axios 异步请求支持 polyfill 解决浏览器api不支持的问题。写好polyfill就让你的浏览器支持，帮你抹平差异化 react开发的主框架react-dom 支持DOMreact-router 支持路由react-router-dom DOM绑定路由 mobx 状态管理库，透明化。mobx-react mobx和react结合的模块 react和mobx是一个强强联合 babel配置.babelrc babel转译的配置文件123456789101112&#123; "presets": [ "react", "env", "stage-0" ], "plugins": [ "transform-decorators-legacy", "transform-runtime", "react-hot-loader/babel" ]&#125; webpack配置webpack.config.dev.js这是一个符合Commonjs的模块 module.exports 导出 devtool：’source-map’ 生成及如何生成source-map文件 source-map适合生成环境使用，会生成完成Sourcemap独立文件 由于在Bundle中添加了引用注释，所以开发工具知道如何找到Sourcemap entry入口 描述入口。webpack会从入口开始，找出直接或间接的模块和库构建依赖树，最后输出为bundles文件中 entry如果是一个字符串，定义就是入口文件 如果是一个数组，数组中每一项都会执行，里面包含入口文件，另一个参数可以用来配置一个服务器，我们这里配置的是热加载插件，可以自动刷新 output输出 告诉webpack输出bundles到哪里去，如何命名。 filename定义输出的bundle的名称 path 输出目录是 __dirname+&#39;dist&#39; ，名字叫做 bundle.js 。 __dirname 是nodejs中获取当前js文件所在的目录名 publicPath 可以是绝对路径或者相对路径，一般会以/结尾。/assets/表示网站根目录下assets目录下 resolve解析 设置模块如何被解析。 extensions 自动解析扩展名。&#39;.js&#39;的意思是，如果用户导入模块的时候不带扩展名，它尝试补全 module 模块 如何处理不同的模块 rules 匹配请求的规则，以应用不同的加载器、解析器等 12345678910111213141516171819202122232425module: &#123; rules: [ &#123; test: /\.js$/, exclude: /node_modules/, use: [ &#123; loader: 'babel-loader' &#125; ] &#125;, &#123; test: /\.css$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;, ] &#125;, &#123; test: /\.less$/, use: [ &#123; loader: "style-loader" &#125;, &#123; loader: "css-loader" &#125;, &#123; loader: "less-loader" &#125; ] &#125; ]&#125;, test 匹配条件的exclude 排除的， /node_modules/打包排除目录。这一句一定要有，否则，编译就把这个目录下所有文件也拿进来了，巨大无比use 使用模块的UseEntries列表中的loaderrules中对.js结尾的但不在node_modules目录的文件使用转译babel-loader 加载器：倒着写，先应用数组中的最后一个 style-loader通过 &lt;style&gt; 标签把css添加到DOM中 css-loader 加载css less-loader 对less的支持 LESSCSS好处简单易学，但是坏处是没有模块化、复用的概念，因为它不是语言LESS是一门CSS的预处理语言，扩展了CSS，增加了变量、Mixin、函数等开发语言的特性，从而简化了CSS的编写LESS本身是一套语法规则及解析器，将写好的LESS解析成CSS。LESS可以使用在浏览器端和服务器端12345678@color: #4D926F; #header &#123; color: @color; &#125; h2 &#123; color: @color; &#125; 可以使用解析成如下的CSS123456#header &#123; color: #4D926F; &#125; h2 &#123; color: #4D926F; &#125; LESS在服务器端使用，需要使用LESS编译器， $ npm install less ，本项目目录已经安装过了12345编译输出到控制台$ node_modules/.bin/lessc test.less编译输出到文件$ node_modules/.bin/lessc test.less test.css plugins：webpack的插件1234plugins: [ new webpack.optimize.OccurrenceOrderPlugin(true), new webpack.HotModuleReplacementPlugin(), new webpack.DefinePlugin(&#123;'process.env': &#123;NODE_ENV: JSON.stringify('development')&#125;&#125;) HotModuleReplacementPlugin 开启HMR DefinePlugin 全局常量配置 devServer，开发用server123456789101112131415161718devServer: &#123; compress: true, port: 3000, publicPath: '/assets/', hot: true, inline: true, historyApiFallback: true, stats: &#123; chunks: false &#125;, proxy: &#123; '/api': &#123; target: 'http://127.0.0.1:8000', changeOrigin: true, pathRewrite: &#123;'^/api':''&#125; &#125; &#125;&#125; compress 启动gzip port 启动端口3000 hot 启用HMR proxy指定访问/api 开头URL都代理到 http://127.0.0.1:8000 去vscode配置jsconfig.json是vscode的配置文件，覆盖当前配置 以上是所有配置文件的解释。拿到这个文件夹后，需要修改name项目名称、version版本、description描述，需要修改repository仓库地址，需要修改author作者、license许可证信息。这些信息修改好之后，就可以开始开发了 启动项目在项目根目录，使用$ npm start启动成功应该就可以访问了webpack使用babel转译、打包，较为耗时，需要等一会儿]]></content>
      <categories>
        <category>前端框架</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>前端框架</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库概念]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@toc 概念 数据库按照数据结构来组织、存储、管理数据的仓库 诞生计算机的发明是为了做科学计算的，而科学计算需要大量的数据输入和输出早期，可以使用打孔卡片的孔、灯泡的亮灭来表示数据输入、输出 1940年，数据可以存储在磁带上，顺序的读取、写入磁带。1956年IBM发明了磁盘驱动器这个革命性产品，支持随机访问。随着信息化时代的到来，有了硬件存储技术的发展，有大量的数据需要存储和管理 数据库DBMS发展 萌芽期：文件管理 第一代：层次数据库、网状数据库 第二代：SQL、关系型数据库 第三代：面向对象的DBMS（OODBMS）、对象关系的DBMS（ORDBMS）文件系统管理 磁盘上一个个文件，数据孤立，数据冗余 格式不统一，很难统一管理 无法高效查询，无法灵活查询层次数据库 以树型结构表示实体及其之间的联系。关系只支持一对多 代表数据库IBM IMS网状数据库 通用电气最早在1964年开发出网状数据库IDS，只能运行在GE自家的主机上 结点描述数据，结点的联系就是数据的关系能够直接描述客观世界，可以表示实体间多种复杂关系，而这是层次数据模型无法做到的。比如，一个结点可以有多个父结点，结点之间支持可以多对多关联关系数据库 使用行、列组成的二维表来组织数据和关系，表中行（记录）即可以描述数据实体，也可以描述实体间关系 关系模型比网状模型、层次模型更简单，不需要关系数存储的物理细节，专心于数据的逻辑构建，而且关系模型有论文的严格的数学理论基础支撑![在这里插入图片描述](https://img-blog.csdnimg.cn/2019062111513723.png) 1970年6月，IBM的研究员E.F.Codd发表了名为“A Relational Model of Data for Large Shared Data Banks”的论文，提出了关系模型的概念，奠定了关系模型的理论基础 1976年，IBM实验室System R项目，通过实现数据结构和操作来证明关系模型实用性，并直接产生了结构化查询语言SQL。1987年，SQL被ISO组织标准化 关系模型，有严格的数学基础，抽象级别较高，简单清晰，便于理解和使用 经过几十年的发展，关系数据库百花齐放，技术日臻成熟和完善 基于关系模型构建的数据库系统称为RDBMS(Relational DataBase System) BM DB2、Oracle的Oracle和Mysql、微软的MS SQL。以前的Infomix、Sybase等Oracle的发展 拉里·埃里森(Larry Ellison)仔细阅读了IBM的关系数据库的论文，敏锐意识到在这个研究基础上可以开发商用软件系统。他们几个创始人决定开发通用商用数据库系统Oracle，这个名字来源于他们曾给中央情报局做过的项目名 1979年发布了ORACLE 2.0版本（实际上是1.0）。1983年，Oracle v3。1984年，Oracle v4。1985年，Oraclev5。1988年，Oracle v6引入了行级锁等新技术，然而这是个不稳定的版本。直到1992年的时候，Oracle7才逐渐稳定下来，并取得巨大成功。2001年的9i版本被广泛应用 2009年4月20日，甲骨文公司宣布将以每股9.50美元，总计74亿美金收购SUN（计算机系统）公司。2010年1月成功收购 2013年，甲骨文超过IBM，成为继微软之后的全球第二大软件公司Mysql发展 1985年几个瑞典人为大型零售商的项目设计了一种利用索引顺序存取数据的软件，这就是MyISAM的前身。1996年，MySQL 1.0发布，随后发布了3.11.1版本，并开始往其它平台移植。2000年MySQL采用GPL协议开源 MySQL 4.0开始支持MyISAM、InnoDB引擎。2005年10月，MySQL 5.0成为里程碑版本 2008年1月被Sun公司收购 2009年1月，在Oracle收购MySQL之前，Monty Widenius担心收购，就从MySQL Server 5.5开始一条新的GPL分支，起名MariaDB MySQL的引擎是插件化的，可以支持很多种引擎： MyISASM，不支持事务，插入、查询速度快。 InnoDB，支持事务，行级锁，MySQL 5.5起的默认引擎 去IOE 它是阿里巴巴造出的概念。其本意是，在阿里巴巴的IT架构中，去掉IBM的小型机、Oracle数据库、EMC存储设备，取而代之使用自己在开源软件基础上开发的系统。传统上，一个高端大气的数据中心，IBM小型机、Oracle数据库、EMC存储设备，可以说缺一不可。而使用这些架构的企业，不但采购、维护成本极高，核心架构还掌握在他人手中 对于阿里巴巴这样大规模的互联网应用，应该采用开源、开放的系统架构。这种思路并不是阿里巴巴的新发明，国外的谷歌、Facebook、亚马逊等早已为之。只不过它们几乎一开始就有没有采用IT商业公司的架构，所以他们也不用“去IOE” 去IOE，转而使用廉价的架构，稳定性一定下降，需要较高的运维水平解决NoSQL NoSQL是对非SQL、非传统关系型数据库的统称。 NoSQL一词诞生于1998年，2009年这个词汇被再次提出指非关系型、分布式、不提供ACID的数据库设计模式 随着互联网时代的到来，数据爆发式增长，数据库技术发展日新月异，要适应新的业务需求。 随着移动互联网、物联网的到来，大数据的技术中NoSQL也同样重要 数据库流行度排名 2017.12 数据库流行度排名 2018.6]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库面试题]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F</url>
    <content type="text"><![CDATA[什么是存储过程？有哪些优缺点？存储过程是一些预编译的SQL语句。 更加直白的理解：存储过程可以说是一个记录集，它是由一些T-SQL语句组成的代码块，这些T-SQL语句代码像一个方法一样实现一些功能（对单表或多表的增删改查），然后再给这个代码块取一个名字，在用到这个功能的时候调用他就行了。 存储过程是一个预编译的代码块，执行效率比较高 一个存储过程替代大量T_SQL语句 ，可以降低网络通信量，提高通信速率 可以一定程度上确保数据安全 如果你对存储过程不熟悉，建议阅读：存储过程详解-博客园 索引是什么？有什么作用以及优缺点？索引是对数据库表中一或多个列的值进行排序的结构，是帮助MySQL高效获取数据的数据结构 你也可以这样理解：索引就是加快检索表中数据的方法。数据库的索引类似于书籍的索引。在书籍中，索引允许用户不必翻阅完整个书就能迅速地找到所需要的信息。在数据库中，索引也允许数据库程序迅速地找到表中的数据，而不必扫描整个数据库。 MySQL数据库几个基本的索引类型：普通索引、唯一索引、主键索引、全文索引 索引加快数据库的检索速度 索引降低了插入、删除、修改等维护任务的速度 唯一索引可以确保每一行数据的唯一性 通过使用索引，可以在查询的过程中使用优化隐藏器，提高系统的性能 索引需要占物理和数据空间 如果你对索引还不太熟悉，建议阅读：漫谈数据库索引 什么是事务？事务（Transaction）是并发控制的基本单位。所谓的事务，它是一个操作序列，这些操作要么都执行，要么都不执行，它是一个不可分割的工作单位。事务是数据库维护数据一致性的单位，在每个事务结束时，都能保持数据一致性。 如果你对索引还不太熟悉，建议阅读：数据库事务 - Mr. David 专栏 数据库的乐观锁和悲观锁是什么？数据库管理系统（DBMS）中的并发控制的任务是确保在多个事务同时存取数据库中同一数据时不破坏事务的隔离性和统一性以及数据库的统一性。 乐观并发控制(乐观锁)和悲观并发控制（悲观锁）是并发控制主要采用的技术手段。 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性。 如果你对两种锁还不太熟悉，建议阅读：深入理解乐观锁与悲观锁 使用索引查询一定能提高查询的性能吗？为什么通常,通过索引查询数据比全表扫描要快.但是我们也必须注意到它的代价. 索引需要空间来存储,也需要定期维护, 每当有记录在表中增减或索引列被修改时,索引本身也会被修改. 这意味着每条记录的INSERT,DELETE,UPDATE将为此多付出4,5 次的磁盘I/O. 因为索引需要额外的存储空间和处理,那些不必要的索引反而会使查询反应时间变慢.使用索引查询不一定能提高查询性能,索引范围查询(INDEX RANGE SCAN)适用于两种情况: 基于一个范围的检索,一般查询返回结果集小于表中记录数的30% 基于非唯一性索引的检索 简单说一说drop、delete与truncate的区别SQL中的drop、delete、truncate都表示删除，但是三者有一些差别 delete和truncate只删除表的数据不删除表的结构 速度,一般来说: drop&gt; truncate &gt;delete delete语句是dml,这个操作会放到rollback segement中,事务提交之后才生效;如果有相应的trigger,执行的时候将被触发. truncate,drop是ddl, 操作立即生效,原数据不放到rollback segment中,不能回滚. 操作不触发trigger. 如果你对这三者的用法还不太熟悉，建议阅读： drop、truncate和delete的区别 drop、delete与truncate分别在什么场景之下使用？ 不再需要一张表的时候，用drop 想删除部分数据行时候，用delete，并且带上where子句 保留表而删除所有数据的时候用truncate 超键、候选键、主键、外键分别是什么？超键：在关系中能唯一标识元组的属性集称为关系模式的超键。一个属性可以为作为一个超键，多个属性组合在一起也可以作为一个超键。超键包含候选键和主键。 候选键：是最小超键，即没有冗余元素的超键。 主键：数据库表中对储存数据对象予以唯一和完整标识的数据列或属性的组合。一个数据列只能有一个主键，且主键的取值不能缺失，即不能为空值（Null）。 外键：在一个表中存在的另一个表的主键称此表的外键。 什么是视图？以及视图的使用场景有哪些？视图是一种虚拟的表，具有和物理表相同的功能。可以对视图进行增，改，查，操作，试图通常是有一个表或者多个表的行或列的子集。对视图的修改不影响基本表。它使得我们获取数据更容易，相比多表查询。 只暴露部分字段给访问者，所以就建一个虚表，就是视图。 查询的数据来源于不同的表，而查询者希望以统一的方式查询，这样也可以建立一个视图，把多个表查询结果联合起来，查询者只需要直接从视图中获取数据，不必考虑数据来源于不同表所带来的差异 说一说三个范式。第一范式（1NF）：数据库表中的字段都是单一属性的，不可再分。这个单一属性由基本类型构成，包括整型、实数、字符型、逻辑型、日期型等。 第二范式（2NF）：数据库表中不存在非关键字段对任一候选关键字段的部分函数依赖（部分函数依赖指的是存在组合关键字中的某些字段决定非关键字段的情况），也即所有非关键字段都完全依赖于任意一组候选关键字。 什么是数据库？数据库(database)保存有组织的数据的容器(通常是一个文件或一组文件). 确切的说, 数据库软件应称为DBMS(数据库管理系统).数据库是通过DBMS创建和操纵的容器.数据库可以是保存在硬设备上的文件,但也可以不是.你使用的DBMS,它替你访问数据库. 在你将资料放入自己的文件柜中, 并不是随便将他们扔进某个抽屉就完事了， 而是在文件柜中创建文件，然后将相关的资料放入特定的文件中。 在数据库领域中， 这种文件称为表，表是一种结构化的文件，可用来存储某种特定类型的数据。表可以保存顾客清单，产品目录，或者其他信息清单。 表某种特定类型数据的结构化清单。列（column）表中的一个字段]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[WSGI]]></title>
    <url>%2F%E5%90%8E%E7%AB%AF%E6%A1%86%E6%9E%B6%2FWSGI%20%2F</url>
    <content type="text"><![CDATA[WSGI（Web Server Gateway Interface）主要规定了服务器端和应用程序间的接口 WSGI服务器——wsgiref wsgiref是Python提供的一个WSGI参考实现库，不适合生产环境使用 wsgiref.simple_server 模块实现一个简单的WSGI HTTP服务器 123456from wsgiref.simple_server import make_server,demo_appip = '127.0.0.1'port = 9999server = make_server(ip, port, demo_app) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 查看demo_app源码 12345678910def demo_app(environ,start_response): from io import StringIO stdout = StringIO() print("Hello world!", file=stdout) print(file=stdout) h = sorted(environ.items()) for k,v in h: print(k,'=',repr(v), file=stdout) start_response("200 OK", [('Content-Type','text/plain; charset=utf-8')]) return [stdout.getvalue().encode("utf-8")] StringIO 在内存中读写str print(&quot;Hello world!&quot;, file=stdout)将Hello world!内容写入内存中 start_response 构造head getvalue 把缓冲区的内容全部读取出来，内容必须为btyesWSGI服务器作用 监听HTTP服务端口（TCPServer，默认端口80） 接收浏览器端的HTTP请求并解析封装成environ环境数据 负责调用应用程序，将environ数据和start_response方法两个实参传入给Application 将应用程序响应的正文封装成HTTP响应报文返回浏览器端 所有头和内容都是由server来封装WSGI APP应用程序端 应用程序应该是一个可调用对象Python中应该是函数、类、实现了 __call__ 方法的类的实例 这个可调用对象应该接收两个参数1. 函数实现123456789101112from wsgiref.simple_server import make_serverreturn_res = b'Hello World'def application(environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application) # demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 2. 类实现1234567891011121314151617from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __init__(self, environ, start_response): self.env = environ self.sr = start_response def __iter__(self): # 对象可迭代 self.sr("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) yield return_resip = '127.0.0.1'port = 9999server = make_server(ip, port, Application) # Demo_app应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 3. 类实现，可调用对象1234567891011121314from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [('Content-Type', 'text/plain; charset=utf-8')]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application(e,s)server.serve_forever() # server.handle_request() 执行一次 environ和start_response这两个参数名可以是任何合法名，但是一般默认都是这2个名字 应用程序端还有些其他的规定，暂不用关心 注意：第2、第3种实现调用时的不同 自定义 返回头一般自定义习惯用‘X’开头12345678910111213141516from wsgiref.simple_server import make_serverreturn_res = b'Hello World'class Application: def __call__(self, environ, start_response): start_response("200 OK", [ ('Content-Type', 'text/plain; charset=utf-8'), ('X-Server', 'MyDemo_app') ]) return [return_res]ip = '127.0.0.1'port = 9999server = make_server(ip, port, Application()) # Application应用程序，可调用server.serve_forever() # server.handle_request() 执行一次 environenviron是包含Http请求信息的dict字典对象| 名称 | 含义 ||:–|:–||REQUEST_METHOD |请求方法，GET、POST等||PATH_INFO| URL中的路径部分||QUERY_STRING| 查询字符串||SERVER_NAME, SERVER_PORT| 服务器名、端口||HTTP_HOST| 地址和端口||SERVER_PROTOCOL |协议||HTTP_USER_AGENT| UserAgent信息| 12345678910111213CONTENT_TYPE = &apos;text/plain&apos;HTTP_HOST = &apos;127.0.0.1:9999&apos;HTTP_USER_AGENT = &apos;Mozilla/5.0 (Windows; U; Windows NT 6.1; zh-CN) AppleWebKit/537.36 (KHTML, like Gecko) Version/5.0.1 Safari/537.36&apos;PATH_INFO = &apos;/&apos;QUERY_STRING = &apos;&apos;REMOTE_ADDR = &apos;127.0.0.1&apos;REMOTE_HOST = &apos;&apos;REQUEST_METHOD = &apos;GET&apos;SERVER_NAME = &apos;DESKTOP-D34H5HF&apos;SERVER_PORT = &apos;9999&apos;SERVER_PROTOCOL = &apos;HTTP/1.1&apos;SERVER_SOFTWARE = &apos;WSGIServer/0.2&apos; start_response它是一个可调用对象。有3个参数，定义如下：start_response(status, response_headers, exc_info=None)|参数名称 |说明||:–|:–||status |状态码和状态描述，例如 200 OK||response_headers |一个元素为二元组的列表例如[(&#39;Content-Type&#39;, &#39;text/plain;charset=utf-8&#39;)]||exc_info |在错误处理的时候使用|start_response应该在返回可迭代对象之前调用，因为它返回的是Response Header。返回的可迭代对象是Response Body 服务器端服务器程序需要调用符合上述定义的可调用对象APP，传入environ、start_response，APP处理后，返回响应头和可迭代对象的正文，由服务器封装返回浏览器端 返回网页的例子1234567891011121314from wsgiref.simple_server import make_serverdef application(environ, start_response): status = '200 OK' headers = [('Content-Type', 'text/html;charset=utf-8')] start_response(status, headers) # 返回可迭代对象 html = '&lt;h1&gt;Hello World&lt;/h1&gt;'.encode("utf-8") return [html]ip = '127.0.0.1'port = 9999server = make_server(ip, port, application)server.serve_forever() # server.handle_request() 执行一次 simple_server 只是参考用，不能用于生产环境 Linux 测试用命令12$ curl -I http://192.168.142.1:9999/xxx?id=5$ curl -X POST http://192.168.142.1:9999/yyy -d &apos;&#123;&quot;x&quot;:2&#125;&apos; -I 使用HEAD方法 -X 指定方法，-d传输数据 到这里就完成了一个简单的WEB 程序开发 WSGI WEB服务器 本质上就是一个TCP服务器，监听在特定端口上 支持HTTP协议，能够将HTTP请求报文进行解析，能够把响应数据进行HTTP协议的报文封装并返回浏览器端 实现了WSGI协议，该协议约定了和应用程序之间接口（参看PEP333，https://www.python.org/dev/peps/pep-0333/ ）WSGI APP应用程序 遵从WSGI协议 本身是一个可调用对象 调用start_response，返回响应头部 返回包含正文的可迭代对象 WSGI 框架库往往可以看做增强的更加复杂的Application]]></content>
      <categories>
        <category>后端框架</category>
      </categories>
      <tags>
        <tag>后端</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[html]]></title>
    <url>%2Fjs%2FHTML%2F</url>
    <content type="text"><![CDATA[@toc1234567891011121314151617&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt; &lt;meta http-equiv="X-UA-Compatible" content="ie=edge"&gt; &lt;title&gt;Document&lt;/title&gt;&lt;/head&gt;&lt;body&gt; &lt;p&gt;这是分段&lt;/p&gt; &lt;h1&gt;这是标题&lt;/h1&gt; &lt;div&gt;&lt;a href="http://www.baidu.com"&gt;这是链接&lt;/a&gt;&lt;/div&gt; &lt;div id="logo" class="logo"&gt; &lt;img src="http://www.baidu.com/wp-content/uploads/2018/12/2018122312035677.png"&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; HTML（超文本标记语言——HyperText Markup Language），它使用标签来定义文本的显示方式。简单来说，HTML就是一种文本文件，里面的内容超出一般文本文件表示，它是用来控制显示格式和对内容进行排版的。 1997年W3C发布HTML 4.0。 2014年发布HTML5 标签12&lt;p&gt;这是分段&lt;/p&gt;&lt;h1&gt;这是大标题&lt;/h1&gt; 如上， &lt;p&gt; 中的p就是标签，且是开始标签， &lt;/p&gt; 是结束标签。开始、结束标签和内容组成完整的元素&lt;p&gt; 标签，它的作用范围是下一个和它层次对应的结束标签 &lt;/p&gt;1&lt;a href="www.baidu.com" target="_blank"&gt;这是链接&lt;/a&gt; href和target是标签的属性 &lt;p /&gt; 空元素可以在开始标签中关闭，也可以 &lt;p&gt;&lt;/p&gt; 。由于p标签是容器标签，在 &lt;p&gt;&lt;/p&gt; 中间可以插入其它标签在HTML中使用单独标签，例如 &lt;br&gt; &lt;hr&gt; &lt;img&gt; 等。它们中就不能插入其它标签标签名可以使用大小写，但是推荐使用小写标签会被解析成一个有层次的DOM树，不要出现标签交错的现象，这是错误的，但是浏览器有容错能力，但是可能显示的格式就不对了 HTML文档结构 文档声明： &lt;!DOCTYPE html&gt; 声明文档类型，这是Html5的声明方式。早期的文档声明很长，规定了HTML遵从的规范，能自动检查错误等 根标签：html标签是根标签 头部：head标签就是头部，一般不是用来显示 内部可以写meta信息、title网页标题、script脚本、样式表等标签 &lt;meta charset=&quot;utf-8&quot;&gt; 定义网页编码格式为utf-8。浏览器会按照这个编码显示字符 正文：body标签才是浏览器显示的正文部分 alt + shift + f 对齐 常用标签链接1&lt;a href="http://www.baidu.com" target="_blank" onclick="alert('anchor')"&gt;这是链接&lt;/a&gt; href属性，指定链接，资源定位符默认 self 打开一个新标签，打开一个新页面，_blank，超链接是最常使用的 target属性，指定是否在本窗口中打开。_blank就是指新窗口打开链接 onclick是点击事件，等号后面往往写一个js函数或脚本执行。很多HTML标签都支持很多事件属性，常见有onclick、ondblclick、onkeydown、onkeyup、onkeypress、onmousedown、onmousemove、onmouseover、onsubmit、onchange等等。后面写的函数称作事件响应函数或事件回调函数。 链接，锚点，定位本页面中资源，还可以定位另一个页面的资源href=“#test” 锚点，前面一定要加# ，在地址栏网页后加#test 123456// 锚点使用&lt;body&gt; &lt;h1&gt;这是最大的标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;div&gt; style="backgroud-color: #f0f0f0"&gt;&lt;a href="#test" target="_blank"&gt;anchor&lt;/a&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt; 默认情况下，超链接点击后会发起一个HTTP GET请求 12345&lt;body&gt; &lt;h1&gt;这是最大的标题&lt;/h1&gt; &lt;p&gt;这是段落&lt;/p&gt; &lt;div&gt; style="backgroud-color: #f0f0f0"&gt;&lt;a href="http://www.baidu.com" target="_blank"&gt;anchor&lt;/a&gt;&lt;/a&gt;&lt;/div&gt;&lt;/body&gt; 一般连接内部直接写内容,也可以放图片 如果需要访问超链接，需要加http:// 不然会当做文件访问，跳转相对路径url index.html 静态页面,更快 如果一个都找不到 会抛404错误,配置错误 .. 上一层的图片1&lt;img src="http://www.baidu.com/wp-content/uploads/2018/12/2018122312035677.png"&gt; 图片标签，src指定图片路径注意，图片会发起一个HTTP GET请求如果去掉http:// 为相对路径直接发起请求 标题&lt;h1&gt;~&lt;h6&gt; ，标题标签，默认h1字体最大，h6字体最小 图层1&lt;div id="logo" class="logo"&gt;&lt;/div&gt; id属性，非常重要，标签的唯一标识 class属性，非常重要，样式表定位并附加样式 &lt;div&gt; 标签，目前该标签加上CSS，被广泛用于网页布局中 script http请求，200 是OK，找不到 404错误 列表 无序列表无符号的默认样子1234&lt;ul&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ul&gt; 有序列表1234&lt;ol&gt; &lt;li&gt;Coffee&lt;/li&gt; &lt;li&gt;Milk&lt;/li&gt;&lt;/ol&gt; 表格登录使用 div报表展示 table HTML 表格的基本结构： &lt;table&gt;…&lt;/table&gt;：定义表格 &lt;tr&gt;…&lt;/tr&gt;：定义表格的行 &lt;th&gt;…&lt;/th&gt;：定义表格的标题列（文字加粗），一般不用 &lt;td&gt;…&lt;/td&gt;：定义表格的列不过th现在用的少了，表格表头是否字体加粗，都用css控制。所以表中有tr表示行，td表示格子 &lt;br&gt; 换行&lt;hr&gt; 分割线&amp;nbsp; 空格12345678910111213&lt;table border="1"&gt; &lt;tr&gt; &lt;th&gt;1,1&lt;/th&gt; &lt;th&gt;1,2&lt;/th&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;2,1&lt;/td&gt; &lt;td&gt;2,2&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt;占2列&lt;/td&gt; &lt;/tr&gt;&lt;/table&gt; path 路径windows 会先搜索当前工作路径,在搜索path路径linux 需要加 ./ 表单12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455&lt;!DOCTYPE html&gt;&lt;html lang="en"&gt;&lt;head&gt; &lt;meta charset="UTF-8"&gt; &lt;title&gt;helloword html&lt;/title&gt; &lt;script src="jquery.min.js"&gt;&lt;/script&gt; &lt;style&gt; td &#123; padding: 5px &#125; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;form action="" method="POST" enctype="application/x-www-form-urlencoded"&gt; &lt;table border="1" style="border-collapse: collapse"&gt; &lt;tr&gt; &lt;td colspan="2"&gt;用户注册&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;/td&gt; &lt;td&gt;&lt;input type="text" placeholder="用户名"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input type="password" name="password" id="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt; &lt;input type="radio" name="gender" id="gender" checked value="M"&gt;男 &lt;input type="radio" name="gender" id="gender" value="F"&gt;女 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input type="checkbox" name="interest" id="interest" value="music"&gt;音乐 &lt;input type="checkbox" name="interest" id="interest" checked value="movie"&gt; 电影 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input type="submit" value="提交"&gt; &lt;input type="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/body&gt;&lt;/html&gt; 特别注意：表单控件如果要提交数据，必须使用name属性，否则不能提交到服务端 form标签的重要属性 action，表单数据submit提交到哪里 method，提交的方法，常用POST enctype，对提交的数据编码 application/x-www-form-urlencoded，在发送前编码所有字符（默认） 空格转换为 “+” 加号，特殊符号转换为 ASCII HEX 值 multipart/form-data，不对字符编码。在使用包含文件上传控件的表单时，必须使用该值 text/plain，空格转换为 “+” 加号，但不对特殊字符编码 form标签方法有 get post get 我要这个资源你给我，get 只有 head post 提交数据,返回数据 ,常用于表单 GET方法 /test.html 请求路径 HTTP/1.1 请求协议 Host: 127.0.0.1 请求主机 keep-alive 留一段时间URL= 路径 + 协议 + 主机 304 用网页本地缓存 referer 基于某个页面 get 方法请求 以问号开头，使用谁and谁方式 ID给JS用的 name是提交用的，没有name就没有资格提交]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>html</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[linux特殊进程]]></title>
    <url>%2Flinux%2FLinux%E4%B8%AD%E7%9A%84%E7%89%B9%E6%AE%8A%E8%BF%9B%E7%A8%8B%2F</url>
    <content type="text"><![CDATA[Linux中的特殊进程 在Linux/Unix中，通过父进程创建子进程僵尸进程 一个进程使用了fork创建了子进程，如果子进程终止进入僵死状态，而父进程并没有调用wait或者waitpid获取子进程的状态信息，那么子进程仍留下一个数据结构保存在系统中，这种进程称为僵尸进程 僵尸进程会占用一定的内存空间，还占用了进程号，所以一定要避免大量的僵尸进程产生。有很多方法可以避免僵尸进程孤儿进程 父进程退出，而它的子进程仍在运行，那么这些子进程就会成为孤儿进程。孤儿进程会被init进程（进程号为1）收养，并由init进程对它们完成状态收集工作 init进程会循环调用wait这些孤儿进程，所以，孤儿进程没有什么危害守护进程 它是运行在后台的一种特殊进程。它独立于控制终端并周期性执行某种任务或等待处理某些事件 守护进程的父进程是init进程，因为其父进程已经故意被终止掉了 守护进程相对于普通的孤儿进程需要做一些特殊处理]]></content>
      <categories>
        <category>linux</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-控制语句]]></title>
    <url>%2Fjs%2FJS%E8%AF%AD%E6%B3%95%20--%20%E6%8E%A7%E5%88%B6%E8%AF%AD%E5%8F%A5%2F</url>
    <content type="text"><![CDATA[@toc 语句块JS使用大括号构成语句块。ES6 之前语句块是没有作用域的，从ES6开始支持 块作用域 ，let只能在块作用域内可见123456789101112131415161718192021222324252627282930313233function hello()&#123; let a = 1; var b = 2; c = 3&#125;if (1)&#123; let d = 4; var e = 5; f = 6 if (true)&#123; console.log(d) // 可见 console.log(e) // 可见 console.log(f) // 可见 console.log('----------') g = 10 var h = 11 &#125;&#125;// console.log(a) 不可见// console.log(b) 不可见// console.log(c) 不可见，函数为执行hello()console.log(c) // 块作用域隐式声明，可见// console.log(d) // 块作用域使用let，不可见;但是块外的d可见console.log(e)) // 块作用域使用var，可见console.log(f)) // 块作用域隐式声明，可见console.log(g)) // 可见console.log(h)) // 可见 let 不能突破函数、{ } 块作用域 var 不能突破函数作用域 c = 3 隐式申明，为全局作用域流程控制条件分支123456789101112if (cond1)&#123;&#125;else if (cond2) &#123;&#125;else if (cond3) &#123;&#125;else &#123;&#125; 123456789条件的False等效 false undefined null 0 NaN 空字符串 其它值都将被视为True switch…case分支语句 当进入case语句后，如果没有break语句，会产生穿透现象 一直穿透到break语句结束 如果一直没有，将把代码执行完 12345678910111213switch (expression) &#123; case label_1: statements_1 [break;] case label_2: statements_2 [break;] ... default: statements_def [break;]&#125; 穿透问题，一定要在case中恰当的使用break语句，否则就会继续顺序向下执行 1234567891011121314151617181920212223242526let x = 5 // 换成1试一试switch (x) &#123; case 0: console.log('zero') break; case 1: console.log('one'); case 2: console.log('two'); case 3: console.log('three'); break; case 5: case 4: console.log('four'); default: console.log('other') // break;&#125;// 执行结果fourother// 如果x = 2，执行结果为twothree for循环12345// C风格for循环for ([initialExpression]; [condition]; [incrementExpression])&#123; statement&#125; 12345678910111213141516171819202122232425262728293031for (let i=0;i&lt;5;i++)&#123; console.log(i)&#125;console.log('-'.repeat(30))for (var x=0,y=9;x&lt;5;x++,y--)&#123; console.log(x*y)&#125;console.log('-'.repeat(30))for (let i=0;i&lt;10;i+=3)&#123; // 步长 console.log(i) &#125;// 执行结果01234------------------------------08141820------------------------------0369 九九乘法表12345678for (let i=1;i&lt;10;i++)&#123; line = '' for (let j=1;j&lt;=i;j++)&#123; line += j + '*' + i + '=' + j*i + ' ' // line += `$&#123;j&#125;*$&#123;i&#125;=$&#123;i*j?'t':'f'&#125; ` &#125; console.log(line)&#125; while循环 和 do…while循环 条件满足，进入循环，条件为真，继续循环 12while (condition) statement 先进入do语句循环，然后判断，为真就继续循环 123do statementwhile (condition); 123456789101112131415161718192021222324let x = 5while (x--)&#123; console.log(x);&#125;console.log('~~~~~~~~~~')do &#123; console.log(x)&#125;while(x++&lt;5)// 执行结果43210~~~~~~~~~~-1012345 for…in循环对象操作语句for...in用来遍历对象的属性123for (variable in object) &#123; statements&#125; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061// 数组let arr = [10, 20, 30, 40];console.log(arr[1]) // 20for (let x in arr)&#123; console.log(x); // 返回索引&#125;for (let index in arr)&#123; console.log(`$&#123;index&#125; : $&#123;arr[index]&#125;`); //插值&#125;// C风格for(let i=0;i&lt;arr.length;i++)&#123; console.log(arr[i]);&#125;// 对象let obj = &#123; a:1, b:'hello', c:true&#125;;console.log(obj.a);console.log(obj['b']); // 对象属性当索引访问console.log(obj.d); // undefinedconsole.log('~~~~~')for (let x in obj)&#123; console.log(x); // 属性名&#125;for (let key in obj)&#123; // 返回数组的index console.log(`$&#123;key&#125; : $&#123;obj[key]&#125;`);&#125;// 执行结果2001230 : 101 : 202 : 303 : 40102030401helloundefined~~~~~abca : 1b : helloc : true for in 循环返回的是索引或者key，需要间接访问到值 *数组8反正返回的是索引，C风格for循环操作可能方便点 对象用for in合适 for…of 循环ES6的新语法123456789101112131415161718192021let arr = [1, 2, 3, 4, 5]let obj =&#123; a:1, b:'hello', c:true&#125;for (let i of arr)&#123; //返回数组元素 console.log(i)&#125;//执行结果12345for (let i of obj)&#123; // 异常，不可以迭代 console.log(i)&#125; 注意 for ... of 不能迭代一个普通对象 原因是，of后面必须是一个迭代器（TypeError: obj[Symbol.iterator] is not a function） 可类比python中的for in，例如for x in [ ]break 、 continue break 结束当前循环 continue 中断当前循环，直接进入下一次循环for迭代的差别123456789101112131415161718192021222324function sum(arr)&#123; for (let x in arr)&#123; // 遍历index或对象属性 console.log(x, typeof(x), arr[x]); &#125; for (let x of arr)&#123; // 遍历元素 console.log(x, typeof(x)); &#125; for (let x=0;x&lt;arr.length;x++)&#123; // 自己定义索引数值遍历 console.log(x, typeof(x), arr[x]); &#125;&#125;sum([3,6,9]); // 执行结果0 string 31 string 62 string 93 'number'6 'number'9 'number'0 'number' 31 'number' 62 'number' 9 Symbols类型 ES6提供Symbol类型，内建原生类型 symbol值是唯一的1234let sym1 =Symbol()let sym2 = Symbol('key1')let sym3 = Symbol('key2')console.log(sym2 == sym3) //false 作为对象的属性key1234567891011121314151617let s = Symbol()let t = 'abc'let a = &#123; [s]:'xyz', // symbol做key，注意要使用中括号，这个key一定唯一 t:'tt', [t]:'oo'&#125;console.log(a)console.log(a[s])a[s] = 2000console.log(a[s])// 执行结果&#123; t: 'tt', abc: 'oo', [Symbol()]: 'xyz' &#125;xyz2000 构建常量 以前的用法 123456var COLOR_RED = 'RED';var COLOR_ORANGE = 'ORANGE';var COLOR_YELLOW = 'YELLOW';var COLOR_GREEN = 'GREEN';var COLOR_BLUE = 'BLUE';var COLOR_VIOLET = 'VIOLET'; 现在的用法 123456const COLOR_RED = Symbol();const COLOR_ORANGE = Symbol();const COLOR_YELLOW = Symbol();const COLOR_GREEN = Symbol();const COLOR_BLUE = Symbol();const COLOR_VIOLET = Symbol();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[node.js]]></title>
    <url>%2Fjs%2FNodejs%20--%20ES6%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83%E5%87%86%E5%A4%87%E5%8F%8A%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95%2F</url>
    <content type="text"><![CDATA[@[toc] NodejsNodejs是服务器端运行JavaScript的开源、跨平台运行环境Nodejs原始作者瑞安·达尔（Ryan Dahl），于2009年发布，使用了V8引擎，并采用事件驱动、非阻塞、异步IO模型 2010年，npm软件包管理器诞生，通过它，可以方便的发布、分享Nodejs的库和源代码 Nodejs 4.0引入了ES6语言特性 安装 国内可以去阿里云镜像站https://npm.taobao.org/mirrors/node Linuxhttps://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-linux-x64.tar.xz解压即可运行 windowshttps://npm.taobao.org/mirrors/node/latest-v10.x/node-v10.16.0-x64.msi 10版本 长期支持版本 11、12 临时版本 10.16.x是LTS msi安装会增加path路径全局安装目录 C:\Program Files\nodejs\本用户目录 C:\Users\Administrator\AppData\Roaming\npm$ node -v 查看版本开发文档搜索MDN，Mozilla Developer Network，提供非常完善HTML、CSS、JS等的技术资料。https://developer.mozilla.org/zh-CN/docs/Web/JavaScript 指南 https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide 非常好的JS文档使用任何一种文本编辑器，都可以开发JS，此次使用微软的Visual Studio Code进行开发 Visual Studio Code下载 https://code.visualstudio.com/Download支持windows、mac、Linux平台新版VS Code Windows版分为System 和 User两个版本，当前用户使用安装User版即可 有代码自动完成功能，还可以安装Node exec插件，将写的js跑在nodejs上Node Exec插件快捷键：F8运行js脚本，F9停止前端开发中，JS脚本一般来说是为了控制浏览器的网页的，这里使用了VSCode，只是为了开发调试方便 解决快捷键冲突F8和某些软件冲突，无法使用，例如某些词典软件可以通过调整VSCode的快捷键设置。当然可以修改其他软件的快捷键 设定 工作目录 创建文件 注释console.log() 输出到控制台，类似于python的print() 和C、Java一样 // 单行注释 /* 注释 */ 多行注释，也可以用在语句中常量和变量标识符标识符必须是字母、下划线、美元符号$和数字，但必须是字母、下划线、美元符号开头，依然是不能数字开头就行标识符区分大小写声明 var 声明一个变量，不能突破函数作用域 let 声明一个块作用域中的局部变量，小范围使用，不能突破大括号作用域，更加不能突破函数作用域 const 声明一个常量常量不允许改变, 常量不能分开写，必须立即赋值 JS中的变量声明和初始化是可以分开的123456789101112var a // 只是声明，a为undefinedlet bconsole.log(1,a,b)a = 1b = 'a string'console.log(2,a,b)//const c // 不可以const c = 100 // 常量必须声明时赋值，之后不能再改console.log(c)//c = 200 // 不可以更改 var y只是声明，y值为undefined var x = 5规范的声明并初始化，声明全局或局部变量。 z = 6不规范的初始化，不推荐。在严格模式下会产生异常。在赋值之前不能引用，因为它没有声明。一旦这样赋值就是全局作用域函数1234567891011function hello()&#123; var a // 只是声明，a为undefined，作用域在函数中 a = 100&#125;console.log(a) // 未声明变量a，异常//a = 200 // 不能声明提升//let a = 200 // 不能声明提升//var a = 200; hello(); // var声明提升hoisting var 可以声明提升 相当于放在console.log()前面 没有赋值打印的是 undefined 如果变量在console.log()后，没有var 会报nameError1234var aconsole.log(a) // undefineda = 100console.log(a) // 100 常量和变量的选择如果明确知道一个标识符定义后不再修改，应该尽量声明成const常量，减少被修改的风险，减少Bug 数据类型 名称 说明 number 数值型，包括整型和浮点型 boolean 布尔型，true和false string 字符串。需用单双引号、反引号 null 只有一个值null undefined 变量声明未赋值的；对象未定义的属性 symbol ES6 新引入类型 object类型 是以上基本类型的复合类型，是容器 ES是动态语言，弱类型语言 动态语言：变量使用时无需事先声明类型 弱类型语言：字符串加整型，不报错就是弱类型console.log(&#39;a&#39; + 1) // a1 虽然先声明了变量，但是变量可以重新赋值任何类型 对象的定义1234567891011let a = &#123;a:100&#125;console.log(a.a) // 100b = 200let c = &#123;b&#125;console.log(c.b) // 200d = 1000e = 2000let f = &#123;d, e&#125;console.log(f) // &#123; d: 1000, e: 2000 &#125; 类型转换字符串1234console.log(a = 3 + 'hello', typeof(a)) // 3hello stringconsole.log(a = null + 'hello', typeof(a)) // nullhello stringconsole.log(a = undefined + 'hello', typeof(a)) // undefinedhello stringconsole.log(a = true + 'hello', typeof(a)) // truehello string python的 typy(str) 返回的是class js的 typeof(str) 返回的是str数字1234console.log(a = null + 8, typeof(a)) // 8 'number'console.log(a = undefined + 8, typeof(a)) // NaN 'number'console.log(a = true + 8, typeof(a)) // 9 'number'console.log(a = false + 8, typeof(a)) // 8 'number' NaN ： not a number不是一个数字，但是他是数字类型 undefined 没法转换成一个对应的数字 null = 0 true = 1 false = 0boolean123456console.log(a = null + true, typeof(a)) // 1 'number'console.log(a = null + false, typeof(a)) // 0 'number'console.log(a = undefined + true, typeof(a)) // NaN 'number'console.log(a = undefined + false, typeof(a)) // NaN 'number'console.log(a = null &amp; true, typeof(a)) // 0 'number'console.log(a = undefined &amp; true, typeof(a)) // 0 'number' 短路12345console.log(a = null &amp;&amp; true, typeof(a)) // null 'object'console.log(a = false &amp;&amp; null, typeof(a)) // false 'boolean'console.log(a = false &amp;&amp; 'hello', typeof(a)) // false 'boolean'console.log(a = true &amp;&amp; 'hello', typeof(a)) // hello stringconsole.log(a = true &amp;&amp; '', typeof(a)) // string 解析： 第一个：逻辑运算符，null 直接就是false短路 第二个：逻辑运算符，false短路返回false 第三个：boolean 第三个：字符串 第五个：返回的是空字符串，看不见。 null1console.log(a = null + undefined, typeof(a)) // NaN 'number' 弱类型，不需要强制类型转换，会隐式类型转换。 NaN，即Not a Number，转换数字失败。它和任何值都不等，和自己也不等，只能使用Number.isNaN(NaN) &amp;&amp; and|| or&amp; 位与 | 位或 总结： 遇到字符串，加号就是拼接字符串，所有非字符串隐式转换为字符串。 如果没有字符串，加号把其他所有类型都当数字处理，非数字类型隐式转换为数字。undefined特殊，因为它都没有定义值，所以转换数字失败得到一个特殊值NaN。 如果运算符是逻辑运算符，短路符，返回就是短路时的类型。没有隐式转换。 除非你十分明确，否则不要依赖隐式转换。写代码的时候，往往为了程序的健壮，请显式转换。注意： 以上的原则不要死记，忘了就实验，或者显式的类型转换 字符串将一个值使用’ 单引号或者 “双引号 引用起来就是字符串ES6提供了反引号定义一个字符串，可以支持多行，还支持插值123456789101112131415161718let a = 'abc'let b = "135"let c = `line1line2line3` // 支持多行console.log(c)// 字符串插值,要求在反引号字符串中.python3.6支持let name="tom", age = 19console.log(`my name is $&#123;name&#125;. I am $&#123;age&#125;`)// 执行结果line1line2line3my name is tom. I am 19 %{} 里面还可以写表达式，例如123456789101112let a = 'abc'let b = "135"let c = `line1$&#123;a + b&#125;line3`console.log(c)# 执行结果line1abc135line3 转义字符 名称 说明 \0 ASCII 0，Null字符，空字符 \b 退格符 \f 换页符 \n 换行符 \r 回车符 \t Tab(制表符) \v 垂直制表符 \’ 单引号 \” 双引号 \ 反斜杠字符 ( \ ) \XXX 由从0到377最多三位八进制数XXX表示的Latin-1字符。例如，\251是版本符号的八进制序列 \xXX 由从00到FF的两位十六进制数字XX表示的Latin-1字符。例如，\xA49是版本符号的十六进制序列 \uXXXX 由四位十六进制数字XXXX表示的Unicode字符。例如，\u00A9是版本符号的Unicode序列。见Unicode escape sequences(Unicode 转义字符) \u{XXXXX} Unicode代码点（code point）转义字符。例如，\u{2f804}相当于Uicode转义字符\uD87E\uDC04的简写 字符串操作方法字符串操作方法很多，但和Python类似12345678910111213141516171819202122232425262728let test = 'Python'console.log(test.charAt(2)) // t 索引console.log(test[2]) // t 索引 常用console.log(test.toUpperCase()) // PYTHONconsole.log(test.concat('.org')) // Python.org 字符串拼接console.log(test.slice(3)) // hon 切片,支持负索引console.log(test.slice(3,5)) // ho [3, 5)前包后不包console.log(test.slice(-2, -1)) // oconsole.log(test.slice(-2)) // onconsole.log(test.repeat(3)) // PythonPythonPythonconsole.log(test.endsWith('n')) // trueconsole.log(test.endsWith('P')) // falseconsole.log(test.search('t')) // 2console.log(test.length) // 6 长度let url = "www.python.org"console.log(url.split('.')) // [ 'www', 'python', 'org' ]console.log(url.substr(7, 2)) // ho 返回字符串从何处开始,取多长console.log(url.substring(7, 10)) //hon 返回子串,从何处开始,到什么为止,前包后不包let s ='python.hon'console.log(s.indexOf('ho')) // 3console.log(s.indexOf('ho', 4)) // 7console.log(s.replace('.hon', '.com')) // python.com 字符串替换s = '\tpyt hon \r\n'console.log(s.trim()) // pyt hon 去除两端的空白字符// trimLeft、trimRight是非标函数，少用 数值型number在JS中，数据均为双精度浮点型范围只能在-(2^53 -1) 和 2^53 -1之间，整型也不例外数字类型还有三种符号值 +Infinity（正无穷） -Infinity（负无穷） NaN (not-a-number非数字) 二进制0b0010、0B110八进制0755。注意0855，将被认作十进制，因为8不在八进制中。ES6中最好使用0o前缀表示八进制。十六进制0xAA、0Xff。指数表示1E3（1000），2e-2（0.02） 常用属性1234567891011121314console.log(Number.MAX_VALUE)console.log(Number.MAX_SAFE_INTEGER)console.log(Number.MIN_VALUE)console.log(Number.POSITIVE_INFINITY) // 正无穷console.log(Number.NEGATIVE_INFINITY) // 负无穷console.log(Number.NaN)// 执行结果1.7976931348623157e+30890071992547409915e-324Infinity-InfinityNaN 数字的方法 方法 描述 Number.parseFloat() 把字符串参数解析成浮点数，和全局方法 parseFloat() 作用一致 Number.parseInt() 把字符串解析成特定基数对应的整型数字，和全局方法 parseInt() 作用一致 Number.isFinite() 判断传递的值是否为有限数字 Number.isInteger() 判断传递的值是否为整数 Number.isNaN() 判断传递的值是否为 NaN 123456789let a = 0x712console.log(Number.MAX_SAFE_INTEGER)console.log(Number.isNaN(NaN))console.log(Number.NaN ==Number.NaN)// 执行结果9007199254740991truefalse NaN不能用等值来做 只能用判断来做 内置数学对象MathMath提供了绝对值、对数指数运算、三角函数运算、最大值、最小值、随机数、开方等运算函数，提供了PI值123456789101112console.log(Math.PI)console.log(Math.abs(-1))console.log(Math.log2(16))console.log(Math.sqrt(2))console.log(Math.random()) // (0,1)// 执行结果3.141592653589793141.41421356237309510.8018837833232821 运算符算数运算符 parseInt 直接截取 整数部分 Math.ceil 向上取整 Math.floor 向下取整 Math.round 四舍五入 + - * / %等运算符和Python一样1234567891011121314151617181920212223242526272829console.log(1/2)console.log(1/0)console.log(5 % 3)console.log(parseInt(1/2),parseInt(3/2),parseInt(5/2))console.log(parseInt(-1/2),parseInt(-3/2),parseInt(-5/2))console.log(Math.floor(1/2),Math.floor(3/2),Math.floor(5/2))console.log(Math.floor(-1/2),Math.floor(-3/2),Math.floor(-5/2))console.log(Math.ceil(1/2),Math.ceil(3/2),Math.ceil(5/2))console.log(Math.ceil(-1/2),Math.ceil(-3/2),Math.ceil(-5/2))console.log(Math.round(1/2),Math.round(3/2),Math.round(5/2))console.log(Math.round(-1/2),Math.round(-3/2),Math.round(-5/2))// 执行结果0.5Infinity2-0 1 2-0 -1 -20 1 2-1 -2 -31 2 3-0 -1 -21 2 3-0 -1 -2 ++ 和 –单目运算符，代表变量自增、自减 i++ 先用i，用完之后i再自增加1++i i先自增，再使用i 123456let i = 0 let a = i++console.log(a , i) // 0 1console.log(a, i++) // 0 1a = ++iconsole.log(a, ++i) // 3 4 123i = 0;let a = ++i+i+++i+++i; // 等价于 (++i) + (i++) + (i++) + iconsole.log(a); // / 1 + 1 + 2 + 3 =7 1、单目运算符优先级高于双目运算符2、加号+是双目运算符，两边的表达式必须先计算好 正负无穷1234console.log(1/2) // 0.5console.log(5 % 2) // 1console.log(1/0) // Infinity 正无穷console.log(-1/0) // -Infinity 负无穷 比较运算符12345&gt; &lt; &gt;= &lt;= 没有什么区别!= == !== ===== 宽松相等，进行类型转换，=== 严格相等，不进行类型转换 123456789101112131415console.log(100 &gt; 200) // falseconsole.log(100 &gt; '200') // falseconsole.log(300 &gt; '200') // trueconsole.log(1000 &gt; '200') // trueconsole.log('1000' &gt; 200) // trueconsole.log('100'&gt; '200') // falseconsole.log('1000' &gt; '200') // falseconsole.log('-'.repeat(30))// 类型转换失败 为falseconsole.log(1000 &gt; '200a') // falseconsole.log(1000 &gt; '0a') // falseconsole.log(1000 &gt; 'a') // falseconsole.log(1000 &gt; NaN) // falseconsole.log(1000 &lt; NaN) // false 类型转换失败 为false == 隐式类型转换=== 严格等式，内容相等，类型相等安全代码，建议使用 三等号1234console.log(100 == 200) // falseconsole.log(100 == '200') // falseconsole.log(200 == '200') // trueconsole.log(200 === '200') // false 逻辑运算符&amp;&amp; 、|| 、 !与、或、非这些运算符和其他高级语言都一样，支持短路 位运算&amp; | ^ ~ &lt;&lt; &gt;&gt;位与、位或、异或、取反、左移、右移，和Python一样异或，相异出1 三元运算符12345678910条件表达式?真值:假值等价于简单的if...else结构if (条件表达式) &#123; 真值&#125;else &#123; 假值&#125; 123456789console.log(('3' &gt; 30)?'t':'f') // flet a = 100console.log(a); // 100let b=a++console.log(b); // 100let c = 100 &gt; ++b?'t':'f'console.log(a, b, c); // 101 101 f 逗号操作符JS运行多个表达式写在一起return 会返回最后一个变量的值 其他 名称 说明 instanceof 判断是否属于指定类型 typeof 返回类型字符串 delete delete操作符, 删除一个对象(an object)或一个对象的属性(an object’s property)或者一个数组中某一个键值(an element at a specified index in an array) in 如果指定的属性在对象内，则返回true instanceof、typeofinstanceof 要求必须明确使用类型定义变量，就是对象必须是new关键字声明创建的。它可以用于继承关系的判断 typeof就是返回对象的类型字符串 实例化 必须要加 new [ ] { } 是 object对象1234567891011console.log('a' instanceof String); // falseconsole.log(typeof 'a', typeof 'a' == 'string'); // string trueconsole.log(1 instanceof Number); // falseconsole.log(typeof 1, typeof 1 == 'number'); // number trueconsole.log(a = new String('a'), a instanceof String,) ; // [String: 'a'] trueconsole.log(typeof a, typeof a == 'string'); // object falseconsole.log(b = new Number(1), b instanceof Number) ; // [Number: 1] trueconsole.log(typeof b, typeof b == 'number'); // object falseconsole.log([] instanceof Object) // true delete删除对象、属性、数组元素 自定义的可以删除 隐式赋值可以删除1234567891011121314151617181920212223242526272829303132333435363738394041x = 42;var y = 43;let z = 60;myobj = new Number();myobj.h = 4; // create property hconsole.log(delete x); // returns true (can delete if declared implicitly)console.log(delete y); // returns false (cannot delete if declared with var)console.log(delete z); // returns falseconsole.log(delete Math.PI); // returns false (cannot delete predefined properties)console.log(delete myobj.h); // returns true (can delete user-defined properties)console.log(delete myobj); // returns true (can delete if declared implicitly)console.log('~~~~~~~~~~~~~~~~~~~~')var trees = new Array("redwood", "bay", "cedar", "oak", "maple");for(var i=0;i&lt;trees.length;i++) console.log(trees[i])console.log('==================')delete trees[3]; // 数组中元素被删除，但空着的位置是undefinedfor(var i=0;i&lt;trees.length;i++) console.log(trees[i])// 执行结果truefalsefalsefalsetruetrue~~~~~~~~~~~~~~~~~~~~redwoodbaycedaroakmaple==================redwoodbaycedarundefinedmaple 删了数组的元素，个数不会少，会补充undefined pop可以pop掉，删除最后一个元素长度会变短，元素会移除123456789101112131415161718var trees = new Array("redwood", "bay", "cedar", "oak");for (var i=0;i&lt;trees.length;i++) console.log(trees[i])console.log('=============')trees.pop()for (var i=0;i&lt;trees.length;i++) console.log(trees[i])// 执行结果redwoodbaycedaroak=============redwoodbaycedar in判断属性是否在对象内1234567891011121314151617181920212223242526272829303132333435363738394041let trees = new Array("redwood", "bay", "cedar", "oak", "maple");console.log(0 in trees); // returns true ，0在数组对象的index中console.log(3 in trees); // returns true ，3在数组对象的index中console.log(6 in trees); // returns false，6不在数组对象的index中console.log("bay" in trees); // return false，bay不是属性，它是值console.log("length" in trees); // returns true，length是对象的属性console.log('~~~~~~~~~~~~~~~~~~~~')delete trees[3];console.log(3 in trees); // return falsefor(var i=0;i&lt;trees.length;i++) console.log(trees[i]);console.log('~~~~~~~~~~~~~~~~~~~~')// Custom objectslet mycar = &#123; color: "red", year: 1998&#125;;console.log("color" in mycar); // returns trueconsole.log("model" in mycar); // returns falseconsole.log('year' in mycar) // true// 执行结果truetruefalsefalsetrue~~~~~~~~~~~~~~~~~~~~falseredwoodbaycedarundefinedmaple~~~~~~~~~~~~~~~~~~~~truefalsetrue 运算符优先级 运算符由高到低，顺序如下* / % 双目,以下都是双目逗号运算符优先级最低，比赋值语句还低。记不住，就使用括号。表达式基本表达式，和Python差不多 解析式也和Python的相似，但在ES6中非标准不推荐使用生成器推荐使用生成器函数，ES6开始支持1234567891011121314151617181920212223function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next());// 执行结果&#123; value: 0, done: false &#125;&#123; value: 1, done: false &#125;&#123; value: 2, done: false &#125;&#123; value: 3, done: false &#125;&#123; value: 4, done: false &#125;&#123; value: 5, done: false &#125;&#123; value: 6, done: false &#125;&#123; value: 7, done: false &#125;&#123; value: 100, done: true &#125;&#123; value: undefined, done: true &#125; j = 7 !j 值取not, 7 为真，取not 为false value 取 值123456789101112131415161718192021222324function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next().value);// 执行结果01234567100undefined done 取状态123456789101112131415161718192021222324function* inc()&#123; let i = 0; let j = 7; while (true) &#123; yield i++; if (!j--) return 100; &#125;&#125;let gen = inc()for (let i=0;i&lt;10;i++) console.log(gen.next().done);// 执行结果falsefalsefalsefalsefalsefalsefalsefalsetruetrue]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-模块化]]></title>
    <url>%2Fjs%2FJS%20--%20%E6%A8%A1%E5%9D%97%E5%8C%96(babel%E8%BD%AC%E8%AF%91%E5%B7%A5%E5%85%B7%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@toc 概念ES6之前，JS没有出现模块化系统。因为它在设计之初根本没有想到今天的JS应用场景 JS主要在前端的浏览器中使用，js文件下载缓存到客户端，在浏览器中执行比如简单的表单本地验证，漂浮一个广告服务器端使用ASP、JSP等动态网页技术，将动态生成数据嵌入一个HTML模板，里面夹杂着JS后使用 &lt;script&gt; 标签，返回浏览器端执行。 &lt;script&gt; 还可以使用src属性，发起一个GET请求返回一个js文件，嵌入到当前页面执行环境中执行 这时候的JS只是一些简单函数和语句的组合 2005年之后，随着Google大量使用了A JAX技术之后，可以异步请求服务器端数据，带来了前端交互的巨大变化前端功能需求越来越多，代码也越来也多。随着js文件的增多，灾难性的后果产生了： 众多js文件通过 &lt;script&gt; 引入到当前页面中，每一个js文件发起一个GET请求，众多的js文件都需要返回到浏览器端。网络开销成本颇高 习惯了随便写，js脚本中各种全局变量污染，函数名冲突 JS脚本加载有顺序，JS文件中的代码之间的依赖关系（依赖前后顺序、相互依赖） 亟待模块化的出现 2008年V8引擎发布，2009年诞生了Nodejs，支持服务端JS编程。使用JS编程的项目规模越来越大，没有模块化是不可以的之后社区中诞生诸多模块化解决方案 CommonJS规范（2009年），使用全局require函数导入模块，将所有对象约束在模块对象内部，使用exports导出指定的对象最早这种规范是用在Nodejs后端的，后来又向前端开发移植，这样浏览器端开发也可以使用CommonJS了 AMD（Asynchronous Module Definition）异步模块定义，这是由社区提出的一种浏览器端模块化标准。使用异步方式加载模块，模块的加载不影响它后面语句的执行。所有依赖这个模块的语句，都需要定义在一个回调函数，回调函数中使用模块的变量和函数，等模块加载完成之后，这个回调函数才会执行，就可以安全的使用模块的资源了。其实现就是AMD/RequireJs。AMD虽然是异步，但是会预先加载和执行。目前应用较少 CMD（Common Module Definition），使用seajs，作者是淘宝前端玉伯，兼容并包解决了RequireJs的问题CMD推崇as lazy as possible，尽可能的懒加载 由于社区的模块化呼声很高，ES6开始提供支持模块的语法，但是浏览器目前支持还不够 ES6模块化ES6中模块自动采用严格模式 import语句，导入另一个模块导出的绑定 export语句，从模块中导出函数、对象、值的，供其它模块import导入用导出建立一个模块目录src，然后在这个目录下新建一个moda.js，内容如下：缺省导出12345678export default class A&#123; constructor(x)&#123; this.x = x; &#125; show()&#123; console.log(this.x); &#125;&#125; 导出函数123export function foo()&#123; console.log('foo function');&#125; 导出常量1export const CONSTA = 'aaa' 导入其它模块中导入语句如下12import &#123;CONSTA, foo&#125; from "./moda";import * as mod_a from "./moda"; VS Code可以很好的语法支持了，但是运行环境，包括V8引擎，都不能很好的支持模块化语法 转译工具转译就是从一种语言代码转换到另一个语言代码，当然也可以从高版本转译到低版本的支持语句 由于JS存在不同版本，不同浏览器兼容的问题使用transpiler转译工具解决对语法的支持问题 babel开发中可以使用较新的ES6语法，通过转译器转换为指定的某些版本代码 官网 http://babeljs.io/ 参考文档 https://babeljs.io/docs/en/6.26.3/index.html 注意当前版本7.x已经有了较大的变化，请参看6.x文档 打开Try it out，测试一段代码12345678function * counter()&#123; let i = 0; while(true) yield (++i);&#125;g = counter();console.log(g.next().value); 预设有如下一些预设presets，我们先看看有哪些，一会儿再进行预设的安装和配置1234567891011121314presets：babel-preset-env 当前环境支持的代码，新targetES2015转码规则$ npm install --save-dev babel-preset-es2015react转码规则$ npm install --save-dev babel-preset-reactES7不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 离线转译安装配置1、初始化npm在项目目录中使用$ npm initnpm 相当于 linux 的yum ；相当于python 的pip在项目根目录下会生成package.json文件，内容就是上面花括号的内容descriotion 描述entry point 入口 test command 测试的命令license 许可证 package.json 根目录 这个文件很重要 先对项目初始化，才可以使用babel 2、设置镜像 为了连接国内的服务器，当前项目创建一个配置 .npmrc文件 可以放在全局配置下，所有人用 可以放到用户家目录中，当前用户下所有项目使用 可以放到项目根目录中，当前项目用（推荐此种做法） 参考 http://npm.taobao.org/本次放到项目根目录中，内容如下 registry=https://registry.npm.taobao.org1`$ echo "registry=https://registry.npm.taobao.org" &gt; .npmrc` 3、安装项目根目录下执行$ npm install babel-core babel-cli --save-dev --save-dev说明 当你为你的模块安装一个依赖模块时，正常情况下你得先安装他们（在模块根目录下npm install module-name），然后连同版本号手动将他们添加到模块配置文件package.json中的依赖里（dependencies）。开发用 --save和--save-dev可以省掉你手动修改package.json文件的步骤 spm install module-name --save 自动把模块和版本号添加到dependencies部分。部署运行时用 spm install module-name --save-dev 自动把模块和版本号添加到devdependencies部分 安装完后，在项目根目录下出现 node_modules目录 ，里面有babel相关模块及依赖的模块 -g 安装全局，非万不得，不要使用没有加 -g 默认安装到当前项目中 4、配置babel和安装预设在目录根目录下创建 .babelrc 文件，Json格式123&#123; "presets": ["env"]&#125; env 可以根据当前环境自动选择安装依赖$ npm install babel-preset-env --save-dev 5、准备目录项目根目录下建立src和lib目录 src 是源码目录 lib 是目标目录 6、修改package.json替换为 scripts 的部分12345678910111213141516&#123; "name": "src", "version": "1.0.0", "description": "", "main": "moda.js", "scripts": &#123; "build": "babel src -d lib" &#125;, "author": "luxia", "license": "ISC", "devDependencies": &#123; "babel-cli": "^6.26.0", "babel-core": "^6.26.3", "babel-preset-env": "^1.7.0" &#125;&#125; babel src -d lib 意思是从src目录中转译后的文件输出到lib目录 7、准备js文件在src中的moda.js文件12345678910111213// 缺省导出export default class A&#123; constructor(x)&#123; this.x = x; &#125; show()&#123; console.log(this.x) &#125;&#125;export function foo()&#123; console.log('foo function')&#125; src目录下新建index.js123456import A, &#123;foo&#125; from "./moda";var a = new A(100);a.show();foo(); 直接在VS Code的环境下执行出错。估计很难有能够正常运行的环境。所以，要转译为ES5的代码。 在项目根目录下执行命令1$ npm run build 可以在lib文件夹中看到，2个文件被转译 运行文件 1$ node lib/index.js 使用babel等转译器转译JS非常流行开发者可以在高版本中使用新的语法特性，提高开发效率，把兼容性问题交给转译器处理 npx是包之心器命令从npm 5.2开始提供。npx可以直接执行已经安装过的包的命令，而不用配置package.json中的run-script1npx babel src -d lib 1node lib/index.js 导入导出导出代码都在src/moda.js中，导入代码都写在src/index.js中 缺省导入导出只允许一个缺省导出，缺省导出可以是变量、函数、类，但不能使用let、var、const关键字作为默认导出 缺省导入的时候，可以自己重新命名，可以不需要和缺省导出时的名称一致，但最好一致 缺省导入，不需要在import后使用花括号12345678// 缺省导出 匿名函数export default function()&#123; console.log('default export function')&#125;// 缺省导入import defaultFunc from '/.moda'defaultFunc(); 12345678// 缺省导出 命名函数export default function xyz()&#123; console.log('default export function')&#125;// 缺省导入import defaultFunc from './moda'defaultFunc(); 命名导入导出 导出举例 123456789101112131415161718192021222324252627// 缺省导出类export default class &#123; constructor(x) &#123; this.x = x; &#125; show() &#123; console.log(this.x); &#125;&#125;// 命名导出 函数export function foo() &#123; console.log('regular foo()');&#125;// 函数定义function bar() &#123; console.log('regular bar()');&#125;// 变量常量定义let x = 100;var y = 200;const z = 300;// 导出export &#123; bar, x, y, z &#125;; 导入举例as 设置别名12345678import defaultCls, &#123; foo, bar, x, y, z as CONST_C &#125; from './moda';foo();bar();console.log(x); // x只读，不可修改，x++异常console.log(y); // y只读console.log(CONST_C);new defaultCls(1000).show(); 也可以使用下面的形式，导入所有导出，但是会定义一个新的名词空间。使用名词空间可以避免冲突12345import * as newmod from './mod';newmod.foo();newmod.bar();new newmod.default(2000).show();]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-对象模型]]></title>
    <url>%2Fjs%2FJS%E5%AF%B9%E8%B1%A1%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[@tocJavaScript 是一种基于原型（Prototype）的面向对象语言，而不是基于类的面向对象语言 C++、Java有类Class和实例Instance的概念，类是一类事物的抽象，而实例则是类的实体 JS是基于原型的语言，它只有原型对象的概念。原型对象就是一个模板，新的对象从这个模板构建从而获取最初的属性。任何对象在运行时可以动态的增加属性。而且，任何一个对象都可以作为另一个对象的原型，这样后者就可以共享前者的属性 定义类字面式声明方式1234567891011121314var obj = &#123; property_1: value_1, // property_# may be an identifier... property_2: value_2, // or a number... ..., "property n": value_n // or a string&#125;;var obj = &#123; x: 1, 1: 'abc', 'y': '123'&#125;for (let s in obj) console.log(s, typeof (s)); 这种方法也称作字面值创建对象Js 1.2开始支持1234567891011let a = 1, b = 2let obj = &#123; a, b &#125;let obj1 = &#123; a: a, 'b': b &#125; // 引号可以省console.log(obj) // &#123; a: 1, b: 2 &#125;console.log(obj1) // &#123; a: 1, b: 2 &#125;let c = 'pro1'let d = &#123; c: 1000, // 注意这个c是'c'，不是上面的变量c [c]: 2000 // 如果要用c变量，就要把c用中括号括起来&#125; 对象的键key只能是字符串类型，最后都会被转换成字符串 ES6之前——构造器1、定义一个函数（构造器）对象，函数名首字母大写2、使用this定义属性3、使用new和构造器创建一个新对象1234567891011121314151617181920212223242526272829303132333435// 定义类，构造器function Point(x, y) &#123; this.x = x; this.y = y; this.show = () =&gt; &#123; console.log(this, this.x, this.y) &#125;; console.log('Point~~~~~~~~');&#125;console.log(Point);p1 = new Point(4, 5);console.log(p1);console.log('----------------');// 继承function Point3D(x, y, z) &#123; Point.call(this, x, y); // "继承" this.z = z; console.log('Point3D~~~~~~~~');&#125;console.log(Point3D);p2 = new Point3D(14, 15, 16);console.log(p2);p2.show();/* 执行结果[Function: Point]Point~~~~~~~~Point &#123; x: 4, y: 5, show: [Function] &#125;----------------[Function: Point3D]Point~~~~~~~~Point3D~~~~~~~~Point3D &#123; x: 14, y: 15, show: [Function], z: 16 &#125;Point3D &#123; x: 14, y: 15, show: [Function], z: 16 &#125; 14 15*/ new 构建一个新的通用对象，new操作符会将新对象的this值传递给Point3D构造器函数，函数为这个对象创建z属性。从上句话知道，new后得到一个对象，使用这个对象的this来调用构造器，那么如何执行“基类”的构造器方法呢？使用Point3D对象的this来执行Point的构造器，所以使用call方法，传入子类的this。最终，构造完成后，将对象赋给p2。 注意：如果不使用new关键字，就是一次普通的函数调用，this不代表实例。 ES6中的class从ES6开始，新提供了class关键字，使得创建对象更加简单、清晰 类定义使用class关键字。创建的本质上还是函数，是一个特殊的函数 一个类只能拥有一个名为constructor的构造器方法。如果没有显式的定义一个构造方法，则会添加一个默认的constuctor方法 继承使用extends关键字 一个构造器可以使用super关键字来调用一个父类的构造函数 类没有私有属性12345678910111213141516171819202122232425262728// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;let p1 = new Point(10, 11)p1.show()// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show()/* 执行结果Point &#123; x: 10, y: 11 &#125; 10 11Point3D &#123; x: 20, y: 21, z: 22 &#125; 20 21*/ 重写方法子类Point3D的show方法，需要重写123456789101112131415161718192021222324252627282930313233// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;let p1 = new Point(10, 11)p1.show()// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125; show() &#123; // 重写 console.log(this, this.x, this.y, this.z); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show();/* 执行结果Point &#123; x: 10, y: 11 &#125; 10 11Point3D &#123; x: 20, y: 21, z: 22 &#125; 20 21 22*/ 子类中直接重写父类的方法即可如果需要使用父类的方法，使用super.method()的 方式调用 使用箭头函数重写上面的方法12345678910111213141516171819202122// 基类定义// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = function () &#123;console.log(this,this.x,this.y)&#125;; this.show = () =&gt; console.log('Point'); &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point3D 从运行结果来看，箭头函数也支持子类的覆盖1234567891011121314151617181920212223242526// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; this.show = () =&gt; console.log('Point'); &#125; // show() /*方法*/ &#123; // console.log(this,this.x,this.y); // &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; //this.show = () =&gt; console.log('Point3D'); &#125; show() &#123; // 重写 console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point 上例优先使用了父类的属性show1234567891011121314151617181920212223// 基类定义class Point &#123; constructor(x, y) /*构造器*/ &#123; this.x = x; this.y = y; //this.show = () =&gt; console.log('Point'); &#125; show() /*方法*/ &#123; console.log(this, this.x, this.y); &#125;&#125;// 继承class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; this.show = () =&gt; console.log('Point3D'); &#125;&#125;let p2 = new Point3D(20, 21, 22);p2.show(); // Point3D 优先使用了子类的属性 总结 父类、子类使用同一种方式类定义属性或者方法，子类覆盖父类 访问同名属性或方法时，优先使用属性静态属性静态属性目前还没有得到很好的支持静态方法在方法名前加上static，就是静态方法123456789101112131415161718192021class Add &#123; constructor(x, y) &#123; this.x = x; this.y = y; &#125; static print() &#123; console.log(this.x); // ? this是什么 &#125;&#125;add = new Add(40, 50);console.log(Add);Add.print();//add.print(); // 实例不能访问直接访问静态方法，和C++、Java一致add.constructor.print(); // 实例可以通过constructor访问静态方法/* 执行结果[Function: Add]undefinedundefined*/ 静态方法中的this是Add类，而不是Add的实例 注意：静态的概念和Python的静态不同，相当于Python中的类变量this的坑虽然Js和 C++ 、Java一样有this，但是Js的表现是不同的。原因在于， C++ 、Java是静态编译型语言，this是编译期绑定，而Js是动态语言，运行期绑定1234567891011121314151617181920var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this === global); // this是否是global对象 return this.name; &#125;; &#125;&#125;;console.log(school.getNameFunc()());/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;trueundefined*/ 函数执行时，会开启新的执行上下文环境ExecutionContext 创建this属性，但是this是什么就要看函数是怎么调用的了 myFunction(1,2,3)，普通函数调用方式，this指向全局对象。全局对象是nodejs的global或者浏览器中的windows myObject.myFunction(1,2,3)，对象方法的调用方式，this指向包含该方法的对象 call、apply、bind方法调用时，要看第一个参数是谁 分析上例 js 和 { name: &#39;js&#39;, getNameFunc: [Function: getNameFunc] } 很好理解 第三行打印的true，是 console.log(this == global) 执行的结果，说明当前是global，因为调用这个返回的函数是直接调用的，这就是个普通函数调用，所以this是全局对象 第四行undefined，就是因为this是global，没有name属性 这就是函数调用的时候，调用方式不同，this对应的对象不同，它已经不是C++、Java的指向实例本身了this的问题，这是历史遗留问题，新版只能保留且兼容了而我们在使用时，有时候需要明确的让this必须是我们期望的对象，如何解决这个问题呢？ 1 显式传入12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return function (that) &#123; console.log(this == global); // this是否是global对象 return that.name; &#125;; &#125;&#125;console.log(school.getNameFunc()(school)); /* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;truejs*/ 通过主动传入对象，这样就避开了this的问题 2、 ES3（ES-262第三版）引入了apply、call方法12345678910111213141516171819var school = &#123; name : 'js', getNameFunc : function () &#123; console.log(this.name); console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125; &#125; console.log(school.getNameFunc().call(school)); // call方法显式传入this对应的对象/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;falsejs*/ apply、call方法都是函数对象的方法，第一参数都是传入对象引入的apply传其他参数需要使用数组call传其他参数需要使用可变参数收集12345678910111213141516171819202122232425262728293031function Point(x, y) &#123; this.x = x; this.y = y; console.log(this === global); console.log('Point ~~~~');&#125;p1 = Point(4, 5);console.log(p1); // undefinedconsole.log('~~~~~~~~~~~~~~~~')p2 = new Object();console.log(p2); // &#123;&#125;p3 = Point.call(p2, 10, 11);// p3 = Point.apply(p2, [11, 13]);console.log(p3); // undefinedconsole.log(p2); // &#123; x: 10, y: 11 &#125;/* 执行结果truePoint ~~~~undefined~~~~~~~~~~~~~~~~&#123;&#125;falsePoint ~~~~undefined&#123; x: 10, y: 11 &#125;*/ 3、ES5 引入了bind方法bind方法来设置函数的this值12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); // console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc().bind(school)); // bind方法绑定/* 执行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;[Function: bound ]*/ 只打印了三行，说明哪里有问题，问题出在bind方法用错了12345678910111213141516171819202122232425262728var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); // console.log(this); return function () &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;var func = school.getNameFunc();console.log(func);var boundfunc = func.bind(school); // bind绑定后返回新的函数console.log(boundfunc);console.log(boundfunc());/* 执行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;[Function][Function: bound ]falsejs*/ apply、call方法，参数不同，调用时传入thisbind方法是为函数先绑定this，调用时直接用 4、ES6引入支持this的箭头函数ES6 新技术，就不需要兼容this问题12345678910111213141516171819var school = &#123; name: 'js', getNameFunc: function () &#123; console.log(this.name); console.log(this); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(school.getNameFunc()());/* 运行结果js&#123; name: 'js', getNameFunc: [Function: getNameFunc] &#125;falsejs */ ES6 新的定义方式如下123456789101112131415161718192021class school &#123; constructor() &#123; this.name = 'js'; &#125; getNameFunc() &#123; console.log(this.name); console.log(this, typeof (this)); return () =&gt; &#123; console.log(this == global); // this是否是global对象 return this.name; &#125;; &#125;&#125;console.log(new school().getNameFunc()());/* 执行结果jsschool &#123; name: 'js' &#125; 'object'falsejs*/ 以上解决this问题的方法，bind方法最常用]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[关系模型和sql]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL%20(DML%20%E2%80%94%E2%80%94%20CRUD%20%E5%A2%9E%E5%88%A0%E6%94%B9%E6%9F%A5)%2F</url>
    <content type="text"><![CDATA[@toc所有操作一定要加==条件== Insert语句 向表中插入一行数据，自增字段、缺省值字段、可为空字段可以不写INSERT INTO table_name(col_name,...) VALUES (value1,...); 将select查询的结果插入到表中INSERT INTO table_name SELECT ... ; 如果主键冲突、唯一键冲突就执行update后的设置。这条语句的意思，就是主键不在新增记录，主键在就更新部分字段INSERT INTO table_name (col_name1,...) VALUES (value1,...) ON DUPLICATE KEY UPDATE col_name1=value1,...; 如果主键冲突、唯一键冲突就忽略错误，返回一个警告INSERT IGNORE INTO table_name (col_name,...) VALUES (value1,...);例：123456789INSERT INTO reg(loginname, `name`, `password`) VALUES('tom', 'tom', 'tom');INSERT INTO reg(if, loginname, `name`, `password`) VALUES (5, 'tom', 'tom', 'tom');INSERT INTO reg(id, loginname, `name`, `password`) VALUED (1, 'tom', 'tom', 'tom') ON DUPLICATE KEY UPDATE name = 'jerry' Update语句 IFNORE 意义同Insert语句 [IGNORE] tal_name SET col_name1123```python-- 例UPDATE reg SET name=&apos;tom· WHERE id=5; 注意这一句非常危险，会更新所有数据 1UPDATE reg SET name ='ben'; 更新一定要加条件 1UPDATE reg SET name = 'ben', password = 'benpwd' WHRER id = 1; Delete语句 删除符合条件的记录DELETE FROM tal_name [WHERE where_defintion] 删除一定要有条件1DELETE FROM reg WHERE id =1; Select语句123456789101112SELECT [DISTINCT] select_expr, ... [FROM table_references [WHERE where_definition] [FROUP BY &#123;col_name | expr | position&#125; [ASC | DESC], ... [WITH ROLLUP]] [HAVING whrer_definition] [ORDER BY &#123;col_name | expr | position&#125; [ASC | DESC], ...] [LIMIT &#123;[offset,&#125; roe_count | row_count OFFSET offset&#125;] [FOR UPDATE | LOCK IN SHARE MODE]] FOR UPDATE会把行进行写锁定，这是排它锁 查询 查询的结果成为结果集recordset 最简单的查询SELECT 1;SELECT * FROM employees; 字符串合并SELECT emp_no, first_name + last_name FROM employees; 执行前执行后 使用字符串相加函数 CONCATSELECT emp_no, CONCAT(first_name,&#39; &#39;,last_name) FROM employees; 执行后 AS定义别名，可选。 写AS是一个好习惯SELECT emp_no as en, CONCAT(first_name,&#39; &#39;,last_name) as name FROM employees; 执行后 Limit子句 返回5条记录， [1,5]左闭右闭SELECT * FROM employees as emp LIMIT 5; 返回5条记录，偏移3条，(3,8]左开右闭SELECT * FROM employees as emp LIMIT 3, 5;等价于SELECT * FROM employees as emp LIMIT 5 offset 3; ， Where子句 运算符 描述符 = 等于 &lt;&gt; 不等于 &gt;、 &lt;、 &gt;=、 &lt;= 大于、小于、大于等于、小于等于 BETWEEN 在某个范围之内，between a and b等价于[a, b] LIKE 字符串模式匹配，%表示任意多个字符，_表示一个字符 IN 指定针对某个列的多个可能值 AND 与 OR 或 能用键匹配用键 LIKE 只能使用左前缀，尽量不使用，性能差 注意：如果很多表达式需要使用AND、OR计算逻辑表达式的值的时候，由于有结合律的问题，建议使用小括号来避免产生错误 查询条件123SELECT * FROM employees WHERE emp_no &lt; 10015 and last_name LIKE 'P%';SELECT * FROM employees WHERE emp_no BETWEEN 10010 AND 10015 AND last_name LIKE 'P%';SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010); EXPLAIN 可判断查询条件性能如何12EXPLAIN SELECT emp_no AS id, birth_date, concat(FIRST_name, ' ', last_name) as name FROM employees as emp WHERE last_name='Sluis'; 12EXPLAIN SELECT emp_no AS id, birth_date, concat(FIRST_name, ' ', last_name) as name FROM employees as emp WHERE emp_no BETWEEN 10010 and 10015 and last_name='Sluis'; 说明第二个查询条件优于第一个 ORder by 子句对查询结果进行排序，可以升序ASC、降序DESC。默认不填为升序 升序SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY emp_no; 降序SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY emp_no DESC OROER BY 先执行，在执行 LIMIT12SELECT * FROM employees WHERE emp_no in (10001, 10002, 10010) ORDER BY birth_date, emp_no DESC LIMIT 1, 2; 会先按照第一条件进行排序，如果无法区分先后顺序，在使用第二条件进行排序DISTINCT不返回重复记录 原表 SELECT DISTINCT dept_no FROM dept_emp;执行结果如下 SELECT DISTINCT emp_no FROM dept_emp;执行结果如下 SELECT dept_no,emp_no FROM dept_emp;会将dept_no与emp_no看成二元祖来筛选聚合函数|函数 | 描述 ||:–|:–|| COUNT(expr) | 返回记录中记录的数目，如果指定列，则返回非NULL值的行数 || COUNT(DISTINCT expr,[expr…]) | 返回不重复的非NULL值的行数|| AVG([DISTINCT] expr) | 返回平均值，返回不同值的平均值 || MIN(expr), MAX(expr) | 最小值，最大值|| SUM([DISTINCT] expr) | 求和，Distinct返回不同值求和 | SELECT COUNT(*), AVG(emp_no), sum(emp_no), min(emp_no), max(emp_no) FROM employees; 原表 执行后1234SELECT emp_no, COUNT( emp_no ), sum( emp_no ), avg( emp_no ) AS sal_avg FROM employees WHERE emp_no &gt; 10001 GROUP BY emp_no HAVING sal_avg &gt; 10005 ORDER BY sal_avg DESC LIMIT 1; 执行顺序 ：HAVING &gt; select &gt; GROUP BY &gt; HAVING &gt; ORDER BY 分别查询使用Group by子句，如果有条件，使用Having子句过滤分组、聚合过的结果 原表1234567891011121314151617181920212223242526272829303132333435363738394041emp_no salary from_date to_date10001 60117 1986-06-26 1987-06-2610001 62102 1987-06-26 1988-06-2510001 66074 1988-06-25 1989-06-2510001 66596 1989-06-25 1990-06-2510001 66961 1990-06-25 1991-06-2510001 71046 1991-06-25 1992-06-2410001 74333 1992-06-24 1993-06-2410001 75286 1993-06-24 1994-06-2410001 75994 1994-06-24 1995-06-2410001 76884 1995-06-24 1996-06-2310001 80013 1996-06-23 1997-06-2310001 81025 1997-06-23 1998-06-2310001 81097 1998-06-23 1999-06-2310001 84917 1999-06-23 2000-06-2210001 85112 2000-06-22 2001-06-2210001 85097 2001-06-22 2002-06-2210001 88958 2002-06-22 9999-01-0110002 65828 1996-08-03 1997-08-0310002 65909 1997-08-03 1998-08-0310002 67534 1998-08-03 1999-08-0310002 69366 1999-08-03 2000-08-0210002 71963 2000-08-02 2001-08-0210002 72527 2001-08-02 9999-01-0110003 40006 1995-12-03 1996-12-0210003 43616 1996-12-02 1997-12-0210003 43466 1997-12-02 1998-12-0210003 43636 1998-12-02 1999-12-0210003 43478 1999-12-02 2000-12-0110003 43699 2000-12-01 2001-12-0110003 43311 2001-12-01 9999-01-0110004 40054 1986-12-01 1987-12-0110004 42283 1987-12-01 1988-11-3010004 42542 1988-11-30 1989-11-3010004 46065 1989-11-30 1990-11-3010004 48271 1990-11-30 1991-11-3010004 50594 1991-11-30 1992-11-2910004 52119 1992-11-29 1993-11-2910004 54693 1993-11-29 1994-11-2910004 58326 1994-11-29 1995-11-2910004 60770 1995-11-29 1996-11-28 聚合所有SELECT emp_no, SUM(salary), avg(salary), count(emp_no) from salaries; 聚合被选择的记录SELECT emp_no, SUM(salary), avg(salary), count(emp_no) from salaries WHERE emp_no &lt; 10003; 分组SELECT emp_no FROM salaries GROUP BY emp_no;SELECT emp_no FROM salaries WHERE emp_no &lt; 10003 GROUP BY emp_no; 按照不同emp_no分组，每组分别聚合12SELECT emp_no, SUM(salary), AVG(salary), count(emp_no) from salaries WHERE emp_no &lt; 10003 GROUP BY emp_no; HAVING子句对分组结果过滤12SELECT emp_no, SUM(salary), AVG(salary), count(emp_no) from salaries GROUP BY emp_no HAVING AVG(salary) &gt; 45000 使用别名12SELECT emp_no, SUM(salary), AVG(salary) as sal_avg, count(emp_no) from salaries GROUP BY emp_no HAVING sal_avg &gt; 45000 最后对分组过滤后的结果排序12SELECT emp_no, SUM(salary), AVG(salary) AS sal_avg, COUNT(emp_no) from salaries GROUP BY emp_no HAVING sal_avg &gt; 60000 ORDER BY sal_avg; 分组是将数据按照指定的字段分组，最终每组只能出来一条记录。这就带来了问题，每一组谁做代表，其实谁做代表都不合适 如果只投影分组字段、聚合数据，不会有问题，如果投影非分组字段，显示的时候不能确定是组内谁的数据 分组12SELECT emp_no, MAX(salary) FROM salaries; -- 10001 88958SELECT emp_no, MIN(salary) FROM salaries; -- 10001 40006 上例很好的说明了使用了聚合函数，虽然没有显式使用Group By语句，但是其实就是把所有记录当做一组，每组只能出一条，那么一组也只能出一条，所以结果就一条 但是emp_no就是非分组字段，那么它就要开始覆盖，所以，显示为10001。当求最大值的时候，正好工资表中10001的工资最高，感觉是对的。但是，求最小工资的时候，明明最小工资是10003的40006，由于emp_no不是分组字段，导致最后被覆盖为100011SELECT emp_no, MIN(salary) FROM salaries GROUP BY emp_no; 上句才是正确的语义，按照不同员工emp_no工号分组，每一个人一组，每一个人有多个工资记录，按时每组只能按照人头出一条记录 单标较为复杂的语句1234567891011121314SELECT emp_no, AVG( salary ) AS avg_sal FROM salaries WHERE salary &gt; 70000 GROUP BY emp_no HAVING avg( salary ) &gt; 50000 ORDER BY avg_sal DESC LIMIT 1; 子查询 查询语句可以嵌套，内部查询就是子查询 子查询必须在一组小括号中 子查询中不能使用Order by12345678SELECT * FROM employees WHERE emp_no IN ( SELECT emp_no FROM employees WHERE emp_no &gt; 10015 ) ORDER BY emp_no DESC; 12345678910SELECT emp.emp_no, emp.first_name, gender FROM ( SELECT * FROM employees WHERE emp_no &gt; 10015 ) AS emp WHERE emp.emp_no &lt; 10019 ORDER BY emp_no DESC; 连接join交叉连接 cross join 笛卡尔乘积，全部交叉 在MySQL中，CROSS JOIN从语法上说与INNER JOIN等同 没有 join 就不能用 on Join会构建一张临时表1234567891011-- 工资40行SELECT * FROM salaries;-- 20行SELECT * FROM employees;-- 800行SELECT * FROM employees CROSS JOIN salaries;-- 隐式连接，800行SELECT * FROM employees, salaries; 注意：salaries和employees并没有直接的关系，做笛卡尔乘积只是为了看的清楚 内连接 inner join 可省略为join 等值连接，只选某些field相等的元组（行），使用On限定关联的结果 自然连接，特殊的等值连接，会去掉重复的列。用的少123456789-- 内连接，笛卡尔乘积 800 行SELECT * FROM employees JOIN salaries;SELECT * FROM employees INNER JOIN salaries;-- on等值连接 40行SELECT * FROM employees JOIN salaries ON employees.emp_no = salaries.emp_no;-- 自然连接，去掉了重复列，且自行使用 employees.emp_no = salaries.emp_no的条件SELECT * FROM employees NATURAL JOIN salaries; 外连接 outer join 可以省略为join分为左外连接，即左连接；右外连接，即右连接；全外连接左连接（56条记录）1SELECT * FROM employees LEFT JOIN salaries ON employees.emp_no = salaries.emp_no; 右连接（40 条记录）1SELECT * FROM employees RIGHT JOIN salaries ON employees.emp_no = salaries.emp_no; 这个右连接等价于上面的左连接（56条记录）1SELECT * FROM salaries RIGHT JOIN employees ON employees.emp_no = salaries.emp_no; 左外连接、右外连接1SELECT * FROM employees RIGHT JOIN salaries ON employees.emp_no = salaries.emp_no; 结果是先employees后salaries的字段显示，Right是看表的数据的方向，从salaries往employees看，以salaries为准，它的所有数据都显示12345678SELECT employees.*FROM salaries RIGHT JOIN employees ON employees.emp_nosalaries.emp_no WHERE salaries.emp_no IS NULL 自连接表，自己和自己连接12345select manager.* from emp manager,emp worker where manaer.empno=worker.mgr and worker.empno=1;select manager.* from emp manager inner join emp worker on manaer.empno=worker.mgr where worker.empno=1; 存储过程、触发器 存储过程（Stored Procedure），数据库系统中，一段完成特定功能的SQL语句。编写成类似函数的方式，可以传参并调用。支持流程控制语句 触发器（Trigger），由事件触发的特殊的存储过程，例如insert数据时触发 这两种技术，虽然是数据库高级内容，性能不错，但基本很少用了 它们移植性差，使用时占用的服务器资源，排错、维护不方便 最大的原因，不太建议把逻辑放在数据库中]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-解构]]></title>
    <url>%2Fjs%2FJS%20-%E8%A7%A3%E6%9E%84%E5%8F%8A%E6%95%B0%E7%BB%84%E5%AF%B9%E8%B1%A1%E6%93%8D%E4%BD%9C%2F</url>
    <content type="text"><![CDATA[@TOCJS的解构很灵活，参考https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator 列表解构123var parts = ['shoulder', 'knees'];var lyrics = ['head', ...parts, 'and', 'toes']; // 使用...解构console.log(lyrics) // [ 'head', 'shoulder', 'knees', 'and', 'toes' ] 参数解构12345678910let arr = [1, 2]let arr1 = [...arr]function f(x, y, z) &#123; console.log(x + y + z)&#125;var args = [2, 3, 4];f(...arr); // NaNf(...args); // 9f(...['a', 'b']); // abundefined 数组解构JS的数组解构非常强大1234567891011121314151617181920212223242526272829303132333435const arr = [100,200,300];let [x,y,z] = arr;console.log(1,x,y,z);// 丢弃const [,b,] = arr;console.log(2,b);//b = 5 // 异常，b声明为const// 少于数组元素const [d,e] = arr;console.log(3,d,e);// 多于数组元素const [m,n,o,p] = arrconsole.log(4,m,n,o,p);// 可变变量const [f,...args] = arrconsole.log(5,f);console.log(5,args);// 支持默认值const [j=1,k,,,l=10] = arrconsole.log(j,k,l);/* 执行结果1 100 200 3002 2003 100 2004 100 200 300 undefined5 1005 [ 200, 300 ]100 200 10*/ 解构的时候，变量从左到右和元素对齐，可变参数放到最右边能对应到数据就返回数据，对应不到数据的返回默认值，如果没有默认值返回undefined 对象解构简单对象解构，非常有用1234567891011121314151617const obj = &#123; a: 100, b: 200, c: 300&#125;var &#123;x, y, z&#125; = obj;console.log(x, y, z); // undefined undefined undefinedvar &#123;a, b, c&#125; = obj; // key名称console.log(a, b, c); // 100 200 300var &#123;a: m, b: n, c&#125; = obj; // 重命名console.log(m, n, c); // 100 200 300var &#123;a: M, c: N, d: D = 'python'&#125; = obj; //缺省值console.log(M, N, D); // 100 300 'python' 解构时，需要提供对象的属性名，会根据属性名找到对应的值。没有找到的返回缺省值，没有缺省值则返回undefined 复杂解构嵌套数组123456789101112const arr = [1, [2, 3], 4];const [a, [b, c], d] = arr;console.log(a, b, c, d); //1 2 3 4const [e, f] = arr;console.log(e, f); //1 [ 2, 3 ]const [g, h, i, j = 18] = arr;console.log(g, h, i, j); //1 [ 2, 3 ] 4 18const [k, ...l] = arr;console.log(k, l); //1 [ [ 2, 3 ], 4 ] 对象1234567891011121314151617181920var data = &#123; a: 100, b: [ &#123; c: 200, d: [], a: 300 &#125;, &#123; c: 1200, d: [1], a: 1300 &#125;, ], c: 500&#125;// 提取3个a出来var &#123; a: m, b: [&#123; a: n &#125;, &#123; a: n1 &#125;] &#125; = data;console.log(m, n, n1) // 100 300 1300 数组的操作 方法 描述 push(…items) 尾部增加多个元素 pop() 移除最后一个元素，并返回它 map 引入处理函数来处理数组中每一个元素，返回新的数组 filter 引入处理函数处理数组中每一个元素，此处理函数返回true的元素保留，否则该元素被过滤掉，保留的元素构成新的数组返回 foreach 迭代所有元素，无返回值 1234567891011121314151617181920const arr = [1, 2, 3, 4, 5];arr.push(6, 7);console.log(arr); // [ 1, 2, 3, 4, 5, 6, 7 ]arr.pop()console.log(arr); // [ 1, 2, 3, 4, 5, 6 ]// mapconst powerArr = arr.map(x =&gt; x * x); // 新数组console.log(powerArr); // [ 1, 4, 9, 16, 25, 36 ]// forEachconst newarr = arr.forEach(x =&gt; x + 10); // 无返回值console.log(newarr, arr); // undefined [ 1, 2, 3, 4, 5, 6 ]narr = []newArr = arr.forEach(x =&gt; narr.push(x + 10));console.log(newArr, narr); // undefined [ 11, 12, 13, 14, 15, 16 ]// filter 只做判断console.log(arr.filter(x =&gt; x % 2 == 0)) // 新数组 [ 2, 4, 6 ] forEach用索引第一个参数是值第二个参数是索引 123456789let arr = [1, 2, 3];let newarr = [];arr.forEach((x, index) =&gt; &#123; newarr.push(arr[index] + 10);&#125;);console.log(newarr); // [ 11, 12, 13 ]console.log(arr); // [ 1, 2, 3 ] 数组练习有一个数组 const arr = [1, 2, 3, 4, 5]; ，要求算出所有元素平方值，且输出平方值是偶数且大于10的平方值 效率偏差 12const arr = [1, 2, 3, 4, 5]console.log(arr.map(x =&gt; x * x).filter(x =&gt; x % 2 === 0).filter(x =&gt; x &gt; 10)); 应该先过滤,再求值比较好 1234567891011121314const arr = [1, 2, 3, 4, 5]// 1console.log(arr.filter(x =&gt; x % 2 === 0).map(x =&gt; x * x).filter(x =&gt; x &gt; 10)); // 先过滤减少迭代次数// 2s = Math.sqrt(10) // 10开方算一次console.log(arr.filter(x =&gt; x &gt; s &amp;&amp; !(x % 2)).map(x =&gt; x * x))// 3let newarr = []arr.forEach(x =&gt; &#123; if (x &gt; s &amp;&amp; !(x % 2)) newarr.push(x * x);&#125;)console.log(newarr); 对象的操作 Object的静态方法 描述 Object.keys(obj) ES5开始支持。返回所有key Object.values(obj) 返回所有值，试验阶段，支持较差 Object.entries(obj) 返回所有值，试验阶段，支持较差 Object.assign(target, …sources) 使用多个source对象，来填充target对象，返回target对象第一参数是目标往往不说明，大部分赋值都是浅拷贝有重复的，后面的覆盖前面的 1234567891011121314151617181920212223242526272829const obj = &#123; a: 100, b: 200, c: 300&#125;;console.log(Object.keys(obj)); // key，ES5console.log(Object.values(obj)); // 值，实验性console.log(Object.entries(obj)); // 键值对，实验性// assignvar o1 = Object.assign(&#123;&#125;, obj, &#123; a: 1000, b: 2000 &#125;, /*覆盖*/ &#123; c: 'abc' &#125;, /*覆盖*/ &#123; c: 3000, d: 'python' &#125;); /*覆盖，新增*/console.log(o1);// 包装一个对象var o2 = new Object(o1);console.log(o2);/* 执行结果[ 'a', 'b', 'c' ][ 100, 200, 300 ][ [ 'a', 100 ], [ 'b', 200 ], [ 'c', 300 ] ]&#123; a: 1000, b: 2000, c: 3000, d: 'python' &#125;&#123; a: 1000, b: 2000, c: 3000, d: 'python' &#125;*/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-高阶对象]]></title>
    <url>%2Fjs%2FJS%20-%20%E9%AB%98%E9%98%B6%E5%AF%B9%E8%B1%A1%E3%80%81%E9%AB%98%E9%98%B6%E7%B1%BB%E6%88%96%E7%A7%B0Mixin%E6%A8%A1%E5%BC%8F%2F</url>
    <content type="text"><![CDATA[@tocMixin模式，混合模式 JS是基于对象的，类和对象都是对象模板混合mixin，指的是将一个对象的全部或者部分拷贝到另一个对象上去。其实就是属性可以将多个类或对象混合成一个类或对象 继承实现继承：子子孙孙都有基类的功能1234567891011121314151617181920class Serialization &#123; constructor() &#123; console.log('Serialization constructor~~~'); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125;&#125;//s = new Serialization(); // 构造Serialization失败//p = new Point(4,5); // 构造子类对象时，调用父类构造器执行也会失败 父类构造函数中，要求具有属性是stringify的序列化函数，如果没有则抛出异常 完整继承的代码1234567891011121314151617181920212223242526272829303132333435363738394041424344454647class Serialization &#123; constructor() &#123; console.log('Serialization constructor~~~'); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point extends Serialization &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); super(); // 调用父构造器 this.x = x; this.y = y; &#125; stringify() &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;&gt;` &#125;&#125;class Point3D extends Point &#123; constructor(x, y, z) &#123; super(x, y); this.z = z; &#125; stringify() &#123; return `&lt;Point x=$&#123;this.x&#125;, y=$&#123;this.y&#125;, z=$&#123;this.z&#125;&gt;` &#125;&#125;p = new Point(4, 5);console.log(p.stringify())p3d = new Point3D(7, 8, 9);console.log(p3d.stringify());/* 执行结果Point Constructor~~~~Serialization constructor~~~&lt;Point x=4, y=5&gt;Point Constructor~~~~Serialization constructor~~~&lt;Point x=7, y=8, z=9&gt;*/ 高阶对象实现将类的继承构建成箭头函数12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364// 普通的继承class A extends Object &#123; &#125;;console.log(A);// 匿名类const A1 = class &#123; constructor(x) &#123; this.x = x; &#125;&#125;console.log(A1);console.log(new A1(100).x);// 匿名继承const B = class extends Object &#123; constructor() &#123; super(); console.log('B constructor'); &#125;&#125;;console.log(B);b = new B();console.log(b);// 箭头函数，参数是类，返回值也是类// 把上例中的Object看成参数const x = (Sup) =&gt; &#123; return class extends Sup &#123; constructor() &#123; super(); console.log('C constructor'); &#125; &#125;;&#125;// 演化成下面的形式const C = Sup =&gt; class extends Sup &#123; constructor() &#123; super(); console.log('C constructor'); &#125;&#125;;//cls = new C(Object); // 不可以new，因为C是一个普通函数，它的返回值是一个带constructor的类cls = C(A); // 调用它返回一个类，一个带constructor的classconsole.log(cls);c = new cls();console.log(c);// 其它写法c1 = new (C(Object))(); // new优先级太高了，所有后面要加括号才能先调用/* 执行结果[Function: A][Function: A1]100[Function: B]B constructorB &#123;&#125;[Function: A]C constructorA &#123;&#125;C constructor*/ 说到底，上面的C这个函数，本质上就是传入一个基类，然后通过基类继承构造一个新的类。 Mixin类缺什么能力 补什么能力 可以改造上面序列化的例子1234567891011121314151617181920212223242526272829303132333435363738const SerializationMixin = Sup =&gt; class extends Sup &#123; constructor(...args) &#123; console.log('SerializationMixin constructor~~~'); super(...args); if (typeof (this.stringify) !== 'function') &#123; throw new ReferenceError('should define stringify.'); &#125; &#125;&#125;class Point &#123; constructor(x, y) &#123; console.log('Point Constructor~~~~'); this.x = x; this.y = y; &#125;&#125;class Point3D extends SerializationMixin(Point) &#123; constructor(x, y, z) &#123; super(x, y); // super是Serialization(Point)包装过的新类型 this.z = z; &#125; stringify() &#123; return `&lt;Point3D $&#123;this.x&#125;.$&#123;this.y&#125;.$&#123;this.z&#125;&gt;`; &#125;&#125;let p3d = new Point3D(70, 80, 90);console.log(p3d.stringify());/*执行结果SerializationMixin constructor~~~Point Constructor~~~~&lt;Point3D 70.80.90&gt;*/ 注意： Serialization(Point)这一步实际上是一个匿名箭头函数调用，返回了一个新的类型，Point3D继承自这个新的匿名类型，增强了功能。 React框架大量使用了这种Mixin技术 Serialization(Point)传入的参数是类，返回值也是一个类，这就是高阶类]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[网络概念]]></title>
    <url>%2F%E7%BD%91%E7%BB%9C%2F%E7%BD%91%E7%BB%9C%E6%A6%82%E5%BF%B5%2F</url>
    <content type="text"><![CDATA[@TOC 什么是网络 网络是由节点和连线构成的图，表示诸多对象及其关系什么是计算机网络 计算机网络指的是将地理位置不同的具有独立功能的多台计算机及其外部设备，通过通信线路物理连接（包括有线、无线连接），并在网络操作系统、网络管理软件和网络通信协议的管理和协调下，实现资源共享和信息传递的计算机系统带宽 在数字设备中，指的是单位时间数据的传输量 网络传输习惯上使用比特率，即bps每秒传输的二进制位数 拓扑总线型 所有设备都连接到公共总线上，结点间使用广播通信方式。一个结点发出的信息，总线上所有其他结点都可以接收到。一段时间只允许一个结点独占总线 常见使用同轴电缆连接，总线两端需要终结器优点 结构简单、易于实现 易于扩充，增加或者移除结点比较灵活 可靠性较高，个别结点发生故障时，不影响网络中其他结点的正常工作 缺点 网络传输能力低，安全性低，总线发生故障时，会导致全网瘫痪 所有数据都需要经过总线传输，总线是整个网络的瓶颈。结点数量的增多会影响网络性能环形结构 环形结构是将联网的计算机由通信线路连接成一个闭合的环，在环形结构网络中信息按照固定方向流动，或顺时针方向，或逆时针方向优点令牌控制，没有线路竞争，实时性强，传输控制容易缺点维护困难，可靠性不高。一个结点发生故障时，可能导致全网瘫痪。可以使用双环拓扑结构，但是复杂性提升星型拓扑 每个结点都由一条单独的通信线路与中心结点连结。其他各结点都与该中心结点有着物理链路的直接互连，其他结点直接不能直接通信，其他结点直接的通信需要该中心结点进行转发。因此中心结点必须有着较强的功能和较高的可靠性。需要中心设备，例如hub、switch、router优点 可靠性高，方便管理，易于扩展，传输效率高缺点 线路利用率低，中心节点需要很高的可靠性和冗余度注意 hub工作在一层，这种星型实际上就是芯片化的总线网络。只是物理拓扑结构上感觉像是星型OSI参考模型 OSI是Open System Interconnection的缩写，意为开放式系统互联。国际标准化组织（ISO）制定了OSI模型，该模型定义了不同计算机互联的标准，是设计和描述计算机网络通信的基本框架 OSI模型把网络通信的工作分为7层，分别是物理层、数据链路层、网络层、传输层、会话层、表示层和应用层 物理层 定义了电气规范，设备规范、物理接口等，电信号的变化，或数字信号变化，比特链路层 二层。将比特组织成帧，即对字节进行定义，支持错误检查。使用物理地址、MAC地址。MAC有48位，前24位厂商编号由IEEE分配，后24位设备序号网络层 三层。将帧组织成包，包传递的路径选择（路由），将包传输到目标地址。使用逻辑地址、IP地址传输层 四层。解决传输的问题，确保数据传输的可靠性；建立、维护、终止虚拟电路；错误检测和恢复会话层 建立、管理、终止应用程序间的逻辑通路，即会话表示层 对应用数据格式化、加密解密等。将上层数据转换为适合网络传输的格式，或将下层数据转化为上应用层 七层。为应用程序提供网络服务接口，用户使用的时候并不关心会话如何建立保持，也不关心协议的协商是否加密等数据传输 数据很大，在应用层切分，每一份数据都会在下一层被封装 在数据链路层会增加tail即校验位，最后在物理层上都是电平信号0、1发送出去 到了对端设备，由下至上逐层解包组合。直到合成并还原应用层的一份数据通讯的三种模式单播 包在计算机网络传输中，目的地址为单一目标的传输方式。每次都是点对点的2个实体间相互通信 广播 数据在网络中传输，目标地址是网络中所有设备的传输方式。所有设备是有范围的，这个范围称为广播域 IP v6不支持广播，由组播替代 多播、组播： 把数据同时传递给一组目的地址。数据源只发出一份数据，会在尽可能远的的设备上复制和分发 冲突域、广播域参看https://baike.baidu.com/item/%E5%B9%BF%E6%92%AD%E5%9F%9F 冲突域 网络中设备A发送数据时，设备B也发送数据，数据碰撞，发生了冲突，这两个设备就属于同一个冲突域 交换机可以隔离冲突域 路由器可以隔离广播域局域网LAN 局域网Local Area Network，指的是某一个区域内，多台计算机互联的计算机组常见组网设备网线、有线网卡、无线网卡、集线器、交换机、路由器等网络设备网络线缆 有线连接，需要使用网线，最早使用同轴电缆，后来使用双绞线，现在高速网络布线可以采用光纤 常用的双绞线使用RJ45水晶头 直通采用两端T568B，互连使用一端T568A一端T568B的交叉线，不过目前新型网卡可以自适应，都使用直通线连接即可集线器hub 工作在一层。使用HUB连接的设备看似是星型，实际是总线型 它是物理层设备，只认识电信号，所以根本不认识什么MAC地址之类的信息。早期用来多机互连，信号中继的作用户 连入设备越多，广播信号，在一个冲突域，网络效率很低 使用HUB连接的所有设备，都在同一个冲突域交换机switch 工作在二层。内部记录着MAC表，通过自学习，建立交换机端口和MAC地址对应表。内部有电路交换数据，如同信号立交桥。网桥也工作这一层路由器Router 工作在三层。内部记录路由表，记录着路由器的端口到 网络 对应关系。这个表可以静态配置，也可以动态更新 功能：分割广播域；选择路由；维护和检查路由信息；连接广域网广域网WAN 广域网，又称外网、公网。连接不同局域网或城域网的计算机通讯网络互联网Internet 互联网Internet，也称因特网。前身是美国军用ARPA网，后来连入了很多的科研院校，并逐步商业化走向全球 它连接了覆盖全球的网络，是众多的广域网互联的大型网络 互联网使用了TCP/IP协议TCP/IP协议栈 TCP/IP，Transmission Control Protocol/Internet Protocol ，传输控制协议/因特网互联协议 它是一个包含很多工作在不同层的协议的协议族，其中最著名的2个协议分别是TCP和IP协议 它最早起源于美国国防部（缩写为DoD）的ARPA网项目，共定义了四层：网络访问层、Internet层、传输层、应用层 TCP/IP协议是事实标准。目前局域网和广域网基本上也都用该协议传输层协议| | TCP|UDP||:–|:–|:–||连续类型 |面向连接 |无连接 || 可靠性| 可靠 | 不可靠 || 有序 | 数据包有序号 | 没有包序 || 使用场景 | 大多数场合，数据不能出任何问题 | 视频、音频 |连接 TCP需要通讯双方预先建立连接，需要三次握手、四次断开 UDP不需要预先建立连接可靠性 TCP需要确定每一个包是否收到，丢包重发，效率低一些 UDP尽最大努力交付数据，不要要确认数据包，丢包无法知道，也不重复，效率高一些有序 TCP包有序号，可以进行顺序控制。第一个包序号随机生成，之后的序号都和它有关 UDP包无序，无法纠正，只能在应用层进行验证TCP协议三次握手/四次断开 三次握手建立连接 Three-way Handshake Client端首先发送一个SYN包告诉Server端我的初始序列号是X Server端收到SYN包后回复给Client一个ACK确认包，告诉Client说我收到了。Server端也需要告诉Client端自己的初始序列号，于是Server也发送一个SYN包告诉Client我的初始序列号是Y。这两个包一起发送 Client收到后，回复Server一个ACK确认包说我知道了 四次断开 Client发送一个FIN包来告诉Server需要断开 Server收到后回复一个ACK确认FIN包收到 Server在自己也没数据发送给Client后，Server也发送一个FIN包给Client，表示也无数据发送 Client收到后，就会回复一个ACK确认Server的FIN包 主动发出Fin包就是主动关闭方，就会进入TIME_WAIT，原因是被动关闭方发来的FIN包需要确认，万一此包丢失，被动关闭方未收到确认会超时重发FIN包，主动关闭方还在，可以重发ACK。 IP地址 IP地址是IP协议提供的一种同一个地址格式，它为互联网上的网络设备分配一个用来通信的逻辑地址 目前分为IP v4和IP v6IP v4 IP v4 是一个32位二进制数，不便记忆，为了使用方便，使用“点分十进制”表示法，将这个二进制数每8位断开，每8位是一个字节，一个字节表示的十进制正整数范围是0~255 IP v4地址早期比较充足，随着全球连入互联网，在2011年IP v4地址分配完毕IP地址的分类 公有地址：需向因特网信息中心申请，在互联网上可以直接使用的IP地址 私有地址：不需要注册，可以组织内部网络使用的IP地址 IP地址这个数被分成2部分，即网络位 + 主机位 网络位表示设备同属一个网络；主机位表示网络中不同的设备的唯一ID子网掩码 子网掩码将IP地址划分为网络ID和主机ID IP地址 位与 子网掩码就是网络IDIP v4地址被分为A、B、C、D、E五类A类 最高位是 0 第一字节（最高字节）为网络位。第一个字节变化为 0000 0001 到 0111 1111，共127，减去回环地址，剩余126个网络 A类IP地址范围1.0.0.0到127.255.255.255。二进制表示为：00000001 00000000 00000000 00000000 至01111111 11111111 11111111 11111111。最后一个是广播地址。 子网掩码 255.0.0.0 每一个网络中主机个数等于 256³ - 2 = 1677716 -2 = 1677714B类 最高位是10 前2个字节为网络位，其变化为128.0~191.255，相当于 1000 0000 0000 0000 到 1011 1111 1111 1111，实际上就是后14位变化，共2^14 = 16384个网络 B类IP地址范围128.0.0.0-191.255.255.255 。二进制表示为：10000000 00000000 00000000 00000000 至10111111 11111111 11111111 11111111 最后一个是广播地址 子网掩码255.255.0.0 每一个网络中主机个数等于 256² - 2 = 65535 -2 = 65534C类 最高位是110 前3个字节为网络位，其变化为192.0.0~223.255.255，相当于1100 0000 0000 0000 0000 0000 到 1101 1111 1111 1111 1111 1111 ，实际上就是后21位变化，共2^21 = 2097152个网络。 C类IP地址地址范围192.0.0.0-223.255.255.255 。二进制表示为：11000000 00000000 00000000 00000000 至11011111 11111111 11111111 11111111。 最后一个是广播地址 子网掩码255.255.255.0 每一个网络中主机个数等于 256 -2 = 254D类 多播地址，或组播地址 多播地址最高4位必须是1110，那么地址范围就是224.0.0.0到239.255.255.255 224.0.0.1特指所有主机 E类 实验用地址 特殊IP地址 0.0.0.0表示当前主机 255.255.255.255 限制广播地址。路由器不会转发这个受限广播地址的数据报文，此地址只能用于本网广播 IP地址中以127开头的地址称为Loopback回环地址 169.254.x.x，windows主机使用了DHCP获取IP，但没有获得地址，windows会临时获得这样的地址 网关GATEWAY 网关(Gateway)又称网间连接器、协议转换器。网关在网络层以上实现网络互连，用于网络间互联举例 IP地址192.168.3.200，要配合子网掩码使用，假设子网掩码为255.255.255.0，说明它是C类地址 网络ID为192.168.3.0，广播地址为192.168.3.255 剩余192.168.3.1~192.168.3.254能够分配给网络中其他设备 网关地址配置一般习惯使用1、100、254等。本例使用192.168.3.1其作用是连接不同的网络，也称为处在不同的网段 又有一个IP地址为192.168.100.10/24，它也是C类地址，/16指B类地址，/8指A类地址。网络ID是192.168.100.0 和上面的IP处在不同的网络，这两个地址的主机通信，就需要使用网关，由网关将数据包转发到另一个网络IP v6 互联网上的公有地址在2011年分配完，而随着互联网的发展，接入设备越来越多，尤其是物联网的到来，此问题必须解决。由此，提出了IP v6 IP v6采用128位二进制数表示，基本解决IP地址短缺现象，同时，该协议还解决原有协议的诸多问题路由Routing 跨网络通信就需要使用路由，通过路由器将数据包从一个网络发往另一个网络 路由器上维护着路由表，它知道如何将数据包发往另外的网络 windows使用 route print ，Linux使用 route -n 可以查看路由表 路由器所有端口都有自己的IP地址，这些IP地址往往处在不同的网络，所以，路由器连接了不同了网络 路由表中记录着路由设备所有端口对应的网络，分为静态、动态配置 静态路由：由管理员手动配置的固定的路由信息 动态路由：网络中的路由器，根据实时网络拓扑变化，相互通信传递路由信息，利用这些路由信息通过路由选择协议动态计算，并更新路由表。常见的协议有RIP、OSPF等等网关：下一跳地址，就是到下一个网络，从哪个网关出去到192.168.0.0/24和10.0.0.0/8网络，R1本身就直接连接着这些网络，所以网关为空，不需要到172.16.0.0/16网络需要找到R2，所以写R2的接口1地址即可DHCP 动态主机设置协议（Dynamic Host Configuration Protocol，DHCP）是一个局域网的网络协议，基于UDP协议工作 主要用途就是用于内部网或网络服务供应商自动给网络中的主机分配IP地址]]></content>
      <categories>
        <category>网络</category>
      </categories>
      <tags>
        <tag>网络</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react技术]]></title>
    <url>%2F%E5%89%8D%E7%AB%AF%E6%A1%86%E6%9E%B6%2FReact%E6%8A%80%E6%9C%AF%2F</url>
    <content type="text"><![CDATA[@TOC 简介React是Facebook开发并开源的前端框架当时他们的团队在市面上没有找到合适的MVC框架，就自己写了一个Js框架，用来架设Instagram（图片分享社交网络）。2013年React开源 React解决的是前端MVC框架中的View视图层的问题 Virtual DOMDOM（文档对象模型Document Object Model） 将网页内所有内容映射到一棵树型结构的层级对象模型上，浏览器提供对DOM的支持，用户可以是用脚本调用DOM API来动态的修改DOM结点，从而达到修改网页的目的，这种修改是浏览器中完成，浏览器会根据DOM的改变重绘改变的DOM结点部分 修改DOM重新渲染代价太高，前端框架为了提高效率，尽量减少DOM的重绘，提出了Virtual DOM。Virtual DOM是一个JavaScript对象，性能更高。所有的修改都是先生成一个新的Virtual DOM，通过比较算法比较新旧Virtual DOM，得到差异化VirtualDOM，将这部分差异更新到浏览器DOM，浏览器只需要渲染这部分变化就行了 React实现了DOM Diff算法可以高效比对Virtual DOM支持JSX语法JSX是一种JavaScript和XML混写的语法，是JavaScript的扩展12345678React.render( &lt;div&gt; &lt;div&gt; &lt;div&gt;content&lt;/div&gt; &lt;/div&gt; &lt;/div&gt;, document.getElementById('example')); 测试程序替换 /src/index.js 为下面的代码12345678910import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; render() &#123; return &lt;div&gt;Hello World&lt;/div&gt;; &#125;&#125;ReactDom.render(&lt;Root/&gt;, document.getElementById('root')); 保存文件后，会自动编译，并重新装载刷新浏览器端页面 程序解释import React from &#39;react&#39;; 导入react模块import ReactDOM from &#39;react-dom&#39;; 导入react的DOM模块 class Root extends React.Component 组件类定义，从React.Component类上继承。这个类生成JSXElement对象即React元素render() 渲染函数。返回组件中渲染的内容。注意，只能返回唯一 一个顶级元素回去 ReactDom.render(&lt;Root/&gt;, document.getElementById(&#39;root&#39;)); 第一个参数是JSXElement对象，第二个是DOM的Element元素。将React元素添加到DOM的Element元素中并渲染 还可以使用React.createElement创建react元素，第一参数是React组件或者一个HTML的标签名称（例如div、span） 改写后代码为12345678910import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; render() &#123; //return &lt;div&gt;Hello World&lt;/div&gt;; return React.createElement('div', null, 'Hello World'); &#125;&#125;//ReactDom.render(&lt;Root/&gt;, document.getElementById('root'));ReactDom.render(React.createElement(Root), document.getElementById('root')); 很明显JSX更简洁易懂，推荐使用JSX语法 增加一个子元素 123456789101112131415161718192021import React from 'react';import ReactDom from 'react-dom';class SubEle extends React.Component &#123; render() &#123; return &lt;div&gt;Sub content&lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h2&gt;Hello World&lt;/h2&gt; &lt;br /&gt; &lt;SubEle /&gt; &lt;/div &gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 注意： React组件的render函数return，只能是一个顶级元素 JSX语法是XML，要求所有元素必须闭合，注意 &lt;br /&gt; 不能写成 &lt;br&gt;JSX规范 约定标签中首字母小写就是html标记，首字母大写就是组件 要求严格的HTML标记，要求所有标签都必须闭合 br也应该写成 &lt;br /&gt; ，/前留一个空格 单行省略小括号，多行请使用小括号 元素有嵌套，建议多行，注意缩进 JSX表达式：表达式使用{}括起来，如果大括号内使用了引号，会当做字符串处理，例如 &lt;div&gt;{&#39;2&gt;1?true:false&#39;}&lt;/div&gt; 里面的表达式成了字符串组件状态state每一个React组件都有一个状态属性state，它是一个JavaScript对象，可以为它定义属性来保存值如果状态变化了，会触发UI的重新渲染。使用setState()方法可以修改state值注意：state是每个组件自己内部使用的，是组件自己的属性 依然修改/src/index.js1234567891011121314151617181920import React from 'react';import ReactDom from 'react-dom';class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; // this.state.p1 = 'python.com'; // 可以修改属性值 // this.setState(&#123;p1:'python.com'&#125;); // 不可以对还在更新中的state使用setState // Warning: setState(...): Cannot update during an existing state transition (such as within render). setTimeout(() =&gt; this.setState(&#123; p1: 'python' &#125;), 5000); return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 如果将 ·this.state.p1 = ‘www.python&#39;· 改为 ·this.setState({p1:’python.com’});· 就会出警告 可以使用延时函数 setTimeout(() =&gt; this.setState({ p1: &#39;python.com&#39; }), 5000); 即可复杂的状态例子先看一个网页123456789101112131415&lt;html&gt;&lt;head&gt; &lt;script type="text/javascript"&gt; function getEventTrigger(event) &#123; x = event.target; // 从事件中获取元素 alert("触发的元素的id是：" + x.id); &#125; &lt;/script&gt;&lt;/head&gt;&lt;body&gt; &lt;div id="t1" onmousedown="getEventTrigger(event)"&gt; 点击这句话，会触发一个事件，并弹出一个警示框 &lt;/div&gt;&lt;/body&gt;&lt;/html&gt; div的id是t1，鼠标按下事件捆绑了一个函数，只要鼠标在对象上按下就会触发调用getEventTrigger函数，浏览器会送给它一个参数event。event是事件对象，当事件触发时，event包含触发这个事件的对象 HTML DOM的JavaScript事件 属性 此事件发生在何时 onabort 图像的加载被中断 onblur 元素失去焦点 onchange 域的内容被改变 onclick（常用） 当用户点击某个对象时调用的事件句柄 ondblclick 当用户双击某个对象时调用的事件句柄 onerror 在加载文档或图像时发生错误 onfocus 元素获得焦点 onkeydown 某个键盘按键被按下 onkeypress 某个键盘按键被按下并松开 onkeyup 某个键盘按键被松开 onload 一张页面或一幅图像完成加载 onmousedown 鼠标按钮被按下 onmousemove 鼠标被移动 onmouseout 鼠标从某元素移开 onmouseover 鼠标移到某元素之上 onmouseup 鼠标按键被松开 onreset 重置按钮被点击 onresize 窗口或框架被重新调整大小 onselect 文本被选中 onsubmit 确认按钮被点击 onunload 用户退出页面 使用React实现上面的传统的HTML1234567891011121314151617181920212223242526272829303132import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 分析Toggle类 它有自己的state属性 当render完成后，网页上有一个div标签，div标签对象捆绑了一个click事件的处理函数，div标签内有文本内容 如果通过点击左键，就触发了click方法关联的handleClick函数，在这个函数里将状态值改变 状态值state的改变将引发render重绘 如果组件自己的state变了，只会触发自己的render方法重绘 注意 {this.handleClick.bind(this)}，不能外加引号 this.handleClick.bind(this) 一定要绑定this，否则当触发捆绑的函数时，this是函数执行的上下文决定的，this已经不是触发事件的对象 console.log(event.target.id)，取回的产生事件的对象的id，但是这不是我们封装的组件对象。所以，console.log(event.target===this)是false。所以这里一定要用this，而这个this是通过绑定来的 this写在类中，始终指的是React组件实例本身 React中的事件 使用小驼峰命名 使用JSX表达式，表达式中指定事件处理函数 不能使用return false，如果要阻止事件默认行为，使用event.preventDefault() 属性propsprops就是组件的属性properties把React组件当做标签使用，可以为其增加属性，如下 &lt;Toggle name=&quot;school&quot; parent={this} /&gt; 为上面的Toggle元素增加属性： name = &quot;school&quot; ，这个属性会作为一个单一的对象传递给组件，加入到组件的props属性中 parent = {this} ，注意这个this是在Root元素中，指的是Root组件本身 在Root中为使用JSX语法为Toggle增加子元素，这些子元素也会被加入Toggle组件的props.children中 12345678910111213141516171819202122232425262728293031323334353637383940import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; state = &#123; flag: true &#125;; // 类中定义state handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1&#125;&#123;this.props.parent.state.p2&#125; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 尝试修改props中的属性值，会抛出 TypeError: Cannot assign to read only property &#39;name&#39; of object &#39;#&lt;Object&gt;&#39;异常 也就是说props在组件内部不能修改，只读 应该说，state是私有private的属于组件自己的属性，组件外无法直接访问。可以修改state，但是建议使用setState方法 props是公有public属性，组件外也可以访问，但组件内只读props是一种组件外部传入向组件内部传入数据的一种方式，只不过采用标签属性的方式 构造器constructor使用ES6的构造器，要提供一个参数props，并把这个参数使用super传递给父类1234567891011121314151617181920212223242526272829303132333435363738394041424344import React from 'react';import ReactDom from 'react-dom';class Toggle extends React.Component &#123; //state = &#123; flag: true &#125;; // 类中定义state constructor(props) &#123; super(props); // 一定要调用super父类构造器，否则报错 this.state = &#123; flag: true &#125;; // 类中定义state &#125; handleClick(event) &#123; console.log(event.target.id); console.log(event.target === this); console.log(this); console.log(this.state); this.setState(&#123; flag: !this.state.flag &#125;); &#125; render() &#123;/* 注意一定要绑定this onClick写成小驼峰 */ return &lt;div id="t1" onClick=&#123;this.handleClick.bind(this)&#125;&gt; 点击这句话，会触发一个事件。&#123;this.state.flag.toString()&#125;&lt;br /&gt; 显示props&lt;br /&gt; &#123;this.props.name&#125; : &#123;this.props.parent.state.p1&#125;&#123;this.props.parent.state.p2&#125; &#123;this.props.children&#125; &lt;/div&gt;; &#125;&#125;class Root extends React.Component &#123; // 定义一个对象 state = &#123; p1: 'www.python', p2: '.org' &#125;; // 构造函数中定义state render() &#123; return ( &lt;div&gt; &lt;div&gt;Welcome to &#123;this.state.p1&#125;&#123;this.state.p2&#125;&lt;/div&gt; &lt;br /&gt; &lt;Toggle name="school" parent=&#123;this&#125;&gt;&#123;/*自定义2个属性通过props传给Toggle组件对象*/&#125; &lt;hr /&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;span&gt;我是Toggle元素的子元素&lt;/span&gt;&#123;/*子元素通过props.children访问*/&#125; &lt;/Toggle&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 组件的生命周期组件的生命周期可分成三个状态： Mounting：已插入真实 DOM Updating：正在被重新渲染 Unmounting：已移出真实 DOM 组件的生命周期状态，说明在不同时机访问组件，组件正处在生命周期的不同状态上。在不同的生命周期状态访问，就产生不同的方法。 生命周期的方法如下： 装载组件触发 componentWillMount 在渲染前调用，在客户端也在服务端。只会在装载之前调用一次 componentDidMount : 在第一次渲染后调用，只在客户端。之后组件已经生成了对应的DOM结构，可以通过this.getDOMNode()来进行访问。 如果你想和其他JavaScript框架一起使用，可以在这个方法中调用setTimeout, setInterval或者发送A JAX请求等操作(防止异部操作阻塞UI)。只在装载完成后调用一次，在render之后 更新组件触发。这些方法不会在首次render组件的周期调用 componentWillReceiveProps(nextProps) 在组件接收到一个新的prop时被调用。这个方法在初始化render时不会被调用 shouldComponentUpdate(nextProps,nextState)返回一个布尔值。在组件接收到新的props或者state时被调用。在初始化时或者使用forceUpdate时不被调用 可以在你确认不需要更新组件时使用 如果设置为false，就是不允许更新组件，那么componentWillUpdate、componentDidUpdate不会执行 componentWillUpdate(nextProps, nextState) 在组件接收到新的props或者state但还没有render时被调用。在初始化时不会被调用 componentDidUpdate(prevProps, prevState) 在组件完成更新后立即调用。在初始化时不会被调用。 卸载组件触发 componentWillUnmount在组件从 DOM 中移除的时候立刻被调用由图可知 constructor构造器是最早执行的函数 组件构建好之后，如果更新组件的state或props（注意在组件内props是只读的），就会在render渲染前触发一系列的 更新生命周期函数 因此，重新编写/src/index.js构造两个组件，在子组件Sub中，加入所有生命周期函数 下面的例子添加是装载、卸载组件的生命周期函数123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354import React from 'react';import ReactDom from 'react-dom';class Sub extends React.Component &#123; constructor(props) &#123; console.log('Sub constructor') super(props); // 调用父类构造器 this.state = &#123; count: 0 &#125;; &#125; handleClick(event) &#123; this.setState(&#123; count: this.state.count + 1 &#125;); &#125; render() &#123; console.log('Sub render'); return (&lt;div id="sub" onClick=&#123;this.handleClick.bind(this)&#125;&gt; Sub's count = &#123;this.state.count&#125; &lt;/div&gt;); &#125; componentWillMount() &#123; // constructor之后，第一次render之前 console.log('Sub componentWillMount'); &#125; componentDidMount() &#123; // 第一次render之后 console.log('Sub componentDidMount'); &#125; componentWillUnmount() &#123; // 清理工作 console.log('Sub componentWillUnmount'); &#125;&#125;class Root extends React.Component &#123; constructor(props) &#123; console.log('Root Constructor') super(props); // 调用父类构造器 // 定义一个对象 this.state = &#123;&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;Sub /&gt; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); 上面可以看到顺序是 1constructor -&gt; componentWillMount -&gt; render -&gt; componentDidMount ----state或props改变----&gt; render 增加 更新组件函数为了演示props的改变，为Root元素增加一个click事件处理函数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980818283848586878889909192import React from 'react';import ReactDom from 'react-dom';class Sub extends React.Component &#123; constructor(props) &#123; console.log('Sub constructor') super(props); // 调用父类构造器 this.state = &#123; count: 0 &#125;; &#125; handleClick(event) &#123; this.setState(&#123; count: this.state.count + 1 &#125;);// 不要用++ &#125; render() &#123; console.log('Sub render'); return (&lt;div style=&#123;&#123; height: 200 + 'px', color: 'red', backgroundColor: '#f0f0f0', padding: '20px' &#125;&#125;&gt; &lt;a id="sub" onClick=&#123;this.handleClick.bind(this)&#125; style=&#123;&#123; backgroundColor: 'white' &#125;&#125;&gt; Sub's count = &#123;this.state.count&#125; &lt;/a&gt; &lt;/div&gt;); &#125; componentWillMount() &#123; // constructor之后，第一次render之前 console.log('Sub componentWillMount'); &#125; componentDidMount() &#123; // 第一次render之后 console.log('Sub componentDidMount'); &#125; componentWillUnmount() &#123; // 清理工作 console.log('Sub componentWillUnmount'); &#125; componentWillReceiveProps(nextProps) &#123; // props变更时，接到新props了，交给shouldComponentUpdate。 // props组件内只读，只能从外部改变 console.log(this.props); console.log(nextProps); console.log('Sub componentWillReceiveProps', this.state.count); &#125; shouldComponentUpdate(nextProps, nextState) &#123; // 是否组件更新，props或state方式改变时，返回布尔值，true才会更新 console.log('Sub shouldComponentUpdate', this.state.count, nextState); return true; // return false将拦截更新 &#125; componentWillUpdate(nextProps, nextState) &#123; // 同意更新后，真正更新前，之后调用render console.log('Sub componentWillUpdate', this.state.count, nextState); &#125; componentDidUpdate(prevProps, prevState) &#123; // 同意更新后，真正更新后，在render之后调用 console.log('Sub componentDidUpdate', this.state.count, prevState); &#125;&#125;class Root extends React.Component &#123; constructor(props) &#123; console.log('Root Constructor') super(props); // 调用父类构造器 // 定义一个对象 this.state = &#123; flag: true, name: 'root' &#125;; &#125; handleClick(event) &#123; this.setState(&#123; flag: !this.state.flag, name: this.state.flag ? this.state.name.toLowerCase() : this.state.name.toUpperCase() &#125;); &#125; render() &#123; return ( &lt;div id="app" onClick=&#123;this.handleClick.bind(this)&#125;&gt; My Name is &#123;this.state.name&#125; &lt;hr /&gt; &lt;Sub /&gt; &#123;/*父组件的render，会引起下一级组件的更新流程，导致props重新发送，即使子组件props没有 改变过*/&#125; &lt;/div&gt;); &#125;&#125;ReactDom.render(&lt;Root /&gt;, document.getElementById('root')); componentWillMount 第一次装载，在首次render之前。例如控制state、propscomponentDidMount 第一次装载结束，在首次render之后。例如控制state、props componentWillReceiveProps 在组件内部，props是只读不可变的，但是这个函数可以接收到新的props，可以对props做一些处理，this.props = {name:’roooooot’};这就是偷梁换柱。componentWillReceiveProps触发，也会走shouldComponentUpdateshouldComponentUpdate 判断是否需要组件更新，就是是否render，精确的控制渲染，提高性能componentWillUpdate 在除了首次render外，每次render前执行，componentDidUpdate在render之后调用 不过，大多数时候，用不上这些函数，这些钩子函数是为了精确的控制 修改Root组件render中的这一句为 &lt;div id=&quot;root&quot; onDoubleClick={this.handleClick.bind(this)}&gt; ，可以看到点击Sub中红色的文字，Root不会重绘 如果子组件和父组件使用了相同的事件，可以认为点击子组件也是点击了父组件，父组件重绘，就会把子组件props更新，引起子组件组件更新流程，就会从componentWillReceiveProps开始执行。如果子组件自己修改自己的state，不会执行componentWillReceiveProps 函数式组件 React从15.0开始支持函数式组件，定义如下1234567import React from 'react';import ReactDom from 'react-dom';function Root(props) &#123; return &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;&#125;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 开发中，很多情况下，组件其实很简单，不需要state状态，也不需要使用生命周期函数函数式组件的函数应该提供一个参数props，返回一个React元素函数式组件的函数本身就是render函数 改写上面代码123456import React from 'react';import ReactDom from 'react-dom';let Root = props =&gt; &lt;div&gt;&#123;props.schoolName&#125;&lt;/div&gt;;ReactDom.render(&lt;Root schoolName="Hello World" /&gt;, document.getElementById('root')); 以前函数式组件还有个名字叫stateless components无状态组件当前React发布了16.8，已经可以在函数式组件中使用state了，所以官方建议叫函数式组件]]></content>
      <categories>
        <category>前端框架</category>
        <category>react</category>
      </categories>
      <tags>
        <tag>react</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js-Promise]]></title>
    <url>%2Fjs%2FJS%20--%20Promise%E5%AF%B9%E8%B1%A1%2F</url>
    <content type="text"><![CDATA[@toc 概念ES6开始支持Promise对象用于一个异步操作的最终完成（包括成功和失败）及结果值的表示 简单说，就是处理异步请求的。之所以叫做Promise，就是我承诺做这件事，如果成功则怎么处理，失败则怎么处理12345// 语法new Promise( /* 下面定义的函数是executor */ function(resolve, reject) &#123;...&#125;); executor executor 是一个带有 resolve 和 reject 两个参数的函数 executor 函数在Promise构造函数执行时立即执行，被传递resolve和reject函数（executor 函数在Promise构造函数返回新建对象前被调用） executor 内部通常会执行一些异步操作，一旦完成，可以调用resolve函数来将promise状态改成fulfilled即完成，或者在发生错误时将它的状态改为rejected即失败 如果在executor函数中抛出一个错误，那么该promise 状态为rejected。executor函数的返回值被忽略 executor中，resolve或reject只能执行其中一个函数Promise的状态 pending: 初始状态，不是成功或失败状态 fulfilled: 意味着操作成功完成 rejected: 意味着操作失败1234567891011121314151617setInterval(function[, delay]); // 间隔多少毫秒就执行函数一次，循环执行setTimeout(function[, delay]); // 等待多少毫秒就执行函数一次，结束delay // 延时，缺省0，立即执行function // 延时到的时候执行的函数var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); &#125;, 3000); // &#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++')&#125;, 1000); // 每隔1秒执行一次 Promise.then(onFulfilled, onRejected)参数是2个函数，根据当前Promise对象A的状态来调用不同的函数，fulfilled走onFulfilled函数F1，rejected走onRejected函数F2then的返回值是一个新的promise对象B，执行任意一个回调函数，对这个promise对象来说就是其返回值调用任何一个函数后，其返回值可以被后续的then方法继续捕捉（链式） 任何一个回调函数执行，其返回值ret被resolve(ret)，作为B的完成结果1234567891011121314151617181920212223242526272829var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++');&#125;, 1000); // 每隔1秒执行一次let pro1 = myPromise.then( value =&gt; &#123; console.log('successful'); return 1111; &#125;, reason =&gt; &#123; console.log('failed'); return 2222; &#125;)setInterval(() =&gt; &#123; console.log(pro1, '@@@@');&#125;, 1000); // 每隔1秒执行一次 catch(onRejected) 为当前Promise对象A添加一个拒绝回调F，返回一个新的Promise对象B 如果A进入fulfilled状态，则A的完成结果作为B的完成结果 如果A进入rejected状态，回调F执行，F的返回值ret来resolve(ret) 12345678910111213141516171819202122var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)console.log(myPromise);setInterval(() =&gt; &#123; console.log(myPromise, '++++');&#125;, 1000); // 每隔1秒执行一次let pro2 = myPromise.catch(reason=&gt;&#123; console.log(reason, '****')&#125;)setInterval(() =&gt; &#123; console.log(pro2, '####');&#125;, 1000); // 每隔1秒执行一次 Promise 提供2个方法： Promise.resolve(value) 返回 状态为fulfilled的Promise对象 Promise.reject(reason)返回 状态为rejected状态的Promise对象12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152var myPromise = new Promise(function(resolve, reject)&#123; console.log('do sth.') setTimeout(()=&gt;&#123; console.log('~~~~~') resolve('ok'); //reject('error'); &#125;, 3000); // 延时3秒执行一次结束&#125;)let pro1 = myPromise.then( value =&gt; &#123;/*如果成功则显示结果*/ console.log(1, 'successful'); return 1111; &#125;, reason =&gt; &#123;/*如果失败则显示原因*/ console.log(2, 'failed'); return 2222; &#125;)let pro2 = myPromise.catch(reason=&gt;&#123; console.log(3, reason)&#125;)// 开始链式调用pro2.then( value =&gt; console.log(4, value), // value是什么？ reason =&gt; console.log(5, reason) // reason是什么？).then( value =&gt; &#123; console.log(6, value) // 已经不是pro2对象了，value是什么 return Promise.reject('pro2 =&gt; new Promise object rejected'); &#125;).catch( reason =&gt; &#123; console.log(7, reason); return Promise.resolve(reason + ' *') &#125;).then( value =&gt; console.log(8, value), // value是什么？ reason =&gt; console.log(9, reason) // reason是什么？) // 返回的是什么？/*执行结果do sth.~~~~~1 'successful'4 'ok'6 undefined7 'pro2 =&gt; new Promise object rejected'8 'pro2 =&gt; new Promise object rejected *'*/ 异步实例1234567891011121314151617181920212223242526272829303132333435363738function runAsync() &#123; return new Promise(function (resolve, reject) &#123; // 异步操作 setTimeout(function () &#123; console.log('do sth...'); resolve('ok...'); &#125;, 3000); &#125;);&#125;// 调用runAsync().then( value =&gt; &#123; console.log(value); return Promise.reject(value + '*'); &#125;).catch( reason =&gt; &#123; console.log(reason); return Promise.resolve(reason + '*'); &#125;).then( value =&gt; &#123; console.log(value); console.log('Promise END'); &#125;)console.log('==== FIN ====');/*执行结果==== FIN ====do sth...ok...ok...*ok...**Promise END*/]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[css]]></title>
    <url>%2Fjs%2FCSS%EF%BC%88Cascading%20Style%20Sheet%EF%BC%89%2F</url>
    <content type="text"><![CDATA[@TOC层叠样式表，控制HTML的布局和样式 使用方式三种使用方式 内联样式：在标签内使用属性stype 页内样式：在 &lt;head&gt; 标签中使用 &lt;style type=&quot;text/css&quot;&gt;&lt;/style&gt; 外部样式：使用CSS文件，使用 &lt;link rel=&quot;stylesheet&quot; type=&quot;text/css&quot; href=&quot;mystyle.css&quot;&gt; 优先级从高到低 基本语法selector {property1: value1, ..., propertyN:valueN} 例如 a {color:red; text-decoration:line-through} ，将链接标签文字颜色变成红色且有横线穿过 颜色写法123p &#123; color: #ff0000; &#125; /*大小写无所谓*/p &#123; color: #f00; &#125; /*FF0000的缩写*/p &#123; color: rgb(255,0,0); &#125; /*三原色表示，0~255*/ 颜色，写16进制，可以压缩 选择器标签选择器body {text-align: center} 上例直接使用HTML标签的选择器，就是标签选择器，元素选择器 注意，如果将标签改为*，表示统配所有HTML标签id选择器id指的是HTML标签内的属性id，例如 &lt;div id=&quot;menu&quot;&gt;# 代表 id123456#menu &#123; background-color: rgb(255, 255, 255); width: 100%; border-bottom: #f0f0f0 solid 1px; margin: 0px 0px 5px 0px;&#125; background-color 背景色border-bottom 向下的边界线margin 外边框 上 右 下 左 类选择器类，指的是标签中的class属性，例如 &lt;div class=&#39;main center&#39;&gt;1234.center &#123; width: 80%; margin: auto;&#125; 居中 margin:auto 选择器分组分组的选择就可以使用同样的样式声明同一个样式的时候可以使用可以是标签,可以是ID 也可以是class123h1,h2,h3,h4,h5,h6 &#123; color: green;&#125; 层次选择器1、后代选择器123div li &#123; display: inline;&#125; 所有div标签下任意层下的li标签123div#menu li &#123; display: inline;&#125; 2、子选择器123ul &gt; li &#123; display: inline;&#125; 所有div标签下直接的子元素li标签123div#menu ul &gt; li &#123; display: inline;&#125; 3、相邻兄弟选择器 兄弟标签改变属性，自己本身不改变123div.detail p + p &#123; color: green;&#125; 4、显示消失123div#menu ul &gt; li &#123; display: none;&#125; class为detail的div标签下任意层下的近邻p标签的下一个p标签 伪类 pseudo-classes 伪类能增加样式，类似于class 锚伪类，链接标签a的四种状态 1234a:link &#123;color: red&#125; /* 未访问的链接 */a:visited &#123;color: green&#125; /* 已访问的链接 */a:hover &#123;color: blue&#125; /* 鼠标移动到链接上 */a:active &#123;color: black&#125; /* 选定的链接 */ 伪类可以和css类配合使用 12345678910a.red:visited &#123;color: #FF0000&#125;a:hover &#123; color: red;&#125;a &#123; color: chartreuse; text-decoration-line: none;&#125;&lt;a class="red" href="css_syntax.asp"&gt;CSS Syntax&lt;/a&gt; 注意，伪类和前面部分中间不要有空格 伪元素pseudo-element伪元素能增加元素 :before 和 :after 可以在元素前后插入内容123456#homepage:after content:url(http://www.baidu.com/kczx/images/why1.png);&#125;a:before &#123; content:"这是链接~~~";&#125; 属性选择器 E [ attr ] { sRules } 具有某属性 E [ attr = value ] { sRules } 具有某属性且等于value E [ attr ~= value ] { sRules } 具有某属性且属性值中的一个是value `E [ attr = value ] { sRules }` 具有某属性且属性值使用了-，且-之前的部分是value的才匹配`*[class =”main”]能和` 减号之前的部分匹配 123456789101112131415161718链接具有href属性a[href] &#123; color: blue; text-decoration:line-through&#125;图片alt属性为magedu_logoimg[alt=magedu_logo] &#123; height: 20px;&#125;*[class="main center"] &#123; color:black&#125;*[class~="center"] &#123; color:black&#125; 继承1234body &#123; text-align: center; color:red;&#125; 观察整个页面文字颜色，几乎都变成了红色。页面中父元素中使用的样式，通过CSS继承，子孙元素将继承并使用祖先元素的属性，除非子元素重新定义了该属性 常见样式背景 background复合属性 http://www.w3school.com.cn/css/css_background.asp字体 font复合属性 http://www.w3school.com.cn/css/css_font.asp 表格border 123456789table&#123; border-collapse:collapse;&#125;table,td&#123; border: 1px solid black;&#125; margin外边距和padding内边距 12345678margin: top right bottom leftpadding: top right bottom leftpadding:10px 5px 15px 20px; /*顺时针上右下左*/padding:10px 5px 15px; /*上10px、左右5px、下15px*/padding:10px 5px; /*上下10px、左右5px*/padding:10px /*4方向全是10px*/margin:auto /*浏览器计算外边距*/ 内外边距都是顺时针设置4个方向，也可以单独设置 测试用HTML12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273&lt;html&gt;&lt;head&gt; &lt;title&gt;test page&lt;/title&gt; &lt;meta charset="utf-8"&gt; &lt;style type="text/css"&gt; &lt;/style&gt;&lt;/head&gt;&lt;body&gt; &lt;div class='main center'&gt; &lt;div id="menu"&gt; &lt;ul&gt; &lt;li&gt;&lt;a id="homepage"&gt;主页&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Linux&lt;/a&gt;&lt;/li&gt; &lt;li&gt;&lt;a&gt;Python&lt;/a&gt;&lt;/li&gt; &lt;/ul&gt; &lt;/div&gt; &lt;a href="https://github.com/" target="_blank" title="abc"&gt;请点击&lt;/a&gt;&lt;span&gt;inline span&lt;/span&gt; &lt;p&gt; &lt;span&gt;biggest title&lt;/span&gt; &lt;img src="https://github.githubassets.com/images/modules/site/integrators/google.png" alt="github_logo"&gt; &lt;/p&gt; &lt;div id='detail' name='detail' class="detail"&gt; &lt;p&gt;title&lt;/p&gt; &lt;p&gt;content&lt;/p&gt; &lt;/div&gt; &lt;div&gt; &lt;form action="" method="POST"&gt; &lt;table&gt; &lt;tr&gt; &lt;td&gt;用户名&lt;input name='h' type="hidden" value="001111256"&gt;&lt;/td&gt; &lt;td&gt;&lt;input name='username' type="text" value="abc"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;密码&lt;/td&gt; &lt;td&gt;&lt;input name='pwd' type="password"&gt;&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;性别&lt;/td&gt; &lt;td&gt;&lt;input name=gender type="radio" checked value="M"&gt;男&lt;input name=gender type="radio" value="F"&gt;女&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;爱好&lt;/td&gt; &lt;td&gt; &lt;input name="interest" type="checkbox" checked value="music"&gt;音乐 &lt;input name="interest" type="checkbox" checked value="movie"&gt;电影 &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td&gt;其他&lt;/td&gt; &lt;td&gt; &lt;textarea&gt; line1 line2 &lt;/textarea&gt; &lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;td colspan="2"&gt; &lt;input name=submit type="submit" value="提交"&gt; &lt;input type="reset" value="重置"&gt; &lt;/td&gt; &lt;/tr&gt; &lt;/table&gt; &lt;/form&gt; &lt;/div&gt; &lt;/div&gt;&lt;/body&gt;&lt;/html&gt;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[js语法]]></title>
    <url>%2Fjs%2FJS%E8%AF%AD%E6%B3%95%20--%20%E5%87%BD%E6%95%B0%E5%8F%8A%E5%BC%82%E5%B8%B8%2F</url>
    <content type="text"><![CDATA[@toc 函数123456789function 函数名(参数列表) &#123; 函数体; return 返回值;&#125;function add(x,y)&#123; return x+y;&#125;console.log(add(3,5)); 函数表达式使用表达式来定义函数，表达式中的函数名可以省略，如果这个函数名不省略，也只能用在此函数内部 匿名函数1234const add = function(x, y)&#123; return x + y;&#125;;console.log(add(4, 6) 有名字的函数表达式12345const sub = function fn(x, y) &#123; return x -y;&#125;console.log(sub(5, 3))// console.log(fn(3, 2)) // fn 只能用在函数内部 内部使用，相当于递归调用 12345const sub = function fn(n) &#123; if (n===1) return n; return n + fn(--n) // fn 只能在函数内部使用&#125;console.log(sub(4)) 函数、匿名函数、函数表达式的差异 函数和匿名函数，本质上都是一样的，都是函数对象，只不过函数有自己的标识符——函数名，匿名函数需要借助其它的标识符而已 区别在于，函数会声明提升，函数表达式不会123456789101112console.log(add(4,6))// 匿名函数function add(x, y)&#123; // 声明提升 return x + y;&#125;;// console.log(sub(5, 3)); // sub 未定义// 有名字的函数表达式const sub = function (x,y)&#123; return x - y;&#125;;console.log(sub(5, 3)); 高阶函数高阶函数：函数作为参数或返回一个函数 完成一个计数器counter 1234567891011const counter = function()&#123; let c = 0 return function()&#123; return ++c; &#125;;&#125;;const c = counter()console.log(c()) // 1console.log(c()) // 2console.log(c()) // 3 完成一个map函数：可以对某一个数组的元素进行某种处理 123456789101112131415161718const map = function(arr,fn)&#123; let newarr = []; for (let i in arr)&#123; newarr[i] = fn(arr[i]); &#125; return newarr&#125;console.log(map([1,2,3,4], function(x) &#123;return x++&#125;))console.log(map([1,2,3,4], function(x) &#123;return ++x&#125;))console.log(map([1,2,3,4], function(x) &#123;return x+1&#125;))console.log(map([1,2,3,4], function(x) &#123;return x+=1&#125;))// 执行结果[ 1, 2, 3, 4 ][ 2, 3, 4, 5 ][ 2, 3, 4, 5 ][ 2, 3, 4, 5 ] 另附counter的生成器版本，仅供参考123456789101112131415const counter = (function * () &#123; let c = 1 while (true) &#123; yield c++ &#125;&#125;)()console.log(counter.next())console.log(counter.next())console.log(counter.next())// 执行结果&#123; value: 1, done: false &#125;&#123; value: 2, done: false &#125;&#123; value: 3, done: false &#125; 箭头函数箭头函数就是匿名函数，它是一种更加精简的格式。将上例中的函数更改为箭头函数1234567891011121314151617const map = function(arr,fn)&#123; let newarr = []; for (let i in arr)&#123; newarr[i] = fn(arr[i]); &#125; return newarr&#125;// 以下三行等价console.log(map([1,2,3,4], (x) =&gt; &#123;return x*2&#125;));console.log(map([1,2,3,4], x =&gt; &#123;return x*2&#125;));console.log(map([1,2,3,4], x =&gt; x*2));// 执行结果[ 2, 4, 6, 8 ][ 2, 4, 6, 8 ][ 2, 4, 6, 8 ] 箭头函数参数 如果一个函数没有参数，使用() 如果只有一个参数，参数列表可以省略小括号() 多个参数不能省略小括号，且使用逗号间隔箭头函数返回值 如果函数体部分有多行，就需要使用{}，如果有返回值使用return 如果只有一行语句，可以同时省略大括号和return 只要有return语句，就不能省略大括号console.log(map([1,2,3,4], x =&gt; {return ++x})) ，有return必须有大括号 如果只有一条非return语句，加上大括号，函数就成了无返回值console.log(map([1,2,3,4], x =&gt; {x*2}));加上了大括号，它不等价于x =&gt;{return x*2}因此，记住 x =&gt; x*2 这种正确的形式就行函数参数普通参数 一个参数占一个位置，支持默认参数1234567const add = (x, y) =&gt; x + yconsole.log(add(4, 5)) // 9// 缺省值const add1 = (x, y=5) =&gt; x + yconsole.log(add1(4, 7)) // 11console.log(add1(4)) // 9 测试下面代码123456const add = (x=6, y) =&gt; x + yconsole.log(add()) // NaNconsole.log(add(1)) // NaNconsole.log(add(y=2, z=3)) // 5console.log(add(3, 4, 5, 6)) // 7 观察上面diamagnetic执行结果，原因 JS中并没有Python中的关键字传参 JS只是做参数位置的对应 JS并不限制默认参数的位置 JS传参个数超范围，多余的参数不影响函数调用 add2(y=2,z=3)相当于add2(2,3)，因为JS没有关键字传参，但是它的赋值表达式有值值，y=2就是2，z=3就是3建议，默认参数写到后面，这是一个好的习惯 可变参数(rest parameters剩余参数)JS使用…表示可变参数（Python用*收集多个参数）12345678910const sum = function (...args)&#123; let result = 0; console.log(...args) // 3 6 9 参数解构 for (let x in args)&#123; result += args[x] &#125;; return result&#125;;console.log(sum(3, 6, 9)) // 18 arguments对象函数的所有参数会被保存在一个arguments的键值对对象中123456789101112131415161718(function (p1, ...args) &#123; console.log(p1) console.log(args) console.log('----------------') console.log(arguments) // 对象 for (let x of arguments) // 该对象可以使用of console.log(x);&#125;)('abc', 1,3,5) // 执行结果abc[ 1, 3, 5 ]----------------[Arguments] &#123; '0': 'abc', '1': 1, '2': 3, '3': 5 &#125;abc135 ES6之前，arguments是唯一可变参数的实现。ES6开始，不推荐，建议使用可变参数。为了兼容而保留。注意，使用箭头函数，取到的arguments不是我们想要的，如下12345((x, ...args) =&gt; &#123; console.log(args); console.log(x); console.log(arguments);&#125;)(...[1,2,3,4]) 参数解构和Python类似，Js提供了参数解构，依然使用了...符号来解构1234const add = (x, y) =&gt; &#123;console.log(x,y);return x + y&#125;;console.log(add(...[100,200]))console.log(add(...[100,200,300,3,5,3]))console.log(add(...[100])) Js支持参数解构，不需要解构后的值个数和参数个数对应 函数返回值python 中可以使用 return 1,2 返回多值，本质上也是一个值，就是一个元组。Js中呢12const add = (x, y) =&gt; &#123;return x,y&#125;;console.log(add(4,100)); // 100 表达式的值 类C的语言，都有一个概念——表达式的值 赋值表达式的值：等号右边的值 逗号表达式的值：类C语言，都支持逗号表达式，逗号表达式的值，就是最后一个表达式的值1234567891011a = (x = 5, y = 6, true);console.log(a); //trueb = (123, true, z = 'test')console.log(b) // testfunction c() &#123; return x = 5, y = 6, true, 'ok';&#125;console.log(c()); // ok 所以，JS的函数返回值依然是单值 作用域1234567891011121314151617181920212223// 函数中变量的作用域function test()&#123; a = 100; var b = 200; let c = 300;&#125; // 先要运行test函数test()console.log(a);// console.log(b); // 不可见// console.log(c); // 不可见 // 块作用域中变量if (1)&#123; a = 100; var b = 200; let c = 300;&#125;console.log(a);console.log(b);// console.log(c); // 不可见 function是函数的定义，是一个独立的作用域，其中定义的变量在函数外不可见 var a = 100 可以提升声明，也可以突破非函数的块作用域 a = 100 隐式声明不能提升声明，在“严格模式”下会出错，但是可以把变量隐式声明为全局变量。建议少用 let a = 100 不能提升声明，而且不能突破任何的块作用域。推荐使用123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475function show(i, arg) &#123; console.log(i, arg)&#125;// 作用域测试x = 500;var j = 'jjjj';var k = 'kkkk';function fn()&#123; let z = 400; &#123; var o = 100; // var 作用域当前上下文 show(1, x); t = 'free'; // 此语句执行后，t作用域就是全局的，不推荐 let p = 200; &#125; var y = 300; show(2,z); show(3,x); show(4,o); show(5,t); //show(6,p); // 异常，let出不来上一个语句块 &#123; show(7,y); show(8,o); show(9,t); &#123; show(10,o); show(11,t); show(12,z); &#125; &#125; j = 'aaaa'; var k = 'bbbb'; show(20, j); show(21, k);&#125;// 先执行函数fn()show(22, j);show(23, k);//show(13,y); // 异常，y只能存在于定义的上下文中，出不了函数show(14,t); // 全局，但是严格模式会抛异常//show(15,o) // 看不到o，异常原因同yshow(16,z); // 变量声明提升，var声明了z，但是此时还没有赋值var z = 10;const m = 1//m = 2 // 常量不可以重新赋值// 执行结果1 5002 4003 5004 1005 'free'7 3008 1009 'free'10 10011 'free'12 40020 'aaaa'21 'bbbb'22 'aaaa'23 'kkkk'14 'free'16 undefined 严格模式 使用”use strict”;，这条语句放到函数的首行，或者js脚本首行异常抛出异常Js的异常语法和Java相同，使用throw关键字抛出。使用throw关键字可以抛出任意对象的异常1234567throw new Error('new error');throw new ReferenceError('Ref Error');throw 1;throw 'not ok';throw [1, 2, 3];throw &#123;'a':1&#125;;throw () =&gt; &#123;&#125;; // 函数 捕获异常try...catch 语句捕获异常try...catch...finally 语句捕获异常，finally保证最终一定执行 注意这里的catch不支持类型，也就是说至多一个catch语句 可以在catch的语句块内，自行处理异常12345678910111213141516try &#123; //throw new Error('new error'); //throw new ReferenceError('Ref Error'); //throw 1; //throw new Number(100); // throw 'not ok'; // throw [1,2,3]; // throw &#123;'a':1&#125;; throw () =&gt; &#123;&#125;; // 函数&#125; catch (error) &#123; console.log(error); console.log(typeof(error)); console.log(error.constructor.name);&#125; finally &#123; console.log('===end===')&#125;]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[数据库索引]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E6%95%B0%E6%8D%AE%E5%BA%93%E7%B4%A2%E5%BC%95%E7%9A%84%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86%2F</url>
    <content type="text"><![CDATA[数据库索引什么是数据库的索引, 图书馆的书就类似我们数据库表中的数据, 楼层索引排, 书架分类标识, 索书号就类似我们查找数据的索引.索引也可以理解为一本书的目录 .而当用户通过目录查询某个章节的某个知识点, ,所以可以有效的提高数据库系统的整体性能.那我们常用的数据库的索引底层的数据结构是什么样的.要了解数据库索引的底层原理,我们就得先了解一种叫树的数据结构, 而树中很经典的一种数据结构就是二叉树. 评价一个数据结构作为索引的优劣最重要的指标就是在查找过程中磁盘IO操作次数的渐进负杂度. 换句话说, 索引的结构组织要尽量减少查找过程中磁盘IO的存取次数. 二叉树(binary search trees)二叉树是每个结点最多有两个子树的树结构。通常子树被称作“左子树”（left subtree）和“右子树”（right subtree）。二叉树常被用于实现二叉查找树和二叉堆. b-树其实从算法逻辑上来讲, 二叉查找树的查找速度和比较次数都是最小的,但是, 我们不得不考虑一个现实问题:磁盘IO,数据库索引是存储在磁盘上的, 当数据量比较大的时候, 索引的大小可能有几个G甚至更多.当我们利用索引查询的时候, 能把整个索引全部加载到内存吗, 显然不可能, 能做的只有逐一加载每一个磁盘页, 这里的磁盘页对应着索引树的节点, 所以,最坏情况下, 磁盘IO次数等于索引树的高度,没错,既然如此,为了减少磁盘IO的次数, 我们就需要把原本”廋高”的树结构变的矮胖.这就是b-树的特征之一.b树是一种多路的平衡查找树, 他的每一个节点最多包含k个孩子,k被称为b树的阶.k的大小取决于磁盘页的大小. b-树在查询中的比较次数其实不比二叉查找树少, 尤其当单一节点中的元素量很多时,可是相比磁盘IO的速度, 内存中的比较耗时几乎可以忽略.所以只要树的高度足够低, IO次数就足够少,就可以提升查找性能.相比之下节点内部元素多一些也没有关系,仅仅是多了几次内存交互,只要不超过磁盘页的大小即可,这就是b-树的优势之一.b-树的一大优势就是自平衡. b-树主要应用于文件系统以及部分数据库索引, 比如著名的非关系型数据库Mongodb.而大部分关系型数据库,比如mysql, 则使用b+树作为索引. b+树b+ 树是基于b-树的一种变体,有着比b-树更高的查询性能. 平衡二叉树平衡二叉树是基于二分法的策略提高数据的查找速度的二叉树的数据结构 基础架构:一条sql查询语句是如何执行的. 1mysql&gt; select * from T where ID=10 大体来说, mysql可以分为server层和存储引擎层两部分. server层包括连接器, 查询缓存, 分析器, 优化器, 执行器等, 涵盖mysql的大多数核心服务功能, 以及所有的内置函数(如日期, 时间, 数学和加密函数等), 所有跨存储引擎的功能都在这一层实现, 比如存储过程,触发器吗视图等. 而存储引擎层负责数据的存储和提取 .其架构模式是插件式的, 支持innodb, mylsam, memory等多个存储引擎.现在常用的存储引擎是innodb, 它从mysql 5.5.5 版本开始成为了默认存储引擎. 也就是说, 你执行create table 建表的时候, 如果不指定引擎类型, 默认使用的就是innodb.不过你也可以通过指定存储引擎的类型来选择别的引擎, 比如在crate table语句中使用engine=memory, 来指定使用内存引擎创建表.不同存储引擎的表数据存取方式不同, 支持的功能也不同. 从图中不难看出, 不同的存储引擎共用一个server层, 也就是从连接器到执行器的部分. 连接器第一步,你会先连接到这个数据库上, 这时候接待你的就是数据库, 连接器负责跟客户端建立连接吗获取权限, 维持和管理连接.连接命令一般这么写 1mysql -h$ip -P$port -u$user -p 输完命令之后, 你就需要在交互对话里面输入密码.虽然密码也可以直接在-p后面写在命令行中, 但这样可能会导致你的密码泄露.如果你连的是生产服务器, 强烈建议你不要这么做. 连接命令中的mysql是客户端工具, 用来跟服务端建立连接.在完成经典的TCP握手后, 连接器就开始认证你的身份, 这个时候用的就是你输入的用户名和密码. 如果用户名或密码不对, 你就会收到一个”Access denied for user”的错误,然后客户端程序结束执行. 如果用户名密码认证通过, 连接器会权限表里面查出你拥有的权限.之后,这个连接里面的权限判断逻辑, 都将会依赖于此时读到的权限. 这就意味着, 一个用户成功建立连接后, 即使你用管理员账号对这个用户的权限做了修改, 也不会影响已经连接的权限.修改完成后, 只有再新建的连接才会使用新的权限设置.连接完成后, 如果你没有后续的动作, 这个连接就处于空闲状态, 你可以在show processlist命令中看到它.文本中这个图是show processlist的结果, 其中的command列显示为”sleep”的这一行, 就表示现在系统里面有一个空闲连接.客户端如果太长时间没动静, 连接器就会自动将它断开.这个时间是由wait_timeout控制的.默认值是8小时. 如果在连接被断开之后, 客户端再次发送请求的话, 就会收到一个错误提醒: Lost connection to mysql server during query/这时候如果你要继续, 就需要重连, 然后再执行请求了.数据库里面, 长连接是指连接成功后, 如果客户端持续有请求, 则一直使用同一个连接.短连接则是指每次执行完很少的几次查询就断开连接, 下次查询在重新建立一个.建立连接的过程通常是比较复杂的, 所以我建议你在使用中药尽量减少连接的动作,也就是尽量长连接. 但是全部使用长连接后, 你可能会发现, 有些时候mysql占用内存涨的特别空间快, 这是因为mysql在执行过程中临时使用的内存是管理在连接对象里面的. 这些资源会在连接断开的时候才会释放. 所以如果长连接累积下来, 可能导致内存占用太大.被系统强行杀掉(oom), 从现象看就是mysql异常重启.怎么解决这个问题,你可以考虑以下两种方案. 定期断开长连接.使用一段时间, 或者程序里面判断执行过一个占用内存的大查询后, 断开连接, 之后在查询再重连. 如果你用的是mysql 5.7 或更新版本,可以在每次执行一个比较大的操作后, 通过执行mysql_reset_connection来重新初始化连接资源.这个过程不需要重连做权限验证, 但是会将连接恢复到刚刚创建完时的状态. 查询缓存连接建立完成后, 你就可以执行select语句了.执行逻辑就会来到第二步: 查询缓存.mysql拿到一个查询请求后, 会先到查询缓存看看, 之前是不是执行过这条语句.之前执行过的这条语句及其结果可能会以key-value对的形式, 被直接缓存在内存中.key是查询的语句, value是查询的结果.如果你的查询能够直接在这个缓存中找到key, 那么这个value就会被直接返回给客户端. 如果语句不在查询缓存中, 就会继续后面的执行阶段.执行完成后, 执行结果会被存入查询缓存.你可以看到,如果查询命中缓存,mysql不需要执行后面的复杂操作,就可以直接返回结果, 这个效率会很高.但是大多数情况下我会建议你不要使用查询缓存, 为什么呢?因为查询缓存往往弊大于利. 查询缓存的实效非常频繁, 只有对一个表的更新, 这个表上所有的查询缓存都会被清空.因此很可能你费劲地把结果存起来, 还没使用呢, 就被一个更新全清空了.对于更新压力大的数据库来说, 查询缓存的命中率会非常低, 除非你的业务就是有一张静态表, 很长时间才会更新一次, 比如, 一个系统配置表, 那这张表上的查询才适合查询缓存. 好在mysql也提供了这种”按需使用”的方式.你可以将参数query_cache-type设置成DEMAND, 这样对于默认的sql语句都不使用查询缓存.而对于你确定要使用查询缓存的语句, 可以用sql_cache显示指定, 像下面这个语句一样:1mysql&gt;select sql_cache * from T where ID=10; 需要注意的是, mysql 8.0 版本直接将查询缓存的整个功能删掉了, 也就是说8.0开始彻底没有这个功能. 分析器如果没有命中查询缓存, 就要开始真正执行语句了.首先, mysql需要知道你要做什么, 因此需要对sql语句做解析. 分析器先做”语法分析”. 你输入的是有多个字符串和空格组成的一条sql语句, mysql需要识别里面的字符串分别是什么, 代表什么. mysql从你输入的”select”这个关键字识别出来, 这是一个查询语句, 他也是要把字符串”T”识别成”表名 T”, 把字符串”ID”识别成”列 ID”. 做完了这些识别以后, 就要做”语法分析”.根据词法分析的结果, 语法分析器会根据语法规则, 判断你输入的这个sql语句是否满足mysql语法. 如果你的语句不对, 就会收到”You have an error in your SQL syntax”的错误提醒, 比如下面这个语句select少打了开头的字母”s”. 一般语法错误会提示第一个出现错误的位置, 所以你要关注的是紧接”user near”的内容. 优化器经过了分析器, mysql就知道你要做什么了.在开始执行之前, 还要先经过优化器的处理. 执行器mysql通过分析器知道了你要做什么, 通过优化器知道了怎么做, 于是就进入了执行器阶段, 开始执行语句. 开始执行的时候, 要先判断一个你对这个表T有没有执行查询的权限, 如果没有, 就会返回没有权限的错误, 如下所示. 如果有权限, 就打开表继续执行, 打开表, 执行器就会根据表的引擎定义, 去使用这个引擎提供的接口.]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[前端]]></title>
    <url>%2Fjs%2F%E5%89%8D%E7%AB%AF%2F</url>
    <content type="text"><![CDATA[前端风云录 前端开发的历史和趋势 什么是前端 前端：针对浏览器的开发，代码在浏览器运行 后端：针对服务器的开发，代码在服务器运行 html html(hypertext markup language)超文本标记语言,它不同于编程语言 超文本就是超出纯文本的范畴, 例如描述文本的颜色、大小、字体等信息、 或使用图片音频、 视屏等非文本内容. 12345html定义了网页的内容css描述了网页的布局javascript网页的行为 cs原理client客户端向server发起请求 通过资源定位符, 找到映射文件, server端读取文件后, 一个个字节又通过管道发回到客户端, 客户端收到之后save下来, 打开html 文本流就是字节流(区别是字节流没有编码) . 前后端不分的时代互联网发展的早期，前后端开发是一体的，前端代码是后端代码的一部分。 后端收到浏览器的请求 生成静态页面 发送到浏览器 后端 MVC 的开发模式那时的网站开发，采用的是后端 MVC 模式。 Model（模型层）：提供/保存数据 Controller（控制层）：数据处理，实现业务逻辑 View（视图层）：展示数据，提供用户界面 前端只是后端 MVC 的 V。 以 PHP 框架 Laravel 为例。 前端工程师的角色那时的前端工程师，实际上是模板工程师，负责编写页面模板。 后端代码读取模板，替换变量，渲染出页面。 典型的 PHP 模板1234567891011&lt;html&gt; &lt;head&gt;&lt;title&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/title&gt;&lt;/head&gt; &lt;body&gt; &lt;h1&gt;Car &#123;&#123; $car-&gt;id &#125;&#125;&lt;/h1&gt; &lt;ul&gt; &lt;li&gt;Make: &#123;&#123; $car-&gt;make &#125;&#125;&lt;/li&gt; &lt;li&gt;Model: &#123;&#123; $car-&gt;model &#125;&#125;&lt;/li&gt; &lt;li&gt;Produced on: &#123;&#123; $car-&gt;produced_on &#125;&#125;&lt;/li&gt; &lt;/ul&gt; &lt;/body&gt;&lt;/html&gt; AjaxAjax 技术诞生，改变了一切。 2004年：Gmail 2005年：Google 地图 前端不再是后端的模板，可以独立得到各种数据。 Web 2.0Ajax 技术促成了 Web 2.0 的诞生。 Web 1.0：静态网页，纯内容展示 Web 2.0：动态网页，富交互，前端数据处理 从那时起，前端变得复杂了，对前端工程师的要求越来越高。 前端 MVC 框架前端通过 Ajax 得到数据，因此也有了处理数据的需求。 前端代码变得也需要保存数据、处理数据、生成视图，这导致了前端 MVC 框架的诞生。 2010年，Backbone.js Backbone.jsBackbone 将前端代码分成两个基本部分。 Model：管理数据 View：数据的展现 前端 ControllerBackbone 只有 M 和 V，没有 C。因为，前端 Controller 与后端不同。 不需要，也不应该处理业务逻辑 只需要处理 UI 逻辑，响应用户的一举一动 所以，前端 Controller 相对比较简单。Backbone 没有 C，只用事件来处理 UI 逻辑。 12345678var AppView = Backbone.View.extend(&#123; // ... events: &#123; "keypress #new-todo": "createOnEnter", "click #clear-completed": "clearCompleted", "click #toggle-all": "toggleAllComplete" &#125;,&#125;); Router前端还有一种天然的方法，可以切换视图，那就是 URL。 通过 URL 切换视图，这就是 Router（路由）的作用。以 Backbone 为例。 123456789101112App.Router = Backbone.Router.extend(&#123; routes: &#123; '': 'index', 'show': 'show' &#125;, index: function () &#123; $(document.body).append("调用了 Index 路由"); &#125;, show: function () &#123; $(document.body).append("调用了 Show 路由"); &#125;,&#125;); 示例：Backbone Router打开demos/backbone-demo/index.html，按照《操作说明》，查看示例。 MVVM 模式另一些框架提出 MVVM 模式，用 View Model 代替 Controller。 Model View View-Model：简化的 Controller，唯一作用就是为 View 提供处理好的数据，不含其他逻辑。 本质：view 绑定 view-model，视图与数据模型强耦合。数据的变化实时反映在 view 上，不需要手动处理。 SPA前端可以做到： 读写数据 切换视图 用户交互 这意味着，网页其实是一个应用程序。 SPA = Single-page application 2010年后，前端工程师从开发页面，变成了开发“前端应用”（跑在浏览器里面的应用程序）。 传统的架构 单页应用的架构 多了一个前端 MVC 层 AngularGoogle 公司推出的 Angular 是最流行的 MVVM 前端框架。 它的风格属于 HTML 语言的增强，核心概念是双向绑定。 示例：Angular 的双向绑定浏览器打开demos/angular-demo/index.html，可以看到一个输入框。 1234567891011&lt;div ng-app=""&gt; &lt;p&gt; 姓名 : &lt;input type="text" ng-model="name" placeholder="在这里输入您的大名" &gt; &lt;/p&gt; &lt;h1&gt;你好，&#123;&#123;name&#125;&#125;&lt;/h1&gt;&lt;/div&gt; VueVue.js 是现在很热门的一种前端 MVVM 框架。 它的基本思想与 Angular 类似，但是用法更简单，而且引入了响应式编程的概念。 示例：Vue 的双向绑定Vue 的模板与数据，是双向绑定的。 打开demos/vue-demo/index1.html，按照《操作说明》，查看示例。 HTML 代码 1234&lt;div id="journal"&gt; &lt;input type="text" v-model="message"&gt; &lt;div&gt;&#123;&#123;message&#125;&#125;&lt;/div&gt;&lt;/div&gt; JS 代码 123456var journal = new Vue(&#123; el: '#journal', data: &#123; message: 'Your first entry' &#125;&#125;); 前后端分离 Ajax -&gt; 前端应用兴起 智能手机 -&gt; 多终端支持 这两个原因，导致前端开发方式发生根本的变化。 前端不再是后端 MVC 中的 V，而是单独的一层。 REST 接口前后端分离以后，它们之间通过接口通信。 后端暴露出接口，前端消费后端提供的数据。 后端接口一般是 REST 形式，前后端的通信协议一般是 HTTP。 Node2009年，Node 项目诞生，它是服务器上的 JavaScript 运行环境。 Node = JavaScript + 操作系统 API Node 的意义 JavaScript 成为服务器脚本语言，与 Python 和 Ruby 一样 JavaScript 成为唯一的浏览器和服务器都支持的语言 前端工程师可以编写后端程序了 前端开发模式的根本改变 Node 环境下开发 大量使用服务器端工具 引入持续集成等软件工程的标准流程 开发完成后，编译成浏览器可以运行的脚本，放上 CDN 全栈工程师前端工程师正在转变为全栈工程师 一个人负责开发前端和后端 从数据库到 UI 的所有开发 全栈技能怎样才能称为全栈工程师？ 传统前端技能：HTML、JavaScript、CSS 一门后端语言 移动端开发：iOS / Android / HTML5 其他技能：数据库、HTTP 等等 软件行业的发展动力历史演变：前后端不分 -&gt; 前后端分离 -&gt; 全栈工程师 动力：更加产业化、大规模地生产软件 效率更高 成本更低 通用性好、能够快速产出的技术最终会赢，单个程序员的生产力要求越来越高。 H5 就是一个最好的例子为什么 H5 技术会赢得移动端？ 开发速度快：Native 需要重新编译才能看到结果，H5 是即时输出 开发成本低：Native 需要两个开发团队，H5 只要一个 快速发布：安卓 Native 新版本需要24小时，iOS 需要 3 ～ 4 天，H5 可以随时更新 未来软件的特点 联网 高并发 分布式 跨终端 现在基于 Web 的前端技术，将演变为未来所有软件的通用的 GUI 解决方案。 未来只有两种软件工程师 端工程师 手机端 PC 端 TV 端 VR 端 …… 云工程师]]></content>
      <categories>
        <category>js</category>
      </categories>
      <tags>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[sql]]></title>
    <url>%2F%E6%95%B0%E6%8D%AE%E5%BA%93%2F%E5%85%B3%E7%B3%BB%E6%A8%A1%E5%9E%8B%E5%92%8CSQL%2F</url>
    <content type="text"><![CDATA[@[toc] 关系模型和SQL为了介绍关系模型，以MySQL数据库为例 安装MariaDB 安装 # yum list | grep mariadb 123456789101112mariadb-libs.x86_64 1:5.5.60-1.el7_5 @anacondamariadb.x86_64 1:5.5.60-1.el7_5 base mariadb-bench.x86_64 1:5.5.60-1.el7_5 base mariadb-devel.i686 1:5.5.60-1.el7_5 base mariadb-devel.x86_64 1:5.5.60-1.el7_5 base mariadb-embedded.i686 1:5.5.60-1.el7_5 base mariadb-embedded.x86_64 1:5.5.60-1.el7_5 base mariadb-embedded-devel.i686 1:5.5.60-1.el7_5 base mariadb-embedded-devel.x86_64 1:5.5.60-1.el7_5 base mariadb-libs.i686 1:5.5.60-1.el7_5 base mariadb-server.x86_64 1:5.5.60-1.el7_5 base mariadb-test.x86_64 1:5.5.60-1.el7_5 base 安装mariadb 服务，会自动安装mairadb# yum install mariadb-server # systemctl start mariadb.service# ss -tanl12State Recv-Q Send-Q Local Address:Port Peer Address:PortLISTEN 0 50 *:3306 *:* 开机启动 systemctl enable mariadb.service```123456789101112131415- 为了安全设置Mysql服务`# mysql_secure_installation`- 数据库密码登录`# mysql -u root -p````pythonmysql&gt; show databases;+--------------------+| Database |+--------------------+| information_schema || mysql || performance_schema |+--------------------+3 rows in set (0.00 sec) 创建并授权用户 12mysql&gt; grant all on *.* to 'tom'@'%' identified by 'tom';mysql&gt; flush privileges; 导入测试脚本 testsql文件# mysql -u root -p &lt; test.sql 如果使用客户端连接数据库提示这个证明防火墙未关闭，CentOS7可以使用systemctl stop firewalld.service来关闭，或者参考下面连接https://www.cnblogs.com/moxiaoan/p/5683743.html SQL语句SQL是结构化查询语言Structured Query Language。1987年被ISO组织标准化所有主流的关系型数据库都支持SQL，NoSQL也有很大一部分支持SQL SQL语句分为 DDL数据定义语言，负责数据库定义、数据库对象定义，由CREATE、ALTER与DROP三种语句组成 DML数据操作语言，负责对数据库对象的操作，CRUD增删改查 DCL数据控制语言，负责数据库权限访问控制，由 GRANT 和 REVOKE 两个指令组成 TCL事务控制语言，负责处理ACID事务，支持commit、rollback指令语言规范 SQL语句大小写不敏感一般建议，SQL的关键字、函数等大写 SQL语句末尾应该使用分号结束 注释多行注释/*注释内容*/单行注释 -- 注释内容MySQL 注释可以使用# 使用空格或缩进来提高可读性 命名规范必须以字母开头可以使用数字、#、$和_不可使用关键字DCL GRANT授权、REVOKE撤销 12GRANT ALL ON employees.* TO 'tom'@'%' IDENTIFIED by 'tom';REVOKE ALL ON *.* FROM tom; *为通配符，指代任意库或者任意表。 *.* 所有库的所有表； employees.* 表示employees库下所有的表 % 为通配符，它是SQL语句的通配符，匹配任意长度字符串DDL删除用户（慎用）DROP USER tom;创建数据库 库是数据的集合，所有数据按照数据模型组织在数据库中 12CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci;CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8; CHARACTER SET指定字符集 utf8mb4是utf8的扩展，支持4字节utf8mb4，需要MySQL5.5.3+ COLLATE指定字符集的校对规则，用来做字符串的比较的。例如a、A谁大？删除数据库DROP DATABASE IF EXISTS gogs;创建表 表分为行和列，MySQL是行存数据库。数据是一行行存的，列必须固定多少列 行Row，也称为记录Record，元组 列Column，也称为字段Field、属性 字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值123456789CREATE TABLE `employees` ( `emp_no` int(11) NOT NULL, `birth_date` date NOT NULL, `first_name` varchar(14) NOT NULL, `last_name` varchar(16) NOT NULL, `gender` enum('M','F') NOT NULL, `hire_date` date NOT NULL, PRIMARY KEY (`emp_no`)) ENGINE=InnoDB DEFAULT CHARSET=utf8; 反引号标注的名称，会被认为是非关键字，使用反引号避免冲突 DESC查看列信息{DESCRIBE | DESC} tbl_name [col_name | wild]12DESC employees;DESC employees '%name'; 练习设计一张表，记录登录账户的注册信息，应该存储用户的姓名、登录名、密码12DROP DATABASE IF EXISTS test;CREATE DATABASE IF NOT EXISTS test CHARACTER SET utf8mb4 COLLATE utf8mb4_general_ci; 1234567CREATE TABLE `reg` ( `id` int(11) NOT NULL, `loginname` varchar(50) NOT NULL, `name` varchar(64) DEFAULT NULL, `password` varchar(128) NOT NULL, PRIMARY KEY (`id`)) ENGINE=InnoDB; 关系 在关系数据库中，关系就是二维表，由行和列组成行Row，也称为记录Record，元组列Column，也称为字段Field、属性 字段的取值范围叫做 域Domain。例如gender字段的取值就是M或者F两个值 维数：关系的维数指关系中属性的个数基数：元组的个数 注意在关系中，属性的顺序并不重要。理论上，元组顺序也不重要，但是由于元组顺序与存储相关，会影响查询效率 候选键 关系中，能唯一标识一条元组的属性或属性集合，称为候选键PRIMARY KEY主键 表中一列或者多列组成唯一的key，也就是通过这一个或者多个列能唯一的标识一条记录。即被选择的候选键 主键的列不能包含空值null。主键往往设置为整型、长整型，可以为自增AUTO_INCREMENT字段 表中可以没有主键，但是，一般表设计中，往往都会有主键，以避免记录重复Foreign KEY外键严格来说，当一个关系中的某个属性或属性集合与另一个关系（也可以是自身）的候选键匹配时，就称作这个属性或属性集合是外键索引Index可以看做是一本字典的目录，为了快速检索用的。空间换时间，显著提高查询效率可以对一列或者多列字段设定索引 主键索引，主键会自动建立主键索引，主键本身就是为了快速定位唯一记录的唯一索引，表中的索引列组成的索引必须唯一，但可以为空，非空值必须唯一普通索引，没有唯一性的要求，就是建了一个字典的目录而已 在MySQL中，InnoDB和MyISAM的索引数据结构可以使用Hash或BTree，默认是BTree Hash时间复杂度是O(1)，但是只能进行精确匹配，也就是Hash值的匹配，比如范围匹配就没办法了，hash值无序所以无法知道原有记录的顺序。Hash问题较多 BTree索引，以B+树为存储结构 虽然，索引可以提高查询所读，但是却影响增删改的效率，因为需要索引更新或重构。频繁出现在where子句中的列可以考虑使用索引。要避免把性别这种字段设索引 约束Constraint为了保证数据的完整正确，数据模型还必须支持完整性约束 “必须有值”约束 某些列的值必须有值，不许为空NULL域约束Domain Constraint 限定了表中字段的取值范围实体完整性Entity Integrity PRIMARY KEY约束定义了主键，就定义了主键约束。主键不重复且唯一，不能为空引用完整性Referential Integrity *** 外键定义中，可以不是引用另一张表的主键，但是，往往实际只会关注引用主键 外键：在表B中的列，引用了表A中的主键，表B中的列就是外键A表称为主表，B表称为从表插入规则 不需要指定 如果在表B插入一条记录，B的外键列插入了一个值，这个值必须是表A中存在的主键值更新规则 定义外键约束时指定该规则删除规则 定义外键约束时指定该规则外键约束的操作| 设定值| 说明 ||:–|:–|| CASCADE | 级联，从父表删除或更新会自动删除或更新子表中匹配的行 || SET NULL | 从父表删除或更新行，会设置子表中的外键列为NULL，但必须保证子表列没有指定NOT NULL，也就是说子表的字段可以为NULL才行|| RESTRICT | 如果从父表删除主键，如果子表引用了，则拒绝对父表的删除或更新操作 ||NO ACTION | 标准SQL的关键字，在MySQL中与RESTRICT相同。拒绝对父表的删除或更新操作 |外键约束，是为了保证数据完整性、一致性，杜绝数冗余、数据错误实体-联系E-R 数据库建立，需要收集用户需求，设计符合企业要求的数据模型。而构建这种模型需要方法，这种方法需要成为E-R实体-联系建模。也出现了一种建模语言——UML（Unified Modeling Language）统一建模语言 实体Entity：现实世界中具有相同属性的一组对象，可以是物理存在的事物或抽象的事物 联系Relationship：实体之间的关联集合实体间联系类型假设有实体部门，实体员工| 类型 | 描述| 解决方案||:–|:–|:–|| 一对多联系 1:n | 一个员工属于一个部门，一个部门有多个员工 |员工外键；部门主键 || 多对多联系 m:n| 一个员工属于多个部门，一个部门有多个员工 |建立第三表 || 一对一联系 1:1| 假设有实体管理者，一个管理者管理一个部门，一个部门只有一个管理者 |字段建在哪张表都行|一对一关系用的较少，往往表示表A的一条记录唯一关联表B的一条记录，反之亦然它往往是为了将一张表多列分割并产生成了多张表，合起来是完整的信息，或为了方便查询，或为了数据安全隔离一部分字段的数据等等视图视图，也称虚表，看起来像表。它是由查询语句生成的。可以通过视图进行CRUD操作视图的作用 简化操作，将复杂查询SQL语句定义为视图，可以简化查询 数据安全，视图可以只显示真实表的部分列，或计算后的结果，从而隐藏真实表的数据数据类型 MySQL中的数据类型 类型 含义 tinyint 1字节，带符号的范围是-128到127。无符号的范围是0到255。bool或boolean，就是tinyint，0表示假，非0表示真 smallint 2字节，带符号的范围是-32768到32767。无符号的范围是0到65535 int 整型，4字节，同Integer，带符号的范围是-2147483648到2147483647。无符号的范围是0到4294967295 bigint 长整型，8字节，带符号的范围是-9223372036854775808到9223372036854775807。无符号的范围是0到18446744073709551615 float 单精度浮点数精确到大约7位小数位 double 双精度浮点数精确到大约15位小数位 DATE 日期。支持的范围为’1000-01-01’到’9999-12-31’ DATETIME 支持的范围是’1000-01-01 00:00:00’到’9999-12-31 23:59:59’ TIMESTAMP 时间戳。范围是’1970-01-01 00:00:00’到2037年 char(M) 固定长度，右边填充空格以达到长度要求。M为长度，范围为0~255。M指的是字符个数 varchar(M) 变长字符串。M 表示最大列长度。M的范围是0到65,535。但不能突破行最大字节数65535 text 大文本。最大长度为65535(2^16-1)个字符 BLOB 大字节。最大长度为65535(2^16–1)字节的BLOB列 LENGTH函数返回字节数。而char和varchar定义的M是字符数限制 char可以将字符串定义为固定长度，空间换时间，效率略高；varchar为变长，省了空间关系操作关系：在关系数据库中，关系就是二维表关系操作就是对表的操作 选择（selection）：又称为限制，是从关系中选择出满足给定条件的元组 投影（projection）：在关系上投影就是从选择出若干属性列组成新的关系 连接（join）：将不同的两个关系连接成一个关系]]></content>
      <categories>
        <category>数据库</category>
        <category>mysql</category>
      </categories>
      <tags>
        <tag>数据库</tag>
      </tags>
  </entry>
</search>
