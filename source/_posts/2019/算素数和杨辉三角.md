---
title: 算素数和杨辉三角

categories:
- 算法习题
tags:
- 算法习题
---

# 求素数算法剖析
* 简单解法

  ```python
  n = 100
  for i in range(2,n):
    for x in range(2 ,int(i**0.5)+1):
        if i % x == 0:
            break
    else:
        count +=1
        print(x)
  ```


  for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.

* 使用奇数

```python
n = 100
count = 1
for x in range(3,n,2):
    for i in range(3,int(x**0.5)+1,2):
        if x % i ==0:
            break
    else:
        count += 1
print (count)
```

* 储存质素

合数一定可以分解为几个质数的乘积,2是质数
质数一定不能整除1和本身之内的整数

```python
n = 100
count = 1
pre
for x in range(3,n,2):
    for i in primenumbers:
        if x % i == 0:
            break
    else:
        premenumber.append(x)
        count +=1
print(count)
```


# 杨辉三角  
预先构成前两行 从而推到后面的所有行

```python
triandle = [[1],[1,1]]
for i in range(2,6):
    cur = [1]
    pre = triandle[i -1]
    for j in range(i-1):
        cur.append(pre[j] + pre[j + 1])
    cur.append(1)
    triandle.append(cur)
print(triandle)
```

变形

```python
triandle = []
n = 6
for i in range(n):
    cur = [1]
    triandle.append(cur)
   
if  i==0:continue
pre = triandle[i -1]
for  j in range(i -1):
    cur.append(pre[j] + pre[j + 1])
cur.append(1)
print(triandle)
```

补零法

```python
n = 6 
newline = [1]
print(newline)

for  i in range(1,n):
    oldline = newline.copy()
    oldline.append(0)
    newline.clear()
    
 
for j in range(i+1):
    newline.append(oldline[j -1] + oldline[j])

print(newline)
```

* 对称性 
一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.

```python
triandle = []
n = 6
for i in range(n):
    row = [1] * (i + 1)
    triandle.append(row)
```

    for j in range(1,i//2+1):
        val = triandle[i-1][j-1] + triandle[i -1][j]
        row[j]  = val
        row[-j-1] = val

```python
print(triandle)
triangle = []
n = 6
for i in range(n):
    row = [1] *(i +1)
    triangle.append(row)
    for  j in range(i,i//2+1):
        val = triangle[i-1][j-1] + triangle[i -1][j]
        row[j] = val
        if  i != 2*j:
            row[-j-i] = val
print(triangle)
```

单行覆盖法

```python
n = 6
row = [1] *n
print(row)
print('_' * 30)

for  i in range(n):
    for j in range(i//2):
        val = row[j] + row[j+1]
        row[j+1]=val
        if i != 2* (j+1):
            row[i-(j+1)] =val
    print(row[:i+1])
```




