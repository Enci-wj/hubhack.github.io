---
title: 草稿

password: mwq
---


在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当

你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它
并不真正构造列表。
我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结
束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代
器。list() 函数是另外一个（ 迭代器 ），
它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，
它能够用来遍历标准模板库容器中的部分或全部元素，
每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，
所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。
然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。

整理:3.29


回顾: 整型分长短,但在python3中已经没有了
bool 是整型的子类
math.sqrt 看帮助 官方文档
bin() 返回的字符串
type isinstance
list 是可迭代对象
index 匹配 count 匹配的次数
extend 魔术方法
"{},{}".format(1.2)

* **随机数**
instantiate 实例
fields领域
random模块
import random 
random.randint(1.2)
random.choice随机取数字 不均匀
for i in range(10):
sample 取样
元组: 不可变
命令元组namedtuple attribute属性特性
例子:
Point = namedtuple('Point',['x','y'])
p = Point(11,y=22)
namespace
exec 当python语句执行
命名元组,返回一个元组的子类,并定义了字段
冒泡法 重点
map高阶函数 映射
aplit 默认使用空白字符分隔
maxsplit
replace
strip 默认去掉字符两端的空白字符
find 时间复杂度和index一样遍历
format 函数格式字符串语法 
"{}".format()
参数解构*
"{}".format(3**0.5)
序列都可以用in
内置函数 5*14 itertor迭代器

冒泡法:经典排序算法
>for i in range(n):
>    for j in range(n-i):
>        num[j],num[j+1] = num[j+1],num[j]
>print()
内置函数说明
len(s)
返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）
zip()
创建一个聚合来自每个可迭代对象中元素的迭代器
返回一个元组的迭代器,其中
我们已经知道,可以直接作用于for循环的数据类型有以下几种:
一类是集合数据类型,如list tuple dictionary set str
一类是generator ,包括生成器和带yield的generator function
这些可以直接作用于for循环的对象统称为可迭代对象:iterable
而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.

# pythonnic
Python的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:

# 不够Pythonic
if a < b and a > c:
    pass

# python里却可以这么写
if c < a < b:
    pass

# bad
i = 0
while i < mylist_length:
    do_something(mylist[i])
    i += 1

# good
for element in mylist:
   do_something(element)

# bad, 不要使用默认可变对象作为默认参数
def f(a, b=[])
    pass

# good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题
def f(a, b=None):
    if b is None:
        b = []
Python有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。

# 列表生成式:
list comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式
举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))
但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：

>>> L = []
>>> for x in range(1, 11):
...    L.append(x * x)
...
>>> L
[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]

c 程序主要包括以下部分
预处理指令
函数
变量
语句
注释
# include <stdio.h>
int main()
{
    print("hello world");
    return 0;
}

# python 中的对象
对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.
Python对象的多态性

　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？
　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject*变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject *变量来保存和维护这个对象，而是通过PyObject *，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject*)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。

# python标准库

文本处理服务:string re textwrap
二进制数据服务
数据类型
数字和数学模块
函数式编程模块
文件和目录访问
数据持久化
数据压缩和存档
文件格式
加密服务
通用操作系统服务 os io time
并发执行 threading
网络和进程间通信
互联网数据处理 email json 
结构化标记处理工具 html xml
互联网协议和支持 urllib.request http.server
多媒体服务 imghdr
国际化
程序框架 cmd turtle
Tk图形用户界面 GUI
开发工具 调试和分析
软件打包和分发 venv
python运行时服务 sysbuiltins   gc垃圾回收器接口
自定义python解释器
导入模块
python语言服务
杂项服务
windows系统相关模块
unix专有服务
被取代的模块
未创建文档的模块

none 与NUll的区别
表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为
0,因为0是有意义的,而none是一个特殊的空值
判断的时候 均是false
属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被
调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.

功能性函数返回都为none
None是一个特殊的常量。
None和False不同。
None不是0。
None不是空字符串。
None和任何其他的数据类型比较永远返回False。
None有自己的数据类型NoneType。
你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。
L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。

单星号(*):*args 将所以参数以元组(tuple)的形式导入:
还有解压参数
双星号以字典的形式导入


# 字典 

字典是python的半壁江山 要熟练
可变的 ,无序的,key不重复
d[key]
返回key对应的值value
key不存在抛出keyerror异常

get(key[,defalut])
返回key对应的值value
key不存在返回缺省值,如果没有设置缺省值就返回none

setdefalut(key[,default])
返回key对应的值value
key不存在,添加kv对,value设置为default,并返回default

字典增加和修改

d[key] = value
将key对应的值修改为value
key不存在添加新的kv对

updata([other])
使用另一个字典的kv对更新本字典
key不存在,就添加
key存在,覆盖已经存在的key对应的值
就地修改

字典删除

pop(key[,default])
key不存在,移除他,并返回它的value
key不存在,返回给定的default
default未设置,key不存在则抛出Keyerror异常
popitem()
移除并返回一个任意的键值对
字典为empty,抛出KEyerror
clear()
清空字典

字典删除
del语句
a = True
b = [6]

字典遍历
for ...in dict
遍历key
for k in d:
print(k)

key的要求和set的元素要求一致
set的元素可以就是看做key,set可以看做dict的简化版
hashable可哈希才可以作为key, 可以使用hash()测试

defaultdict

# 解析式

列表解析list comprehension

语法
返回值 for 元素 in 可迭代 对象if 条件
使用中括号[],内部是for循环,if条件语句可选
返回一个新的列表

列表解析式是一种语法糖
编译器会优化,不会因为简写而影响效率,反而因优化提高了效率

# 生成器

python三剑客 生成器 装饰器 描述器
熟练运用
生成器表达式是按需计算 或惰性求值,延迟计算
列表解析式是立即返回值
生成器 是可迭代对象 迭代器

生成器表达式**
单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表
生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存
列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据

计算速度
单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长
但是生成器本身并没有返回任何值,只返回一个生成器对象
列表解析式构造并返回了一个新的列表,所以看起来耗时了

类似:字典,集合解析式

# collections 容器数据类型
这个模块实现了特定目标的容器
nametuple 创建命名元组子类的工厂函数

counter 字典的子类,提供了可哈希对象的计数功能
OrderedDict 字典的子类,保存了他们被添加的顺序
defaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.