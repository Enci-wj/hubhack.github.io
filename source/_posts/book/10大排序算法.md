---
title: 10大排序算法
categories: 
- 算法
tags:
- 算法
---
基本入门算法有三个经典算法:冒泡,选择和插入算法


### 选择排序

简单选择排序属于选择排序
两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端
结果分为升序和降序排列

基本思路:
* 求出最大索引(或最小索引)并记录
* 两两交换
* 补充特殊情况,完善代码

先用几个数做测试

```python
nums = [1, 9, 8]
length = len(nums)

maxindex = 0
for i in range(maxindex+1, length):
    if nums[i] > nums[maxindex]:
        maxindex = i
print(maxindex, nums[maxindex])
# 结果 1,9
# 做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]
# 做外层循环for i in range(length)
# 基本代码实现
nums = [1, 9, 8]
length = len(nums)
```

```python
maxindex = 0

for j in range(length):
    maxindex = j
    for i in range(maxindex+1, length):
        if nums[i] > nums[maxindex]:
            maxindex = i # 比较先确定索引 记录maxindex为最大索引
    if maxindex != i:
            nums[i], nums[maxindex] = nums[maxindex], nums[i]
print(nums)
```

做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序

第二种方法:

```python
import random
nums = list(range(10))
random.shuffle(nums)

length = len(nums)
```

```python
maxindex = 0

for i in range(length // 2):
    maxindex = i
    minindex = -1-i
    minorigin = length + minindex
    for j in range(i + 1, length - i):
        if nums[j] > nums[maxindex]:
            maxindex = j # 比较先确定索引 记录maxindex为最大索引
        if nums[-j-1] < nums[minindex]:
            minindex = -j-1
    if nums[maxindex] == nums[minindex]: break
    minindex = length + minindex
    if maxindex != i: # 进去 ,说明一定有交换
        nums[i], nums[maxindex] = nums[maxindex], nums[i]
        if minindex == i:
            minindex = maxindex
    if minindex != minorigin and nums[minorigin] != nums[minindex]:
        nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]
print(nums)
```

### 冒泡法

实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.
下面是使用代码的实现:

```python
arr = [7, 4, 3, 67, 34, 1, 8]

def bubble_sort(arr):
    n = len(arr)
    for j in range(0, n - 1):
        for i in range(0, n - 1 - j):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]

bubble_sort(arr)
print(arr)  # [1, 3, 4, 7, 8, 34, 67]

```

1
2
3
4
5
6
7
8
9
10
11
12
关键点其实在双重for循环变量的配置，我们来分析一下
第一次循环： j = 0, i~n-2 range(0, n-1)
第二次循环： j = 1, i~n-3 range(0, n-1-1)
第三次循环： j = 2, i~n-4 range(0, n-1-1-1)
—> range(0, n-1-j)

理解这一点后，我们就可以换一种写法来实现了

```python
def bubble_sort2(arr):
    for j in range(len(arr) - 1, 0, -1):  # [n-1, n-2, ....2, 1]
        for i in range(0, j):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]

bubble_sort2(arr)
print(arr)  # [1, 3, 4, 7, 8, 34, 67]
```

> 1
> 2
> 3
> 4
> 5
> 6
> 7
> 8
> 9
> 优化
> 写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化



```python
def bubble_sort3(arr):
    for j in range(len(arr)-1, 0, -1):
        count = 0
        for i in range(0, j):
            if arr[i] > arr[i + 1]:
                arr[i], arr[i + 1] = arr[i + 1], arr[i]
                count += 1
        if count == 0:
            return

bubble_sort3(arr)
print(arr)  # [1, 3, 4, 7, 8, 34, 67]
```


1
2
3
4
5
6
7
8
9
10
11
12
13
我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)


扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。


def add(x):
    return x + 5

### 插入排序

在未排序序列中, 构建一个字排序序列,直至全部数据排序完成
将待排序的数, 插入到已经排序的序列中合适的位置.
增加一个哨兵, 放在待比较值, 让他和后面已经排好序的序列比较,找到合适的插入点.

在列表前面增加哨兵位,可以是None空间复杂度为1, 时间复杂度On

```python
m_list = [1, 9, 8, 6, 5, 4, 3, 2, 2, 1]
nums = [0] + list[0]
length = len(nums)
count_move = 0
for i in range(2, length):
    nums[0] = nums[i]
    j = i - 1 
    if nums[j] > nums[0]:
        while nums[j] > nums[0]:
            nums[j+1] = nums[j]
            j -=1
            count_move += 1
        nums[j+1] = nums[0]
print(nums[1:])
```


总结: 交换依次从前至后,两两依次比较,从中选出最大将这个值交换到右边,之后第二个和第三个比较,在这一趟比较出最大的放在无序区里.无序区减少,有序区增加时间复杂度为大On**2,可以提前终.

选择排序: 就地排序,在这一趟选择极值,假定第一个最大,记录索引.比较完成后与真实最大的交换,有序区增加,无序区减少,优化算法一次性找出最大和最小,依次固定2个位置,复杂度高一点,不管你是升序还是降序,特殊情况,数值都是一样的.

插入排序: 在未排序序列中,构建一个子排序序列,直至全部数据排序完成.
将带排序的数,插入到已经排序的序列中合适的位置.
增加一个哨兵,放入待比较值,让他和后面已经排好序的序列比较,找到合适的插入点.

