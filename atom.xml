<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千分无言</title>
  
  <subtitle>人生苦短 我用python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hubhack.github.io/"/>
  <updated>2019-07-10T09:47:50.633Z</updated>
  <id>https://hubhack.github.io/</id>
  
  <author>
    <name>mwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>理解js中的promise</title>
    <link href="https://hubhack.github.io/book/%E7%90%86%E8%A7%A3js%20%E7%9A%84promise/"/>
    <id>https://hubhack.github.io/book/理解js 的promise/</id>
    <published>2019-07-10T08:08:50.783Z</published>
    <updated>2019-07-10T09:47:50.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.</p><p>简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line"><span class="comment">/*下面定义的函数是executor*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>executor是一个带有resolve和reject 两个参数的函数.</p><p>executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败.</p><p>如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略.</p><p>executor中, resolve或reject只能执行其中一个函数.</p><p>promise的状态</p><ul><li>fulfilled:意味着操作成功完成</li><li>pending:初始状态,不是成功或失败状态</li></ul><ul><li>rejected: 意味着操作失败.</li></ul><p><strong>Promise.then(onfilled, onRejected)</strong></p><p>参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉.</p><p><strong>catch(onRejected)</strong></p><p>为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象.</p><p>Promise提供2个方法:</p><ul><li>Promise.resolve(value)返回 状态为fulfilled的Promise对象</li><li>Promise.reject(reason)返回 状态为rejected状态的Promise对象.</li></ul><p>catch其实是then(undefined, () =&gt; {})的语法糖,如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">p.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch'</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调.</p><p>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'do sth ----'</span>)</span><br><span class="line">            resolve(<span class="string">'ok----'</span>)</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">runAsync().then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(value + <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(reason + <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Promise end'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'========='</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.&lt;/p&gt;
&lt;p&gt;简单说, 就是处理异步请求的.
      
    
    </summary>
    
      <category term="js" scheme="https://hubhack.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://hubhack.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>序列化与json</title>
    <link href="https://hubhack.github.io/book/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson/"/>
    <id>https://hubhack.github.io/book/序列化与json/</id>
    <published>2019-07-04T02:31:22.966Z</published>
    <updated>2019-07-04T02:45:41.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.</p><p>如果是自己定义的类的实例, 如何保存到一个文件中.</p><p>如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例.</p><p>要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化.</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>serialization 序列化</p><p>将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制</p><p>deserialization 反序列化</p><p>将文件的一个个字节恢复成内存中对象 &lt;-二进制</p><p>序列化保存到文件就是持久化.</p><p>可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化.</p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>JSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。</p><p>json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。</p><h2 id="1、JSON语法规则"><a href="#1、JSON语法规则" class="headerlink" title="1、JSON语法规则"></a>1、JSON语法规则</h2><p>JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。</p><p><strong>（1）简单值</strong></p><p>简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单值</span></span><br><span class="line"><span class="string">"Hello World!"</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="number">99</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">false</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JSON中不能使用的值</span></span><br><span class="line"><span class="literal">NaN</span> <span class="comment">// 数值不能是NaN</span></span><br><span class="line"><span class="literal">Infinity</span> <span class="comment">// 数值不能是Infinity</span></span><br><span class="line"><span class="literal">undefined</span> <span class="comment">// 在JSON也不可以使用JavaScript中的undefined</span></span><br><span class="line"><span class="string">'Hello World!'</span> <span class="comment">// 字符串必须使用双引号表示，不能使用单引号</span></span><br><span class="line"><span class="number">0x1</span> <span class="comment">// 数值必须以十进制表示，不能使用十六进制</span></span><br></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p>对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">"isStudent"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"isLeader"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"mark"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"school"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"BIT"</span>,</span><br><span class="line">    <span class="string">"region"</span>: <span class="string">"Beijing"</span> <span class="comment">// 这个地方不能有逗号，因为是对象的最后一个属性成员</span></span><br><span class="line">  &#125; <span class="comment">// 这个地方也不可以有逗号，因为也是对象的最后一个属性成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）数组</strong></p><p>数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line">[<span class="string">"Andy"</span>, <span class="string">"Ruby"</span>, <span class="string">"Danny"</span>, <span class="string">"Peter"</span>, <span class="string">"Lisa"</span>]</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment">// 示例三</span></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Andy"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Ruby"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Danny"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 示例四</span></span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="2、JSON字符串和JSON对象"><a href="#2、JSON字符串和JSON对象" class="headerlink" title="2、JSON字符串和JSON对象"></a>2、JSON字符串和JSON对象</h2><p><strong>（1）JSON字符串</strong></p><p>JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure><p><strong>（2）JSON对象</strong></p><p>JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON对象</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><strong>（3）JSON字符串和JSON对象互相转换</strong></p><p>JavaScript中有一个全局的对象，JSON。JSON中有两个方法 <em>stringify() 和 parse()。</em></p><p><em>JSON.parse()</em> 把JSON字符串解析为JSON对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串通过parse转化为JSON对象</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line">person = <span class="built_in">JSON</span>.parse(p)</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><em>JSON.stringify()</em> 用于把JSON对象序列化为JSON字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON对象通过stringify转化为JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">JSON</span>.stringify(person)</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h3&gt;&lt;p&gt;内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.&lt;/p&gt;
&lt;p&gt;如果是自己定义的
      
    
    </summary>
    
      <category term="json" scheme="https://hubhack.github.io/categories/json/"/>
    
    
      <category term="序列化" scheme="https://hubhack.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>编程的4门功课</title>
    <link href="https://hubhack.github.io/book/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91/"/>
    <id>https://hubhack.github.io/book/计算机4科/</id>
    <published>2019-07-01T08:29:49.176Z</published>
    <updated>2019-07-01T08:57:33.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><p>首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。<br>综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。<br>最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。<br>其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。</p><h3 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h3><p>综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。<br>比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。<br>理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。</p><p>现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！<br>我希望我写过的程序能在任何一台机上运行。<br>我希望我能边听音乐边干活——即同一时间可以运行多个程序。<br>我希望别人写的傻×东西不要影响到我的工作——即多任务控制。<br>我希望计算机里面的各种资源都能得到良好的组织，更快的访问。<br>我希望我的用户界面更好看，使用更方便，功能更强大！<br>我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！<br>如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。<br>计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。</p><p>而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。<br>操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。<br>操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。<br>当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。</p><p>既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。<br>我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。</p><p>至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构的作用, 就是为了提高硬件利用率.</p><p>比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。</p><p>数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h3><p>计算机网络分为3块：</p><p>硬件<br>网卡，网线，交换机这些，用来处理数据的。</p><p>协议<br>数据在网络中通信如何组织？如何识别？如何保证数据的正确性？<br>这2块我就不多说了。</p><p>操作系统<br>这就是如何把计算机网络和操作系统结合起来的问题了。<br>对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。<br>操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。<br>传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。</p><p>网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h3&gt;&lt;p&gt;首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：
      
    
    </summary>
    
      <category term="计算机" scheme="https://hubhack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="https://hubhack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>web路由</title>
    <link href="https://hubhack.github.io/book/web%E8%B7%AF%E7%94%B1/"/>
    <id>https://hubhack.github.io/book/web路由/</id>
    <published>2019-07-01T02:02:08.604Z</published>
    <updated>2019-07-01T02:24:12.031Z</updated>
    
    <content type="html"><![CDATA[<p>web开发中路由route和路由器router到底是什么</p><h3 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h3><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p><h3 id="2-router和route的区别"><a href="#2-router和route的区别" class="headerlink" title="2. router和route的区别"></a>2. router和route的区别</h3><p>route就是一条路由，它将一个URL路径和一个函数进行映射，例如：</p><blockquote><p>/users -&gt; getAllUsers()</p><p>/users/count -&gt; getUsersCount()</p></blockquote><p>这就是两条路由，当访问<code>/users</code>的时候，会执行<code>getAllUsers()</code>函数；当访问<code>/users/count</code>的时候，会执行<code>getUsersCount()</code>函数。</p><p>而router可以理解为一个容器，或者说一种机制，它管理了一组<code>route</code>。简单来说，<code>route</code>只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由<code>router</code>来处理的。一句话概括就是 “The router routes you to a route”。</p><h3 id="3-服务器端路由"><a href="#3-服务器端路由" class="headerlink" title="3. 服务器端路由"></a>3. 服务器端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。</p><p>以Express为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(&apos;index&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&apos;/users&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  db.queryAllUsers()</span><br><span class="line">    .then(data =&gt; res.send(data))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里定义了两条路由：</p><ul><li>当访问/的时候，会返回index页面</li><li>当访问/users的时候，会从数据库中取出所有用户数据并返回</li></ul><blockquote><p>不仅仅是URL</p><p>在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。</p></blockquote><h3 id="4-客户端路由"><a href="#4-客户端路由" class="headerlink" title="4. 客户端路由"></a>4. 客户端路由</h3><p>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：</p><ul><li>基于Hash</li><li>基于History API</li></ul><h4 id="1-基于Hash"><a href="#1-基于Hash" class="headerlink" title="(1) 基于Hash"></a>(1) 基于Hash</h4><p>我们知道，URL中#及其后面的部分为hash。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line">var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)</span><br><span class="line">console.log(a.hash)</span><br><span class="line">// =&gt; #/foo/bar</span><br></pre></td></tr></table></figure><p>hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。</p><p>通过监听window对象的hashChange事件，可以实现简单的路由。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function() &#123;</span><br><span class="line">  var hash = window.location.hash</span><br><span class="line">  var path = hash.substring(1)</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-基于History-API"><a href="#2-基于History-API" class="headerlink" title="(2) 基于History API"></a>(2) 基于History API</h4><p>通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考：</p><p>Manipulating the browser history<br>Using the HTML5 History API<br>我们可以通过监听window对象的popstate事件，来实现简单的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = function() &#123;</span><br><span class="line">  var path = window.location.pathname</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pushState = history.pushState</span><br><span class="line">history.pushState = function() &#123;</span><br><span class="line">  pushState.apply(history, arguments)</span><br><span class="line"></span><br><span class="line">  // emit a event or just run a callback</span><br><span class="line">  emitEventOrRunCallback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，最好的方法还是使用实现好的history库。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="(3) 两种实现的比较"></a>(3) 两种实现的比较</h4><p>总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。</p><p>但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。</p><p>假设服务器只有如下文件（script.js被index.html所引用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line"> |- index.html</span><br><span class="line"> |- script.js</span><br></pre></td></tr></table></figure><p>基于Hash的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/#/foobar</span><br></pre></td></tr></table></figure><p>基于History API的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/foobar</span><br></pre></td></tr></table></figure><p>当直接访问<code>http://example.com/</code>的时候，两者的行为是一致的，都是返回了<code>index.html</code>文件。</p><p>当从<code>http://example.com/</code>跳转到<code>http://example.com/#/foobar</code>或者<code>http://example.com/foobar</code>的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。</p><p>当直接访问<code>http://example.com/#/foobar</code>的时候，实际上向服务器发起的请求是<code>http://example.com/</code>，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。</p><p>当直接访问<code>http://example.com/foobar</code>的时候，实际上向服务器发起的请求也是<code>http://example.com/foobar</code>，然而服务器端只能匹配<code>/</code>而无法匹配<code>/foobar</code>，因此会出现404错误。</p><p>因此如果使用了基于History API的路由，需要改造服务器端，使得访问<code>/foobar</code>的时候也能返回<code>index.html</code>文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。</p><h4 id="5-动态路由"><a href="#5-动态路由" class="headerlink" title="5. 动态路由"></a>5. 动态路由</h4><p>上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。</p><p>例如在Express中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">  // ... ...</span><br><span class="line">&#125;)</span><br><span class="line">在Flask中：</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/user/&lt;user_id&gt;&apos;)</span><br><span class="line">def get_user_info(user_id):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h4 id="6-严格路由"><a href="#6-严格路由" class="headerlink" title="6. 严格路由"></a>6. 严格路由</h4><p>在很多情况下，会遇到<code>/foobar</code>和<code>/foobar/</code>的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。</p><p>在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到<code>/foobar/</code>，而反过来则不会。</p><p>如果使用的是<code>Express</code>，默认这两者是一样的，也可以通过<code>app.set</code>来设置<code>strict routing</code>，来区别对待这两种情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web开发中路由route和路由器router到底是什么&lt;/p&gt;
&lt;h3 id=&quot;1-什么是路由&quot;&gt;&lt;a href=&quot;#1-什么是路由&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是路由&quot;&gt;&lt;/a&gt;1. 什么是路由&lt;/h3&gt;&lt;p&gt;在Web开发过程中，经常
      
    
    </summary>
    
      <category term="web" scheme="https://hubhack.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://hubhack.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>yaml语言</title>
    <link href="https://hubhack.github.io/book/Yaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    <id>https://hubhack.github.io/book/Yaml语言编程/</id>
    <published>2019-07-01T02:00:31.456Z</published>
    <updated>2019-07-01T02:24:34.296Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Yaml语言编程"><a href="#Yaml语言编程" class="headerlink" title="Yaml语言编程"></a>Yaml语言编程</h3><p>Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便.</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><p>它的基本语法规则如下。</p><blockquote><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul></blockquote><p><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p><p>YAML 支持的数据结构有三种。</p><blockquote><ul><li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul></blockquote><p>以下分别介绍这三种数据结构。</p><h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>对象的一组键值对，使用冒号结构表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; animal: pets</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">animal</span>: <span class="string">'pets'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hash: &#123; <span class="attr">name</span>: Steve, <span class="attr">foo</span>: bar &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">hash</span>: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">foo</span>: <span class="string">'bar'</span> &#125; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><p>一组连词线开头的行，构成一个数组。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; - Cat</span><br><span class="line">&gt; - Dog</span><br><span class="line">&gt; - Goldfish</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; -</span><br><span class="line">&gt;  - Cat</span><br><span class="line">&gt;  - Dog</span><br><span class="line">&gt;  - Goldfish</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ] ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>数组也可以采用行内表示法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; animal: [Cat, Dog]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、复合结构"><a href="#四、复合结构" class="headerlink" title="四、复合结构"></a>四、复合结构</h2><p>对象和数组可以结合使用，形成复合结构。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; languages:</span><br><span class="line">&gt;  - Ruby</span><br><span class="line">&gt;  - Perl</span><br><span class="line">&gt;  - Python </span><br><span class="line">&gt; websites:</span><br><span class="line">&gt;  YAML: yaml.org </span><br><span class="line">&gt;  Ruby: ruby-lang.org </span><br><span class="line">&gt;  Python: python.org </span><br><span class="line">&gt;  Perl: use.perl.org </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">&gt;   websites: </span><br><span class="line">&gt;    &#123; <span class="attr">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">&gt;      Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">&gt;      Python: <span class="string">'python.org'</span>,</span><br><span class="line">&gt;      Perl: <span class="string">'use.perl.org'</span> &#125; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、纯量"><a href="#五、纯量" class="headerlink" title="五、纯量"></a>五、纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。</p><blockquote><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul></blockquote><p>数值直接以字面量的形式表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; number: <span class="number">12.30</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">number</span>: <span class="number">12.30</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>布尔值用<code>true</code>和<code>false</code>表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; isSet: <span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">isSet</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>null</code>用<code>~</code>表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent: ~ </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>时间采用 ISO8601 格式。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; iso8601: <span class="number">2001</span><span class="number">-12</span><span class="number">-14</span>t21:<span class="number">59</span>:<span class="number">43.10</span><span class="number">-05</span>:<span class="number">00</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">iso8601</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2001-12-14t21:59:43.10-05:00'</span>) &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>日期采用复合 iso8601 格式的年、月、日表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date: <span class="number">1976</span><span class="number">-07</span><span class="number">-31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1976-07-31'</span>) &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>YAML 允许使用两个感叹号，强制转换数据类型。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; e: !!str <span class="number">123</span></span><br><span class="line">&gt; f: !!str <span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">e</span>: <span class="string">'123'</span>, <span class="attr">f</span>: <span class="string">'true'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>字符串是最常见，也是最复杂的一种数据类型。</p><p>字符串默认不使用引号表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: 这是一行字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'这是一行字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果字符串之中包含空格或特殊字符，需要放在引号之中。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: <span class="string">'内容： 字符串'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'内容: 字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>单引号和双引号都可以使用，双引号不会对特殊字符转义。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; s1: <span class="string">'内容\n字符串'</span></span><br><span class="line">&gt; s2: <span class="string">"内容\n字符串"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">s1</span>: <span class="string">'内容\\n字符串'</span>, <span class="attr">s2</span>: <span class="string">'内容\n字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: <span class="string">'labor'</span><span class="string">'s day'</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'labor\'s day'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: 这是一段</span><br><span class="line">&gt;   多行</span><br><span class="line">&gt;   字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'这是一段 多行 字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">this</span>: |</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;   Bar</span><br><span class="line">&gt; that: &gt;</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;   Bar</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">this</span>: <span class="string">'Foo\nBar\n'</span>, <span class="attr">that</span>: <span class="string">'Foo Bar\n'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; s1: |</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt; </span><br><span class="line">&gt; s2: |+</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; s3: |-</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">s1</span>: <span class="string">'Foo\n'</span>, <span class="attr">s2</span>: <span class="string">'Foo\n\n\n'</span>, <span class="attr">s3</span>: <span class="string">'Foo'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>字符串之中可以插入 HTML 标记。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; message: |</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &lt;p style="color: red"&gt;</span><br><span class="line">&gt;     段落</span><br><span class="line">&gt;   &lt;/p&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">message</span>: <span class="string">'\n&lt;p style="color: red"&gt;\n  段落\n&lt;/p&gt;\n'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="七、引用"><a href="#七、引用" class="headerlink" title="七、引用"></a>七、引用</h2><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; defaults: &amp;defaults</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; development:</span><br><span class="line">&gt;   database: myapp_development</span><br><span class="line">&gt;   &lt;&lt;: *defaults</span><br><span class="line">&gt; </span><br><span class="line">&gt; test:</span><br><span class="line">&gt;   database: myapp_test</span><br><span class="line">&gt;   &lt;&lt;: *defaults</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>等同于下面的代码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; defaults:</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; development:</span><br><span class="line">&gt;   database: myapp_development</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; test:</span><br><span class="line">&gt;   database: myapp_test</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>&amp;</code>用来建立锚点（<code>defaults</code>），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; - &amp;showell Steve </span><br><span class="line">&gt; - Clark </span><br><span class="line">&gt; - Brian </span><br><span class="line">&gt; - Oren </span><br><span class="line">&gt; - *showell </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ <span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、函数和正则表达式的转换"><a href="#八、函数和正则表达式的转换" class="headerlink" title="八、函数和正则表达式的转换"></a>八、函数和正则表达式的转换</h2><p>这是 <a href="https://github.com/nodeca/js-yaml" target="_blank" rel="noopener">JS-YAML</a> 库特有的功能，可以把函数和正则表达式转为字符串。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # example.yml</span><br><span class="line">&gt; fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&gt; reg: <span class="regexp">/test/</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>解析上面的 yml 文件的代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> yaml = <span class="built_in">require</span>(<span class="string">'js-yaml'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> doc = yaml.load(</span><br><span class="line">&gt;     fs.readFileSync(<span class="string">'./example.yml'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&gt;   );</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(doc);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(e);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>从 JavaScript 对象还原到 yaml 文件的代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> yaml = <span class="built_in">require</span>(<span class="string">'js-yaml'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> obj = &#123;</span><br><span class="line">&gt;   fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&gt;   reg: <span class="regexp">/test/</span></span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;   fs.writeFileSync(</span><br><span class="line">&gt;     <span class="string">'./example.yml'</span>,</span><br><span class="line">&gt;     yaml.dump(obj),</span><br><span class="line">&gt;     <span class="string">'utf8'</span></span><br><span class="line">&gt;   );</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(e);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Yaml语言编程&quot;&gt;&lt;a href=&quot;#Yaml语言编程&quot; class=&quot;headerlink&quot; title=&quot;Yaml语言编程&quot;&gt;&lt;/a&gt;Yaml语言编程&lt;/h3&gt;&lt;p&gt;Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便.&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="yaml" scheme="https://hubhack.github.io/categories/yaml/"/>
    
    
      <category term="yaml" scheme="https://hubhack.github.io/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>js基础</title>
    <link href="https://hubhack.github.io/book/js%E5%9F%BA%E7%A1%80/"/>
    <id>https://hubhack.github.io/book/js基础/</id>
    <published>2019-06-30T11:53:54.879Z</published>
    <updated>2019-07-01T08:24:16.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js基础语法"><a href="#js基础语法" class="headerlink" title="js基础语法"></a>js基础语法</h3><hr><h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><p>标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写.</p><p>声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var声明一个变量</span><br><span class="line"></span><br><span class="line">let声明一个块作用域中的局部变量</span><br><span class="line"></span><br><span class="line">const声明一个常量</span><br><span class="line"></span><br><span class="line">js中的变量声明和初始化时可以分开的.</span><br><span class="line"></span><br><span class="line">var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug.</span><br></pre></td></tr></table></figure><p>数据类型</p><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>number</td><td>数值型,包括整型和浮点型</td></tr><tr><td>2</td><td>boolean</td><td>布尔型,true和false</td></tr><tr><td>3</td><td>string</td><td>字符串</td></tr><tr><td>4</td><td>null</td><td>只有一个值null</td></tr><tr><td>5</td><td>undefined</td><td>变量声明未赋值的;对象未定义的属性</td></tr><tr><td>6</td><td>symbol</td><td>ES6新引入类型</td></tr><tr><td>7</td><td>object</td><td>是以上基本类型的复合类型,是容器</td></tr></tbody></table><p>弱类型,不需要强制类型转换, 会隐式类型转换.</p><p>NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN</p><p>总结:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.</span><br><span class="line"></span><br><span class="line">如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.</span><br><span class="line"></span><br><span class="line">如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.</span><br><span class="line"></span><br><span class="line">除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换.</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>条件表达式?真值:假值</p><p>等价于简单的if…else结构</p><p>函数, 匿名函数,函数表达式的差异</p><p>函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已.</p><p>区别在于, 函数会声明提升, 函数表达式不会 .</p><p>高阶函数: 函数作为参数或返回 一个函数.</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数列表</span>)</span>&#123;</span><br><span class="line">函数体;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h4 id="函数-匿名函数-函数表达式的差异"><a href="#函数-匿名函数-函数表达式的差异" class="headerlink" title="函数, 匿名函数, 函数表达式的差异"></a>函数, 匿名函数, 函数表达式的差异</h4><p>函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已.</p><p>区别在于, 函数会申明提升, 函数表达式不会.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x -y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">5</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>高阶函数</p><p>高阶函数: 函数作为参数或返回一个函数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数就是匿名函数,它是一种更加精简的格式.</p><p>箭头函数参数</p><ul><li><p>如果一个函数没有参数,使用()</p></li><li><p>如果只有一个参数,参数列表可以省略小括号()</p></li><li><p>多个参数不能省略小括号,且使用逗号间隔.</p></li></ul><p><strong>箭头函数返回值.</strong></p><p>如果函数体部分有多行,就需要使用{}, 如果有返回值使用return.</p><p>如果只有一行语句, 可以同时省略大括号和return.</p><p>只有return语句, 就不能省略大括号, </p><p>如果只有一条非return语句, 加上大括号, 函数就成了无返回值, </p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h5 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h5><p>一个参数占一个位置,支持默认参数.</p><p>可变参数(rest parameters剩余参数)</p><p>js使用…表示可变参数(python用*手机多个参数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> args)&#123;</span><br><span class="line">result += args[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>函数的所有参数会被保存在一个arguments的键值对对象中.</p><h4 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h4><p>和python类似, js提供了参数解构, 依然使用了…符号来结构.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span>&#123;<span class="built_in">console</span>.log(x, y); <span class="keyword">return</span> x + y&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>, <span class="number">200</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>]))</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组.</p><p>表达式的值</p><p>类c的语言,都有一个概念 – 表达式的值</p><p>赋值表达式的值: 等号右边的值</p><p>逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值.</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>抛出异常</p><p>js的异常语法和java相同, 使用throw关键字抛出.</p><p>使用throw关键字可以抛出任意对象的异常.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'new error'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">'Ref Error'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'not ok'</span>;</span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>try…catch语句捕获异常</p><p>try …catch…finally 语句捕获异常, finally保证最终一定执行.</p><h4 id="问题-null和undefined的异同"><a href="#问题-null和undefined的异同" class="headerlink" title="问题: null和undefined的异同"></a>问题: null和undefined的异同</h4><p>1.undefined：是所有没有赋值变量的默认值，自动赋值。</p><p>2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</p><p>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。</p><p><strong>共同点</strong>：都是原始类型，保存在栈中变量本地。</p><p>不同点：</p><p>undefined——表示变量声明过但并未赋过值。</p><p>它是所有未赋值变量默认值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a;    // a 自动被赋值为 undefined</span><br></pre></td></tr></table></figure><p>null——表示一个变量将来可能指向一个对象。</p><p>一般用于主动释放指向对象的引用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var emps = [&apos;ss&apos;,&apos;nn&apos;];</span><br><span class="line"> emps = null;     // 释放指向数组的引用</span><br></pre></td></tr></table></figure><p>它是专门释放对象内存的一个程序。</p><ul><li>在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；</li><li>总有一个对象不再被任何变量引用时，才释放</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js基础语法&quot;&gt;&lt;a href=&quot;#js基础语法&quot; class=&quot;headerlink&quot; title=&quot;js基础语法&quot;&gt;&lt;/a&gt;js基础语法&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="前端" scheme="https://hubhack.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScrript" scheme="https://hubhack.github.io/tags/JavaScrript/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法</title>
    <link href="https://hubhack.github.io/book/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/魔术方法/</id>
    <published>2019-06-23T14:04:28.585Z</published>
    <updated>2019-06-19T14:49:09.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>__name__</td><td>类,函数,方法等名字</td></tr><tr><td>__module__</td><td>类定义所在的模块名</td></tr><tr><td>__class__</td><td>对象或类所属的类</td></tr><tr><td>__base__</td><td>类的基类的元组,顺序为他们在基类中出现的顺序</td></tr><tr><td>__doc__</td><td>类, 函数的文档字符串, 如果没有定义则为None</td></tr><tr><td>__mro__</td><td>类的mro, class.mro()返回的结果的保存在__mro__ 中</td></tr><tr><td>__dict__</td><td>类或实例的属性, 可写的字典</td></tr></tbody></table><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><p>__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.</p><p>如果dir()参数obj包括方法_<em>dir__(), 该方法将被调用.如果参数obj不包含\</em>_dir__(), 该方法将最大限度地收集属性信息.</p><p>dir(obj)对于不同类型的对象obj具有不同的行为:</p><ul><li>如果对象是模块对象, 返回的列表包含模块的属性名和变量名</li><li>如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名</li><li>如果是类的实例<ul><li>有__dir__方法, 返回可迭代对象的返回值</li><li>没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名</li></ul></li><li>如果obj不写, 返回列表包含内容不同<ul><li>在模块中, 返回模块的属性和变量名</li><li>在函数中, 返回本地作用域的变量名</li><li>在方法中,  返回本地作用域的变量名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animal.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self._name = name</span><br><span class="line">        self.__age = <span class="number">10</span></span><br><span class="line">        self.weight = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'animal Module\ s names = &#123;&#125;'</span>.format(dir()))<span class="comment"># 模块的属性 )</span></span><br></pre></td></tr></table></figure><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法***"></a>魔术方法***</h3><hr><ul><li><p>分类:</p><ul><li><p>创建, 初始化与销毁</p></li><li><p>可视化</p></li><li>hash</li><li>bool</li><li>运算符重载</li><li>容器和大小</li><li>可调用对象</li><li>上下文管理</li><li>反射</li><li>描述器</li><li>其他杂项</li></ul></li></ul><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__new__</td><td>实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法</td></tr></tbody></table><p>__new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回</p><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__str__</td><td>str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息</td></tr><tr><td>__repr__</td><td>内建函数repr()对一个对象获取<strong>字符串</strong>表达</td></tr><tr><td>__bytes__</td><td>bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age = <span class="number">18</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'repr:&#123;&#125;&#123;&#125;'</span>.format(self.name, self.age)</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__hash__</td><td>内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash</td></tr><tr><td>__eq__</td><td>对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了</td></tr></tbody></table><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__bool__</td><td>内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真</td></tr></tbody></table><h3 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h3><p>文件IO操作可以对文件对象使用上下文管理，使用with。。as语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>仿照上例写一个自己的泪，实现上下文管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> Point <span class="keyword">as</span> p:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>提示属性错误，没有__exit__，看了需要这个属性</p><p>某些版本会显示没有__enter__</p><p>上下文管理对象</p><p>当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象</p><p>__enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上</p><p>__exit__退出与此对象相关的上下文</p><p>with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作</p><p>注意,with 并不开启一个新的作用域</p><p>上下文管理是安全的</p><p>上下文应用场景</p><p>1.增强功能</p><p>在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能</p><p>2.资源管理</p><p>打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等</p><p>3.权限验证</p><p>在执行代码之前,做权限验证,在__enter__</p><h4 id="contextilb-contextmanager"><a href="#contextilb-contextmanager" class="headerlink" title="contextilb.contextmanager"></a>contextilb.contextmanager</h4><p>他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法</p><p>对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.</p><p>也就是这个装饰器接受一个生成器对象作为参数.</p><p>总结</p><p>如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>概述</p><p>运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候</p><p>反射,  reflection, 指的是运行时获取类型定义信息</p><p>一个对象能够在运行时,像照镜子一样,反射出其类型信息</p><p>简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身</p><p>具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等</p><h4 id="反射相关的函数和方法"><a href="#反射相关的函数和方法" class="headerlink" title="反射相关的函数和方法"></a>反射相关的函数和方法</h4><table><thead><tr><th>getattar</th><th>通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串.</th></tr></thead><tbody><tr><td>setattar</td><td>object的属性存在,这覆盖, 不存在,新增</td></tr><tr><td>hasattat</td><td>判断对象是否有这个名字的属性,name必须为字符串</td></tr></tbody></table><h4 id="反射相关的魔术方法"><a href="#反射相关的魔术方法" class="headerlink" title="反射相关的魔术方法"></a>反射相关的魔术方法</h4><p>__getattr__(), __setattr__(), __delattr__(), 三个魔术方法</p><p>实例属性会按照继承关系找,  如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出</p><p>AttributeError异常表示找不到属性.</p><p>查找属性顺序为:</p><p>instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特殊属性&quot;&gt;&lt;a href=&quot;#特殊属性&quot; class=&quot;headerlink&quot; title=&quot;特殊属性&quot;&gt;&lt;/a&gt;特殊属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://hubhack.github.io/book/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hubhack.github.io/book/面向对象/</id>
    <published>2019-06-23T14:04:28.568Z</published>
    <updated>2019-06-19T14:48:56.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言的分类"><a href="#语言的分类" class="headerlink" title="语言的分类"></a>语言的分类</h2><p>面向机器:抽象成机器指令, 机器容易理解.<br>代表:汇编语言<br>面向过程:<br>做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.<br>问题规模小, 可以步骤化.按部就班处理.<br>代表:c语言<br>面向对象OOP<br>随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.<br>代表:C++, java, python等</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类:class<br>类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.<br>用计算机语言来描述类,是属性和方法的集合.<br>对象:instance, object<br>对象是类的具象, 是一个实体.<br>对于我们每个人这个个体, 都是抽象概念人类不同的实体.</p><p>属性:它是对象状态的抽象,用数据结构来描述.<br>操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.<br>哲学:<br>一切皆对象<br>对象是数据和操作的封装.<br>对象是独立的,但是对象之间可以相互作用.<br>目前OOP是最接近人类认知的编程范式.</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p>1.封装<br>组装:将数据和操作组装到一起.<br>隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的<br>构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.<br>2.继承<br>多复用,继承来的就不用了自己写了<br>多继承少修改,OCP,使用继承来改变,来体现个性.<br>3.多态<br>面向对象编程最灵活的地方,动态绑定<br>人类就是封装<br>人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:<br>多态,继承自动物类的人类,猫类的操作’吃’不同.</p><p>python的类:<br>1.必须使用class关键字<br>2.类名必须使用大驼峰命名<br>3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.</p><h2 id="类对象及类属性"><a href="#类对象及类属性" class="headerlink" title="类对象及类属性"></a>类对象及类属性</h2><p>类对象,类的定义执行后会生成一个类对象.<br>类的属性,类定义中的变量和类中定义的方法都是类的属性.<br>类变量,<br>self指代当前实例本身.</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>a = Myclass() # 实例化<br>使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.<br>实例化就真正创建一个该类的对象<br>tom = Person()<br>jerry = Person()<br>每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.<br>python类实例化后, 会调用<strong>init</strong>方法,这个方法第一个形式参数必须留给self,其他参数随意.<br><strong>init</strong>方法</p><p>注意:<strong>init</strong>()方法不能有返回值,也就是只能是return None</p><p>实例对象instance<br>类实例化后一定会获得一个类的实例,就是实例对象<br><strong>init</strong>方法的第一参数self就是指代某一个实例自身.<br>类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.</p><p>实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.</p><p>总结:<br>是类的,也就是这个类所有实例的,器实例都可以访问到:<br>是实例的,就是这个实例自己的,通过类访问不到.<br>类变量是属于类的变量,这个类的所有实例可以共享这个变量.<br>对象可以动态的给自己增加一个属性.<br>实例属性的查找顺序<br>指的是实例使用,.点号来访问属性.会先找自己的<strong>dict</strong>,如果没有,然后通过属性<strong>class</strong>找到自家的类, 再去类的<strong>dict</strong>中找.<br>注意:如果实例使用<strong>dict</strong>访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.</p><p>一般来说, 类变量可使用全大写来命名.</p><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>1.在类定义中,使用@classmethod装饰器的方法<br>2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.<br>3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改<br>4.通过cls可以直接操作类的属性.<br>静态方法:<br>在类定义中, 使用@staticmethod装饰器的方法<br>2在调用时, 不会隐式的传入参数.<br>静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.</p><p>类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,<br>原因是第一参数必须是类的实例.<br>总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.<br>实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.<br>实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.</p><p>访问控制:<br>私有属性<br>私有属性,使用双下划线开头的属性名就是私有属性.</p><p>私有属性的本质:<br>类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.</p><p>保护变量:<br>在变量名前使用一个下划线,称为保护变量<br>这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.<br>私有方法:<br>参照保护变量,私有变量,使用单下划线,双下化线的命名方法,</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变<br>猴子补丁:<br>在运行时,对属性,方法,函数,等进行动态替换<br>其目的往往是为了通过替换,修改来增强,扩展原有代码的能力</p><h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.</p><p>property装饰器</p><p>后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性<br>setter装饰器<br>可以控制是否删除属性,很少用<br>deleter装饰器<br>可以控制是否删除属性,很少用<br>property装饰器必须在前,setter deleter装饰器在后,<br>property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.</p><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>类中可以定义<strong>del</strong>方法 ,称为析构函数.<br>作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.<br>注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.<br>使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用<strong>del</strong>方法.<br>由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.<br>封装:<br>将数据和操作组织到类中,即属性和方法.<br>将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.<br>通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语言的分类&quot;&gt;&lt;a href=&quot;#语言的分类&quot; class=&quot;headerlink&quot; title=&quot;语言的分类&quot;&gt;&lt;/a&gt;语言的分类&lt;/h2&gt;&lt;p&gt;面向机器:抽象成机器指令, 机器容易理解.&lt;br&gt;代表:汇编语言&lt;br&gt;面向过程:&lt;br&gt;做一件事,排出个步骤,第一
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>草稿</title>
    <link href="https://hubhack.github.io/book/%E8%8D%89%E7%A8%BF/"/>
    <id>https://hubhack.github.io/book/草稿/</id>
    <published>2019-06-23T14:04:28.545Z</published>
    <updated>2019-07-01T08:56:05.652Z</updated>
    
    <content type="html"><![CDATA[<p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p><p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;none 与NUll的区别&lt;br&gt;表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为&lt;br&gt;0,因为0是有意义的,而none是一个特殊的空值&lt;br&gt;判断的时候 均是false&lt;br&gt;属性不同:使用dir()函数返回参数的属性,方法列表
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://hubhack.github.io/book/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://hubhack.github.io/book/网络协议/</id>
    <published>2019-06-23T14:04:28.528Z</published>
    <updated>2019-06-19T14:49:50.767Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th>模型</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等.</td></tr><tr><td>表示层</td><td>提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码.</td></tr><tr><td>会话层</td><td>建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传.</td></tr><tr><td>传输层</td><td>提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket).</td></tr><tr><td>网络层</td><td>为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF.</td></tr><tr><td>链路层</td><td>在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 .</td></tr><tr><td>物理层</td><td>为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准.</td></tr></tbody></table><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><table><thead><tr><th>链路层和物理层</th><th>描述</th></tr></thead><tbody><tr><td>ARP(地址解析协议)</td><td>IP地址——-&gt;MAC地址</td></tr><tr><td>RARP</td><td>MAC地址——&gt;IP地址（逆向的）</td></tr><tr><td>PPP协议</td><td>拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样</td></tr><tr><td>MAC地址</td><td>48位全球唯一,网络设备的身份识别</td></tr></tbody></table><table><thead><tr><th>网络层</th><th>描述</th></tr></thead><tbody><tr><td>IP协议</td><td>IP:（分为IPV4（168….）和IPV6（16进制用：隔开））</td></tr><tr><td>ICMP（Internet控制管理协议）</td><td>ping命令属于ICMP</td></tr><tr><td>IGMP（Internet分组管理协议）</td><td>广播，组播</td></tr></tbody></table><table><thead><tr><th>传输层</th><th>描述</th></tr></thead><tbody><tr><td>TCP（传输控制协议)</td><td>面向连接，可靠,效率低，一对一的可靠数据传输的协议</td></tr><tr><td>UDP（用户数据报协议）</td><td>面向无连接，不可靠，效率高，提供不可靠的数据尽力传输</td></tr><tr><td>SCTP</td><td>是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信</td></tr></tbody></table><table><thead><tr><th>应用层</th><th>描述</th></tr></thead><tbody><tr><td>网页访问协议</td><td>HTTP HTTPS(S是安全)</td></tr><tr><td>邮件发送接收协议</td><td>POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件）</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>Telnet（明文传输）/SSH（安全）</td><td>远程登录</td></tr></tbody></table><table><thead><tr><th>嵌入式</th><th>描述</th></tr></thead><tbody><tr><td>NTP</td><td>网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的）</td></tr><tr><td>SNMP(开源（SNMP.NET）)</td><td>简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置</td></tr><tr><td>RTP/RTSP</td><td>用传输音视频传输（监控等）</td></tr></tbody></table><h3 id="中继系统"><a href="#中继系统" class="headerlink" title="中继系统"></a>中继系统</h3><p>中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。</p><h3 id="中继系统之集线器"><a href="#中继系统之集线器" class="headerlink" title="中继系统之集线器"></a>中继系统之集线器</h3><p>光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。</p><p>这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。</p><h3 id="中继系统之交换机"><a href="#中继系统之交换机" class="headerlink" title="中继系统之交换机"></a>中继系统之交换机</h3><p>还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：<strong>有记忆功能</strong>。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？</p><p>交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。</p><p>如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。</p><h3 id="中继系统之路由器"><a href="#中继系统之路由器" class="headerlink" title="中继系统之路由器"></a>中继系统之路由器</h3><p>路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。</p><p><strong><em>这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。</em></strong></p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.</p><h3 id="路由Routing"><a href="#路由Routing" class="headerlink" title="路由Routing"></a>路由Routing</h3><p>跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.</p><p>路由器上维护着路由表,他知道如何将数据包发往另外的网络.</p><p>windows使用route print, liunx使用route -n可以查看路由表.</p><p>路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.</p><p>静态路由:有管理员手动配置的固定的路由信息</p><p>动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI参考模型&quot;&gt;&lt;a href=&quot;#OSI参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI参考模型&quot;&gt;&lt;/a&gt;OSI参考模型&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/
      
    
    </summary>
    
      <category term="网络原理" scheme="https://hubhack.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="https://hubhack.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="https://hubhack.github.io/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hubhack.github.io/book/深入理解计算机系统/</id>
    <published>2019-06-23T14:04:28.491Z</published>
    <updated>2019-06-19T14:48:44.301Z</updated>
    
    <content type="html"><![CDATA[<p>源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.<br>源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制<br>堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.<br>内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.</p><h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.<br>一个字节包括8位,在二进制表示法中,00000000<code>11111111  0</code>255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.<br>2进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.&lt;br&gt;源程序 -&amp;gt;预处理器(cpp) -&amp;gt;编译器(cc1)-&amp;gt;汇编器-&amp;gt;链接器-可执行二进制&lt;br&gt;堆:代码和数据去后紧随着的是运行时堆.代码和
      
    
    </summary>
    
      <category term="系统" scheme="https://hubhack.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="https://hubhack.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解预处理器</title>
    <link href="https://hubhack.github.io/book/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://hubhack.github.io/book/深入浅出理解预处理器/</id>
    <published>2019-06-23T14:04:28.473Z</published>
    <updated>2019-06-19T14:49:44.230Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.</p><h4 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h4><p>预处理指令</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#include</td><td>包含一个源代码</td></tr><tr><td>#define</td><td>定义宏</td></tr><tr><td>#undef</td><td>取消已定义的宏</td></tr><tr><td>#ifdef</td><td>如果宏已经定义,则返回真</td></tr><tr><td>#ifndef</td><td>如果宏没有定义,则返回真</td></tr><tr><td>#if</td><td>如果给定条件为真,则编译下面代码</td></tr><tr><td>#else</td><td>#if的替代方案</td></tr><tr><td>#elif</td><td>如果前面的#if给定条件不为真,当前条件为真,则编译下面代码</td></tr><tr><td>#endif</td><td>结束一个#if…#else 条件编译块</td></tr><tr><td>#error</td><td>当遇到标准错误时, 输出错误消息</td></tr><tr><td>#pragma</td><td>使用标准化方法, 向编译器发布特殊的命令道编译器中</td></tr></tbody></table><p>typedef </p><p>c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .</p><p>动态内存分配</p><p>当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.</p><p>c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.</p><p>python对象就是 c语言结构体在堆上申请的一块内存.</p><p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>c中大量操作字符串的函数</p><table><thead><tr><th>函数</th><th>目的</th></tr></thead><tbody><tr><td>strcpy</td><td>复制字符串s2到字符串s1</td></tr><tr><td>strcat</td><td>连接s2 到字符串s1的末尾</td></tr><tr><td>strlen</td><td>返回字符串s1的长度</td></tr><tr><td>strcmp</td><td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td></tr><tr><td>strchar</td><td>返回一个指针,指向字符串s1中字符ch的第一次出现的位置</td></tr><tr><td>strstr</td><td>返回一个指针,指向字符串s1中字符串s2的第一次出现的位置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预处理器&quot;&gt;&lt;a href=&quot;#预处理器&quot; class=&quot;headerlink&quot; title=&quot;预处理器&quot;&gt;&lt;/a&gt;预处理器&lt;/h3&gt;&lt;p&gt;编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主
      
    
    </summary>
    
      <category term="c语言" scheme="https://hubhack.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://hubhack.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://hubhack.github.io/book/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://hubhack.github.io/book/正则表达式/</id>
    <published>2019-06-23T14:04:28.457Z</published>
    <updated>2019-06-19T14:48:50.730Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式简绍"><a href="#正则表达式简绍" class="headerlink" title="正则表达式简绍"></a>正则表达式简绍</h1><p>概述:正则表达式<br>正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.<br>正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.<br>正则表达式 Regular Expression,缩写regex, regexp ,RE等.<br>分类<br>1.BRE<br>基本正则表达式,grep,sed,vi等软件支持.vim有扩展.<br>2.ERE<br>扩展正则表达式,egrep, sed -r等.<br>3.PCRE<br>几乎所有高级语言都是PCRE的方言或者变种.</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>元字符 metacharacter<br>转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.<br>反斜杠自身,得使用\ \r \n还是转义后代表回车,换行</p><h1 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h1><p>默认是贪婪模式,也就是说尽量多匹配更长的字符串,<br>非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.</p><p>单行模式:<br>. 可以匹配所有的字符, 包括换行符.<br>^ 表示整个字符串的开头, &amp;整个字符串的结尾<br>多行模式:<br>. 可以匹配除了换行符之外的字符,多行不影响.点号<br>^ 表示行首, &amp;行尾, 只不过这里的行是每一行</p><p>默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.<br>单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.<br>多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n</p><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>re.M多行模式<br>re.S单行模式<br>re.I忽略大小写<br>re.X忽略表达式中的空白字符<br>使用 | 位或运算开启多种选项<br>方法<br>编译<br>re.compile(pattern, flag=0)<br>设定flags, 编译模式,返回正则表达式对象regex<br>pattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.<br>单次匹配<br>re.match(pattern, string, flags=0)<br>match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象<br>从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.</p><p>全局搜索<br>对整个字符串, 从左至右匹配,返回匹配项的列表.<br>匹配替换<br>使用pattern对字符串string进行匹配,对匹配使用repl替换.<br>replacement可以是string, bytes, function.</p><p>分割字符串<br>字符串的分割函数split,太难用, 不能指定多个字符进行分割.<br>分组<br>使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象<br>如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.<br>1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.<br>2.如果使用了命名分组,可以使用group的方式取分组<br>3.也可以使用group返回所有组.<br>4.使用groupdict()返回命名的分组.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式简绍&quot;&gt;&lt;a href=&quot;#正则表达式简绍&quot; class=&quot;headerlink&quot; title=&quot;正则表达式简绍&quot;&gt;&lt;/a&gt;正则表达式简绍&lt;/h1&gt;&lt;p&gt;概述:正则表达式&lt;br&gt;正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法</title>
    <link href="https://hubhack.github.io/book/%E6%96%B9%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/方法/</id>
    <published>2019-06-23T14:04:28.447Z</published>
    <updated>2019-06-19T14:50:04.679Z</updated>
    
    <content type="html"><![CDATA[<p>魔术方法</p><table><thead><tr><th>类别</th><th>方法名</th></tr></thead><tbody><tr><td>可视化</td><td>__str__, __repr__, __format__, __bytes__</td></tr><tr><td>数值转换</td><td>__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__</td></tr><tr><td>容器模拟</td><td>__len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__</td></tr><tr><td>迭代枚举</td><td>__iter__, __reversed__, __next__</td></tr><tr><td>可调用模拟</td><td>__call__</td></tr><tr><td>上下文管理</td><td>__enter__, __exit__</td></tr><tr><td>实例创建和销毁</td><td>__new__, __init__, __del__</td></tr><tr><td>属性管理(反射)</td><td>__dir__, __getattr__, __setattr__, __delattr__, __getattribute__</td></tr><tr><td>属性描述符(描述器)</td><td>__get__, __set__, __delete__</td></tr><tr><td>特殊属性</td><td>__name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__</td></tr><tr><td>比较运算符</td><td>__eq__,__lt__, __le__, __gt__, __ge__, __ne__</td></tr><tr><td>算数运算符</td><td>__add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__</td></tr><tr><td>增量运算符</td><td>__iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__</td></tr><tr><td>反向运算符</td><td>__radd__, __rsub__</td></tr><tr><td>其他</td><td>__slots__</td></tr></tbody></table><p>内置函数</p><table><thead><tr><th>内置函数名</th><th>方法名</th></tr></thead><tbody><tr><td>数学运算</td><td>abs, divmod,max,min,pow, round, sum</td></tr><tr><td>类型转换</td><td>bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex</td></tr><tr><td>序列操作</td><td>all, any, filter, map,next,reversed, sorted, zip</td></tr><tr><td>对象操作</td><td>help,dir,id,hash, type,len, ascii,format, vars,</td></tr><tr><td>反射操作</td><td>__import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable</td></tr><tr><td>变量操作</td><td>globals, locals,</td></tr><tr><td>交互操作</td><td>print,input</td></tr><tr><td>文件操作</td><td>open</td></tr><tr><td>编译执行</td><td>compile, eval,exec, repr</td></tr><tr><td>装饰器</td><td>property,classmethod, staticmethod,</td></tr><tr><td>数据结构</td><td>tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object</td></tr></tbody></table><p>标识符:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span>      <span class="keyword">await</span>      <span class="keyword">else</span>       <span class="keyword">import</span>     <span class="keyword">pass</span></span><br><span class="line"><span class="literal">None</span>       <span class="keyword">break</span>      <span class="keyword">except</span>     <span class="keyword">in</span>         <span class="keyword">raise</span></span><br><span class="line"><span class="literal">True</span>       <span class="class"><span class="keyword">class</span>      <span class="title">finally</span>    <span class="title">is</span>         <span class="title">return</span></span></span><br><span class="line"><span class="class"><span class="title">and</span>        <span class="title">continue</span>   <span class="title">for</span>        <span class="title">lambda</span>     <span class="title">try</span></span></span><br><span class="line"><span class="class"><span class="title">as</span>         <span class="title">def</span>        <span class="title">from</span>       <span class="title">nonlocal</span>   <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">assert</span>     <span class="title">del</span>        <span class="title">global</span>     <span class="title">not</span>        <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">async</span>      <span class="title">elif</span>       <span class="title">if</span>         <span class="title">or</span>         <span class="title">yield</span></span></span><br></pre></td></tr></table></figure><p>模块常用方法</p><table><thead><tr><th>内置模块</th><th>方法名</th></tr></thead><tbody><tr><td>re</td><td>compile, search, match, fullmatch,split,findall, sub,</td></tr><tr><td>string</td><td>ascii_letters,ascii_lowercase.digits</td></tr><tr><td>datetime</td><td>datetime</td></tr><tr><td>collections</td><td>nametuple, deque, OrderdDict, defaultdict,</td></tr><tr><td>bisect</td><td>bisect_left,bisect_right,</td></tr><tr><td>math</td><td>ceil</td></tr><tr><td>random</td><td>randint, choice, randrange,shuffle, sample</td></tr><tr><td>functools</td><td>reduce, partial,lru_cache</td></tr><tr><td>pathlib</td><td></td></tr><tr><td>os</td><td></td></tr><tr><td>shutil</td><td>copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move,</td></tr><tr><td>pickle</td><td></td></tr><tr><td>csv</td><td>reader</td></tr><tr><td>time</td><td></td></tr><tr><td>threading</td><td></td></tr><tr><td>queue</td><td></td></tr><tr><td>json</td><td></td></tr><tr><td>base64</td><td></td></tr><tr><td>sys</td><td></td></tr><tr><td>inspect</td><td>signature(callable)获取签名,</td></tr><tr><td>ConfigParser</td><td></td></tr><tr><td>argparse</td><td></td></tr><tr><td>heapq</td><td>hea</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;魔术方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;方法名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可视化&lt;/td&gt;
&lt;td&gt;__str__, __repr__, __format__, __byte
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>描述器</title>
    <link href="https://hubhack.github.io/book/%E6%8F%8F%E8%BF%B0%E5%99%A8/"/>
    <id>https://hubhack.github.io/book/描述器/</id>
    <published>2019-06-23T14:04:28.437Z</published>
    <updated>2019-06-19T14:49:26.925Z</updated>
    
    <content type="html"><![CDATA[<h3 id="描述器-Descriptors"><a href="#描述器-Descriptors" class="headerlink" title="描述器 Descriptors"></a><strong>描述器 Descriptors</strong></h3><p><strong>描述器的表现</strong></p><p><strong>用到3个魔术方法: __get__() 、 __set__() 、 __delete__()</strong></p><p><strong>方法签名如下</strong></p><p><strong>object.__get__(self, instance, owner)</strong></p><p><strong>object.__set__(self, instance, value)</strong></p><p><strong>object.__delete__(self, instance)</strong></p><p><strong>self 指代当前实例，调用者</strong></p><p><strong>instance 是owner的实例</strong></p><p><strong>owner 是属性的所属的类</strong></p><p><strong>请思考下面程序的执行流程是什么？</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">self.a1 = <span class="string">'a1'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'A.init'</span>)</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"></span><br><span class="line">x = A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'B.init'</span>)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(B.x.a1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(b.x.a1)</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行结果</span></span><br><span class="line"></span><br><span class="line">A.init</span><br><span class="line"></span><br><span class="line">--------------------</span><br><span class="line"></span><br><span class="line">a1</span><br><span class="line"></span><br><span class="line">====================</span><br><span class="line"></span><br><span class="line">B.init</span><br><span class="line"></span><br><span class="line">a1</span><br></pre></td></tr></table></figure><p><strong>可以看出执行的先后顺序吧？</strong></p><p><strong>类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。</strong></p><p><strong>然后实例化并初始化B的实例b。</strong></p><p><strong>打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。</strong></p><h3 id="描述器定义"><a href="#描述器定义" class="headerlink" title="描述器定义"></a>描述器定义</h3><p><strong>Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。</strong></p><blockquote><p><strong>仅实现了 __get__ ，就是非数据描述符 non-data descriptor</strong></p><p><strong>实现了 __get__ 、 __set__ 就是数据描述符 data descriptor</strong></p></blockquote><p><strong>如果一个类的类属性设置为描述器实例，那么它被称为owner属主。</strong></p><p><strong>当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。</strong></p><h3 id="属性的访问顺序"><a href="#属性的访问顺序" class="headerlink" title="属性的访问顺序"></a><strong>属性的访问顺序</strong></h3><p><strong>为上例中的类B增加实例属性x</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">self.a1 = <span class="string">'a1'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'A.init'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;"</span>.format(self, instance, owner))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"></span><br><span class="line">x = A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'B.init'</span>)</span><br><span class="line"></span><br><span class="line">self.x = <span class="string">'b.x'</span> <span class="comment"># 增加实例属性x</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(B.x)</span><br><span class="line"></span><br><span class="line">print(B.x.a1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(b.x)</span><br><span class="line"></span><br><span class="line">print(b.x.a1) <span class="comment"># AttributeError: 'str' object has no attribute 'a1'</span></span><br></pre></td></tr></table></figure><p><strong>类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。</strong></p><p><strong>继续修改代码，为类A增加 __set__ 方法。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">self.a1 = <span class="string">'a1'</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'A.init'</span>)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__get__</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;"</span>.format(self, instance, owner))</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__set__</span><span class="params">(self, instance, value)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(self, instance, value))</span><br><span class="line"></span><br><span class="line">self.data = value</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"></span><br><span class="line">x = A()</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'B.init'</span>)</span><br><span class="line"></span><br><span class="line">self.x = <span class="string">'b.x'</span> <span class="comment"># 增加实例属性x</span></span><br><span class="line"></span><br><span class="line">print(<span class="string">'-'</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">print(B.x)</span><br><span class="line"></span><br><span class="line">print(B.x.a1)</span><br><span class="line"></span><br><span class="line">print(<span class="string">'='</span>*<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line">b = B()</span><br><span class="line"></span><br><span class="line">print(b.x) <span class="comment"># 返回什么</span></span><br><span class="line"></span><br><span class="line">print(b.x.a1) <span class="comment"># 返回什么</span></span><br><span class="line"></span><br><span class="line">print(b.x.data) <span class="comment"># 返回什么？</span></span><br></pre></td></tr></table></figure><p><strong>所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。</strong></p><hr><h3 id="属性查找顺序"><a href="#属性查找顺序" class="headerlink" title="属性查找顺序"></a><strong>属性查找顺序</strong></h3><p><strong>实例的 __dict__ 优先于 非数据描述器</strong></p><p><strong>数据描述器 优先于 实例的 __dict__</strong></p><blockquote><p><strong>__delete__ 方法有同样的效果，有了这个方法，也是数据描述器。</strong></p></blockquote><p><strong>尝试着增加下面的2行代码，看看字典的变化</strong></p><p><strong>b.x = 500</strong></p><p><strong>B.x = 600</strong></p><p><strong>b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。</strong></p><p><strong>B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。</strong></p><hr><p>### </p><p><strong>Python中的描述器</strong></p><p><strong>描述器在Python中应用非常广泛。</strong></p><p><strong>Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。</strong></p><p><strong>property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @classmethod</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">foo</span><span class="params">(cls)</span>:</span> <span class="comment"># 非数据描述器</span></span><br><span class="line"></span><br><span class="line">        <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @staticmethod # 非数据描述器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">bar</span><span class="params">()</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line"><span class="meta">    @property # 数据描述器</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">z</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">5</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">getfoo</span><span class="params">(self)</span>:</span> <span class="comment"># 非数据描述器</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> self.foo</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self)</span>:</span> <span class="comment"># 非数据描述器</span></span><br><span class="line"></span><br><span class="line">    self.foo = <span class="number">100</span></span><br><span class="line"></span><br><span class="line">    self.bar = <span class="number">200</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">#self.z = 300</span></span><br><span class="line"></span><br><span class="line">a = A()</span><br><span class="line"></span><br><span class="line">print(a.__dict__)</span><br><span class="line"></span><br><span class="line">print(A.__dict__)</span><br></pre></td></tr></table></figure><blockquote></blockquote><p><strong>foo、bar都可以在实例中覆盖，但是z不可以。</strong></p><hr><p><strong>新增方法</strong></p><p><strong>3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">init</span><span class="params">(self)</span>:</span></span><br><span class="line"></span><br><span class="line">   print(<span class="string">'A init'</span>)</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">get</span><span class="params">(self, instance, owner)</span>:</span></span><br><span class="line"></span><br><span class="line">       print(<span class="number">1</span>, self, instance, owner)</span><br><span class="line"></span><br><span class="line">   <span class="keyword">return</span> self</span><br><span class="line"></span><br><span class="line">   <span class="function"><span class="keyword">def</span> <span class="title">set_name</span><span class="params">(self, owner, name)</span>:</span></span><br><span class="line">       print(<span class="number">2</span>, self, owner, name)</span><br><span class="line"></span><br><span class="line">       self.name = name</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span>:</span></span><br><span class="line"></span><br><span class="line">x = A() <span class="comment"># 类属性创建时调用描述器的set_name方法 print('-' * 30)</span></span><br><span class="line"></span><br><span class="line">print(B().x)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;描述器-Descriptors&quot;&gt;&lt;a href=&quot;#描述器-Descriptors&quot; class=&quot;headerlink&quot; title=&quot;描述器 Descriptors&quot;&gt;&lt;/a&gt;&lt;strong&gt;描述器 Descriptors&lt;/strong&gt;&lt;/h3&gt;&lt;p&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>处理异常</title>
    <link href="https://hubhack.github.io/book/%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>https://hubhack.github.io/book/处理异常/</id>
    <published>2019-06-23T14:04:28.427Z</published>
    <updated>2019-06-19T14:49:03.134Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理(Exception)"></a>异常处理(Exception)</h2><h4 id="错误Error"><a href="#错误Error" class="headerlink" title="错误Error"></a>错误Error</h4><p>逻辑错误:算法写错了, 例如加法写成了减法</p><p>笔误:例如变量名写错了,语法错误</p><p>函数或类使用错误, 其实这也属于逻辑错误</p><p>总之,错误是可以避免的</p><h4 id="异常Eception"><a href="#异常Eception" class="headerlink" title="异常Eception"></a>异常Eception</h4><p>本意就是意外情况</p><p>这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.</p><p>例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.</p><h4 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h4><p>在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'tetsabcd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 异常</span></span><br></pre></td></tr></table></figure><h2 id="产生异常"><a href="#产生异常" class="headerlink" title="产生异常"></a>产生异常</h2><p>产生:</p><ul><li>raise语句显示的抛出异常</li><li>Python解释器自己检测异常并引发它<br>程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)</li></ul><h2 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    待捕获异常的代码块</span><br><span class="line"><span class="keyword">except</span> [异常类型]</span><br><span class="line">异常的处理代码块</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常处理-Exception&quot;&gt;&lt;a href=&quot;#异常处理-Exception&quot; class=&quot;headerlink&quot; title=&quot;异常处理(Exception)&quot;&gt;&lt;/a&gt;异常处理(Exception)&lt;/h2&gt;&lt;h4 id=&quot;错误Error&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="https://hubhack.github.io/book/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/二分法/</id>
    <published>2019-06-23T14:04:28.417Z</published>
    <updated>2019-06-19T14:49:21.051Z</updated>
    
    <content type="html"><![CDATA[<p>练习</p><p>有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。<br>分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。<br>思路<br>排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。<br>查找插入点，使用二分查找完成。<br>假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。<br>直到中点就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(orderlist, i)</span>:</span>    </span><br><span class="line">    ret = orderlist[:]    </span><br><span class="line">    low = <span class="number">0</span>    </span><br><span class="line">    high = len(ret) - <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">while</span> low &lt; high: </span><br><span class="line">        mid = (low + high) // <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> ret[mid] &lt; i: </span><br><span class="line">            low = mid + <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 说明i大，往右找，调整下限 else: high = mid </span></span><br><span class="line">            <span class="comment"># 说明i小于等于，往左找，调整上限    </span></span><br><span class="line">            print(low, i) </span><br><span class="line">            <span class="comment"># low为插入点    </span></span><br><span class="line">            ret.insert(low, i)    </span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class="line">newlst = sorted(lst) </span><br><span class="line"><span class="comment"># 升序 </span></span><br><span class="line">print(newlst) <span class="comment">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">40</span>, <span class="number">20</span>, <span class="number">41</span>):    </span><br><span class="line">    newlst = insert_sort(newlst, x)    </span><br><span class="line">    print(newlst)</span><br></pre></td></tr></table></figure><p>看似上面代码不错，请测试插入100。<br>问题来了，100插入的位置不对，为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(orderlist, i)</span>:</span>    </span><br><span class="line">    ret = orderlist[:]    </span><br><span class="line">    low = <span class="number">0</span>    </span><br><span class="line">    high = len(ret) <span class="comment"># 去掉减1    </span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high: </span><br><span class="line">        mid = (low + high) // <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> ret[mid] &lt; i: </span><br><span class="line">            low = mid + <span class="number">1</span> <span class="comment"># 说明i大，往右找，调整下限 </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid <span class="comment"># 说明i小于等于，往左找，调整上限    </span></span><br><span class="line">     print(low, i) <span class="comment"># low为插入点    </span></span><br><span class="line">     ret.insert(low, i)    </span><br><span class="line">     <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class="line"> </span><br><span class="line">newlst = sorted(lst) <span class="comment"># 升序</span></span><br><span class="line">print(newlst) <span class="comment">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">40</span>, <span class="number">20</span>, <span class="number">41</span>, <span class="number">100</span>):    </span><br><span class="line">    newlst = insert_sort(newlst, x)    </span><br><span class="line">    print(newlst)</span><br></pre></td></tr></table></figure><p> high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。<br>如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分前提是有序，否则不可以二分。<br>二分查找算法的时间复杂度O(log n)</p><h3 id="bisect模块"><a href="#bisect模块" class="headerlink" title="bisect模块"></a>bisect模块</h3><p>bisect模块提供的函数有：</p><ul><li>bisect.bisect_left(a,x, lo=0, hi=len(a))<br>查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。</li><li>bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))<br>在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。</li><li>bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。<br>函数可以分2类： bisect系，用于查找index。<br>Insort系，用于实际插入。默认重复时从右边插入。</li></ul><p>应用<br>判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(score)</span>:</span>    </span><br><span class="line">    breakpoints = [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]    </span><br><span class="line">    grades = <span class="string">'EDCBA'</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> grades[bisect.bisect(breakpoints, score)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">91</span>, <span class="number">82</span>, <span class="number">77</span>, <span class="number">65</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>):    </span><br><span class="line">    print(<span class="string">'&#123;&#125; =&gt; &#123;&#125;'</span>.format(x, get_grade(x)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;练习&lt;/p&gt;
&lt;p&gt;有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。&lt;br&gt;分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。&lt;br&gt;思路&lt;br&gt;排序后二分查找到适当位置插入数值。排序使用
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python知识框架</title>
    <link href="https://hubhack.github.io/book/python%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <id>https://hubhack.github.io/book/python知识框架/</id>
    <published>2019-06-23T14:04:28.408Z</published>
    <updated>2019-06-19T14:47:10.292Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>python是一种动态的强类型语言,底层是用C语言开发的.</p><p>平台：*nix平台<br>系统：线程、进程、Shell编程<br>网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发<br>算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写<br>数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个<br>中间件：消息队列原理和应用，例如8曲bitMQ<br>WEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一<br>可视化：WEB的前端开发多一些HTML、jS要会<br>数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用</p><p>python学习路线:<br>基础：操作系统、网络基础、数据库基础、python语言基础..<br>进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..<br>高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).<br>新前端开发(ES6、React、Antd）…<br>实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..<br>高端：数据清洗、企业数据分析、预测准荐、机器视觉．</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母A用ASCII编码是十进制的65，二进制的01000001；</p><p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p><p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p><p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.</p><h3 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h3><p>format函数或 格式符</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>字符串与bytes<br>字符串是字符组成的有序序列，字符可以使用编码来理解<br>bytes是字节组成的有序的不可变序列<br>bytearray是字节组成的有序的可变序列</p><p>编码与解码：<br>字符串按照不同的字符集编码encode返回字节序列bytes<br>encode（encoding=‘utf-8’，errors=‘strict’）<br>字节序列按照不同的字符集解码decode返回字符串<br>bytes.decode（encoding=“utf-8”，errors=“strict”）<br>ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统</p><p>要熟记31 41 61 的ascii表</p><p>字节序：<br>大端模式，big-endian；小端模式，little-endian<br>intel x86cpu使用小端 模式<br>网络传输更多使用大端模式<br>windows，linux 使用小端模式<br>mac os使用大端模式<br>java 虚拟机是大端模式</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>有整数 浮点数 复数等</p><h2 id="true-false"><a href="#true-false" class="headerlink" title="true false"></a>true false</h2><p>主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。</p><p>None：Python里面特殊的空值，不能理解为0。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>list（列表） tuple（元组） set（集合） dictionary（字典）<br>这些都是可以迭代的</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组和列表类似，但是不同的是元组不能修改，元组使用小括号。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><h2 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p><p>elif 语句</p><p>elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。</p><p>if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for循环可以遍历任何序列的项目：</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环：</p><p>break和continue语句：</p><p>break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。</p><p>continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;python是一种动态的强类型语言,底层是用C语言开发的.&lt;/p&gt;
&lt;p&gt;平台：*
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python特殊函数</title>
    <link href="https://hubhack.github.io/book/python%E7%89%B9%E6%AE%8A%E5%87%BD%E6%95%B0/"/>
    <id>https://hubhack.github.io/book/python特殊函数/</id>
    <published>2019-06-23T14:04:28.398Z</published>
    <updated>2019-06-19T14:48:15.380Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数 :隐藏名字,即没有名称<br>匿名函数: 没有名字的函数<br>lambda表达式<br>python中,使用lambda表达式构建匿名函数<br>使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式<br>参数列表不需要小括号,无参就不写参数<br>冒号用来分割参数和表达式部分<br>不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.<br>lambda表达式匿名函数只能写在一行上,也称为单行函数.</p><p>匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.</p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>函数执行流程:压栈</p><p>递归函数recursion<br>函数直接或者间接调用自身就是递归.<br>递归需要有边界条件,递归前进段,递归返回段.<br>递归一定要有边界条件.<br>当边界条件不满足的时候,递归前进<br>当边界条件满足的时候,递归返回.</p><p>递归例子:斐波那契数列<br>如果用循环写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">n = 10</span><br><span class="line">for i in range(n -1):</span><br><span class="line">    a,b=b, a+b</span><br><span class="line">else:</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure></p><p>递归写法:<br>def fib(n):<br>    return 1 if n &lt;3 else fib(n-1) +fib(n-2)</p><p>递归要求<br>递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.<br>递归调用的深度不宜<br>python 对递归调用的深度做了限制,以保护解释器<br>超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度<br>sys.getrecursionlimit()</p><p>循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.<br>递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.</p><p>递归是一种很自然的表达,符合逻辑思维<br>递归相对效率低,每一次调用都要开辟栈帧.<br>递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.<br>如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.<br>绝大多数递归,都可以使用循环实现<br>即使递归代码很简洁,但是能不用则不用递归.</p><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>生成器generator<br>生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.<br>生成器对象,是一个可迭代对象,是有个迭代器.<br>生成器对象,是延时计算,惰性求值的.</p><p>函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.<br>普通函数调用,函数会立即执行直到执行完毕.<br>生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.<br>生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑.</p><p>在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回<br>再执行会执行到下一个yield语句又会暂停执行<br>return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.<br>如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration<br>生成器函数<br>包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行<br>next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.<br>再次调用next函数,和上一条一样的处理过程.<br>继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常.</p><p>协程<br>生成器的高级用法<br>他比进程,线程轻量级,是在用户空间调度函数的一种实现.<br>协程调度器实现思路<br>协程是一种非抢占式调度.</p><p>yield from 语法<br>yield from就是一种简化语法的语法糖.</p><h1 id="yield-和return的区别"><a href="#yield-和return的区别" class="headerlink" title="yield 和return的区别"></a>yield 和return的区别</h1><p>带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return</p><p>如何生成斐波那契数列:<br>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">def fab(max):</span><br><span class="line">    a, b = 1, 1</span><br><span class="line">    n = 1</span><br><span class="line">    while n &lt; max:</span><br><span class="line">        print(b)</span><br><span class="line">        a, b = b, a+b</span><br><span class="line">        n +=1</span><br><span class="line">fab(20)</span><br></pre></td></tr></table></figure><p>结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.<br>要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">def fab(max):</span><br><span class="line">    n, a, b = 0, 0, 1</span><br><span class="line">    l = []</span><br><span class="line">    while  n &lt; max:</span><br><span class="line">        l.append(b)</span><br><span class="line">        b = b+a</span><br><span class="line">        a = b-a</span><br><span class="line">        n = n+1</span><br><span class="line">    return l</span><br></pre></td></tr></table></figure></p><p>改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,<br>该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要<br>用list来保存中间结果, 而是通过iterable对象来迭代.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">class Fab(object): </span><br><span class="line"> </span><br><span class="line">   def __init__(self, max): </span><br><span class="line">       self.max = max </span><br><span class="line">       self.n, self.a, self.b = 0, 0, 1 </span><br><span class="line"> </span><br><span class="line">   def __iter__(self): </span><br><span class="line">       return self </span><br><span class="line"> </span><br><span class="line">   def next(self): </span><br><span class="line">       if self.n &lt; self.max: </span><br><span class="line">           r = self.b </span><br><span class="line">           self.b = self.a + self.b</span><br><span class="line">           self.a = self.b - self.a</span><br><span class="line">           self.n = self.n + 1 </span><br><span class="line">           return r </span><br><span class="line">       raise StopIteration()</span><br></pre></td></tr></table></figure><p>然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:<br>def fab(max):<br>    n, a, b = 0, 0, 1<br>    while n &lt; max:<br>        yield b<br>        b =  b+a<br>        a = b-a<br>        n = n + 1</p><p>第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果<br>调用第四版的fab和第二版的fab完全一致:</p><p>简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,<br>而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法<br>这样我们就可以清楚看到fab的执行流程.</p><h1 id="高阶函数"><a href="#高阶函数" class="headerlink" title="高阶函数"></a>高阶函数</h1><p>函数也是对象, 是可调用对象<br>函数可以作为普通变量,也可以作为函数的参数, 返回值.</p><p>在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数<br>接受一个或多个函数作为参数<br>输出一个函数</p><p>排序sorted<br>排序函数,可以接受key作为参数进行排序,不改变序列的原有值.<br>排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.<br>然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素.</p><p>过滤filter<br>对可迭代对象进行遍历,返回一个迭代器<br>function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值<br>function参数如果是None, 可迭代对象的每一个元素自身等效布尔值.</p><p>映射map<br>对多个可迭代对象的元素,按照指定的函数进行映射<br>返回一个迭代器</p><h1 id="柯里化"><a href="#柯里化" class="headerlink" title="柯里化"></a>柯里化</h1><p>指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h1&gt;&lt;p&gt;匿名函数 :隐藏名字,即没有名称&lt;br&gt;匿名函数: 没有名字的函数&lt;br&gt;lambda表达式&lt;br&gt;python中,使用la
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python文件io</title>
    <link href="https://hubhack.github.io/book/python%E6%96%87%E4%BB%B6io/"/>
    <id>https://hubhack.github.io/book/python文件io/</id>
    <published>2019-06-23T14:04:28.388Z</published>
    <updated>2019-06-19T14:48:36.385Z</updated>
    
    <content type="html"><![CDATA[<h1 id="文件io常用操作"><a href="#文件io常用操作" class="headerlink" title="文件io常用操作"></a>文件io常用操作</h1><p>一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io<br>open:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取<br>seek: 文件指针操作 tell: 指针位置</p><p>打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.<br>文件操作中,最常用的操作就是读和写.<br>文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.<br>注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.<br>open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.<br>mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件<br>a: 写入打开,如果文件存在,则追加<br>b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力.</p><p>open默认是只读模式r打开已经存在的文件.</p><p>文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOF<br>buffering:缓冲区<br>0:只在二进制模式打开,表示关buffer<br>1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush<br>大于1:用于指定buffer的大小.</p><h1 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h1><p>1.异常处理<br>当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.<br>使用finally可以保证打开的文件可以被关闭.<br>2.上下文管理<br>一种特殊的语法, 交给解释器去释放文件对象.<br>使用with … as关键字<br>上下文管理的语句并不会开启新的作用域<br>with语句执行的时候,自动关闭文件对象.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">f1 = open(&apos;text&apos;)</span><br><span class="line">with f1:</span><br><span class="line">    f1.write(&apos;abc&apos;)</span><br><span class="line">f1.closed</span><br></pre></td></tr></table></figure></p><p>对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源<br>io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题.</p><p>StringIO和BytesIO<br>StringIO<br>io模块中的类<br>from io import StringIO<br>内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.<br>当close方法被调用的时候,这个buffer被释放.</p><p>好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率.</p><p>BytesIO<br>io模块中的类<br>from io import BytesIO<br>内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.<br>当close方法被调用的时候, 这个buffer会释放.</p><p>file-like对象<br>类文件对象,可以像文件一样操作<br>socket对象,输入输出对象都是类文件对象.</p><h1 id="路径操作"><a href="#路径操作" class="headerlink" title="路径操作"></a>路径操作</h1><p>from os import path<br>3.4版本开始<br>建议使用pathlib模块,提供path对象来操作.包括目录和文件<br>Pathlib模块</p><p>目录操作初始化<br>路径拼接和分解<br>操作符<br>分解<br>joinpath</p><h1 id="通配符"><a href="#通配符" class="headerlink" title="通配符"></a>通配符</h1><p>glob通配给定的模式<br>rglob通配给定的模式,递归目录<br>都返回一个生成器<br>?代表一个字符<br>*表示任意个字符<br>[abc]或[a-z]表示一个字符</p><p>匹配<br>match(pattern)<br>模式匹配,成功返回True</p><p>文件操作<br>os模块<br>os.name windows是nt, linux是posix<br>os.uname() *nix支持<br>sys.platform windows显示win32, linux 显示linux<br>os.listdir返回指定目录内容列表, 不递归<br>os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似.</p><h1 id="shutil模块"><a href="#shutil模块" class="headerlink" title="shutil模块"></a>shutil模块</h1><p>文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.<br>python提供了一个方便的shutil(高级文件操作)<br>copy复制<br>copyfileobj(fsrc, fdst[, length])</p><p>文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">import shutil</span><br><span class="line">with open (&apos;text&apos;, &apos;r+&apos;) as f:</span><br><span class="line">    f.write(&apos;abcd&apos;)</span><br><span class="line">    with open(&apos;text1&apos;, &apos;w+&apos;) as f1:</span><br><span class="line">        shutil.copyfileobj(f, f1)</span><br></pre></td></tr></table></figure></p><p>复制文件内容,不含元数据,src,dst为文件的路径字符串.</p><h1 id="rm删除"><a href="#rm删除" class="headerlink" title="rm删除"></a>rm删除</h1><p>shutil.rmtree(path, ignore_errors=False, oneerror=None)<br>递归删除,如同rm -rf一样危险,慎用.<br>他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.<br>shutil.retree(“text”) 类似rm -rf</p><h1 id="move移动"><a href="#move移动" class="headerlink" title="move移动"></a>move移动</h1><p>递归移动文件,目标到目标,返回目标<br>本身使用的是os.rename方法<br>如果不支持rename,如果是目录则copytree再删除源目录.<br>shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz</p><h1 id="csv文件"><a href="#csv文件" class="headerlink" title="csv文件"></a>csv文件</h1><p>csv是一个被行分隔符,列分割符划分成行和列的文本文件.<br>csv不指定字符编码.<br>行分割符为\r\n,最后一行可以没有换行符.<br>列分割符常用逗号或者制表符.<br>每一行称为一条记录record.<br>字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.<br>csv模块<br>返回reader对象,是一个行迭代器<br>默认使用excel方言.<br>delimiter列分割符,逗号.<br>lineterminator行分割符\r\n</p><h1 id="ini文件处理"><a href="#ini文件处理" class="headerlink" title="ini文件处理"></a>ini文件处理</h1><p>作为配置文件,ini文件格式的很流行.</p><p>中括号里面的部分称为section,译作节,区, 段<br>每一个section内, 都是key=value形成的键值对,key称为option选项.<br>注意这里的DEFAULT是缺省section的名字,必须大写.<br>configparser<br>configparser模块的configparser类就是用来操作.<br>可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典.</p><h1 id="序列化和反序列化"><a href="#序列化和反序列化" class="headerlink" title="序列化和反序列化"></a>序列化和反序列化</h1><p>为什么要序列化<br>内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.<br>要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.<br>serialization序列化<br>将内存中对象存储下来,把他变为一个个字节.<br>deserialization反序列化<br>将文件的一个个字节恢复成内存中的对象<br>序列化保存到文件就是持久化<br>可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化<br>python提供了pickle库</p><p>dumps 对象序列化为bytes对象<br>dump 对象序列化到文件对象,就是存入文件<br>loads 从bytes对象反序列化<br>load 对象反序列化,从文件读取数据</p><p>序列化应用<br>一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.<br>将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用<br>但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.<br>但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.<br>不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型<br>json<br>json的数据类型</p><p>messagepack<br>messagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.<br>他可以像json那样,在许多语言之间交换结构对象.<br>但是他比json更快速也跟轻巧.<br>支持python.ruby,java等众多语言,<br>兼容json 和pickle</p><p>安装pip install msgpack</p><p>常用方法序列化对象,提供dumps来兼容pickle和json<br>unpackb反序列化对象.提供了loads来兼容.<br>pack序列化对象保存到文件对象,提供了dump来兼容.<br>unpack反序列化对象保存到文件对象,提供了load来兼容.<br>messagepack简单易用,高效压缩,支持语言丰富.<br>所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;文件io常用操作&quot;&gt;&lt;a href=&quot;#文件io常用操作&quot; class=&quot;headerlink&quot; title=&quot;文件io常用操作&quot;&gt;&lt;/a&gt;文件io常用操作&lt;/h1&gt;&lt;p&gt;一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io&lt;br&gt;open:打
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
</feed>
