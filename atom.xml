<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千分无言</title>
  
  <subtitle>人生苦短 我用python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hubhack.github.io/"/>
  <updated>2019-04-15T12:50:34.492Z</updated>
  <id>https://hubhack.github.io/</id>
  
  <author>
    <name>mwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python特殊函数</title>
    <link href="https://hubhack.github.io/13/"/>
    <id>https://hubhack.github.io/13/</id>
    <published>2019-04-14T14:26:00.000Z</published>
    <updated>2019-04-15T12:50:34.492Z</updated>
    
    <content type="html"><![CDATA[<h1 id="匿名函数"><a href="#匿名函数" class="headerlink" title="匿名函数"></a>匿名函数</h1><p>匿名函数 :隐藏名字,即没有名称<br>匿名函数: 没有名字的函数<br>lambda表达式<br>python中,使用lambda表达式构建匿名函数<br>使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式<br>参数列表不需要小括号,无参就不写参数<br>冒号用来分割参数和表达式部分<br>不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.<br>lambda表达式匿名函数只能写在一行上,也称为单行函数.</p><p>匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.</p><h1 id="递归函数"><a href="#递归函数" class="headerlink" title="递归函数"></a>递归函数</h1><p>函数执行流程:压栈</p><p>递归函数recursion<br>函数直接或者间接调用自身就是递归.<br>递归需要有边界条件,递归前进段,递归返回段.<br>递归一定要有边界条件.<br>当边界条件不满足的时候,递归前进<br>当边界条件满足的时候,递归返回.</p><p>递归例子:斐波那契数列<br>如果用循环写法:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a = 0</span><br><span class="line">b = 1</span><br><span class="line">n = 10</span><br><span class="line">for i in range(n -1):</span><br><span class="line">    a,b=b, a+b</span><br><span class="line">else:</span><br><span class="line">    print(b)</span><br></pre></td></tr></table></figure></p><p>递归写法:<br>def fib(n):<br>    return 1 if n &lt;3 else fib(n-1) +fib(n-2)</p><p>递归要求<br>递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.<br>递归调用的深度不宜<br>python 对递归调用的深度做了限制,以保护解释器<br>超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度<br>sys.getrecursionlimit()</p><p>循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.<br>递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.</p><p>递归是一种很自然的表达,符合逻辑思维<br>递归相对效率低,每一次调用都要开辟栈帧.<br>递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.<br>如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.<br>绝大多数递归,都可以使用循环实现<br>即使递归代码很简洁,但是能不用则不用递归.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;匿名函数&quot;&gt;&lt;a href=&quot;#匿名函数&quot; class=&quot;headerlink&quot; title=&quot;匿名函数&quot;&gt;&lt;/a&gt;匿名函数&lt;/h1&gt;&lt;p&gt;匿名函数 :隐藏名字,即没有名称&lt;br&gt;匿名函数: 没有名字的函数&lt;br&gt;lambda表达式&lt;br&gt;python中,使用la
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python小技巧</title>
    <link href="https://hubhack.github.io/12/"/>
    <id>https://hubhack.github.io/12/</id>
    <published>2019-04-14T14:26:00.000Z</published>
    <updated>2019-04-14T11:01:50.182Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为多个变量赋值"><a href="#为多个变量赋值" class="headerlink" title="为多个变量赋值"></a>为多个变量赋值</h2><p>有时，有多个变量需要赋值，这时你会怎么赋值呢？<br>常规方法：常规方法是给变量逐个赋值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>  </span><br><span class="line">b = <span class="number">1</span>  </span><br><span class="line">c = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>优雅方法：<br>直接按顺序对应一一赋值.<br>a, b, c = 0, 1, 2</p><h2 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h2><p>需要取出列表中的元素。<br>常规方法：一般我们知道可以通过下标获取具体元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">info = [<span class="string">'brucepk'</span>, <span class="string">'man'</span>, <span class="string">'python'</span>]</span><br><span class="line">name = info[<span class="number">0</span>]</span><br><span class="line">sex = info[<span class="number">1</span>]</span><br><span class="line">tech = info[<span class="number">2</span>]</span><br><span class="line">print(name,sex,tech)</span><br><span class="line">结果:</span><br><span class="line">brucepk man python</span><br></pre></td></tr></table></figure></p><p>优雅方法：给出对应变量接收所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]</span><br><span class="line">name,sex,tech = info</span><br><span class="line">print(name,sex,tech)</span><br><span class="line">结果:</span><br><span class="line">brucepk man python</span><br></pre></td></tr></table></figure></p><h2 id="优雅你的判断语句"><a href="#优雅你的判断语句" class="headerlink" title="优雅你的判断语句"></a>优雅你的判断语句</h2><p>我们用判断语句来定义一个绝对值函数。<br>常规方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-6</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    y = -x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = x</span><br><span class="line">print(y)</span><br><span class="line">结果:</span><br><span class="line"><span class="number">6</span></span><br><span class="line">优雅方法：</span><br><span class="line">x = <span class="number">-6</span></span><br><span class="line">y = -x <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> x</span><br><span class="line">print(y)</span><br><span class="line">结果</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="区间判断"><a href="#区间判断" class="headerlink" title="区间判断"></a>区间判断</h2><p>使用 and 连续两次判断的语句，条件都符合时才执行语句。<br>常规方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">82</span></span><br><span class="line"><span class="keyword">if</span> score &gt;=<span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>:</span><br><span class="line">    level = <span class="string">'B'</span></span><br><span class="line">print(level)</span><br><span class="line">结果</span><br><span class="line">B</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用链式判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = 82</span><br><span class="line">if  80 &lt;= score &lt; 90:</span><br><span class="line">    level = &apos;B&apos;</span><br><span class="line">print(level)</span><br><span class="line">结果</span><br><span class="line">B</span><br></pre></td></tr></table></figure></p><h2 id="多个值符合条件判断"><a href="#多个值符合条件判断" class="headerlink" title="多个值符合条件判断"></a>多个值符合条件判断</h2><p>多个值任意一个值符合条件即为 True 的情况。<br>常规方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">if num == 1 or num == 3 or num == 5:</span><br><span class="line">    type = &apos;奇数&apos;</span><br><span class="line">print(type)</span><br><span class="line">结果</span><br><span class="line">奇数</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用关键字 in，让你的语句更优雅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">if num in(1,3,5):</span><br><span class="line">    type = &apos;奇数&apos;</span><br><span class="line">print(type)</span><br><span class="line">结果</span><br><span class="line">奇数</span><br></pre></td></tr></table></figure></p><h2 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h2><p>判断元素是空还是非空。<br>常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;</span><br><span class="line">if len(A) &gt; 0:</span><br><span class="line">    print(&apos;A 为非空&apos;)</span><br><span class="line">if len(B) &gt; 0:</span><br><span class="line">    print(&apos;B 为非空&apos;)</span><br><span class="line">if len(C) &gt; 0:</span><br><span class="line">    print(&apos;C 为非空&apos;)</span><br><span class="line">结果</span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure></p><p>优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;  </span><br><span class="line">if A:</span><br><span class="line">    print(&apos;A 为非空&apos;)  </span><br><span class="line">if B:</span><br><span class="line">    print(&apos;B 为非空&apos;)  </span><br><span class="line">if C:</span><br><span class="line">    print(&apos;C 为非空&apos;)  </span><br><span class="line">结果</span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure><h2 id="多条件内容判断至少一个成立"><a href="#多条件内容判断至少一个成立" class="headerlink" title="多条件内容判断至少一个成立"></a>多条件内容判断至少一个成立</h2><p>常规方法：用 or 连接多个条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if math&lt;60 or English&lt;60 or computer&lt;60:</span><br><span class="line">    print(&apos;not pass&apos;)</span><br><span class="line">结果</span><br><span class="line">not pass</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 any 语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,59,88</span><br><span class="line">if any([math&lt;60,English&lt;60,computer&lt;60]):</span><br><span class="line">    print(&apos;not pass&apos;)</span><br><span class="line">结果</span><br><span class="line">not pass</span><br></pre></td></tr></table></figure></p><h2 id="多条件内容判断全部成立"><a href="#多条件内容判断全部成立" class="headerlink" title="多条件内容判断全部成立"></a>多条件内容判断全部成立</h2><p>常规方法：使用 and 连接条件做判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if math&gt;60 and English&gt;60 and computer&gt;60:</span><br><span class="line">    print(&apos;pass&apos;)</span><br><span class="line">结果</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 all 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if all([math&gt;60,English&gt;60,computer&gt;60]):</span><br><span class="line">    print(&apos;pass&apos;)</span><br><span class="line">结果</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><h2 id="遍历序列的元素和元素下标"><a href="#遍历序列的元素和元素下标" class="headerlink" title="遍历序列的元素和元素下标"></a>遍历序列的元素和元素下标</h2><p>常规方法：使用 for 循环进行遍历元素和下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class="line">for i in range(len(L)):</span><br><span class="line">    print(i, &apos;:&apos;, L[i])</span><br><span class="line">结果</span><br><span class="line">0 : math</span><br><span class="line">1 : English</span><br><span class="line">2 : computer</span><br><span class="line">3 : Physics</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 enumerate 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class="line">for k,v in enumerate(L):</span><br><span class="line">    print(k, &apos;:&apos;, v)</span><br><span class="line">结果</span><br><span class="line">0 : math</span><br><span class="line">1 : English</span><br><span class="line">2 : computer</span><br><span class="line">3 : Physics</span><br></pre></td></tr></table></figure></p><h2 id="循环语句优化"><a href="#循环语句优化" class="headerlink" title="循环语句优化"></a>循环语句优化</h2><p>之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。<br>常规方法：使用简单的 for 循环可以达到目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for i in range(1, 6):</span><br><span class="line">    L.append(i*i)</span><br><span class="line">print(L) </span><br><span class="line">结果：</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用列表生成式，一行代码搞定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print([x*x for x in range(1, 6)]) </span><br><span class="line">结果：</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p><h2 id="将list中的所有元素转为单个字符串"><a href="#将list中的所有元素转为单个字符串" class="headerlink" title="将list中的所有元素转为单个字符串"></a>将list中的所有元素转为单个字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]</span><br><span class="line">print(&quot; &quot;,join(a))</span><br></pre></td></tr></table></figure><h2 id="字符串倒转"><a href="#字符串倒转" class="headerlink" title="字符串倒转"></a>字符串倒转</h2><p>方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。<br>方法二：用Python自带reversed()函数，它可被用于list倒转。<br>方法三：第三种是通过倒转数据类型和切片倒转整数.</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>在python 中实现链式调用只需在函数返回对象自己就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def product(a, b):</span><br><span class="line">    return a * b</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line">b = True</span><br><span class="line">print((product if b else add)(5, 7))</span><br></pre></td></tr></table></figure></p><h2 id="复制list"><a href="#复制list" class="headerlink" title="复制list"></a>复制list</h2><p>在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：<br>方法一：b=a[:]。<br>方法二：b=list(a)。<br>方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。<br>方法四：使用copy.deepcopy()。</p><h2 id="按value排序字典"><a href="#按value排序字典" class="headerlink" title="按value排序字典"></a>按value排序字典</h2><p>Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：<br>方法一：用sorted函数排序，其中key参数是lamda表达式。<br>方法二：用operator.itemgetter而不是lamda表达式进行排序。<br>方法三：如果只需得到排序后的key，可用.get。</p><h2 id="for-…-else语法"><a href="#for-…-else语法" class="headerlink" title="for … else语法"></a>for … else语法</h2><h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>方法一：Python 3.5可以存在重复键值，print({<strong>d1 ,</strong>d2})。<br>方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。<br>方法三：d1.update()。</p><h2 id="从list中删除重复项"><a href="#从list中删除重复项" class="headerlink" title="从list中删除重复项"></a>从list中删除重复项</h2><p>方法一：把list转成set，去除重复项，再转回list。<br>方法二：调用collections里的OrderedDict，和set差不多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为多个变量赋值&quot;&gt;&lt;a href=&quot;#为多个变量赋值&quot; class=&quot;headerlink&quot; title=&quot;为多个变量赋值&quot;&gt;&lt;/a&gt;为多个变量赋值&lt;/h2&gt;&lt;p&gt;有时，有多个变量需要赋值，这时你会怎么赋值呢？&lt;br&gt;常规方法：常规方法是给变量逐个赋值。&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python函数</title>
    <link href="https://hubhack.github.io/11/"/>
    <id>https://hubhack.github.io/11/</id>
    <published>2019-04-11T14:26:00.000Z</published>
    <updated>2019-04-15T00:44:18.278Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>数学定义<br>y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)<br>python函数:<br>是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元<br>完成一定的功能<br>函数的作用<br>结构化编程对代码的最基本的封装, 一般按照功能组织一段代码<br>封装的目的为了复用,减少冗余代码<br>代码更加简洁美观,可读易懂</p><p>函数的分类:<br>内建函数,如max()<br>库函数,如math.ceil<br>自定义函数,使用def关键字定义</p><p>函数定义<br>def 函数名(参数列表):<br>    函数体(代码块)<br>    [return 返回值]<br>函数名就是标识符,命名要求一样<br>语句块必须缩进,约定4个空格<br>函数名就是标识符就是变量python的函数没有return,会返回none<br>定义中的参数列表称为形式参数,只是一种标识符占位置的<br>函数的标识符就是指向函数对象<br>函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参<br>不定义会报nameERREO</p><p>传参方式:</p><ul><li>位置传参<br>按照参数定义顺序传入实参</li><li>关键字<br>使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同<br>要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的<br>参数缺省值<br>缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:<br>参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值<br>参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用</li></ul><p>可变位置参数<br>在形参使用* 表示该形参是可变位置参数, 可以接受多个实参<br>它将收集来的实参组织到一个tuple中<br>tuple 有序按位置传参<br>可变关键字参数<br>在形参使用<strong>表示该形参是可变关键字参数,可以接受多个关键字参数<br>它将收集来的实参的名称和值,组织到一个dict中<br>可变的关键字传参</strong> kwargs</p><p>有可变位置参数和可变关键字参数<br>可变位置参数在形参前使用一个*号<br>可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple<br>可变关键字参数收集形成一个dict<br>混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面<br>要在可变关键字参数之前.</p><h1 id="keyword-only-参数"><a href="#keyword-only-参数" class="headerlink" title="keyword-only 参数"></a>keyword-only 参数</h1><p>def fn(<em>args, x, y, **kwargs):<br>    print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)<br>fn(3, 5)<br>fn(3, ,5, 7)<br>在python3之后,新增了keyword-only参数<br>keyword-only参数:在形参定义时,在一个</em>星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数<br>keyword-only参数,言下之意就是这个参数必须采取关键字传参<br>可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.<em>星号后所有的普通参数都成了keyword-only参数<br>参数的混合使用<br>参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数<br>代码应该易读易懂, 而不是为难别人<br>请按照书写习惯定义函数参数.<br>参数解构:<br>在给函数提供实参的时候,可以在可迭代对象前使用</em>或者<strong>来进行的解构,提取出其中所有元素作为函数的实参.<br>使用*解构成位置参数<br>使用</strong>解构成位置 传参<br>提取出来的元素数目要和参数的要求匹配</p><p>python函数使用return语句返回”返回值”<br>所有函数都有返回值,如果没有return语句, 隐式调用return None<br>return语句并不一定是函数的语句块的最后一条语句<br>一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None<br>如果有必要,可以显示调用return None ,可以简写return<br>如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行<br>返回值的作用: 结束函数调用,返回返回值<br>函数不能同时返回多个值.</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域<br>注意:每一个函数都会开辟一个作用域<br>分类:<br>全局作用域:<br>在整个程序运行环境中都可见<br>全局作用域中的变量称为全局变量<br>局部作用域:<br>在函数 ,类等内部可见<br>局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域<br>函数嵌套<br>在一个函数中定义了另一个函数<br>内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见</p><p>global语句<br>使用global关键字的变量,将声明为外部的全局作用域中定义的<br>使用了global 不再是局部变量,它是全局变量<br>global使用原则<br>外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离<br>如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决<br>一句话:不要global,学习他就是深入理解变量作用域</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>自由变量:未在本地作用域中定义的变量<br>闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript</p><p>nonlocal语句<br>将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义<br>内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义<br>代码中内层函数引到外部局部作用域中的自由变量,形成闭包</p><p>函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联<br>python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期<br>查看<strong>default</strong>属性,他是个元组</p><h1 id="变量名解析原则LEGB"><a href="#变量名解析原则LEGB" class="headerlink" title="变量名解析原则LEGB***"></a>变量名解析原则LEGB***</h1><p>local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡<br>Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间<br>global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡<br>build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡<br>所以一个名词的查找顺序就是LEGB.</p><p>|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;数学定义&lt;br&gt;y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)&lt;br&gt;python函数:&lt;br
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>基本算法</title>
    <link href="https://hubhack.github.io/4/"/>
    <id>https://hubhack.github.io/4/</id>
    <published>2019-04-11T14:26:00.000Z</published>
    <updated>2019-04-12T00:40:29.995Z</updated>
    
    <content type="html"><![CDATA[<p>基本入门算法有三个经典算法:冒泡,选择和插入算法</p><h1 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h1><p>简单选择排序属于选择排序<br>两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端<br>结果分为升序和降序排列</p><p>基本思路:</p><ul><li>求出最大索引(或最小索引)并记录</li><li>两两交换</li><li>补充特殊情况,完善代码</li></ul><p>先用几个数做测试</p><blockquote><p>nums = [1, 9, 8]<br>length = len(nums)</p><p>maxindex = 0<br>for i in range(maxindex+1, length):<br>   if nums[i] &gt; nums[maxindex]:<br>       maxindex = i<br>print(maxindex, nums[maxindex])<br>结果 1,9<br>做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]<br>做外层循环for i in range(length)<br>基本代码实现<br>nums = [1, 9, 8]<br>length = len(nums)</p><h1 id="maxindex-0"><a href="#maxindex-0" class="headerlink" title="maxindex = 0"></a>maxindex = 0</h1><p>for j in range(length):<br>   maxindex = j<br>   for i in range(maxindex+1, length):<br>       if nums[i] &gt; nums[maxindex]:<br>           maxindex = i # 比较先确定索引 记录maxindex为最大索引<br>   if maxindex != i:<br>           nums[i], nums[maxindex] = nums[maxindex], nums[i]<br>print(nums)</p></blockquote><p>做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序</p><p>第二种方法:</p><blockquote><p>import random<br>nums = list(range(10))<br>random.shuffle(nums)</p><p>length = len(nums)</p><h1 id="maxindex-0-1"><a href="#maxindex-0-1" class="headerlink" title="maxindex = 0"></a>maxindex = 0</h1><p>for i in range(length // 2):<br>   maxindex = i<br>   minindex = -1-i<br>   minorigin = length + minindex<br>   for j in range(i + 1, length - i):<br>       if nums[j] &gt; nums[maxindex]:<br>           maxindex = j # 比较先确定索引 记录maxindex为最大索引<br>       if nums[-j-1] &lt; nums[minindex]:<br>           minindex = -j-1<br>   if nums[maxindex] == nums[minindex]: break<br>   minindex = length + minindex<br>   if maxindex != i: # 进去 ,说明一定有交换<br>       nums[i], nums[maxindex] = nums[maxindex], nums[i]<br>       if minindex == i:<br>           minindex = maxindex<br>   if minindex != minorigin and nums[minorigin] != nums[minindex]:<br>       nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]<br>print(nums)</p></blockquote><h1 id="冒泡法"><a href="#冒泡法" class="headerlink" title="冒泡法"></a>冒泡法</h1><p>实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.<br>下面是使用代码的实现</p><p>arr = [7, 4, 3, 67, 34, 1, 8]</p><p>def bubble_sort(arr):<br>    n = len(arr)<br>    for j in range(0, n - 1):<br>        for i in range(0, n - 1 - j):<br>            if arr[i] &gt; arr[i + 1]:<br>                arr[i], arr[i + 1] = arr[i + 1], arr[i]</p><p>bubble_sort(arr)<br>print(arr)  # [1, 3, 4, 7, 8, 34, 67]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>关键点其实在双重for循环变量的配置，我们来分析一下<br>第一次循环： j = 0, i~n-2 range(0, n-1)<br>第二次循环： j = 1, i~n-3 range(0, n-1-1)<br>第三次循环： j = 2, i~n-4 range(0, n-1-1-1)<br>—&gt; range(0, n-1-j)</p><p>理解这一点后，我们就可以换一种写法来实现了</p><p>def bubble_sort2(arr):<br>    for j in range(len(arr) - 1, 0, -1):  # [n-1, n-2, ….2, 1]<br>        for i in range(0, j):<br>            if arr[i] &gt; arr[i + 1]:<br>                arr[i], arr[i + 1] = arr[i + 1], arr[i]</p><p>bubble_sort2(arr)<br>print(arr)  # [1, 3, 4, 7, 8, 34, 67]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>优化<br>写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化</p><p>def bubble_sort3(arr):<br>    for j in range(len(arr)-1, 0, -1):<br>        count = 0<br>        for i in range(0, j):<br>            if arr[i] &gt; arr[i + 1]:<br>                arr[i], arr[i + 1] = arr[i + 1], arr[i]<br>                count += 1<br>        if count == 0:<br>            return</p><p>bubble_sort3(arr)<br>print(arr)  # [1, 3, 4, 7, 8, 34, 67]<br>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)</p><p>扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。</p><p>def add(x):<br>    return x + 5</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;基本入门算法有三个经典算法:冒泡,选择和插入算法&lt;/p&gt;
&lt;h1 id=&quot;选择排序&quot;&gt;&lt;a href=&quot;#选择排序&quot; class=&quot;headerlink&quot; title=&quot;选择排序&quot;&gt;&lt;/a&gt;选择排序&lt;/h1&gt;&lt;p&gt;简单选择排序属于选择排序&lt;br&gt;两两比较大小,找出极值或极小
      
    
    </summary>
    
      <category term="数据结构" scheme="https://hubhack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构和算法" scheme="https://hubhack.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E5%92%8C%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>算素数和杨辉三角</title>
    <link href="https://hubhack.github.io/10/"/>
    <id>https://hubhack.github.io/10/</id>
    <published>2019-04-03T02:46:44.955Z</published>
    <updated>2019-04-05T01:28:26.785Z</updated>
    
    <content type="html"><![CDATA[<h1 id="求素数算法剖析"><a href="#求素数算法剖析" class="headerlink" title="求素数算法剖析"></a>求素数算法剖析</h1><ul><li><p>简单解法<br>n = 100<br>for i in range(2,n):<br>  for x in range(2 ,int(i**0.5)+1):</p><pre><code>if i % x == 0:    break</code></pre><p>  else:</p><pre><code>count +=1print(x)</code></pre><p>for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.</p></li><li><p>使用奇数</p></li></ul><p>n = 100<br>count = 1<br>for x in range(3,n,2):<br>    for i in range(3,int(x**0.5)+1,2):<br>        if x % i ==0:<br>            break<br>    else:<br>        count += 1<br>print (count)</p><ul><li>储存质素</li></ul><p>合数一定可以分解为几个质数的乘积,2是质数<br>质数一定不能整除1和本身之内的整数<br>n = 100<br>count = 1<br>pre<br>for x in range(3,n,2):<br>    for i in primenumbers:<br>        if x % i == 0:<br>            break<br>    else:<br>        premenumber.append(x)<br>        count +=1<br>print(count)</p><h1 id="杨辉三角"><a href="#杨辉三角" class="headerlink" title="杨辉三角"></a>杨辉三角</h1><p>预先构成前两行 从而推到后面的所有行<br>triandle = [[1],[1,1]]<br>for i in range(2,6):<br>    cur = [1]<br>    pre = triandle[i -1]<br>    for j in range(i-1):<br>        cur.append(pre[j] + pre[j + 1])<br>    cur.append(1)<br>    triandle.append(cur)<br>print(triandle)</p><p>变形<br>triandle = []<br>n = 6<br>for i in range(n):<br>    cur = [1]<br>    triandle.append(cur)</p><pre><code>if  i==0:continuepre = triandle[i -1]for  j in range(i -1):    cur.append(pre[j] + pre[j + 1])cur.append(1)</code></pre><p>print(triandle)</p><ul><li>补零法<br>n = 6<br>newline = [1]<br>print(newline)</li></ul><p>for  i in range(1,n):<br>    oldline = newline.copy()<br>    oldline.append(0)<br>    newline.clear()</p><pre><code>for j in range(i+1):    newline.append(oldline[j -1] + oldline[j])print(newline)</code></pre><ul><li>对称性<br>一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.</li></ul><p>triandle = []<br>n = 6<br>for i in range(n):<br>    row = [1] * (i + 1)<br>    triandle.append(row)</p><pre><code>for j in range(1,i//2+1):    val = triandle[i-1][j-1] + triandle[i -1][j]    row[j]  = val    row[-j-1] = val</code></pre><p>print(triandle)<br>triangle = []<br>n = 6<br>for i in range(n):<br>    row = [1] <em>(i +1)<br>    triangle.append(row)<br>    for  j in range(i,i//2+1):<br>        val = triangle[i-1][j-1] + triangle[i -1][j]<br>        row[j] = val<br>        if  i != 2</em>j:<br>            row[-j-i] = val<br>print(triangle)</p><ul><li>单行覆盖法<br>n = 6<br>row = [1] <em>n<br>print(row)<br>print(‘_’ </em> 30)</li></ul><p>for  i in range(n):<br>    for j in range(i//2):<br>        val = row[j] + row[j+1]<br>        row[j+1]=val<br>        if i != 2* (j+1):<br>            row[i-(j+1)] =val<br>    print(row[:i+1])</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;求素数算法剖析&quot;&gt;&lt;a href=&quot;#求素数算法剖析&quot; class=&quot;headerlink&quot; title=&quot;求素数算法剖析&quot;&gt;&lt;/a&gt;求素数算法剖析&lt;/h1&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;简单解法&lt;br&gt;n = 100&lt;br&gt;for i in range(2,n):&lt;b
      
    
    </summary>
    
      <category term="算法" scheme="https://hubhack.github.io/categories/%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="算法" scheme="https://hubhack.github.io/tags/%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>python知识框架</title>
    <link href="https://hubhack.github.io/6/"/>
    <id>https://hubhack.github.io/6/</id>
    <published>2019-03-30T14:25:34.000Z</published>
    <updated>2019-03-31T12:19:49.157Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>python是一种动态的强类型语言,底层是用C语言开发的.</p><p>平台：*nix平台<br>系统：线程、进程、Shell编程<br>网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发<br>算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写<br>数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个<br>中间件：消息队列原理和应用，例如8曲bitMQ<br>WEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一<br>可视化：WEB的前端开发多一些HTML、jS要会<br>数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用</p><p>python学习路线:<br>基础：操作系统、网络基础、数据库基础、python语言基础..<br>进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..<br>高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).<br>新前端开发(ES6、React、Antd）…<br>实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..<br>高端：数据清洗、企业数据分析、预测准荐、机器视觉．</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母A用ASCII编码是十进制的65，二进制的01000001；</p><p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p><p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p><p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.</p><h3 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h3><p>format函数或 格式符</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>字符串与bytes<br>字符串是字符组成的有序序列，字符可以使用编码来理解<br>bytes是字节组成的有序的不可变序列<br>bytearray是字节组成的有序的可变序列</p><p>编码与解码：<br>字符串按照不同的字符集编码encode返回字节序列bytes<br>encode（encoding=‘utf-8’，errors=‘strict’）<br>字节序列按照不同的字符集解码decode返回字符串<br>bytes.decode（encoding=“utf-8”，errors=“strict”）<br>ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统</p><p>要熟记31 41 61 的ascii表</p><p>字节序：<br>大端模式，big-endian；小端模式，little-endian<br>intel x86cpu使用小端 模式<br>网络传输更多使用大端模式<br>windows，linux 使用小端模式<br>mac os使用大端模式<br>java 虚拟机是大端模式</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>有整数 浮点数 复数等</p><h2 id="true-false"><a href="#true-false" class="headerlink" title="true false"></a>true false</h2><p>主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。</p><p>None：Python里面特殊的空值，不能理解为0。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>list（列表） tuple（元组） set（集合） dictionary（字典）<br>这些都是可以迭代的</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组和列表类似，但是不同的是元组不能修改，元组使用小括号。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><h2 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p><p>elif 语句</p><p>elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。</p><p>if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for循环可以遍历任何序列的项目：</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环：</p><p>break和continue语句：</p><p>break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。</p><p>continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;python是一种动态的强类型语言,底层是用C语言开发的.&lt;/p&gt;
&lt;p&gt;平台：*
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>99乘法表的不同解法</title>
    <link href="https://hubhack.github.io/7/"/>
    <id>https://hubhack.github.io/7/</id>
    <published>2019-03-30T14:25:34.000Z</published>
    <updated>2019-04-11T12:31:33.639Z</updated>
    
    <content type="html"><![CDATA[<p>第一种方法：用先打印正方形之后打印下三角 </p><blockquote><p>for i in range (1,10):<br>   line = ‘’<br>   for j in range (1,10):<br>       if i &gt;=j:</p><pre><code>line += str (j) +&apos;*&apos;+str(i) +&apos;=&apos;+ str(i*j) + &apos; &apos;</code></pre><p>   print(line)<br>第二种用format 格式化字符串<br>for i range(1,10):<br>   line =’’<br>   for j in range(1,10):<br>       line += “{}<em>{}={} “.foramt(j,i,(j</em>i))<br>   print(line)<br>第三种 j的取值范围是（1，i+1）<br>for i in range(1,10):<br>   line =’’<br>   for j in range(1,i+1):<br>        line += ‘{}<em>{}={} ‘.format(j,i,(i</em>j))<br>   print(line,end=’\n’)<br>range 函数可以控制语句 可以当if<br>变形<br>for i in range(1,10):<br>   for j in range(1,i+1):<br>       line = ‘{}<em>{}={} ‘.format(j,i,(i</em>j))<br>       print(line, end=’’)<br>   print()<br>row 是行 column 是列<br>for i in range(1,10):<br>   for j in range(1,i+1):<br>       line = ‘{}<em>{}={} ‘.format(j,i,(i</em>j))<br>       print(line, end=’’)<br>       if  i==j:<br>           print()<br>再变形<br>for i in range(1,10):<br>   for j in range(1,i+1):<br>       if  i==j:<br>           endchar = ‘\n’<br>       else:<br>           endchar = ‘’</p><pre><code>line = &apos;{}*{}={} &apos;.format(j,i,(i*j) ,end = endchar)print(line, end=&apos;&apos;)</code></pre><p>三元表达式 写法<br>endchar = ‘\n’ if  i==j else ‘’<br>三行 代码写出程序<br>for i in range (1,10):<br>   for j in range(1,i+1):<br>       print(“{}<em>{}={} “.format(j,i,i</em>j) ,end = ‘\n’ if i ==j else ‘’)<br>用列表方式来写 ,最后再解构<br>for i in range(1,10):<br>   line = []<br>   for j in  range(1,i+1):<br>       line.append(“{}<em>{}={} “.format(j,i,i</em>j))<br>   print(<em>line,sep=’ ‘)<br>tip：再括号内换行不用换行符<br>for i in range(1,10):<br>   for j in range(1,i+1):<br>       print(“{}</em>{}={}{}”.format(j,i,j<em>i, ‘’ if  j==2 and i&lt;5 else ‘’),<br>       end= ‘\n’ if  i==j else ‘ ‘)<br>用格式符对齐方式 写<br>for i in range(1,10):<br>   for  j in range(1,i+1):<br>       print(“{}</em>{}={:&lt;2}”.format(j,i,i*j),<br>       end=’\n’ if  i == j else ‘\t’)</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;第一种方法：用先打印正方形之后打印下三角 &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;for i in range (1,10):&lt;br&gt;   line = ‘’&lt;br&gt;   for j in range (1,10):&lt;br&gt;       if i &amp;gt;=j:&lt;/p&gt;

      
    
    </summary>
    
      <category term="数据结构与算法" scheme="https://hubhack.github.io/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
    
      <category term="数据结构与算法" scheme="https://hubhack.github.io/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E4%B8%8E%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>linux知识框架</title>
    <link href="https://hubhack.github.io/1/"/>
    <id>https://hubhack.github.io/1/</id>
    <published>2019-03-19T14:26:13.000Z</published>
    <updated>2019-03-31T11:10:09.531Z</updated>
    
    <content type="html"><![CDATA[<h1 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2><p>os(operating system),通用目的的软件程序</p><blockquote><p>硬件驱动<br>进程管理<br>内存管理<br>网络管理<br>安全管理<br>文件管理</p></blockquote><h2 id="安装linux"><a href="#安装linux" class="headerlink" title="安装linux"></a>安装linux</h2><blockquote><p>linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的<a href="https://www.manjaro.cn/153" target="_blank" rel="noopener">manjaro</a>或<a href="https://www.linuxmint.com/download.php" target="_blank" rel="noopener">mint</a><br>分区和启动:<br>硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tb<br>uefi的GPT分区:逐渐代替MBR标准<br>主分区 一块硬盘最多4个,不能划分更小,最小单位<br>扩展分区:一块硬盘最多一个,不能直接创建文件系统<br>安装过程大同小异 <a href="https://blog.csdn.net/python_lqx/article/details/88670425" target="_blank" rel="noopener">详细步骤</a><br>需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌.<br>/dev/sda 100g<br>/dev/sda1 /boot mountpoint  1g<br>/dev/sda2 /                50g<br>/dev/sda3 /data            20g<br>/dev/sda5 /swap             2g</p></blockquote><h2 id="开发接口标准"><a href="#开发接口标准" class="headerlink" title="开发接口标准"></a>开发接口标准</h2><blockquote><p>ABI:application binary interface ABI描述了程序与os之间的底层接口<br>API:application programming interface<br>开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit</p></blockquote><h2 id="用户和内核空间"><a href="#用户和内核空间" class="headerlink" title="用户和内核空间"></a>用户和内核空间</h2><blockquote><p>username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响<br>内核空间:kernel space</p></blockquote><h2 id="linux哲学思想"><a href="#linux哲学思想" class="headerlink" title="linux哲学思想"></a>linux哲学思想</h2><p>在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的</p><h1 id="文件操作"><a href="#文件操作" class="headerlink" title="文件操作"></a>文件操作</h1><p>文件和目录被组织成单根倒置树结构<br>文件系统从根目录下开始,用”/“表示<br>proc虚拟的,在硬盘上不存在<br>文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)<br>以.开头的文件为隐藏文件<br>元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.<br>数据:data(内容在硬盘上)<br>文件系统分成结构:LSB<br>文件名最长255个字节,文件系统不一样大小不一样<br>包括路径在内文件名称最长4095个字节<br>蓝色—目录 绿色—可执行文件  红色—压缩文件<br>浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递<br>管道文件 p开头(pipe)单工传输</p><h2 id="文件系统结构元素"><a href="#文件系统结构元素" class="headerlink" title="文件系统结构元素"></a>文件系统结构元素</h2><p>/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录<br>/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序<br>/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序<br>/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)<br>/lib64：专用于x86_64系统上的辅助共享库文件存放位置<br>/etc：配置文件目录<br>/home/USERNAME：普通用户家目录<br>/root：管理员的家目录<br>/media：便携式移动设备挂载点<br>/mnt：临时文件系统挂载点<br>/dev：设备文件及特殊文件存储位置  b: block device，随机访问  c: character device，线性访问<br>/opt：第三方应用程序的安装位置<br>/srv：系统上运行的服务用到的数据<br>/tmp：临时文件存储位置<br>/proc: 用于输出内核与进程信息相关的虚拟文件系统<br>/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统<br>/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文<br>/usr: universal shared, read-only data  bin: 保证系统拥有完整功能而提供的应用程序<br>sbin:  lib：32位使用  lib64：只存在64位系统<br>include: C程序的头文件(header files)<br>share：结构化独立的数据，例如doc, man等<br>local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文</p><p>/var: variable data files  cache: 应用程序缓存数据目录<br>lib: 应用程序状态信息数据<br>local：专用于为/usr/local下的应用程序存储可变数据<br>lock: 锁文件  log: 日志目录及文件<br>opt: 专用于为/opt下的应用程序存储可变数据<br>run: 运行中的进程相关数据,通常用于存储进程pid文件<br>spool: 应用程序数据池<br>tmp: 保存系统两次重启之间产生的临时数据</p><h2 id="Linux下的文件类型"><a href="#Linux下的文件类型" class="headerlink" title="Linux下的文件类型"></a>Linux下的文件类型</h2><p>-：普通文件<br>d: 目录文件<br>b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)<br>c: 字符设备(设备主要以字符为单位,键盘为主)<br>l: 符号链接文件<br>p: 管道文件pipe<br>s: 套接字文件socket</p><h3 id="显示当前工作目录"><a href="#显示当前工作目录" class="headerlink" title="显示当前工作目录"></a>显示当前工作目录</h3><p>每个shell和系统进程都有一个当前的工作目录<br>CWD:current work directory<br>显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认）</p><h3 id="更改目录"><a href="#更改目录" class="headerlink" title="更改目录"></a>更改目录</h3><p>cd  改变目录 使用绝对或相对路径： cd /home/wang/        cd home/wang 切换至父目录：  cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -<br>选项：-P<br>相关的环境变量：  PWD：当前目录路径   OLDPWD：上一次目录路径</p><h3 id="列出目录内容"><a href="#列出目录内容" class="headerlink" title="列出目录内容"></a>列出目录内容</h3><p>列出当前目录的内容或指定目录<br>用法：ls [options] [ files_or_dirs ]<br>示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R  目录递归通过 ls -ld  目录和符号链接信息 ls -1  文件分行显示 ls –S  按从大到小排序 ls –t   按mtime排序 ls –u   配合-t选项，显示并按atime从新到旧排序<br>ls –U  按目录存放顺序显示 ls –X  按文件后缀排序</p><blockquote><p>[root@centos7 sysconfig]# ll /etc/motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd<br>[root@centos7 sysconfig]# ll ../motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd<br>-a 全部<br>-r 递归<br>ll 是别名 (ls -l)</p></blockquote><h3 id="查看文件状态"><a href="#查看文件状态" class="headerlink" title="查看文件状态"></a>查看文件状态</h3><p>stat<br>文件：metadata, data<br>三个时间戳: access time：访问时间，atime，读取文件内容<br>modify time: 修改时间,<br>mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变<br>data 时间不会一直更新<br>通配符* 任意字符<br>二进制查看hexdump -C</p><h3 id="创建和查看文件"><a href="#创建和查看文件" class="headerlink" title="创建和查看文件"></a>创建和查看文件</h3><p>touch 命令是个外部命令<br>[]表示其中一个字母<br>[^  ]表示除去其中字符的任意字符<br>两个大于号比 touch安全</p><h3 id="文件统配符"><a href="#文件统配符" class="headerlink" title="文件统配符"></a>文件统配符</h3><p>man 7 glob</p><h3 id="复制和转移删除文件"><a href="#复制和转移删除文件" class="headerlink" title="复制和转移删除文件"></a>复制和转移删除文件</h3><p>cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失<br>原始命令前加\<br>拷贝文件夹 -r(递归)<br>cp 有可能丢失数据不能用rmdir删除</p><p>data是个挂载点<br>cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中      如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中  基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中<br>cp SRC… DEST    SRC…：多个文件<br>DEST必须存在，且为目录，其它情形均会出错；cp SRC DEST<br>SRC是目录：此时使用选项：-r<br>如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；<br>如果DEST存在：<br>如果DEST是文件：报错<br>如果DEST是目录：<br>inode（index node）表中包含文件系统所有文件列表<br>一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括：  文件类型，权限，UID，GID  链接数（指向这个文件名路径名称个数）  该文件的大小和不同的时间戳  指向磁盘上文件的数据块指针  有关文件的其他数据 </p><p>inode 唯一标识在元数据里<br>删除其实删的元数据.删文件比建文件快多了</p><h3 id="软和硬链接"><a href="#软和硬链接" class="headerlink" title="软和硬链接"></a>软和硬链接</h3><p>硬链接<br>创建硬链接会增加额外的记录项以引用文件<br>对应于同一文件系统上一个物理文件<br>每个目录引用相同的inode号<br>创建时链接数递增<br>删除文件时：<br>rm命令递减计数的链接<br>文件要存在，至少有一个链接数<br>当链接数为零时，该文件被删除<br>不能跨越驱动器或分区<br>语法:  ln filename  [linkname ]<br>软连接<br>一个符号文件链接指向一个文件<br>ls -s显示链接的名称和应用的文件<br>一个符号链接的内容是他引用文件的名称<br>可以对目录进行<br>可以跨分区<br>指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数<br>语法:ln -s 文件 链接名</p><h2 id="i-0-重定向至文件"><a href="#i-0-重定向至文件" class="headerlink" title="i/0 重定向至文件"></a>i/0 重定向至文件</h2><p>程序:指令+数据<br>input 和output<br>打开的文件都有一个fd:file descrptor(文件描述符)<br>linux 给程序提供三种i/o设备<br>标准输入(STDIN)-0 默认接受来自键盘的输入<br>标准输出(STDOUT) -1默认输出到终端窗口<br>标准错误(STDERR) -2 默认输出到窗口<br>i/o重定向:改变默认位置<br>语法:命令  操作符号 文件名<br>操作符&gt;把STDOUT重定向到文件<br>2&gt; 把STDERR重定向到文件<br>$&gt; 把所有输出重定向到文件<br>tr 转换和删除字符</p><h2 id="管道"><a href="#管道" class="headerlink" title="管道"></a>管道</h2><p>管道用来连接命令<br>命令1|命令2|命令3<br>将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDIN<br>less 一页一页地查看输入<br>重定向到多个目标(tee)<br>把命令1的STDOUT保存在文件中,作为命令2的输入<br>-a追加<br>使用:<br>保存不同阶段的输入<br>复杂管道的故障排除<br>同时查看和记录输出</p><h1 id="用户组权限"><a href="#用户组权限" class="headerlink" title="用户组权限"></a>用户组权限</h1><h2 id="用户user"><a href="#用户user" class="headerlink" title="用户user"></a>用户user</h2><p>令牌token,identity<br>linux用户:username/UID<br>管理员:root,0<br>普通用户:1-65535<br>系统用户:1-499,1-999<br>对守护进程获取资源进行权限进行分配<br>登录用户:500+,1000<br>交互式登录<br>nologin 是软件启动没有用户登录</p><h2 id="组group"><a href="#组group" class="headerlink" title="组group"></a>组group</h2><p>linux:Groupname/GID<br>管理员:<br>系统 :1-499,1-999<br>普通组:500+,1000+<br>安全上下文:<br>进行中的程序:程序(process)<br>以进程发起者的身份运行:<br>root:/bin/cat<br>mage:/bin/cat<br>组的类别<br>用户的主要组:<br>用户必须属于一个且只有一个主组<br>组名同用户名,且包含一个用户,私有组<br>用户和组的配置文件<br>/etc/passwd:用户及其属性信息<br>/etc/group:组及其属性信息<br>/etc/shadow:用户密码及其相关属性<br>/etc/gshadow:组密码及其相关属性<br>passwd文件格式<br>login name:登录用名<br>passwd:密码<br>UID:用户身份编号<br>GID:登录默认所在组编号<br>GECOS:用户全名或注释<br>home diretory:用户主目录<br>shell:用户默认使用shell<br>shadow文件格式<br>useradd usermod userdel<br>组账号维护命令:groupadd<br>groupmod groupdel</p><h2 id="用户创建-useradd"><a href="#用户创建-useradd" class="headerlink" title="用户创建:useradd"></a>用户创建:useradd</h2><p>useradd [options]LOGIN<br>-u UID<br>-o 配合-u选项,不检查UID的唯一性<br>-g GID:指明用户所属基本组,可谓组名,也可以GID<br>-c “COMMENT”:用户的注释信息<br>默认设置:/etc/default/useradd文件中<br>删除用户:userdel -r删除用户目录</p><h2 id="查看用户相关的ID信息"><a href="#查看用户相关的ID信息" class="headerlink" title="查看用户相关的ID信息"></a>查看用户相关的ID信息</h2><p>id [OPTIONS]…[USER]<br>-u :显示UID<br>-g :显示GID<br>-G :显示用户所属的组的ID<br>-n :显示名称,需配合ugG使用</p><h2 id="切换用户或以其他用户身份执行命令"><a href="#切换用户或以其他用户身份执行命令" class="headerlink" title="切换用户或以其他用户身份执行命令"></a>切换用户或以其他用户身份执行命令</h2><p>su[options] [-] [user[args…]]<br>切换用户的方式<br>ssh root@ip<br>curl ww<br>service network restat</p><h2 id="设置密码"><a href="#设置密码" class="headerlink" title="设置密码"></a>设置密码</h2><p>passwd<br>常用选项：<br> -d:删除指定用户密码<br> -l:锁定指定用户<br> -u:解锁指定用户<br> -e:强制用户下次登录修改密码<br> -f: 强制操作<br> -n mindays: 指定最短使用期限<br> -x maxdays：最大使用期限<br> -w warndays：提前多少天开始警告<br> -i inactivedays：非活动期限<br> –stdin：从标准输入接收用户密码<br> echo “PASSWORD” | passwd –stdin USERNAME</p><h2 id="创建组"><a href="#创建组" class="headerlink" title="创建组"></a>创建组</h2><p>groupadd[option]…group_name<br>-g GID:指明GID号:<br>-r:创建系统组<br>修改和删除组:<br>组属性修改:groupmod<br>组删除:groupdel<br>组密码:gpasswd<br>newgrp命令:临时切换主组<br>chown设置文件的所有者<br>chgrp设置文件的属组信息<br>修改文件的属主和属组chown<br>修改文件的属组:chgrp</p><h2 id="文件权限"><a href="#文件权限" class="headerlink" title="文件权限"></a>文件权限</h2><p>文件的权限主要针对三类对象进行定义<br>owner: 属主, u<br>group: 属组, g<br>other: 其他, o<br>每个文件针对每类访问者都定义了三种权限<br>r: Readable<br>w: Writable<br>x: eXcutable</p><h3 id="修改文件权限"><a href="#修改文件权限" class="headerlink" title="修改文件权限"></a>修改文件权限</h3><p>chmod [OPTION]… OCTAL-MODE FILE…<br> -R: 递归修改权限<br>chmod [OPTION]… MODE[,MODE]… FILE…<br> MODE：<br> 修改一类用户的所有权限：<br> u= g= o= ug= a= u=,g=<br> 修改一类用户某位或某些位权限<br> u+ u- g+ g- o+ o- a+ a- + -<br>chmod [OPTION]… –reference=RFILE FILE…<br>参考RFILE文件的权限，将FILE的修改为同RFILE<br>数字权限法:chmod数字 file<br>rwx r-x r– file<br>其中：</p><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li></ul><p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本</p><h1 id="文本工具"><a href="#文本工具" class="headerlink" title="文本工具"></a>文本工具</h1><h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>文件内容:less和cat<br>文件截取:head和tail<br>按列抽取:cut<br>按关键字抽取:grep<br>文件查看:cat tac rev<br>分页查看:more<br>一页一页的查看:less<br>less 命令是man命令使用的分页器</p><h3 id="显示文本前后或后行内容"><a href="#显示文本前后或后行内容" class="headerlink" title="显示文本前后或后行内容"></a>显示文本前后或后行内容</h3><p>head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行<br>tail[option]…[FILE]看文本尾<br>tail-f 跟踪看日志<br>cut命令取字段<br>past 横着合并文件<br>wc 收集文本</p><h3 id="文本排序sort"><a href="#文本排序sort" class="headerlink" title="文本排序sort"></a>文本排序sort</h3><p>把整理过的文本显示在STDOUT,不改变原始文件<br>sort[opiton]file(s)<br>uniq:从输入中删除前后相接的重复的行,处理日志<br>liunx:文本处理三剑客<br>grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红<br>sed:stream editor, 文本编辑工具<br>awk:liunx上的实现gawk,文本报告生成器<br>grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行</p><h2 id="正则表达式"><a href="#正则表达式" class="headerlink" title="正则表达式"></a>正则表达式</h2><p>匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数<br>位置锚定:定位<br>正则字符特殊 元字符<br>.单个任意字符<br>[abc]表示其中一个字符<br>[^abc]除去abc任意字母<br>[:lower:]小写<br>[:upper:]大写<br>分组方式<br>abc{3}\<br>搜索替代工具<br>grep过滤特定行,sed也可以并且编辑修改文件</p><h2 id="vim编辑器"><a href="#vim编辑器" class="headerlink" title="vim编辑器"></a>vim编辑器</h2><p>vi:visual interface 文本编辑器<br>文本:asscii ,unicode<br>文本编辑种类:<br>行编辑器:sed<br>全屏编辑器:nano,vi<br>vim -viimproved<br>其他编辑器<br>gedit 一个简单的图形编辑器<br>gvim 一个vim编辑器的图形版本<br>vi一开始是vim的别名<br>vim有三种模式:normal(普通) insert(插入) extendcommand(命令)<br>normal :默认模式,移动光标,剪切/粘贴文本<br>insert :修改文本<br>extend command:保存,退出</p><h3 id="搜索替代"><a href="#搜索替代" class="headerlink" title="搜索替代"></a>搜索替代</h3><p>/ :从当前光标所在处向文件尾部查找<br>? :从当前光标所在处向文件首部查找<br>n :与命令同方向<br>N :与命令反方向<br>处理文本的工具sed<br>stream editor 行编辑器<br>sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.<br>vim不适合修改大批量文件,sed可以<br>sed 配合管道可以使用<br>awk 语言<br>sed ‘’ passwd<br>‘地址命令’地址不写代表全部文件 命令不写代表输出</p><h1 id="软件管理"><a href="#软件管理" class="headerlink" title="软件管理"></a>软件管理</h1><h2 id="包管理器"><a href="#包管理器" class="headerlink" title="包管理器"></a>包管理器</h2><p>rpm 打包文件 不需要考虑部署 安装路径都定义好<br>二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件<br>程序包管理器：<br>debian：deb文件, dpkg包管理器<br>redhat: rpm文件, rpm包管理器<br>rpm: Redhat Package Manager   RPM  Package Manager<br>源代码：name-VERSION.tar.gz|bz2|xz  VERSION: major.minor.release<br>rpm包命名方式:name-VERSION-release.arch.rpm<br>例：bash-4.2.46-19.el7.x86_64.rpm  VERSION: major.minor.release  release：release.OS<br>常见的arch：  x86: i386, i486, i586, i686  x86_64: x64, x86_64, amd64  powerpc: ppc  跟平台无关：noarch</p><p>包：分类和拆包<br>Application-VERSION-ARCH.rpm: 主包<br>Application-devel-VERSION-ARCH.rpm 开发子包  Application-utils-VERSION-ARHC.rpm 其它子包  Application-libs-VERSION-ARHC.rpm 其它子包<br>包之间：可能存在依赖关系，甚至循环依赖<br>解决依赖包管理<br>工具:yum：rpm包管理器的前端工具  apt-get：deb包管理器前端工具  zypper: suse上的rpm前端管理工具  dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具</p><p>查看二进制程序所依赖的库文件  ldd /PATH/TO/BINARY_FILE<br>管理及查看本机装载的库文件  ldconfig 加载库文件  /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系  配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf  缓存文件：/etc/ld.so.cache</p><h3 id="程序包管理器"><a href="#程序包管理器" class="headerlink" title="程序包管理器"></a>程序包管理器</h3><p>功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.<br>包文件组成 (每个包独有)<br>RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.<br>安装或卸载时运行的脚本<br>数据库(公共)：/var/lib/rpm 程序包名称及版本  依赖关系  功能说明  包安装后生成的各文件路径及校验码信息<br>管理程序包的方式:使用包管理器：rpm  使用前端工具：yum, dnf<br>获取程序包的途径：<br>(1) 系统发版的光盘或官方的服务器;CentOS镜像:<a href="https://www.centos.org/download/" target="_blank" rel="noopener">https://www.centos.org/download/</a>   <a href="http://mirrors.aliyun.com" target="_blank" rel="noopener">http://mirrors.aliyun.com</a>   <a href="http://mirrors.sohu.com" target="_blank" rel="noopener">http://mirrors.sohu.com</a>   <a href="http://mirrors.163.com" target="_blank" rel="noopener">http://mirrors.163.com</a><br>(2) 项目官方站点程序包的来源<br>(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux  Rpmforge:RHEL推荐，包很全 搜索引擎:<a href="http://pkgs.org" target="_blank" rel="noopener">http://pkgs.org</a> <a href="http://rpmfind.net" target="_blank" rel="noopener">http://rpmfind.net</a>   <a href="http://rpm.pbone.net" target="_blank" rel="noopener">http://rpm.pbone.net</a> <a href="https://sourceforge.net/" target="_blank" rel="noopener">https://sourceforge.net/</a><br>(4) 自己制作 注意：第三方包建议要检查其合法性  来源合法性,程序包的完整性</p><ul><li><p>rpm包管理<br>CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护  安装：<br>rpm {-i|–install} [install-options] PACKAGE_FILE…<br> -v: verbose<br> -h: 以#显示程序包管理执行进度  rpm -ivh PACKAGE_FILE …</p></li><li><p>rpm包安装<br>[install-options]<br>–test: 测试安装，但不真正执行安装，即dry run模式<br>–nodeps：忽略依赖关系<br>–replacepkgs | replacefiles<br>–nosignature: 不检查来源合法性<br>–nodigest：不检查包完整性<br>–noscripts：不执行程序包脚本   %pre: 安装前脚本；<br>–nopre   %post: 安装后脚本；<br>–nopost   %preun: 卸载前脚本；<br>–nopreun   %postun: 卸载后脚本；  –nopostun</p></li><li><p>rpm包升级<br>升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…<br>rpm {-F|–freshen} [install-options] PACKAGE_FILE…<br>upgrade：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则“安装”<br>freshen：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则不执行升级操作  rpm -Uvh PACKAGE_FILE …  rpm -Fvh PACKAGE_FILE …<br>–oldpackage：降级<br>–force: 强制安装</p></li><li><p>升级注意项<br>注意：<br>(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留</p></li><li><p>包查询<br>rpm {-q|–query} [select-options] [query-options] [select-options]<br>-a: 所有包<br>-f: 查看指定的文件由哪个程序包安装生成<br>-p rpmfile：针对尚未安装的程序包文件做查询操作<br>–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供  –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖<br>rpm2cpio 包文件|cpio –itv  预览包内文件 rpm2cpio 包文件|cpio –id  “*.conf” 释放包内文件</p></li><li><p>常用查询用法：  -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE  -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, …  -qa<br>包卸载：  rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME …</p></li></ul><p>包校验<br>rpm {-V|–verify} [select-options] [verify-options]  S file Size differs  M Mode differs (includes permissions and file type)  5 digest (formerly MD5 sum) differs  D Device major/minor number mismatch  L readLink(2) path mismatch  U User ownership differs  G Group ownership differs  T mTime differs  P capabilities differ<br>包校验<br>包来源合法性验正及完整性验正<br>完整性验正：SHA256<br>来源合法性验正：RSA 公钥加密<br>对称加密：加密、解密使用同一密钥<br>非对称加密：密钥是成对儿的<br>public key: 公钥，公开所有人</p><ul><li>rpm数据库<br>数据库重建：  /var/lib/rpm rpm {–initdb|–rebuilddb}  initdb: 初始化   如果事先不存在数据库，则新建之   否则，不执行任何操作  rebuilddb：重建已安装的包头的数据库索引目录</li></ul><h2 id="yum"><a href="#yum" class="headerlink" title="yum"></a>yum</h2><p>CentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具  yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下）  文件服务器: http:// https://   ftp://   file:// </p><ul><li>yum配置文件<br>yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置  /etc/yum.repos.d/*.repo：为仓库的指向提供配置<br>仓库指向的定义：   [repositoryID]   name=Some name for this repository   baseurl=url://path/to/repository/   enabled={1|0}   gpgcheck={1|0}   gpgkey=URL   enablegroups={1|0}   failovermethod={roundrobin|priority}    roundrobin：意为随机挑选，默认值    priority:按顺序访问   cost=   默认为1000</li><li>yum仓库<br>yum的repo配置文件中可用的变量：  $releasever: 当前OS的发行版的主版本号  $arch: 平台，i386,i486,i586,x86_64等  $basearch：基础平台；i386, x86_64  $YUM0-$YUM9:自定义变量 实例:  <a href="http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64" target="_blank" rel="noopener">http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64</a>  <a href="http://server/centos/6/i384" target="_blank" rel="noopener">http://server/centos/6/i384</a><br>yum源<br>阿里云repo文件:<a href="http://mirrors.aliyun.com/repo/" target="_blank" rel="noopener">http://mirrors.aliyun.com/repo/</a><br>CentOS系统的yum源 阿里云：<a href="https://mirrors.aliyun.com/centos/$releasever/os/x86_64/" target="_blank" rel="noopener">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a><br>EPEL的yum源:阿里云：<a href="https://mirrors.aliyun.com/epel/$releasever/x86_64" target="_blank" rel="noopener">https://mirrors.aliyun.com/epel/$releasever/x86_64</a> </li></ul><h3 id="yum命令"><a href="#yum命令" class="headerlink" title="yum命令"></a>yum命令</h3><p>yum命令的用法：  yum [options] [command] [package …]<br>显示仓库列表：  yum repolist [all|enabled|disabled]<br>显示程序包：  yum list  yum list [all | glob_exp1] [glob_exp2] […]  yum list {available|installed|updates} [glob_exp1] […] 安装程序包：  yum install package1 [package2] […]  yum reinstall package1 [package2] […]  (重新安装)<br>yum命令<br>升级程序包：  yum update [package1] [package2] […]  yum downgrade package1 [package2] […] (降级)<br>检查可用升级：  yum check-update<br>卸载程序包：  yum remove | erase package1 [package2] […]<br>yum命令<br>查看程序包information：  yum info […]<br>查看指定的特性(可以是某文件)是由哪个程序包所提供：  yum provides | whatprovides feature1 [feature2] […]<br>清理本地缓存：  清除/var/cache/yum/$basearch/$releasever缓存  yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]<br>构建缓存：  yum makecache<br>yum命令<br>搜索：yum search string1 [string2] […]  以指定的关键字搜索程序包名及summary信息<br>查看指定包所依赖的capabilities：  yum deplist package1 [package2] […]<br>查看yum事务历史：  yum history [info|list|packages-list|packages-info|  summary|addon-info|redo|undo|  rollback|new|sync|stats]  yum history  yum history info 6  yum history undo 6<br>日志 ：/var/log/yum.log<br>安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] <a href="用install替代">…</a><br>yum localupdate rpmfile1 [rpmfile2] […] (用update替代)<br>包组管理的相关命令：  yum groupinstall group1 [group2] […]   groupupdate group1 [group2] […]   yum grouplist [hidden] [groupwildcard] […]   yum groupremove group1 [group2] […]   yum groupinfo group1 […]<br>yum命令<br>yum的命令行选项：  –nogpgcheck：禁止进行gpg check  -y: 自动回答为“yes”  -q：静默模式  –disablerepo=repoidglob：临时禁用此处指定的repo  –enablerepo=repoidglob：临时启用此处指定的repo  –noplugins：禁用所有插件<br>系统光盘yum仓库<br>系统安装光盘作为本地yum仓库：<br>(1) 挂载光盘至某目录，例如/mnt/cdrom   mount /dev/cdrom /mnt/cdrom<br>(2) 创建配置文件   [CentOS7]   name=   baseurl=   gpgcheck=   enabled= 创建yum仓库：  createrepo [options] <directory></directory></p><h3 id="程序包编译"><a href="#程序包编译" class="headerlink" title="程序包编译"></a>程序包编译</h3><p>程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行<br>源代码组织格式：  多文件：文件中的代码之间，很可能存在跨文件依赖关系  C、C++：make 项目管理器   configure脚本 –&gt; Makefile.in –&gt; Makefile  java: maven</p><h2 id="C语言源代码编译安装三步骤"><a href="#C语言源代码编译安装三步骤" class="headerlink" title="C语言源代码编译安装三步骤:"></a>C语言源代码编译安装三步骤:</h2><p>1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make  根据Makefile文件，构建应用程序<br>3、make install  复制文件到相应路径<br>开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in<br>注意：安装前查看INSTALL，README</p><p>开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software    Foundation) mariadb.org 代码托管:SourceForge.net  Github.com      code.google.com<br>c/c++编译器: gcc (GNU C Complier)</p><p>编译C源代码：  准备：提供开发工具及开发环境   开发工具：make, gcc等   开发环境：开发库，头文件    glibc：标准库  实现：通过“包组”提供开发组件   Development Tools   Server Platform Development</p><p>第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项  选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译</p><p>Optional Features: 可选特性 –disable-FEATURE  –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包    –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION</p><p>第二步：make 第三步：make install</p><p>安装后的配置：<br>(1) 二进制程序目录导入至PATH环境变量中   编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH<br>(2) 导入帮助手册  编辑/etc/man.config|man_db.conf文件 添加一个MANPATH</p><h1 id="shell编程"><a href="#shell编程" class="headerlink" title="shell编程"></a>shell编程</h1><h2 id="基础-1"><a href="#基础-1" class="headerlink" title="基础"></a>基础</h2><p>程序：指令+数据<br>程序编程风格：<br>        过程式：以指令为中心，数据服务于指令<br>        对象式：以数据为中心，指令服务于数据<br>        shell程序：提供了编程能力，解释执行</p><h3 id="编程基本概念"><a href="#编程基本概念" class="headerlink" title="编程基本概念"></a>编程基本概念</h3><p>编程逻辑处理方式：<br>顺序执行<br>循环执行<br>选择执行</p><h3 id="shell编程：过程式、解释执行"><a href="#shell编程：过程式、解释执行" class="headerlink" title="shell编程：过程式、解释执行"></a>shell编程：过程式、解释执行</h3><p>编程语言的基本结构：<br>各种系统命令的组合<br>数据存储：变量、数组<br>表达式: a + b<br>语句:if<br>shell脚本基础<br>shell脚本:<br>包含一些命令或声明，并符合一定格式的文本文件<br>格式要求:首行shebang机制</p><blockquote><p>#!/bin/bash</p><p>#!/usr/bin/python</p><p>#!/usr/bin/perl<br>shell脚本的用途有：<br>自动化常用命令</p></blockquote><p>执行系统管理和故障排除</p><p>创建简单的应用程序</p><p>处理文本或文件</p><h3 id="添加注释"><a href="#添加注释" class="headerlink" title="添加注释"></a>添加注释</h3><p>注释以#开头<br>第二步：运行脚本<br>给予执行权限，在命令行上指定脚本的绝对或相对路径<br>直接运行解释器，将脚本作为解释器程序的参数运行</p><h3 id="脚本规范"><a href="#脚本规范" class="headerlink" title="脚本规范"></a>脚本规范</h3><p>脚本代码开头约定<br>1、第一行一般为调用使用的语言<br>2、程序名，避免更改文件名为无法找到正确的文件<br>3、版本号<br>4、更改后的时间<br>5、作者相关信息<br>6、该程序的作用，及注意事项<br>7、最后是各版本的更新简要说明</p><p>脚本调试<br>检测脚本中的语法错误<br>bash -n /path/to/some_script<br>调试执行<br>bash -x /path/to/some_script</p><h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><p>变量：命名的内存空间<br>数据存储方式：<br>字符：<br>数值：整型，浮点型<br>变量：变量类型<br>作用：<br>1、数据存储格式<br>2、参与的运算<br>3、表示的数据范围<br>类型：<br>字符<br>数值：整型、浮点型<br>变量命名法则：<br>1、不能使程序中的保留字：例如 if, for<br>2、只能使用数字、字母及下划线，且不能以数字开头<br>3、见名知义<br>4、统一命名规则：驼峰命名法，建议大写</p><ul><li>bash中变量的种类<br>根据变量的生效范围等标准划分下面变量类型：<pre><code>局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，</code></pre>包括当前shell的子shell进程均无效<pre><code>环境（全局）变量：生效范围为当前shell进程及其子进程本地变量：生效范围为当前shell进程中某代码片断，通常指函数位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传</code></pre>递给它的参数<pre><code>特殊变量：$?, $0, $*, $@, $#,$$</code></pre></li><li><p>局部变量<br>变量赋值：name=‘value’<br>可以使用引用value:<br>(1) 可以是直接字串; name=“root”<br>(2) 变量引用：name=”$USER”<br>(3) 命令引用：name=<code>COMMAND</code> name=$(COMMAND)<br>变量引用：${name} $name<br>“”：弱引用，其中的变量引用会被替换为变量值<br>‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br>显示已定义的所有变量：set<br>删除变量：unset name</p></li><li><p>环境变量<br>bash内建的环境变量：<br>PATH<br>SHELL<br>USER<br>UID<br>HOME<br>PWD<br>SHLVL<br>LANG<br>MAIL<br>HOSTNAME<br>HISTSIZE<br>—</p></li></ul><h3 id="只读和位置变量"><a href="#只读和位置变量" class="headerlink" title="只读和位置变量"></a>只读和位置变量</h3><p>只读变量：只能声明，但不能修改和删除<br>声明只读变量：<br>        readonly name<br>        declare -r name<br>查看只读变量：<br>        readonly –p<br>位置变量：在脚本代码中调用通过命令行传递给脚本的参数<br>$1, $2, …：对应第1、第2等参数，shift [n]换位置<br>$0: 命令本身<br>$<em>: 传递给脚本的所有参数，全部参数合为一个字符串<br>$@: 传递给脚本的所有参数，每个参数为独立字符串<br>$#: 传递给脚本的参数的个数<br>$@ $</em> 只在被双引号包起来的时候才会有差异<br>set – 清空所有位置变量</p><ul><li>退出状态<br>进程使用退出状态来报告成功或失败<br>• 0 代表成功，1－255代表失败<br>• $? 变量保存最近的命令退出状态<br>例如：<br>ping -c1 -W1 hostdown &amp;&gt; /dev/null<br>echo $?<br>退出状态码<br>bash自定义退出状态码<br>exit [n]：自定义退出状态码<br>注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命<br>令后面的数字<br>注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执<br>行的最后一条命令的状态码</li></ul><h2 id="运算"><a href="#运算" class="headerlink" title="运算"></a>运算</h2><p>bash中的算术运算:help let<br>+, -, <em>, /, %取模（取余）, **（乘方）<br>实现算术运算：<br>(1) let var=算术表达式<br>(2) var=$[算术表达式]<br>(3) var=$((算术表达式))<br>(4) var=$(expr arg1 arg2 arg3 …)<br>(5) declare –i var = 数值<br>(6) echo ‘算术表达式’ | bc<br>乘法符号有些场景中需要转义，如</em><br>bash有内建的随机数生成器：RANDOM（0-32767）<br>echo $[$RANDOM%50] ：0-49之间随机数<br>赋值</p><ul><li>增强型赋值：<br>+=, -=, *=, /=, %=<br>let varOPERvalue<br>例如:let count+=3<br>自加3后自赋值<br>自增，自减：<pre><code>let var+=1let var++let var-=1let var--</code></pre></li><li><p>逻辑运算<br>true, false<br>1, 0</p><pre><code>与：1 与 1 = 11 与 0 = 00 与 1 = 00 与 0 = 0或:1 或 1 = 11 或 0 = 10 或 1 = 10 或 0 = 0非：！! 1 = 0! 0 = 1</code></pre></li><li><p>短路运算</p></li><li><p>短路与<br>第一个为0，结果必定为0<br>第一个为1，第二个必须要参与运算</p></li><li>短路或<br>第一个为1，结果必定为1<br>第一个为0，第二个必须要参与运算</li><li>异或：^<br>异或的两个值,相同为假，不同为真</li><li>条件测试<br>判断某需求是否满足，需要由测试机制来实现<br>专用的测试表达式需要由测试命令辅助完成测试过程<br>评估布尔声明，以便用在条件性执行中<br>• 若真，则返回0<br>• 若假，则返回1</li><li>测试命令：<br>• test EXPRESSION<br>• [ EXPRESSION ]<br>• [[ EXPRESSION ]]<br>注意：EXPRESSION前后必须有空白字符<br>bash的数值测试<br>-v VAR<br>变量VAR是否设置</li><li><p>数值测试：<br>-gt 是否大于<br>-ge 是否大于等于<br>-eq 是否等于<br>-ne 是否不等于<br>-lt 是否小于<br>-le 是否小于等于<br>bash的字符串测试</p></li><li><p>字符串测试:</p></li></ul><blockquote><p>== 是否等于<br>ascii码是否大于ascii码<br>&lt; 是否小于<br>!= 是否不等于<br>=~ 左侧字符串是否能够被右侧的PATTERN所匹配<br>注意: 此表达式一般用于[[ ]]中；扩展的正则表达式<br>-z “STRING“ 字符串是否为空，空为真，不空为假<br>-n “STRING“ 字符串是否不空，不空为真，空为假<br>注意：用于字符串比较时的用到的操作数都应该使用引号<br>Bash的文件测试</p></blockquote><ul><li>存在性测试</li></ul><p>-a FILE：同-e<br>-e FILE: 文件存在性测试，存在为真，否则为假<br>存在性及类别测试<br>-b FILE：是否存在且为块设备文件<br>-c FILE：是否存在且为字符设备文件<br>-d FILE：是否存在且为目录文件<br>-f FILE：是否存在且为普通文件<br>-h FILE 或 -L FILE：存在且为符号链接文件<br>-p FILE：是否存在且为命名管道文件<br>-S FILE：是否存在且为套接字文件<br>Bash的文件权限测试</p><ul><li>文件权限测试：<br>-r FILE：是否存在且可读<br>-w FILE: 是否存在且可写<br>-x FILE: 是否存在且可执行</li><li>文件特殊权限测试：<br>-u FILE：是否存在且拥有suid权限<br>-g FILE：是否存在且拥有sgid权限<br>-k FILE：是否存在且拥有sticky权限<br>Bash的文件属性测试</li><li>文件大小测试：<br>-s FILE: 是否存在且非空<br>文件是否打开：<br>-t fd: fd 文件描述符是否在某终端已经打开<br>-N FILE：文件自从上一次被读取之后是否被修改过<br>-O FILE：当前有效用户是否为文件属主<br>-G FILE：当前有效用户是否为文件属组<br>Bash的文件属性测试</li><li>双目测试：<br>FILE1 -ef FILE2: FILE1是否是FILE2的硬链接<br>FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）<br>FILE1 -ot FILE2: FILE1是否旧于FILE2</li></ul><p>使用read命令来接受输入<br>使用read来把输入值分配给一个或多个shell变量<br>-p 指定要显示的提示<br>-s 静默输入，一般用于密码<br>-n N 指定输入的字符长度N<br>-d ‘字符’ 输入结束符<br>-t N TIMEOUT为N秒<br>read 从标准输入中读取值，给每个单词分配一个变量<br>所有剩余单词都被分配给最后一个变量<br>read -p “Enter a filename: “ FILE</p><h2 id="流程控制"><a href="#流程控制" class="headerlink" title="流程控制"></a>流程控制</h2><p>过程式编程语言：<br>        顺序执行<br>        选择执行<br>        循环执行<br>条件选择if语句</p><ul><li>选择执行:</li></ul><p>注意：if语句可嵌套<br>单分支<br>        if 判断条件;then<br>        条件为真的分支代码<br>        fi<br>双分支<br>        if 判断条件; then<br>        条件为真的分支代码<br>        else<br>条件为假的分支代码<br>fi</p><ul><li><p>多分支</p><pre><code>if 判断条件1; then条件为真的分支代码elif 判断条件2; then条件为真的分支代码elif 判断条件3; then条件为真的分支代码else以上条件都为假的分支代码fi</code></pre><p>逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句</p></li><li><p>条件判断：case语句</p><pre><code>case 变量引用 inPAT1)分支1;;PAT2)分支2;;...*)默认分支;;esac</code></pre></li></ul><p>case支持glob风格的通配符：<br>        *: 任意长度任意字符<br>        ?: 任意单个字符<br>        []：指定范围内的任意单个字符<br>        a|b: a或b</p><ul><li>循环</li></ul><p>循环执行<br>将某代码段重复运行多次<br>重复运行多少次：<br>循环次数事先已知<br>循环次数事先未知<br>有进入条件和退出条件<br>for, while, until<br>for循环<br>for 变量名 in 列表;do<br>循环体<br>done<br>执行机制：<br>依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直<br>到列表中的元素耗尽，循环结束</p><ul><li>for循环<br>列表生成方式：<br>(1) 直接给出列表<br>(2) 整数列表：<br>(a) {start..end}<br>(b) $(seq [start [step]] end)<br>(3) 返回列表的命令<br>$(COMMAND)<br>(4) 使用glob，如：<em>.sh<br>(5) 变量引用；<br>$@, $</em><br>while循环<br>while CONDITION; do<br>循环体<br>done<br>CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后<br>会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为<br>“false”终止循环<br>因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地<br>被修正<br>进入条件：CONDITION为true<br>退出条件：CONDITION为false<br>until循环<br>until CONDITION; do<br>循环体<br>done<br>进入条件： CONDITION 为false<br>退出条件： CONDITION 为true<br>循环控制语句continue<br>用于循环体中<br>ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为<br>第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>continue<br>fi<br>CMDn<br>…<br>done<br>循环控制语句break<br>用于循环体中<br>break [N]：提前结束第N层循环，最内层为第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>break<br>fi<br>CMDn<br>…<br>done<br>特殊用法<br>双小括号方法，即((…))格式，也可以用于算术运算<br>双小括号方法也可以使bash Shell实现C语言风格的变量操作<br>I=10<br>((I++))<br>for循环的特殊格式：<br>for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))<br>do</li><li>循环体<br>done<br>控制变量初始化：仅在运行到循环代码段时执行一次<br>控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做<br>条件判断</li></ul><h2 id="函数介绍"><a href="#函数介绍" class="headerlink" title="函数介绍"></a>函数介绍</h2><p>函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程<br>它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运<br>行，而是shell程序的一部分<br>函数和shell程序比较相似，区别在于：<br>Shell程序在子Shell中运行<br>而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变<br>量进行修改<br>定义函数<br>函数由两部分组成：函数名和函数体<br>help function<br>语法一：<br>f_name （）{<br>…函数体…<br>}<br> 语法二：<br>function f_name {<br>…函数体…<br>}<br> 语法三：<br>function f_name （） {<br>…函数体…<br>}</p><ul><li>函数使用<br>函数的定义和使用：<br>可在交互式环境下定义函数<br>可将函数放在脚本文件中作为它的一部分<br>可放在只包含函数的单独文件中<br>调用：函数只有被调用才会执行<br>调用：给定函数名<br>函数名出现的地方，会被自动替换为函数代码<br>函数的生命周期：被调用时创建，返回时终止函数返回值<br>函数有两种返回值：<br>函数的执行结果返回值：<br>(1) 使用echo等命令进行输出<br>(2) 函数体中调用命令的输出结果<br>函数的退出状态码：<br>(1) 默认取决于函数中执行的最后一条命令的退出状态码<br>(2) 自定义退出状态码，其格式为：<br>return 从函数中返回，用最后状态命令决定返回值<br>return 0 无错误返回。<br>return 1-255 有错误返回<br>交互式环境下定义和使用函数</li></ul><blockquote><p>示例:<br>dir() {<br>ls -l<br>}<br>定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同<br>dir<br>该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令<br>unset dir<br>在脚本中定义及使用函数<br>函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它<br>后才能使用<br>调用函数仅使用其函数名即可<br>示例：<br>cat func1<br>!/bin/bash<br>func1<br>hello()<br>{<br>echo “Hello there today’s date is <code>date +%F</code>“<br>}<br>echo “now going to the function hello”<br>hello<br>echo “back from the function”<br>使用函数文件<br>可以将经常使用的函数存入函数文件，然后将函数文件载入shell<br>文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main<br>一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set<br>命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数<br>若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新<br>载入此文件</p></blockquote><ul><li>创建函数文件</li></ul><p>函数文件示例：</p><blockquote><p>cat functions.main</p><p>#!/bin/bash</p><p>#functions.main<br>findit()<br>{<br>if [ $# -lt 1 ] ; then<br>echo “Usage:findit file”<br>return 1<br>fi<br>find / -name $1 –print<br>}</p></blockquote><ul><li><p>载入函数<br>函数文件已创建好后，要将它载入shell<br>定位函数文件并载入shell的格式：<br>. filename 或 source filename<br>注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;<br>这里的文件名要带正确路径</p></li><li><p>检查载入函数<br>使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数</p></li></ul><blockquote><p>示例：<br>set<br>findit=( )<br>{<br>if [ $# -lt 1 ]; then<br>echo “usage :findit file”;<br>return 1<br>fi<br>find / -name $1 -print<br>}</p></blockquote><ul><li>执行shell函数<br>要执行函数，简单地键入函数名即可<br>示例：<br>findit groups<br>/usr/bin/groups<br>/usr/local/backups/groups.bak</li><li>删除shell函数<br>现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命<br>令完成删除函数<br>命令格式为：<br>unset function_name<br>示例：<br>unset findit<br>再键入set命令，函数将不再显示</li><li>函数参数<br>函数可以接受参数：<br>传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；<br>例如“testfunc arg1 arg2 …”<br>在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#<br>等特殊变量<br>函数变量<br>变量作用域：<br>环境变量：当前shell和子shell有效<br>本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；<br>因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数<br>局部变量：函数的生命周期；函数结束时变量被自动销毁<br>注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量<br>在函数中定义局部变量的方法<br>local NAME=VALUE<br>函数递归示例</li><li>函数递归：<br>函数直接或间接调用自身<br>注意递归层数<br>递归实例：<br>阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的<br>阶乘为1，自然数n的阶乘写作n!<br>n!=1×2×3×…×n<br>阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n<br>n!=n(n-1)(n-2)…1<br>n(n-1)! = n(n-1)(n-2)!<br>函数递归示例:</li></ul><blockquote><pre><code>示例：fact.shfact() {if [ $1 -eq 0 -o $1 -eq 1 ]; thenecho 1elseecho $[$1*$(fact $[$1-1])]fi}fact $1</code></pre></blockquote><ul><li>fork炸弹</li></ul><p>fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是<br>一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个<br>简单的程序迅速耗尽系统里面的所有资源<br>函数实现<br>:(){ :|:&amp; };:<br>bomb() { bomb | bomb &amp; }; bomb  实际上: 代表bomb<br>脚本实现</p><blockquote><p>cat Bomb.sh<br>./$0|./$0&amp;</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h1&gt;&lt;h2 id=&quot;操作系统&quot;&gt;&lt;a href=&quot;#操作系统&quot; class=&quot;headerlink&quot; title=&quot;操作系统&quot;&gt;&lt;/a&gt;操作系统&lt;/h
      
    
    </summary>
    
      <category term="linux" scheme="https://hubhack.github.io/categories/linux/"/>
    
    
      <category term="linux基础" scheme="https://hubhack.github.io/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>linux命令整理(2)</title>
    <link href="https://hubhack.github.io/8/"/>
    <id>https://hubhack.github.io/8/</id>
    <published>2019-03-19T14:26:00.000Z</published>
    <updated>2019-04-01T07:40:53.005Z</updated>
    
    <content type="html"><![CDATA[<h2 id="文档编辑"><a href="#文档编辑" class="headerlink" title="文档编辑"></a>文档编辑</h2><h3 id="grep"><a href="#grep" class="headerlink" title="grep"></a>grep</h3><p>Linux grep命令用于查找文件里符合条件的字符串。</p><p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p><p>语法<br>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]<br>参数：</p><p>-a 或 –text : 不要忽略二进制的数据。<br>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br>-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。<br>-c 或 –count : 计算符合样式的列数。<br>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。<br>-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。<br>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。<br>-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。<br>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。<br>-F 或 –fixed-regexp : 将样式视为固定字符串的列表。<br>-G 或 –basic-regexp : 将样式视为普通的表示法来使用。<br>-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。<br>-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。<br>-i 或 –ignore-case : 忽略字符大小写的差别。<br>-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。<br>-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。<br>-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。<br>-o 或 –only-matching : 只显示匹配PATTERN 部分。<br>-q 或 –quiet或–silent : 不显示任何信息。<br>-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。<br>-s 或 –no-messages : 不显示错误信息。<br>-v 或 –revert-match : 显示不包含匹配文本的所有行。<br>-V 或 –version : 显示版本信息。<br>-w 或 –word-regexp : 只显示全字符合的列。<br>-x –line-regexp : 只显示全列符合的列。<br>-y : 此参数的效果和指定”-i”参数相同。</p><h3 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h3><p>Linux sort命令用于将文本文件内容加以排序。</p><p>sort可针对文本文件的内容，以行为单位来排序。</p><p>语法<br>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]<br>参数说明：</p><p>-b 忽略每行前面开始出的空格字符。<br>-c 检查文件是否已经按照顺序排序。<br>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>-f 排序时，将小写字母视为大写字母。<br>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。<br>-m 将几个排序好的文件进行合并。<br>-M 将前面3个字母依照月份的缩写进行排序。<br>-n 依照数值的大小排序。<br>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。<br>-r 以相反的顺序来排序。<br>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。<br>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。<br>–help 显示帮助。<br>–version 显示版本信息。</p><h3 id="tr"><a href="#tr" class="headerlink" title="tr"></a>tr</h3><p>Linux tr 命令用于转换或删除文件中的字符。</p><p>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p><p>语法<br>tr [-cdst][–help][–version][第一字符集][第二字符集]<br>tr [OPTION]…SET1[SET2]<br>参数说明：</p><p>-c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换<br>-d, –delete：删除指令字符<br>-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符<br>-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等<br>–help：显示程序用法信息<br>–version：显示程序本身的版本信息<br>字符集合的范围：</p><p>\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)<br>\ 反斜杠<br>\a Ctrl-G 铃声<br>\b Ctrl-H 退格符<br>\f Ctrl-L 走行换页<br>\n Ctrl-J 新行<br>\r Ctrl-M 回车<br>\t Ctrl-I tab键<br>\v Ctrl-X 水平制表符<br>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>[CHAR<em>] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止<br>[CHAR</em>REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)<br>[:alnum:] ：所有字母字符与数字<br>[:alpha:] ：所有字母字符<br>[:blank:] ：所有水平空格<br>[:cntrl:] ：所有控制字符<br>[:digit:] ：所有数字<br>[:graph:] ：所有可打印的字符(不包含空格符)<br>[:lower:] ：所有小写字母<br>[:print:] ：所有可打印的字符(包含空格符)<br>[:punct:] ：所有标点字符<br>[:space:] ：所有水平与垂直空格符<br>[:upper:] ：所有大写字母<br>[:xdigit:] ：所有 16 进位制的数字<br>[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)</p><h3 id="uniq"><a href="#uniq" class="headerlink" title="uniq"></a>uniq</h3><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p><p>uniq 可检查文本文件中重复出现的行列。</p><p>语法<br>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]<br>参数：</p><p>-c或–count 在每列旁边显示该行重复出现的次数。<br>-d或–repeated 仅显示重复出现的行列。<br>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。<br>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。<br>-u或–unique 仅显示出一次的行列。<br>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。<br>–help 显示帮助。<br>–version 显示版本信息。<br>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；<br>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p><h3 id="wc"><a href="#wc" class="headerlink" title="wc"></a>wc</h3><p>Linux wc命令用于计算字数。</p><p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p><p>语法<br>wc [-clw][–help][–version][文件…]<br>参数：</p><p>-c或–bytes或–chars 只显示Bytes数。<br>-l或–lines 只显示行数。<br>-w或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。</p><h3 id="let"><a href="#let" class="headerlink" title="let"></a>let</h3><p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p><p>语法格式<br>let arg [arg …]<br>参数说明：<br>arg：要执行的表达式</p><h3 id="sed"><a href="#sed" class="headerlink" title="sed"></a>sed</h3><p>Linux sed命令是利用script来处理文本文件。</p><p>sed可依照script的指令，来处理、编辑文本文件。</p><p>Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p><p>语法<br>sed [-hnV][-e<script>][-f&lt;script文件&gt;][文本文件]<br>参数说明：</p><p>-e<script>或–expression=<script> 以选项中指定的script来处理输入的文本文件。<br>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。<br>-h或–help 显示帮助。<br>-n或–quiet或–silent 仅显示script处理后的结果。<br>-V或–version 显示版本信息。<br>动作说明：</p><p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.</p></script></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;文档编辑&quot;&gt;&lt;a href=&quot;#文档编辑&quot; class=&quot;headerlink&quot; title=&quot;文档编辑&quot;&gt;&lt;/a&gt;文档编辑&lt;/h2&gt;&lt;h3 id=&quot;grep&quot;&gt;&lt;a href=&quot;#grep&quot; class=&quot;headerlink&quot; title=&quot;grep&quot;&gt;&lt;/a
      
    
    </summary>
    
      <category term="linux" scheme="https://hubhack.github.io/categories/linux/"/>
    
    
      <category term="linux基础" scheme="https://hubhack.github.io/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>linux命令整理(1)</title>
    <link href="https://hubhack.github.io/3/"/>
    <id>https://hubhack.github.io/3/</id>
    <published>2019-03-19T14:26:00.000Z</published>
    <updated>2019-04-01T07:31:02.423Z</updated>
    
    <content type="html"><![CDATA[<p>1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read<br>2 文档编辑:grep sed tr sort uniq wc let<br>3 磁盘管理:cd df du mkdir pwd mount stat tree ls<br>4 网络通讯:telnet httpd ifconfig netatat ping tty write<br>5 系统管理:useradd data adduser exit kill ps  pstree top reboot sudo uname who whoami whois w id free<br>6 系统设置:reset clear alias enable rpm set passwd time setup<br>7 备份压缩:zip tar<br>8 其他命令: bc tail</p><h2 id="文档命令"><a href="#文档命令" class="headerlink" title="文档命令"></a>文档命令</h2><h3 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h3><p>全称: concatenate files and print on the standard output<br>cat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者<br>语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName<br>参数说明：<br>-n 或 –number：由 1 开始对所有输出的行数编号。<br>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。<br>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 –show-ends : 在每行结束处显示 $。<br>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。<br>-A, –show-all：等价于 -vET。<br>-e：等价于”-vE”选项；<br>-t：等价于”-vT”选项；</p><p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：<br>cat -n textfile1 &gt; textfile2<br>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：<br>cat -b textfile1 textfile2 &gt;&gt; textfile3<br>清空 /etc/test.txt 文档内容：<br>cat /dev/null &gt; /etc/test.txt<br>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：<br>cat /dev/fd0 &gt; OUTFILE<br>相反的，如果想把 image file 写到软盘，输入：<br>cat IMG_FILE &gt; /dev/fd0<br>注：</p><ol><li>OUTFILE 指输出的镜像文件名.</li><li>IMG_FILE 指镜像文件。</li><li>若从镜像文件写回 device 时，device 容量需与相当。</li><li>通常用制作开机磁片</li></ol><h3 id="chgrp"><a href="#chgrp" class="headerlink" title="chgrp"></a>chgrp</h3><p>Linux chgrp命令用于变更文件或目录的所属群组。</p><p>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p><p>语法:<br>chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br>参数说明<br>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p><p>　　-f或–quiet或–silent 　不显示错误信息。</p><p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p><p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p><p>　　-v或–verbose 　显示指令执行过程。</p><p>　　–help 　在线帮助。</p><p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p><p>　　–version 　显示版本信息。</p><h3 id="chmod"><a href="#chmod" class="headerlink" title="chmod"></a>chmod</h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p><p>使用权限 : 所有使用者</p><p>语法<br>chmod [-cfvR] [–help] [–version] mode file…<br>参数说明<br>mode : 权限设定字串，格式如下 :</p><p>[ugoa…][[+-=][rwxX]…][,…]<br>其中：</p><p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p><ul><li>表示增加权限、- 表示取消权限、= 表示唯一设定权限<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li></ul><p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本<br>实例<br>将文件 file1.txt 设为所有人皆可读取 :</p><p>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :</p><p>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p><p>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :</p><p>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p><p>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :</p><p>chmod 777 file<br>语法为：</p><p>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p><p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br>chmod a=rwx file<br>和</p><p>chmod 777 file<br>效果相同</p><p>chmod ug=rwx,o=x file<br>和</p><p>chmod 771 file<br>效果相同</p><p>若用chmod 4755 filename可使此程序具有root的权限</p><h3 id="chown"><a href="#chown" class="headerlink" title="chown"></a>chown</h3><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。<br>使用权限 : root<br>语法<br>chown [-cfhvR] [–help] [–version] user[:group] file…<br>参数 :<br>user : 新的文件拥有者的使用者 ID<br>group : 新的文件拥有者的使用者组(group)<br>-c : 显示更改的部分的信息<br>-f : 忽略错误信息<br>-h :修复符号链接<br>-v : 显示详细的处理信息<br>-R : 处理指定目录以及其子目录下的所有文件<br>–help : 显示辅助说明<br>–version : 显示版本</p><h3 id="file"><a href="#file" class="headerlink" title="file"></a>file</h3><p>Linux file命令用于辨识文件类型。</p><p>通过file指令，我们得以辨识该文件的类型。</p><p>语法<br>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]<br>参数：</p><p>-b 　列出辨识结果时，不显示文件名称。<br>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。<br>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。<br>-L 　直接显示符号连接所指向的文件的类别。<br>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。<br>-v 　显示版本信息。<br>-z 　尝试去解读压缩文件的内容。<br>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</p><h3 id="find"><a href="#find" class="headerlink" title="find"></a>find</h3><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p><p>语法<br>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \;<br>参数说明 :</p><p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p><p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p><p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p><p>-amin n : 在过去 n 分钟内被读取过</p><p>-anewer file : 比文件 file 更晚被读取过的文件</p><p>-atime n : 在过去n天内被读取过的文件</p><p>-cmin n : 在过去 n 分钟内被修改过</p><p>-cnewer file :比文件 file 更新的文件</p><p>-ctime n : 在过去n天内被修改过的文件</p><p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p><p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p><p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p><p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p><p>d: 目录</p><p>c: 字型装置文件</p><p>b: 区块装置文件</p><p>p: 具名贮列</p><p>f: 一般文件</p><p>l: 符号连结</p><p>s: socket</p><p>-pid n : process id 是 n 的文件</p><p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p><p>exp1 -and exp2</p><p>! expr</p><p>-not expr</p><p>exp1 -or exp2</p><p>exp1, exp2</p><h3 id="cut"><a href="#cut" class="headerlink" title="cut"></a>cut</h3><p>Linux cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p><p>语法<br>cut  [-bn] [file]<br>cut [-c] [file]<br>cut [-df] [file]<br>使用说明:</p><p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p><p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p><p>参数:</p><p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<br>-c ：以字符为单位进行分割。<br>-d ：自定义分隔符，默认为制表符。<br>-f ：与-d一起使用，指定显示哪个区域。<br>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</p><h3 id="ln"><a href="#ln" class="headerlink" title="ln"></a>ln</h3><p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p><p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p><p>语法<br> ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为<br>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p><p>[–help] [–version] [–]</p><p>命令功能 :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p><p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p><p>软链接：</p><p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>硬链接：</p><p>1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>2.不允许给目录创建硬链接<br>3.硬链接只有在同一个文件系统中才能创建<br>命令参数<br>必要参数：</p><p>-b 删除，覆盖以前建立的链接<br>-d 允许超级用户制作目录的硬链接<br>-f 强制执行<br>-i 交互模式，文件存在则提示用户是否覆盖<br>-n 把符号链接视为一般目录<br>-s 软链接(符号链接)<br>-v 显示详细的处理过程<br>选择参数：</p><p>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”<br>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”<br>–help 显示帮助信息<br>–version 显示版本信息</p><h3 id="less"><a href="#less" class="headerlink" title="less"></a>less</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p><p>语法<br>less [参数] 文件<br>参数说明：</p><p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小<br>-e 当文件显示结束后，自动离开<br>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件<br>-g 只标志最后搜索的关键词<br>-i 忽略搜索时的大小写<br>-m 显示类似more命令的百分比<br>-N 显示每行的行号<br>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>-Q 不使用警告音<br>-s 显示连续空行为一行<br>-S 行过长时间将超出部分舍弃<br>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格<br>/字符串：向下搜索”字符串”的功能<br>?字符串：向上搜索”字符串”的功能<br>n：重复前一个搜索（与 / 或 ? 有关）<br>N：反向重复前一个搜索（与 / 或 ? 有关）<br>b 向后翻一页<br>d 向后翻半页<br>h 显示帮助界面<br>Q 退出less 命令<br>u 向前滚动半页<br>y 向前滚动一行<br>空格键 滚动一页<br>回车键 滚动一行<br>[pagedown]： 向下翻动一页<br>[pageup]： 向上翻动一页</p><h3 id="more"><a href="#more" class="headerlink" title="more"></a>more</h3><p>Linux more命令<br>Linux 命令大全 Linux 命令大全</p><p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p><p>语法<br>more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]<br>参数：</p><p>-num 一次显示的行数<br>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声<br>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能<br>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）<br>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容<br>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料<br>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）<br>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示<br>+num 从第 num 行开始显示<br>fileNames 欲显示内容的文档，可为复数个数</p><h3 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h3><p>Linux mv命令<br>Linux 命令大全 Linux 命令大全</p><p>Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p><p>语法<br>mv [options] source dest<br>mv [options] source… directory<br>参数说明：</p><p>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;<br>-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;<br>mv参数设置与运行结果</p><p>mv 文件名 文件名 将源文件名改为目标文件名<br>mv 文件名 目录名 将文件移动到目标目录<br>mv 目录名 目录名 目标目录已存在，将源目录<br>移动到目标目录；目标<br>目录不存在则改名<br>mv 目录名 文件名 出错</p><h3 id="rm"><a href="#rm" class="headerlink" title="rm"></a>rm</h3><p>rm命令用于删除一个文件或者目录。</p><p>语法<br>rm [options] name…<br>参数：</p><p>-i 删除前逐一询问确认。<br>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r 将目录及以下之档案亦逐一删除。</p><h3 id="tee"><a href="#tee" class="headerlink" title="tee"></a>tee</h3><p>Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。</p><p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p><p>语法<br>tee [-ai][–help][–version][文件…]<br>参数：</p><p>-a或–append 　附加到既有文件的后面，而非覆盖它．<br>-i或–ignore-interrupts 　忽略中断信号。<br>–help 　在线帮助。<br>–version 　显示版本信息。</p><h3 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h3><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p><p>ls -l 可以显示档案的时间记录。</p><p>语法<br>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]<br>参数说明：<br>a 改变档案的读取时间记录。<br>m 改变档案的修改时间记录。<br>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。<br>f 不使用，是为了与其他 unix 系统的相容性而保留。<br>r 使用参考档的时间记录，与 –file 的效果一样。<br>d 设定时间与日期，可以使用各种不同的格式。<br>t 设定档案的时间记录，格式与 date 指令相同。<br>–no-create 不会建立新档案。<br>–help 列出指令格式。<br>–version 列出版本讯息。</p><h3 id="which"><a href="#which" class="headerlink" title="which"></a>which</h3><p>Linux which命令用于查找文件。</p><p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p><p>语法<br>which [文件…]<br>参数：</p><p>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。<br>-w 　指定输出时栏位的宽度。<br>-V 　显示版本信息</p><h3 id="cp"><a href="#cp" class="headerlink" title="cp"></a>cp</h3><p>Linux cp命令主要用于复制文件或目录。</p><p>语法<br>cp [options] source dest<br>或</p><p>cp [options] source… directory<br>参数说明：</p><p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。<br>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p><h3 id="read"><a href="#read" class="headerlink" title="read"></a>read</h3><p>Linux read命令用于从标准输入读取数值。</p><p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p><p>语法<br>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]<br>参数说明:</p><p>-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。<br>-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。<br>-p 后面跟提示信息，即在输入前打印提示信息。<br>-e 在输入的时候可以使用命令补全功能。<br>-n 后跟一个数字，定义输入文本的长度，很实用。<br>-r 屏蔽\，如果没有该选项，则\作为一个转义字符，有的话 \就是个正常的字符了。<br>-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。<br>-t 后面跟秒数，定义输入字符的等待时间。<br>-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read&lt;br&gt;2 文档编辑:grep sed tr sort uniq wc let&lt;br&gt;3 磁盘管理:cd df
      
    
    </summary>
    
      <category term="linux" scheme="https://hubhack.github.io/categories/linux/"/>
    
    
      <category term="linux基础" scheme="https://hubhack.github.io/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>linux命令整理(3)</title>
    <link href="https://hubhack.github.io/9/"/>
    <id>https://hubhack.github.io/9/</id>
    <published>2019-03-19T14:26:00.000Z</published>
    <updated>2019-04-01T07:28:05.929Z</updated>
    
    <content type="html"><![CDATA[<h2 id="磁盘管理"><a href="#磁盘管理" class="headerlink" title="磁盘管理"></a>磁盘管理</h2><h3 id="cd"><a href="#cd" class="headerlink" title="cd"></a>cd</h3><p>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</p><p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p><p>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p><p>语法<br>cd [dirName]<br>dirName：要切换的目标目录。</p><h3 id="df"><a href="#df" class="headerlink" title="df"></a>df</h3><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p><p>语法<br>df [选项]… [FILE]…<br>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<br>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks<br>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<br>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<br>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<br>文件-k, –kilobytes 就像是 –block-size=1024<br>文件-l, –local 限制列出的文件结构<br>文件-m, –megabytes 就像 –block-size=1048576<br>文件–no-sync 取得资讯前不 sync (预设值)<br>文件-P, –portability 使用 POSIX 输出格式<br>文件–sync 在取得资讯前 sync<br>文件-t, –type=TYPE 限制列出文件系统的 TYPE<br>文件-T, –print-type 显示文件系统的形式<br>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE<br>文件-v (忽略)<br>文件–help 显示这个帮手并且离开<br>文件–version 输出版本资讯并且离开</p><h3 id="du"><a href="#du" class="headerlink" title="du"></a>du</h3><p>Linux du命令用于显示目录或文件的大小。</p><p>du会显示指定的目录或文件所占用的磁盘空间。</p><p>语法<br>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]<br>参数说明：</p><p>-a或-all 显示目录中个别文件的大小。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计。<br>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p><h3 id="mkdir"><a href="#mkdir" class="headerlink" title="mkdir"></a>mkdir</h3><p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p><p>语法<br>mkdir [-p] dirName<br>参数说明：</p><p>-p 确保目录名称存在，不存在的就建一个。</p><h3 id="pwd"><a href="#pwd" class="headerlink" title="pwd"></a>pwd</h3><p>Linux pwd命令用于显示工作目录。</p><p>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p><p>语法<br>pwd [–help][–version]<br>参数说明:</p><p>–help 在线帮助。<br>–version 显示版本信息。</p><h3 id="mount"><a href="#mount" class="headerlink" title="mount"></a>mount</h3><p>Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</p><p>语法<br>mount [-hV]<br>mount -a [-fFnrsvw] [-t vfstype]<br>mount [-fnrsvw] [-o options [,…]] device | dir<br>mount [-fnrsvw] [-t vfstype] [-o options] device dir<br>参数说明：</p><p>-V：显示程序版本<br>-h：显示辅助讯息<br>-v：显示较讯息，通常和 -f 用来除错。<br>-a：将 /etc/fstab 中定义的所有档案系统挂上。<br>-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。<br>-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。<br>-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。<br>-s-r：等于 -o ro<br>-w：等于 -o rw<br>-L：将含有特定标签的硬盘分割挂上。<br>-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br>-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。<br>-o sync：在同步模式下执行。<br>-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。<br>-o auto、-o noauto：打开/关闭自动挂上模式。<br>-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.<br>-o dev、-o nodev-o exec、-o noexec允许执行档被执行。<br>-o suid、-o nosuid：<br>允许执行档在 root 权限下执行。<br>-o user、-o nouser：使用者可以执行 mount/umount 的动作。<br>-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。<br>-o ro：用唯读模式挂上。<br>-o rw：用可读写模式挂上。<br>-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</p><h3 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h3><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p><p>语法<br> ls [-alrtAFR] [name…]<br>参数 :</p><p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出</p><h2 id="系统管理"><a href="#系统管理" class="headerlink" title="系统管理"></a>系统管理</h2><h3 id="useradd"><a href="#useradd" class="headerlink" title="useradd"></a>useradd</h3><p>Linux useradd命令用于建立用户帐号。</p><p>useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p><p>语法<br>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>][-u <uid>][用户帐号]<br>或</uid></shell></p><p>useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>]<br>参数说明：</shell></p><p>-c&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。<br>-d&lt;登入目录&gt; 　指定用户登入时的启始目录。<br>-D 　变更预设值．<br>-e&lt;有效期限&gt; 　指定帐号的有效期限。<br>-f&lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。<br>-g&lt;群组&gt; 　指定用户所属的群组。<br>-G&lt;群组&gt; 　指定用户所属的附加群组。<br>-m 　自动建立用户的登入目录。<br>-M 　不要自动建立用户的登入目录。<br>-n 　取消建立以用户名称为名的群组．<br>-r 　建立系统帐号。<br>-s<shell>　 　指定用户登入后所使用的shell。<br>-u<uid> 　指定用户ID</uid></shell></p><h3 id="data"><a href="#data" class="headerlink" title="data"></a>data</h3><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：</p><p>时间方面：</p><p>% : 印出 %<br>%n : 下一行<br>%t : 跳格<br>%H : 小时(00..23)<br>%I : 小时(01..12)<br>%k : 小时(0..23)<br>%l : 小时(1..12)<br>%M : 分钟(00..59)<br>%p : 显示本地 AM 或 PM<br>%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)<br>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数<br>%S : 秒(00..61)<br>%T : 直接显示时间 (24 小时制)<br>%X : 相当于 %H:%M:%S<br>%Z : 显示时区<br>日期方面：</p><p>%a : 星期几 (Sun..Sat)<br>%A : 星期几 (Sunday..Saturday)<br>%b : 月份 (Jan..Dec)<br>%B : 月份 (January..December)<br>%c : 直接显示日期与时间<br>%d : 日 (01..31)<br>%D : 直接显示日期 (mm/dd/yy)<br>%h : 同 %b<br>%j : 一年中的第几天 (001..366)<br>%m : 月份 (01..12)<br>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)<br>%w : 一周中的第几天 (0..6)<br>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)<br>%x : 直接显示日期 (mm/dd/yy)<br>%y : 年份的最后两位数字 (00.99)<br>%Y : 完整年份 (0000..9999)<br>若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。</p><p>使用权限：所有使用者。</p><p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。</p><p>当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p><p>语法<br>date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]<br>参数说明：</p><p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)<br>–help : 显示辅助讯息<br>-s datestr : 将系统时间设为 datestr 中所设定的时间<br>-u : 显示目前的格林威治时间<br>–version : 显示版本编号</p><h3 id="ps"><a href="#ps" class="headerlink" title="ps"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p><p>语法<br>ps [options] [–help]<br>参数：</p><p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p><h3 id="top"><a href="#top" class="headerlink" title="top"></a>top</h3><p>Linux top命令用于实时显示 process 的动态。</p><p>使用权限：所有使用者。</p><p>语法<br>top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]<br>参数说明：</p><p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<br>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<br>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来<br>s : 安全模式，将交谈式指令取消, 避免潜在的危机<br>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程<br>n : 更新的次数，完成后将会退出 top<br>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p><h3 id="pstree"><a href="#pstree" class="headerlink" title="pstree"></a>pstree</h3><p>Linux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</p><p>使用权限：所有使用者。</p><p>语法<br>pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]<br>或</p><p>pstree -V<br>参数说明：</p><p>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号<br>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）</p><h3 id="reboot"><a href="#reboot" class="headerlink" title="reboot"></a>reboot</h3><p>Linux reboot命令用于用来重新启动计算机。</p><p>若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代</p><p>语法<br>reboot [-n] [-w] [-d] [-f] [-i]<br>参数：</p><p>-n : 在重开机前不做将记忆体资料写回硬盘的动作<br>-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里<br>-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）<br>-f : 强迫重开机，不呼叫 shutdown 这个指令<br>-i : 在重开机之前先把所有网络相关的装置先停止</p><h3 id="screen"><a href="#screen" class="headerlink" title="screen"></a>screen</h3><p>Linux screen命令用于多重视窗管理程序。</p><p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p><p>语法<br>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s <shell>][-S &lt;作业名称&gt;]<br>参数说明：</shell></p><p>-A 　将所有的视窗都调整为目前终端机的大小。<br>-d&lt;作业名称&gt; 　将指定的screen作业离线。<br>-h&lt;行数&gt; 　指定视窗的缓冲区行数。<br>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r&lt;作业名称&gt; 　恢复离线的screen作业。<br>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-s<shell> 　指定建立新视窗时，所要执行的shell。<br>-S&lt;作业名称&gt; 　指定screen作业的名称。<br>-v 　显示版本信息。<br>-x 　恢复之前离线的screen作业。<br>-ls或–list 　显示目前所有的screen作业。<br>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</shell></p><h3 id="shutdown"><a href="#shutdown" class="headerlink" title="shutdown"></a>shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p><p>使用权限：系统管理者。</p><p>语法<br>shutdown [-t seconds] [-rkhncfF] time [message]<br>参数说明：</p><p>-t seconds : 设定在几秒钟之后进行关机程序。<br>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。<br>-r : 关机后重新开机。<br>-h : 关机后停机。<br>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。<br>-c : 取消目前已经进行中的关机动作。<br>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。<br>-F : 关机时，强迫进行 fsck 动作。<br>time : 设定关机的时间。<br>message : 传送给所有使用者的警告讯息。</p><h3 id="swatch"><a href="#swatch" class="headerlink" title="swatch"></a>swatch</h3><p>Linux swatch命令用于系统监控程序。</p><p>swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。</p><p>语法<br>swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]<br>参数说明：</p><p>-A&lt;分隔字符&gt; 　预设配置文件中，动作的分隔字符，预设为逗号。<br>-c&lt;设置文件&gt; 　指定配置文件，而不使用预设的配置文件。<br>-f&lt;记录文件&gt; 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。<br>-I&lt;分隔字符&gt; 　指定输入记录的分隔字符，预设为换行字符。<br>-P&lt;分隔字符&gt; 　指定配置文件中，事件的分隔字符，预设为逗号。<br>-r&lt;时间&gt; 　在指定的时间重新启动。<br>-t&lt;记录文件&gt; 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。</p><h3 id="id"><a href="#id" class="headerlink" title="id"></a>id</h3><p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p><p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p><p>语法<br>id [-gGnru][–help][–version][用户名称]<br>参数说明：</p><p>-g或–group 　显示用户所属群组的ID。<br>-G或–groups 　显示用户所属附加群组的ID。<br>-n或–name 　显示用户，所属群组或附加群组的名称。<br>-r或–real 　显示实际ID。<br>-u或–user 　显示用户ID。<br>-help 　显示帮助。<br>-version 　显示版本信息。</p><h3 id="free"><a href="#free" class="headerlink" title="free"></a>free</h3><p>Linux free命令用于显示内存状态。</p><p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p><p>语法<br>free [-bkmotV][-s &lt;间隔秒数&gt;]<br>参数说明：</p><p>-b 　以Byte为单位显示内存使用情况。<br>-k 　以KB为单位显示内存使用情况。<br>-m 　以MB为单位显示内存使用情况。<br>-o 　不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。<br>-t 　显示内存总和列。<br>-V 　显示版本信息。</p><h2 id="系统设置"><a href="#系统设置" class="headerlink" title="系统设置"></a>系统设置</h2><h3 id="setup"><a href="#setup" class="headerlink" title="setup"></a>setup</h3><p>Linux setup命令设置公用程序，是一个启动图形设置系统的命令。</p><p>setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。</p><p>语法<br>setup<br>setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：</p><p>１.登陆认证方式<br>２.键盘组态设置<br>３.鼠标组态设置<br>４.开机时所要启动的系统服务<br>５.声卡组态设置<br>６.时区设置<br>７.X Windows组态设置</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;磁盘管理&quot;&gt;&lt;a href=&quot;#磁盘管理&quot; class=&quot;headerlink&quot; title=&quot;磁盘管理&quot;&gt;&lt;/a&gt;磁盘管理&lt;/h2&gt;&lt;h3 id=&quot;cd&quot;&gt;&lt;a href=&quot;#cd&quot; class=&quot;headerlink&quot; title=&quot;cd&quot;&gt;&lt;/a&gt;cd&lt;/h
      
    
    </summary>
    
      <category term="linux" scheme="https://hubhack.github.io/categories/linux/"/>
    
    
      <category term="linux基础" scheme="https://hubhack.github.io/tags/linux%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
  <entry>
    <title>草稿</title>
    <link href="https://hubhack.github.io/5/"/>
    <id>https://hubhack.github.io/5/</id>
    <published>2019-03-19T14:25:34.000Z</published>
    <updated>2019-04-10T16:13:00.690Z</updated>
    
    <content type="html"><![CDATA[<pre><code>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当</code></pre><p>你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它<br>并不真正构造列表。<br>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结<br>束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代<br>器。list() 函数是另外一个（ 迭代器 ），<br>它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，<br>它能够用来遍历标准模板库容器中的部分或全部元素，<br>每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，<br>所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。<br>然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p><p>整理:3.29</p><p>回顾: 整型分长短,但在python3中已经没有了<br>bool 是整型的子类<br>math.sqrt 看帮助 官方文档<br>bin() 返回的字符串<br>type isinstance<br>list 是可迭代对象<br>index 匹配 count 匹配的次数<br>extend 魔术方法<br>“{},{}”.format(1.2)</p><ul><li><strong>随机数</strong><br>instantiate 实例<br>fields领域<br>random模块<br>import random<br>random.randint(1.2)<br>random.choice随机取数字 不均匀<br>for i in range(10):<br>sample 取样<br>元组: 不可变<br>命令元组namedtuple attribute属性特性<br>例子:<br>Point = namedtuple(‘Point’,[‘x’,’y’])<br>p = Point(11,y=22)<br>namespace<br>exec 当python语句执行<br>命名元组,返回一个元组的子类,并定义了字段<br>冒泡法 重点<br>map高阶函数 映射<br>aplit 默认使用空白字符分隔<br>maxsplit<br>replace<br>strip 默认去掉字符两端的空白字符<br>find 时间复杂度和index一样遍历<br>format 函数格式字符串语法<br>“{}”.format()<br>参数解构<em><br>“{}”.format(3**0.5)<br>序列都可以用in<br>内置函数 5</em>14 itertor迭代器</li></ul><p>冒泡法:经典排序算法</p><blockquote><p>for i in range(n):<br>   for j in range(n-i):<br>       num[j],num[j+1] = num[j+1],num[j]<br>print()<br>内置函数说明<br>len(s)<br>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）<br>zip()<br>创建一个聚合来自每个可迭代对象中元素的迭代器<br>返回一个元组的迭代器,其中<br>我们已经知道,可以直接作用于for循环的数据类型有以下几种:<br>一类是集合数据类型,如list tuple dictionary set str<br>一类是generator ,包括生成器和带yield的generator function<br>这些可以直接作用于for循环的对象统称为可迭代对象:iterable<br>而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.</p></blockquote><h1 id="pythonnic"><a href="#pythonnic" class="headerlink" title="pythonnic"></a>pythonnic</h1><p>Python的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:</p><h1 id="不够Pythonic"><a href="#不够Pythonic" class="headerlink" title="不够Pythonic"></a>不够Pythonic</h1><p>if a &lt; b and a &gt; c:<br>    pass</p><h1 id="python里却可以这么写"><a href="#python里却可以这么写" class="headerlink" title="python里却可以这么写"></a>python里却可以这么写</h1><p>if c &lt; a &lt; b:<br>    pass</p><h1 id="bad"><a href="#bad" class="headerlink" title="bad"></a>bad</h1><p>i = 0<br>while i &lt; mylist_length:<br>    do_something(mylist[i])<br>    i += 1</p><h1 id="good"><a href="#good" class="headerlink" title="good"></a>good</h1><p>for element in mylist:<br>   do_something(element)</p><h1 id="bad-不要使用默认可变对象作为默认参数"><a href="#bad-不要使用默认可变对象作为默认参数" class="headerlink" title="bad, 不要使用默认可变对象作为默认参数"></a>bad, 不要使用默认可变对象作为默认参数</h1><p>def f(a, b=[])<br>    pass</p><h1 id="good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题"><a href="#good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题" class="headerlink" title="good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题"></a>good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题</h1><p>def f(a, b=None):<br>    if b is None:<br>        b = []<br>Python有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。</p><h1 id="列表生成式"><a href="#列表生成式" class="headerlink" title="列表生成式:"></a>列表生成式:</h1><p>list comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式<br>举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))<br>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p><blockquote><blockquote><blockquote><p>L = []<br>for x in range(1, 11):<br>…    L.append(x * x)<br>…<br>L<br>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p></blockquote></blockquote></blockquote><p>c 程序主要包括以下部分<br>预处理指令<br>函数<br>变量<br>语句<br>注释</p><h1 id="include-lt-stdio-h-gt"><a href="#include-lt-stdio-h-gt" class="headerlink" title="include &lt;stdio.h&gt;"></a>include &lt;stdio.h&gt;</h1><p>int main()<br>{<br>    print(“hello world”);<br>    return 0;<br>}</p><h1 id="python-中的对象"><a href="#python-中的对象" class="headerlink" title="python 中的对象"></a>python 中的对象</h1><p>对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.<br>Python对象的多态性</p><p>　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？<br>　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject<em>变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject </em>变量来保存和维护这个对象，而是通过PyObject <em>，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject</em>)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。</p><h1 id="python标准库"><a href="#python标准库" class="headerlink" title="python标准库"></a>python标准库</h1><p>文本处理服务:string re textwrap<br>二进制数据服务<br>数据类型<br>数字和数学模块<br>函数式编程模块<br>文件和目录访问<br>数据持久化<br>数据压缩和存档<br>文件格式<br>加密服务<br>通用操作系统服务 os io time<br>并发执行 threading<br>网络和进程间通信<br>互联网数据处理 email json<br>结构化标记处理工具 html xml<br>互联网协议和支持 urllib.request http.server<br>多媒体服务 imghdr<br>国际化<br>程序框架 cmd turtle<br>Tk图形用户界面 GUI<br>开发工具 调试和分析<br>软件打包和分发 venv<br>python运行时服务 sysbuiltins   gc垃圾回收器接口<br>自定义python解释器<br>导入模块<br>python语言服务<br>杂项服务<br>windows系统相关模块<br>unix专有服务<br>被取代的模块<br>未创建文档的模块</p><p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p><p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p><p>单星号(<em>):</em>args 将所以参数以元组(tuple)的形式导入:<br>还有解压参数<br>双星号以字典的形式导入</p><h1 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h1><p>字典是python的半壁江山 要熟练<br>可变的 ,无序的,key不重复<br>d[key]<br>返回key对应的值value<br>key不存在抛出keyerror异常</p><p>get(key[,defalut])<br>返回key对应的值value<br>key不存在返回缺省值,如果没有设置缺省值就返回none</p><p>setdefalut(key[,default])<br>返回key对应的值value<br>key不存在,添加kv对,value设置为default,并返回default</p><p>字典增加和修改</p><p>d[key] = value<br>将key对应的值修改为value<br>key不存在添加新的kv对</p><p>updata([other])<br>使用另一个字典的kv对更新本字典<br>key不存在,就添加<br>key存在,覆盖已经存在的key对应的值<br>就地修改</p><p>字典删除</p><p>pop(key[,default])<br>key不存在,移除他,并返回它的value<br>key不存在,返回给定的default<br>default未设置,key不存在则抛出Keyerror异常<br>popitem()<br>移除并返回一个任意的键值对<br>字典为empty,抛出KEyerror<br>clear()<br>清空字典</p><p>字典删除<br>del语句<br>a = True<br>b = [6]</p><p>字典遍历<br>for …in dict<br>遍历key<br>for k in d:<br>print(k)</p><p>key的要求和set的元素要求一致<br>set的元素可以就是看做key,set可以看做dict的简化版<br>hashable可哈希才可以作为key, 可以使用hash()测试</p><p>defaultdict</p><h1 id="解析式"><a href="#解析式" class="headerlink" title="解析式"></a>解析式</h1><p>列表解析list comprehension</p><p>语法<br>返回值 for 元素 in 可迭代 对象if 条件<br>使用中括号[],内部是for循环,if条件语句可选<br>返回一个新的列表</p><p>列表解析式是一种语法糖<br>编译器会优化,不会因为简写而影响效率,反而因优化提高了效率</p><h1 id="生成器"><a href="#生成器" class="headerlink" title="生成器"></a>生成器</h1><p>python三剑客 生成器 装饰器 描述器<br>熟练运用<br>生成器表达式是按需计算 或惰性求值,延迟计算<br>列表解析式是立即返回值<br>生成器 是可迭代对象 迭代器</p><p>生成器表达式**<br>单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表<br>生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存<br>列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据</p><p>计算速度<br>单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长<br>但是生成器本身并没有返回任何值,只返回一个生成器对象<br>列表解析式构造并返回了一个新的列表,所以看起来耗时了</p><p>类似:字典,集合解析式</p><h1 id="collections-容器数据类型"><a href="#collections-容器数据类型" class="headerlink" title="collections 容器数据类型"></a>collections 容器数据类型</h1><p>这个模块实现了特定目标的容器<br>nametuple 创建命名元组子类的工厂函数</p><p>counter 字典的子类,提供了可哈希对象的计数功能<br>OrderedDict 字典的子类,保存了他们被添加的顺序<br>defaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;pre&gt;&lt;code&gt;在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当
&lt;/code&gt;&lt;/pre&gt;&lt;p&gt;你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它&lt;br&gt;并不真正构造列表。&lt;br&gt;我们称此类对象是 可迭代的，即适合作
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>python入门笔记</title>
    <link href="https://hubhack.github.io/2/"/>
    <id>https://hubhack.github.io/2/</id>
    <published>2019-03-19T14:25:34.000Z</published>
    <updated>2019-04-08T03:19:55.904Z</updated>
    
    <content type="html"><![CDATA[<h1 id="计算机基础"><a href="#计算机基础" class="headerlink" title="计算机基础"></a>计算机基础</h1><p>程序是一组让计算机识别和执行的指令<br>电子计算机:能够执行程序的机器<br>计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)<br>为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.<br>即8位 2**8=256种状态  </p><p>内存 掉电易失 与晶振频率有关 临时数据 mermory<br>cpu与内存速度差几个数量级<br>cpu 只认内存 io设备最慢<br>CPU 缓存 cache  bus 总线<br>先写源程序 通过编译程序把源程序转换成机器指令的程序<br>python是跑在虚拟机上的 动态语言 做节点 集群优化<br>编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样</p><p>机器语言: 是一定位数组成的0 1序列 称为机器指令  机器指令的集合就是机器语言<br>汇编: 是用助记符替代机器指令<br>静态语言: 是声明变量类型,不能再改变,编译需要检查<br>动态语言: 不用声明类型 随时可以赋值为其他类型<br>强类型: 不同类型之间操作 必须强制类型转换为同一类型<br>弱类型: 不同类型之间操作 自动隐式转换</p><h2 id="python基础介绍"><a href="#python基础介绍" class="headerlink" title="python基础介绍"></a>python基础介绍</h2><p>python 的源代码需要被解释器编译成中间代码,在虚拟机上运行<br>程序 = 算法 +数据结构<br>数据一切程序的核心<br>数据结构是数据在计算机中的类型和组织方式<br>算法是处理数据的方式,算法有优劣之分.<br>python自带了一个IDLE的程序,全称是交互式开发环境.<br>注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可<br>只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要.</p><blockquote><p>import math</p><p>#对角线的长度<br>i = 4<br>w = 10<br>d = math.sqrt(1<strong>2 + w</strong>2)<br>即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的<br>编写尽量用pep8风格</p></blockquote><p>数据类型:python将数据划分为不同的类别,即数据类型.<br>每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.<br>对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.<br>对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.<br>对象的数据类型是对象所属的数据类别.<br>“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号<br>数据类型为bool的对象被称为布尔值.<br>数据类型为nonetype的对象,其值永远我none 用来表示数据缺失.</p><p>系统编程<br>python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件<br>(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.<br>python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道<br>进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展<br>此外很多python的系统工具设计都考虑了其可移植性.</p><p>python解释器<br>python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成<br>当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行.</p><h2 id="python变量和内存"><a href="#python变量和内存" class="headerlink" title="python变量和内存"></a>python变量和内存</h2><p>变量在python是表示内存的地址.<br>可以用id()函数获取内存地址</p><blockquote><p>a=5<br>id(a)<br>id(5)<br>会发现这两个地址一样,都输出140720362218448</p></blockquote><p>即python的编程哲学 :一切皆对象,一切皆指针<br>只有指针,要说变量也是指针变量<br>variable 变量是改变的值.变量由一个或多个字符组成的名称构成<br>并使用赋值符 等号赋予了这个名称一个值<br>变量是记住内存中 0 1数字  开始和结束的一串</p><p>指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。</p><p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p><p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p><p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>对于C和C++这样的没有Garbage Collection 的语言来讲<br>我们主要关注两种类型的内存泄漏：</p><p>堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. </p><p>系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p><h3 id="python虚拟机原理"><a href="#python虚拟机原理" class="headerlink" title="python虚拟机原理"></a>python虚拟机原理</h3><p>python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.<br>pycodeobject保存字节码以及进程上下文信息.</p><p>过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行<br>字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象<br>.pyc文件字节码在磁盘上的表现形式<br>pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,<br>从技术上将,他才是所谓python解释器的最后一步.<br>代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式.</p><p>开发环境 —-pyenv<br>python多版本管理工具<br>pip包管理器<br>pip install xxx<br>pip list<br>pip search keyword 或者 pypi<br>pip help install<br>pip install redis ipython<br>pip install jupyter<br>pip -V<br>pip freeze &gt; requirement<br>pip install-r requirement</p><h3 id="原码补码反码"><a href="#原码补码反码" class="headerlink" title="原码补码反码"></a>原码补码反码</h3><p>原码是给人看的,补码是给计算机用的<br>127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。<br>因为它是用补码的编码方式。<br>正数的补码就是它的原码，也就是单纯的二进制数。负数的话，<br>1111 1111这个二进制串，首先它最高位是1，明确他是个负数。<br>那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001<br>也就是1，再加上符号位。最终结果是-1</p><p>补码 从小到大 二进制<br>1000 0000—-0000 0000—-0111 1111<br>首尾相连，刚好连个时钟，最大的加一到最小的</p><h1 id="基础语法"><a href="#基础语法" class="headerlink" title="基础语法"></a>基础语法</h1><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><p>使用单双三引号括起来的序列叫字符串</p><p>r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理<br>f前缀:3.6版本开始,新增f前缀,格式化字符串<br>转义序列<br>\ \t \r \n \’ \”<br>缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系<br>约定使用4个空格缩进<br>续行:在行尾使用\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\<br>extend 魔术方法<em>add</em>()</p><h2 id="标识符"><a href="#标识符" class="headerlink" title="标识符"></a>标识符</h2><p>一个名字,用来指代一个值<br>只能是字母,下划线和数字<br>只能以字母或下划线开头<br>不能是python的关键字,例如def,class等<br>python是大小写敏感的<br>约定:<br>不允许使用中文<br>不要使用歧义单词,例如class_<br>在python中不要随便使用下划线开头的标识符</p><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><ul><li>算术运算符</li></ul><p>+-*/%**<br>自然除/结果是浮点数,整除//</p><ul><li>位运算符</li></ul><p>&amp; | ~ ^ &lt;&lt; &gt;&gt;</p><ul><li>比较运算符</li></ul><p>== != &gt; &lt; &gt;= &lt;=<br>返回一个bool值</p><ul><li>逻辑运算符</li></ul><p>与或非 and or not<br>短路运算符</p><ul><li>赋值运算符<br>0 *? =0短路<br>1+? =1短路运算 可以提高效率 可以提前算完了<br>赋值运算 先算右边 和左边相连(映射)</li></ul><p>a=min(3,5)</p><p>运算符优先级 就记住一句话  a+b&gt;c and</p><p>折半思想可以优化程序</p><h2 id="程序控制"><a href="#程序控制" class="headerlink" title="程序控制"></a>程序控制</h2><p>顺序结构:按照先后顺序一条条执行<br>分支结构:根据不同情况判断,条件满足执行某条件下的语句<br>循环结构:条件满足就反复执行,不满足就不执行或不再执行</p><h2 id="内置类型"><a href="#内置类型" class="headerlink" title="内置类型"></a>内置类型</h2><p>内置对象使程序更容易编写<br>内置对象使扩展的组件<br>内置对象往往比定制的数据结构更有效率<br>内置对象使语言的标准的一部分<br>python的核心数据类型<br>模式匹配</p><h2 id="循环"><a href="#循环" class="headerlink" title="循环"></a>循环</h2><p>while 语句<br>whlie condition:<br>    block<br>当他成立则进入循环<br>while true:<br>    pass #死循环 冒号后要形成语句块 死循环都用这个语法<br>例子:</p><p>flag = 10<br>while flag:<br>    print(flag)<br>    flag-= 1</p><p>在做循环时,一定要分析边界 边界最容易出错<br>range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包</p><blockquote><p>for i in range(10):<br>   print(i+1)<br>   i= i+10<br>循环 隐含赋值 原来有什么会被冲掉<br>for相当于遍历 不会重复拿 挨个拿<br>如果要倒着遍历 应当在range函数内加步长-1<br>例子:<br>for i in range(10):<br>    if i %2 == 0:<br>        print(i)</p></blockquote><p>for i in range(10):<br>    if not i % 2:<br>        print(i)<br>not 经常用<br>for i in range (10):<br>    if i &amp;1 == 0:<br>        print(i)</p><p>for i in range(10):<br>    if i &amp; 1:<br>        continue<br>    print(i)</p><p>写程序要减少循环提高效率</p><p>for i in range(10):<br>    if i % 2:<br>        continue<br>    print(i)</p><p>如果循环嵌套 continue 和break也只影响语句所在的那一层循环</p><h2 id="迭代器和生成器"><a href="#迭代器和生成器" class="headerlink" title="迭代器和生成器"></a>迭代器和生成器</h2><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p><p>一类是集合数据类型，如list、tuple、dict、set、str等；</p><p>一类是generator，包括生成器和带yield的generator function。</p><p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p><p>可以使用isinstance()判断一个对象是否是Iterable对象：</p><blockquote><blockquote><blockquote><p>from collections import Iterable<br>isinstance([], Iterable)<br>True<br>isinstance({}, Iterable)<br>True<br>isinstance(‘abc’, Iterable)<br>True<br>isinstance((x for x in range(10)), Iterable)<br>True<br>isinstance(100, Iterable)<br>False<br>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p></blockquote></blockquote></blockquote><p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator.</p><p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p><p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p><blockquote><blockquote><blockquote><p>L = [x <em> x for x in range(10)]<br>L<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br>g = (x </em> x for x in range(10))<br>g</p></blockquote></blockquote></blockquote><p>&lt;generator object <genexpr> at 0x1022ef630&gt;</genexpr></p><h1 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h1><p>python 内置了很多有用的函数,我们可以直接调用<br>要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()<br>调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;计算机基础&quot;&gt;&lt;a href=&quot;#计算机基础&quot; class=&quot;headerlink&quot; title=&quot;计算机基础&quot;&gt;&lt;/a&gt;计算机基础&lt;/h1&gt;&lt;p&gt;程序是一组让计算机识别和执行的指令&lt;br&gt;电子计算机:能够执行程序的机器&lt;br&gt;计算机中的冯诺依曼体系:控制器 运算
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python基础" scheme="https://hubhack.github.io/tags/python%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
