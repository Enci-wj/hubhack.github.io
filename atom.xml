<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千分无言</title>
  
  <subtitle>人生苦短 我用python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hubhack.github.io/"/>
  <updated>2019-08-22T04:48:52.430Z</updated>
  <id>https://hubhack.github.io/</id>
  
  <author>
    <name>mwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>编程的4门功课</title>
    <link href="https://hubhack.github.io/book/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91/"/>
    <id>https://hubhack.github.io/book/计算机4科/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><p>首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。<br>综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。<br>最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。<br>其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。</p><h3 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h3><p>综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。<br>比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。<br>理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。</p><p>现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！<br>我希望我写过的程序能在任何一台机上运行。<br>我希望我能边听音乐边干活——即同一时间可以运行多个程序。<br>我希望别人写的傻×东西不要影响到我的工作——即多任务控制。<br>我希望计算机里面的各种资源都能得到良好的组织，更快的访问。<br>我希望我的用户界面更好看，使用更方便，功能更强大！<br>我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！<br>如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。<br>计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。</p><p>而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。<br>操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。<br>操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。<br>当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。</p><p>既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。<br>我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。</p><p>至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构的作用, 就是为了提高硬件利用率.</p><p>比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。</p><p>数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h3><p>计算机网络分为3块：</p><p>硬件<br>网卡，网线，交换机这些，用来处理数据的。</p><p>协议<br>数据在网络中通信如何组织？如何识别？如何保证数据的正确性？<br>这2块我就不多说了。</p><p>操作系统<br>这就是如何把计算机网络和操作系统结合起来的问题了。<br>对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。<br>操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。<br>传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。</p><p>网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h3&gt;&lt;p&gt;首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：
      
    
    </summary>
    
      <category term="计算机" scheme="https://hubhack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="https://hubhack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>深入浅出理解预处理器</title>
    <link href="https://hubhack.github.io/book/%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA%E7%90%86%E8%A7%A3%E9%A2%84%E5%A4%84%E7%90%86%E5%99%A8/"/>
    <id>https://hubhack.github.io/book/深入浅出理解预处理器/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="预处理器"><a href="#预处理器" class="headerlink" title="预处理器"></a>预处理器</h3><p>编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.</p><h4 id="预定义符号"><a href="#预定义符号" class="headerlink" title="预定义符号"></a>预定义符号</h4><p>预处理指令</p><table><thead><tr><th>指令</th><th>描述</th></tr></thead><tbody><tr><td>#include</td><td>包含一个源代码</td></tr><tr><td>#define</td><td>定义宏</td></tr><tr><td>#undef</td><td>取消已定义的宏</td></tr><tr><td>#ifdef</td><td>如果宏已经定义,则返回真</td></tr><tr><td>#ifndef</td><td>如果宏没有定义,则返回真</td></tr><tr><td>#if</td><td>如果给定条件为真,则编译下面代码</td></tr><tr><td>#else</td><td>#if的替代方案</td></tr><tr><td>#elif</td><td>如果前面的#if给定条件不为真,当前条件为真,则编译下面代码</td></tr><tr><td>#endif</td><td>结束一个#if…#else 条件编译块</td></tr><tr><td>#error</td><td>当遇到标准错误时, 输出错误消息</td></tr><tr><td>#pragma</td><td>使用标准化方法, 向编译器发布特殊的命令道编译器中</td></tr></tbody></table><p>typedef </p><p>c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .</p><p>动态内存分配</p><p>当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.</p><p>c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.</p><p>python对象就是 c语言结构体在堆上申请的一块内存.</p><p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p><p>c中大量操作字符串的函数</p><table><thead><tr><th>函数</th><th>目的</th></tr></thead><tbody><tr><td>strcpy</td><td>复制字符串s2到字符串s1</td></tr><tr><td>strcat</td><td>连接s2 到字符串s1的末尾</td></tr><tr><td>strlen</td><td>返回字符串s1的长度</td></tr><tr><td>strcmp</td><td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td></tr><tr><td>strchar</td><td>返回一个指针,指向字符串s1中字符ch的第一次出现的位置</td></tr><tr><td>strstr</td><td>返回一个指针,指向字符串s1中字符串s2的第一次出现的位置</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;预处理器&quot;&gt;&lt;a href=&quot;#预处理器&quot; class=&quot;headerlink&quot; title=&quot;预处理器&quot;&gt;&lt;/a&gt;预处理器&lt;/h3&gt;&lt;p&gt;编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主
      
    
    </summary>
    
      <category term="c语言" scheme="https://hubhack.github.io/categories/c%E8%AF%AD%E8%A8%80/"/>
    
    
      <category term="c语言" scheme="https://hubhack.github.io/tags/c%E8%AF%AD%E8%A8%80/"/>
    
  </entry>
  
  <entry>
    <title>理解restful</title>
    <link href="https://hubhack.github.io/book/%E7%90%86%E8%A7%A3restful/"/>
    <id>https://hubhack.github.io/book/理解restful/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><p>越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件.</p><p>这种”互联网软件”采用客户端/服务器模式, 建立在分布式体系上, 通过互联网通信, 具有高延时(high latency) , 高并发等特点.</p><p>网站开发, 完全可以采用软件开发的模式, 但是传统上, 软件和网络是两个不同的领域, 很少有交集. 软件开发主要针对单机环境, 网络则主要研究系统之间的通信.</p><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。</p><h3 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h3><p>rest的名称”表现层状态转化” 中, 省略了主语, “ 表现层” 其实指的是”资源”(resource) 的”表现层”.</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h3 id="表现层-representation"><a href="#表现层-representation" class="headerlink" title="表现层(representation)"></a>表现层(representation)</h3><p>“资源”是一种信息实体, 他可以有多种外在表现形式. 我们把”资源” 具体呈现出来的形式. 叫做它的”表现层”(representation).</p><p>比如, 文本可以用txt格式表现, 也可以用html格式, xml格式,JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p><p>注意:资源不能是动词.</p><p>在RESTful架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表格名对应.一般来说, 数据库中的表都是同种记录的”集合”, 所以api中的名词也应该使用复数.</p><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><p>对于资源的具体操作类型, 由http动词表示.</p><p>常用的http动词有下面五个, (括号里对应的sql命令).</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>还有两个不常用的http动词.</p><p>HEAD:获取资源的元数据.</p><p>OPTIONS:获取信息, 关于资源的那些属性是客户端可以改变的.</p><p>下面是一些例子:</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><p>过滤信息(filtering)</p><p>如果记录信息很多, 服务器不可能都将他们返回给用户, API应该提供参数, 过滤返回结果.</p><p>下面是一些常见的参数.</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余, 即允许api路径和url参数偶尔有重复.比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><p>api的身份认证应该使用oauth 2.0框架.</p><p>服务器返回的数据格式, 应该尽量使用json, 避免使用xml.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Restful-API&quot;&gt;&lt;a href=&quot;#Restful-API&quot; class=&quot;headerlink&quot; title=&quot;Restful API&quot;&gt;&lt;/a&gt;Restful API&lt;/h3&gt;&lt;p&gt;越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件.&lt;/p
      
    
    </summary>
    
      <category term="理解restful" scheme="https://hubhack.github.io/categories/%E7%90%86%E8%A7%A3restful/"/>
    
    
      <category term="理解restful" scheme="https://hubhack.github.io/tags/%E7%90%86%E8%A7%A3restful/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="https://hubhack.github.io/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hubhack.github.io/book/深入理解计算机系统/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.<br>源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制<br>堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.<br>内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.</p><h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.<br>一个字节包括8位,在二进制表示法中,00000000<code>11111111  0</code>255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.<br>2进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.&lt;br&gt;源程序 -&amp;gt;预处理器(cpp) -&amp;gt;编译器(cc1)-&amp;gt;汇编器-&amp;gt;链接器-可执行二进制&lt;br&gt;堆:代码和数据去后紧随着的是运行时堆.代码和
      
    
    </summary>
    
      <category term="系统" scheme="https://hubhack.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="https://hubhack.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
  <entry>
    <title>草稿</title>
    <link href="https://hubhack.github.io/book/%E8%8D%89%E7%A8%BF/"/>
    <id>https://hubhack.github.io/book/草稿/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p><p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;none 与NUll的区别&lt;br&gt;表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为&lt;br&gt;0,因为0是有意义的,而none是一个特殊的空值&lt;br&gt;判断的时候 均是false&lt;br&gt;属性不同:使用dir()函数返回参数的属性,方法列表
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>理解js中的promise</title>
    <link href="https://hubhack.github.io/book/%E7%90%86%E8%A7%A3js%20%E7%9A%84promise/"/>
    <id>https://hubhack.github.io/book/理解js 的promise/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.</p><p>简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line"><span class="comment">/*下面定义的函数是executor*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>executor是一个带有resolve和reject 两个参数的函数.</p><p>executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败.</p><p>如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略.</p><p>executor中, resolve或reject只能执行其中一个函数.</p><p>promise的状态</p><ul><li>fulfilled:意味着操作成功完成</li><li>pending:初始状态,不是成功或失败状态</li></ul><ul><li>rejected: 意味着操作失败.</li></ul><p><strong>Promise.then(onfilled, onRejected)</strong></p><p>参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉.</p><p><strong>catch(onRejected)</strong></p><p>为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象.</p><p>Promise提供2个方法:</p><ul><li>Promise.resolve(value)返回 状态为fulfilled的Promise对象</li><li>Promise.reject(reason)返回 状态为rejected状态的Promise对象.</li></ul><p>catch其实是then(undefined, () =&gt; {})的语法糖,如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">p.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch'</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调.</p><p>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'do sth ----'</span>)</span><br><span class="line">            resolve(<span class="string">'ok----'</span>)</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">runAsync().then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(value + <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(reason + <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Promise end'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'========='</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.&lt;/p&gt;
&lt;p&gt;简单说, 就是处理异步请求的.
      
    
    </summary>
    
      <category term="js" scheme="https://hubhack.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://hubhack.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法</title>
    <link href="https://hubhack.github.io/book/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/魔术方法/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>__name__</td><td>类,函数,方法等名字</td></tr><tr><td>__module__</td><td>类定义所在的模块名</td></tr><tr><td>__class__</td><td>对象或类所属的类</td></tr><tr><td>__base__</td><td>类的基类的元组,顺序为他们在基类中出现的顺序</td></tr><tr><td>__doc__</td><td>类, 函数的文档字符串, 如果没有定义则为None</td></tr><tr><td>__mro__</td><td>类的mro, class.mro()返回的结果的保存在__mro__ 中</td></tr><tr><td>__dict__</td><td>类或实例的属性, 可写的字典</td></tr></tbody></table><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><p>__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.</p><p>如果dir()参数obj包括方法_<em>dir__(), 该方法将被调用.如果参数obj不包含\</em>_dir__(), 该方法将最大限度地收集属性信息.</p><p>dir(obj)对于不同类型的对象obj具有不同的行为:</p><ul><li>如果对象是模块对象, 返回的列表包含模块的属性名和变量名</li><li>如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名</li><li>如果是类的实例<ul><li>有__dir__方法, 返回可迭代对象的返回值</li><li>没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名</li></ul></li><li>如果obj不写, 返回列表包含内容不同<ul><li>在模块中, 返回模块的属性和变量名</li><li>在函数中, 返回本地作用域的变量名</li><li>在方法中,  返回本地作用域的变量名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animal.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self._name = name</span><br><span class="line">        self.__age = <span class="number">10</span></span><br><span class="line">        self.weight = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'animal Module\ s names = &#123;&#125;'</span>.format(dir()))<span class="comment"># 模块的属性 )</span></span><br></pre></td></tr></table></figure><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法***"></a>魔术方法***</h3><hr><ul><li><p>分类:</p><ul><li><p>创建, 初始化与销毁</p></li><li><p>可视化</p></li><li>hash</li><li>bool</li><li>运算符重载</li><li>容器和大小</li><li>可调用对象</li><li>上下文管理</li><li>反射</li><li>描述器</li><li>其他杂项</li></ul></li></ul><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__new__</td><td>实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法</td></tr></tbody></table><p>__new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回</p><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__str__</td><td>str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息</td></tr><tr><td>__repr__</td><td>内建函数repr()对一个对象获取<strong>字符串</strong>表达</td></tr><tr><td>__bytes__</td><td>bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age = <span class="number">18</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'repr:&#123;&#125;&#123;&#125;'</span>.format(self.name, self.age)</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__hash__</td><td>内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash</td></tr><tr><td>__eq__</td><td>对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了</td></tr></tbody></table><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__bool__</td><td>内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真</td></tr></tbody></table><h3 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h3><p>文件IO操作可以对文件对象使用上下文管理，使用with。。as语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>仿照上例写一个自己的泪，实现上下文管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> Point <span class="keyword">as</span> p:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>提示属性错误，没有__exit__，看了需要这个属性</p><p>某些版本会显示没有__enter__</p><p>上下文管理对象</p><p>当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象</p><p>__enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上</p><p>__exit__退出与此对象相关的上下文</p><p>with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作</p><p>注意,with 并不开启一个新的作用域</p><p>上下文管理是安全的</p><p>上下文应用场景</p><p>1.增强功能</p><p>在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能</p><p>2.资源管理</p><p>打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等</p><p>3.权限验证</p><p>在执行代码之前,做权限验证,在__enter__</p><h4 id="contextilb-contextmanager"><a href="#contextilb-contextmanager" class="headerlink" title="contextilb.contextmanager"></a>contextilb.contextmanager</h4><p>他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法</p><p>对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.</p><p>也就是这个装饰器接受一个生成器对象作为参数.</p><p>总结</p><p>如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>概述</p><p>运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候</p><p>反射,  reflection, 指的是运行时获取类型定义信息</p><p>一个对象能够在运行时,像照镜子一样,反射出其类型信息</p><p>简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身</p><p>具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等</p><h4 id="反射相关的函数和方法"><a href="#反射相关的函数和方法" class="headerlink" title="反射相关的函数和方法"></a>反射相关的函数和方法</h4><table><thead><tr><th>getattar</th><th>通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串.</th></tr></thead><tbody><tr><td>setattar</td><td>object的属性存在,这覆盖, 不存在,新增</td></tr><tr><td>hasattat</td><td>判断对象是否有这个名字的属性,name必须为字符串</td></tr></tbody></table><h4 id="反射相关的魔术方法"><a href="#反射相关的魔术方法" class="headerlink" title="反射相关的魔术方法"></a>反射相关的魔术方法</h4><p>__getattr__(), __setattr__(), __delattr__(), 三个魔术方法</p><p>实例属性会按照继承关系找,  如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出</p><p>AttributeError异常表示找不到属性.</p><p>查找属性顺序为:</p><p>instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特殊属性&quot;&gt;&lt;a href=&quot;#特殊属性&quot; class=&quot;headerlink&quot; title=&quot;特殊属性&quot;&gt;&lt;/a&gt;特殊属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://hubhack.github.io/book/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hubhack.github.io/book/面向对象/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言的分类"><a href="#语言的分类" class="headerlink" title="语言的分类"></a>语言的分类</h2><p>面向机器:抽象成机器指令, 机器容易理解.<br>代表:汇编语言<br>面向过程:<br>做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.<br>问题规模小, 可以步骤化.按部就班处理.<br>代表:c语言<br>面向对象OOP<br>随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.<br>代表:C++, java, python等</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类:class<br>类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.<br>用计算机语言来描述类,是属性和方法的集合.<br>对象:instance, object<br>对象是类的具象, 是一个实体.<br>对于我们每个人这个个体, 都是抽象概念人类不同的实体.</p><p>属性:它是对象状态的抽象,用数据结构来描述.<br>操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.<br>哲学:<br>一切皆对象<br>对象是数据和操作的封装.<br>对象是独立的,但是对象之间可以相互作用.<br>目前OOP是最接近人类认知的编程范式.</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p>1.封装<br>组装:将数据和操作组装到一起.<br>隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的<br>构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.<br>2.继承<br>多复用,继承来的就不用了自己写了<br>多继承少修改,OCP,使用继承来改变,来体现个性.<br>3.多态<br>面向对象编程最灵活的地方,动态绑定<br>人类就是封装<br>人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:<br>多态,继承自动物类的人类,猫类的操作’吃’不同.</p><p>python的类:<br>1.必须使用class关键字<br>2.类名必须使用大驼峰命名<br>3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.</p><h2 id="类对象及类属性"><a href="#类对象及类属性" class="headerlink" title="类对象及类属性"></a>类对象及类属性</h2><p>类对象,类的定义执行后会生成一个类对象.<br>类的属性,类定义中的变量和类中定义的方法都是类的属性.<br>类变量,<br>self指代当前实例本身.</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>a = Myclass() # 实例化<br>使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.<br>实例化就真正创建一个该类的对象<br>tom = Person()<br>jerry = Person()<br>每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.<br>python类实例化后, 会调用<strong>init</strong>方法,这个方法第一个形式参数必须留给self,其他参数随意.<br><strong>init</strong>方法</p><p>注意:<strong>init</strong>()方法不能有返回值,也就是只能是return None</p><p>实例对象instance<br>类实例化后一定会获得一个类的实例,就是实例对象<br><strong>init</strong>方法的第一参数self就是指代某一个实例自身.<br>类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.</p><p>实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.</p><p>总结:<br>是类的,也就是这个类所有实例的,器实例都可以访问到:<br>是实例的,就是这个实例自己的,通过类访问不到.<br>类变量是属于类的变量,这个类的所有实例可以共享这个变量.<br>对象可以动态的给自己增加一个属性.<br>实例属性的查找顺序<br>指的是实例使用,.点号来访问属性.会先找自己的<strong>dict</strong>,如果没有,然后通过属性<strong>class</strong>找到自家的类, 再去类的<strong>dict</strong>中找.<br>注意:如果实例使用<strong>dict</strong>访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.</p><p>一般来说, 类变量可使用全大写来命名.</p><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>1.在类定义中,使用@classmethod装饰器的方法<br>2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.<br>3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改<br>4.通过cls可以直接操作类的属性.<br>静态方法:<br>在类定义中, 使用@staticmethod装饰器的方法<br>2在调用时, 不会隐式的传入参数.<br>静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.</p><p>类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,<br>原因是第一参数必须是类的实例.<br>总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.<br>实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.<br>实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.</p><p>访问控制:<br>私有属性<br>私有属性,使用双下划线开头的属性名就是私有属性.</p><p>私有属性的本质:<br>类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.</p><p>保护变量:<br>在变量名前使用一个下划线,称为保护变量<br>这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.<br>私有方法:<br>参照保护变量,私有变量,使用单下划线,双下化线的命名方法,</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变<br>猴子补丁:<br>在运行时,对属性,方法,函数,等进行动态替换<br>其目的往往是为了通过替换,修改来增强,扩展原有代码的能力</p><h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.</p><p>property装饰器</p><p>后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性<br>setter装饰器<br>可以控制是否删除属性,很少用<br>deleter装饰器<br>可以控制是否删除属性,很少用<br>property装饰器必须在前,setter deleter装饰器在后,<br>property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.</p><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>类中可以定义<strong>del</strong>方法 ,称为析构函数.<br>作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.<br>注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.<br>使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用<strong>del</strong>方法.<br>由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.<br>封装:<br>将数据和操作组织到类中,即属性和方法.<br>将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.<br>通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语言的分类&quot;&gt;&lt;a href=&quot;#语言的分类&quot; class=&quot;headerlink&quot; title=&quot;语言的分类&quot;&gt;&lt;/a&gt;语言的分类&lt;/h2&gt;&lt;p&gt;面向机器:抽象成机器指令, 机器容易理解.&lt;br&gt;代表:汇编语言&lt;br&gt;面向过程:&lt;br&gt;做一件事,排出个步骤,第一
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python部署</title>
    <link href="https://hubhack.github.io/book/%E9%83%A8%E7%BD%B2/"/>
    <id>https://hubhack.github.io/book/部署/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<p>Django打包</p><p>构建setup.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd python</span><br><span class="line">echo python | passwd python --stdin</span><br><span class="line">yum install git python-devel mysql-devel</span><br><span class="line">yum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc </span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>python setup.py sdist –formats=gztar</p><p>ln -sv blog-1.0 web</p><p>/root/blog/projects/web</p><p>uwsgi -d –ini blog.ini  后台启动服务, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; resolve &#125; from &quot;url&quot;;</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //做一些事情</span><br><span class="line">    //然后再某些条件下resolve, 或者reject</span><br><span class="line">    if(/*条件随便写*/) &#123;</span><br><span class="line">        resolve()</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.then(() =&gt; &#123;</span><br><span class="line">    //如果p的状态被resolve, 就进入这里</span><br><span class="line">&#125;), () =&gt; &#123;</span><br><span class="line">    //如果p的状态被reject,进入这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段调用了Promise构造函数, 第二段是调用了promise实例的.then方法</p><p>构造实例</p><p>构造函数接受一个参数作为参数</p><p>调用构造函数得到实例p的同时,作为参数的函数会立即执行.</p><p>参数函数接受两个回调函数参数resolve和reject</p><p>在参数函数被执行的过程中, 如果在其内部调用resolve, 会被p的状态变为fulfilled, 或者调用reject, 会将p的状态变为rejected.</p><p>调用.then</p><p>调用.then可以为实例p注册两种状态回调函数</p><p>当实例p的状态为fulfilled, 会触发第一个函数执行</p><p>当实例p的状态为rejected, 则会触发第二个函数执行.</p><p>总结</p><p>上面这样构造promise实例, 然后调用.then.then.then的编写代码方式, 就是promise.</p><p>其基本模式是:</p><p>将异步过程转换成promise对象.</p><p>对象有三种状态, </p><p>通过.then注册状态的回调.</p><p>已完成的状态能触发回调.</p><p>采用这种方式来处理编程中的异步任务, 就是在使用promise了.</p><p>所以promise就是一种异步编程模式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Django打包&lt;/p&gt;
&lt;p&gt;构建setup.py文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="项目部署" scheme="https://hubhack.github.io/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="项目部署" scheme="https://hubhack.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://hubhack.github.io/book/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://hubhack.github.io/book/网络协议/</id>
    <published>2019-08-22T04:48:52.430Z</published>
    <updated>2019-08-22T04:48:52.430Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th>模型</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等.</td></tr><tr><td>表示层</td><td>提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码.</td></tr><tr><td>会话层</td><td>建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传.</td></tr><tr><td>传输层</td><td>提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket).</td></tr><tr><td>网络层</td><td>为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF.</td></tr><tr><td>链路层</td><td>在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 .</td></tr><tr><td>物理层</td><td>为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准.</td></tr></tbody></table><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><table><thead><tr><th>链路层和物理层</th><th>描述</th></tr></thead><tbody><tr><td>ARP(地址解析协议)</td><td>IP地址——-&gt;MAC地址</td></tr><tr><td>RARP</td><td>MAC地址——&gt;IP地址（逆向的）</td></tr><tr><td>PPP协议</td><td>拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样</td></tr><tr><td>MAC地址</td><td>48位全球唯一,网络设备的身份识别</td></tr></tbody></table><table><thead><tr><th>网络层</th><th>描述</th></tr></thead><tbody><tr><td>IP协议</td><td>IP:（分为IPV4（168….）和IPV6（16进制用：隔开））</td></tr><tr><td>ICMP（Internet控制管理协议）</td><td>ping命令属于ICMP</td></tr><tr><td>IGMP（Internet分组管理协议）</td><td>广播，组播</td></tr></tbody></table><table><thead><tr><th>传输层</th><th>描述</th></tr></thead><tbody><tr><td>TCP（传输控制协议)</td><td>面向连接，可靠,效率低，一对一的可靠数据传输的协议</td></tr><tr><td>UDP（用户数据报协议）</td><td>面向无连接，不可靠，效率高，提供不可靠的数据尽力传输</td></tr><tr><td>SCTP</td><td>是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信</td></tr></tbody></table><table><thead><tr><th>应用层</th><th>描述</th></tr></thead><tbody><tr><td>网页访问协议</td><td>HTTP HTTPS(S是安全)</td></tr><tr><td>邮件发送接收协议</td><td>POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件）</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>Telnet（明文传输）/SSH（安全）</td><td>远程登录</td></tr></tbody></table><table><thead><tr><th>嵌入式</th><th>描述</th></tr></thead><tbody><tr><td>NTP</td><td>网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的）</td></tr><tr><td>SNMP(开源（SNMP.NET）)</td><td>简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置</td></tr><tr><td>RTP/RTSP</td><td>用传输音视频传输（监控等）</td></tr></tbody></table><h3 id="中继系统"><a href="#中继系统" class="headerlink" title="中继系统"></a>中继系统</h3><p>中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。</p><h3 id="中继系统之集线器"><a href="#中继系统之集线器" class="headerlink" title="中继系统之集线器"></a>中继系统之集线器</h3><p>光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。</p><p>这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。</p><h3 id="中继系统之交换机"><a href="#中继系统之交换机" class="headerlink" title="中继系统之交换机"></a>中继系统之交换机</h3><p>还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：<strong>有记忆功能</strong>。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？</p><p>交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。</p><p>如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。</p><h3 id="中继系统之路由器"><a href="#中继系统之路由器" class="headerlink" title="中继系统之路由器"></a>中继系统之路由器</h3><p>路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。</p><p><strong><em>这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。</em></strong></p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.</p><h3 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h3><p>因为ip数据包是在以太网数据包里发送, 所以我们必须同时知道两个地址, 一个是对方的MAC地址, 另一个是对方的IP地址, 通常情况下, 对方的IP地址是已知的, 但是我们不知道它的mac地址.<br>所以, 我们需要一种地址, 能够从ip地址得到mac地址.<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h3 id="路由Routing"><a href="#路由Routing" class="headerlink" title="路由Routing"></a>路由Routing</h3><p>跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.</p><p>路由器上维护着路由表,他知道如何将数据包发往另外的网络.</p><p>windows使用route print, liunx使用route -n可以查看路由表.</p><p>路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.</p><p>静态路由:有管理员手动配置的固定的路由信息</p><p>动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI参考模型&quot;&gt;&lt;a href=&quot;#OSI参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI参考模型&quot;&gt;&lt;/a&gt;OSI参考模型&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/
      
    
    </summary>
    
      <category term="网络原理" scheme="https://hubhack.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="https://hubhack.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>序列化与json</title>
    <link href="https://hubhack.github.io/book/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson/"/>
    <id>https://hubhack.github.io/book/序列化与json/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.</p><p>如果是自己定义的类的实例, 如何保存到一个文件中.</p><p>如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例.</p><p>要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化.</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>serialization 序列化</p><p>将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制</p><p>deserialization 反序列化</p><p>将文件的一个个字节恢复成内存中对象 &lt;-二进制</p><p>序列化保存到文件就是持久化.</p><p>可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化.</p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>JSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。</p><p>json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。</p><h2 id="1、JSON语法规则"><a href="#1、JSON语法规则" class="headerlink" title="1、JSON语法规则"></a>1、JSON语法规则</h2><p>JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。</p><p><strong>（1）简单值</strong></p><p>简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单值</span></span><br><span class="line"><span class="string">"Hello World!"</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="number">99</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">false</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JSON中不能使用的值</span></span><br><span class="line"><span class="literal">NaN</span> <span class="comment">// 数值不能是NaN</span></span><br><span class="line"><span class="literal">Infinity</span> <span class="comment">// 数值不能是Infinity</span></span><br><span class="line"><span class="literal">undefined</span> <span class="comment">// 在JSON也不可以使用JavaScript中的undefined</span></span><br><span class="line"><span class="string">'Hello World!'</span> <span class="comment">// 字符串必须使用双引号表示，不能使用单引号</span></span><br><span class="line"><span class="number">0x1</span> <span class="comment">// 数值必须以十进制表示，不能使用十六进制</span></span><br></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p>对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">"isStudent"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"isLeader"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"mark"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"school"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"BIT"</span>,</span><br><span class="line">    <span class="string">"region"</span>: <span class="string">"Beijing"</span> <span class="comment">// 这个地方不能有逗号，因为是对象的最后一个属性成员</span></span><br><span class="line">  &#125; <span class="comment">// 这个地方也不可以有逗号，因为也是对象的最后一个属性成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）数组</strong></p><p>数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line">[<span class="string">"Andy"</span>, <span class="string">"Ruby"</span>, <span class="string">"Danny"</span>, <span class="string">"Peter"</span>, <span class="string">"Lisa"</span>]</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment">// 示例三</span></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Andy"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Ruby"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Danny"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 示例四</span></span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="2、JSON字符串和JSON对象"><a href="#2、JSON字符串和JSON对象" class="headerlink" title="2、JSON字符串和JSON对象"></a>2、JSON字符串和JSON对象</h2><p><strong>（1）JSON字符串</strong></p><p>JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure><p><strong>（2）JSON对象</strong></p><p>JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON对象</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><strong>（3）JSON字符串和JSON对象互相转换</strong></p><p>JavaScript中有一个全局的对象，JSON。JSON中有两个方法 <em>stringify() 和 parse()。</em></p><p><em>JSON.parse()</em> 把JSON字符串解析为JSON对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串通过parse转化为JSON对象</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line">person = <span class="built_in">JSON</span>.parse(p)</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><em>JSON.stringify()</em> 用于把JSON对象序列化为JSON字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON对象通过stringify转化为JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">JSON</span>.stringify(person)</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h3&gt;&lt;p&gt;内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.&lt;/p&gt;
&lt;p&gt;如果是自己定义的
      
    
    </summary>
    
      <category term="json" scheme="https://hubhack.github.io/categories/json/"/>
    
    
      <category term="序列化" scheme="https://hubhack.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>正则表达式</title>
    <link href="https://hubhack.github.io/book/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <id>https://hubhack.github.io/book/正则表达式/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="正则表达式简绍"><a href="#正则表达式简绍" class="headerlink" title="正则表达式简绍"></a>正则表达式简绍</h1><p>概述:正则表达式<br>正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.<br>正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.<br>正则表达式 Regular Expression,缩写regex, regexp ,RE等.<br>分类<br>1.BRE<br>基本正则表达式,grep,sed,vi等软件支持.vim有扩展.<br>2.ERE<br>扩展正则表达式,egrep, sed -r等.<br>3.PCRE<br>几乎所有高级语言都是PCRE的方言或者变种.</p><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><p>元字符 metacharacter<br>转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\转义.<br>反斜杠自身,得使用\ \r \n还是转义后代表回车,换行</p><h1 id="贪婪与非贪婪"><a href="#贪婪与非贪婪" class="headerlink" title="贪婪与非贪婪"></a>贪婪与非贪婪</h1><p>默认是贪婪模式,也就是说尽量多匹配更长的字符串,<br>非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.</p><p>单行模式:<br>. 可以匹配所有的字符, 包括换行符.<br>^ 表示整个字符串的开头, &amp;整个字符串的结尾<br>多行模式:<br>. 可以匹配除了换行符之外的字符,多行不影响.点号<br>^ 表示行首, &amp;行尾, 只不过这里的行是每一行</p><p>默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.<br>单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.<br>多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\n后紧接着下一个字符;结束指的是\n前的字符,注意最后一行可以没有\n</p><h1 id="re模块"><a href="#re模块" class="headerlink" title="re模块"></a>re模块</h1><p>re.M多行模式<br>re.S单行模式<br>re.I忽略大小写<br>re.X忽略表达式中的空白字符<br>使用 | 位或运算开启多种选项<br>方法<br>编译<br>re.compile(pattern, flag=0)<br>设定flags, 编译模式,返回正则表达式对象regex<br>pattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.<br>单次匹配<br>re.match(pattern, string, flags=0)<br>match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象<br>从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.</p><p>全局搜索<br>对整个字符串, 从左至右匹配,返回匹配项的列表.<br>匹配替换<br>使用pattern对字符串string进行匹配,对匹配使用repl替换.<br>replacement可以是string, bytes, function.</p><p>分割字符串<br>字符串的分割函数split,太难用, 不能指定多个字符进行分割.<br>分组<br>使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象<br>如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.<br>1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.<br>2.如果使用了命名分组,可以使用group的方式取分组<br>3.也可以使用group返回所有组.<br>4.使用groupdict()返回命名的分组.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;正则表达式简绍&quot;&gt;&lt;a href=&quot;#正则表达式简绍&quot; class=&quot;headerlink&quot; title=&quot;正则表达式简绍&quot;&gt;&lt;/a&gt;正则表达式简绍&lt;/h1&gt;&lt;p&gt;概述:正则表达式&lt;br&gt;正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python小技巧</title>
    <link href="https://hubhack.github.io/book/python%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
    <id>https://hubhack.github.io/book/python小技巧/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="为多个变量赋值"><a href="#为多个变量赋值" class="headerlink" title="为多个变量赋值"></a>为多个变量赋值</h2><p>有时，有多个变量需要赋值，这时你会怎么赋值呢？<br>常规方法：常规方法是给变量逐个赋值。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = <span class="number">0</span>  </span><br><span class="line">b = <span class="number">1</span>  </span><br><span class="line">c = <span class="number">2</span></span><br></pre></td></tr></table></figure></p><p>优雅方法：<br>直接按顺序对应一一赋值.<br>a, b, c = 0, 1, 2</p><h2 id="序列解包"><a href="#序列解包" class="headerlink" title="序列解包"></a>序列解包</h2><p>需要取出列表中的元素。<br>常规方法：一般我们知道可以通过下标获取具体元素。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">info = [<span class="string">'brucepk'</span>, <span class="string">'man'</span>, <span class="string">'python'</span>]</span><br><span class="line">name = info[<span class="number">0</span>]</span><br><span class="line">sex = info[<span class="number">1</span>]</span><br><span class="line">tech = info[<span class="number">2</span>]</span><br><span class="line">print(name,sex,tech)</span><br><span class="line">结果:</span><br><span class="line">brucepk man python</span><br></pre></td></tr></table></figure></p><p>优雅方法：给出对应变量接收所有元素。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]</span><br><span class="line">name,sex,tech = info</span><br><span class="line">print(name,sex,tech)</span><br><span class="line">结果:</span><br><span class="line">brucepk man python</span><br></pre></td></tr></table></figure></p><h2 id="优雅你的判断语句"><a href="#优雅你的判断语句" class="headerlink" title="优雅你的判断语句"></a>优雅你的判断语句</h2><p>我们用判断语句来定义一个绝对值函数。<br>常规方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">x = <span class="number">-6</span></span><br><span class="line"><span class="keyword">if</span> x &lt; <span class="number">0</span>:</span><br><span class="line">    y = -x</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    y = x</span><br><span class="line">print(y)</span><br><span class="line">结果:</span><br><span class="line"><span class="number">6</span></span><br><span class="line">优雅方法：</span><br><span class="line">x = <span class="number">-6</span></span><br><span class="line">y = -x <span class="keyword">if</span> x&lt;<span class="number">0</span> <span class="keyword">else</span> x</span><br><span class="line">print(y)</span><br><span class="line">结果</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure></p><h2 id="区间判断"><a href="#区间判断" class="headerlink" title="区间判断"></a>区间判断</h2><p>使用 and 连续两次判断的语句，条件都符合时才执行语句。<br>常规方法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = <span class="number">82</span></span><br><span class="line"><span class="keyword">if</span> score &gt;=<span class="number">80</span> <span class="keyword">and</span> score &lt; <span class="number">90</span>:</span><br><span class="line">    level = <span class="string">'B'</span></span><br><span class="line">print(level)</span><br><span class="line">结果</span><br><span class="line">B</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用链式判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">score = 82</span><br><span class="line">if  80 &lt;= score &lt; 90:</span><br><span class="line">    level = &apos;B&apos;</span><br><span class="line">print(level)</span><br><span class="line">结果</span><br><span class="line">B</span><br></pre></td></tr></table></figure></p><h2 id="多个值符合条件判断"><a href="#多个值符合条件判断" class="headerlink" title="多个值符合条件判断"></a>多个值符合条件判断</h2><p>多个值任意一个值符合条件即为 True 的情况。<br>常规方法：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">if num == 1 or num == 3 or num == 5:</span><br><span class="line">    type = &apos;奇数&apos;</span><br><span class="line">print(type)</span><br><span class="line">结果</span><br><span class="line">奇数</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用关键字 in，让你的语句更优雅。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">num = 1</span><br><span class="line">if num in(1,3,5):</span><br><span class="line">    type = &apos;奇数&apos;</span><br><span class="line">print(type)</span><br><span class="line">结果</span><br><span class="line">奇数</span><br></pre></td></tr></table></figure></p><h2 id="判断是否为空"><a href="#判断是否为空" class="headerlink" title="判断是否为空"></a>判断是否为空</h2><p>判断元素是空还是非空。<br>常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;</span><br><span class="line">if len(A) &gt; 0:</span><br><span class="line">    print(&apos;A 为非空&apos;)</span><br><span class="line">if len(B) &gt; 0:</span><br><span class="line">    print(&apos;B 为非空&apos;)</span><br><span class="line">if len(C) &gt; 0:</span><br><span class="line">    print(&apos;C 为非空&apos;)</span><br><span class="line">结果</span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure></p><p>优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;  </span><br><span class="line">if A:</span><br><span class="line">    print(&apos;A 为非空&apos;)  </span><br><span class="line">if B:</span><br><span class="line">    print(&apos;B 为非空&apos;)  </span><br><span class="line">if C:</span><br><span class="line">    print(&apos;C 为非空&apos;)  </span><br><span class="line">结果</span><br><span class="line">A 为非空</span><br></pre></td></tr></table></figure><h2 id="多条件内容判断至少一个成立"><a href="#多条件内容判断至少一个成立" class="headerlink" title="多条件内容判断至少一个成立"></a>多条件内容判断至少一个成立</h2><p>常规方法：用 or 连接多个条件。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if math&lt;60 or English&lt;60 or computer&lt;60:</span><br><span class="line">    print(&apos;not pass&apos;)</span><br><span class="line">结果</span><br><span class="line">not pass</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 any 语句。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,59,88</span><br><span class="line">if any([math&lt;60,English&lt;60,computer&lt;60]):</span><br><span class="line">    print(&apos;not pass&apos;)</span><br><span class="line">结果</span><br><span class="line">not pass</span><br></pre></td></tr></table></figure></p><h2 id="多条件内容判断全部成立"><a href="#多条件内容判断全部成立" class="headerlink" title="多条件内容判断全部成立"></a>多条件内容判断全部成立</h2><p>常规方法：使用 and 连接条件做判断。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if math&gt;60 and English&gt;60 and computer&gt;60:</span><br><span class="line">    print(&apos;pass&apos;)</span><br><span class="line">结果</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 all 方法。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">math,English,computer =90,80,88</span><br><span class="line">if all([math&gt;60,English&gt;60,computer&gt;60]):</span><br><span class="line">    print(&apos;pass&apos;)</span><br><span class="line">结果</span><br><span class="line">pass</span><br></pre></td></tr></table></figure></p><h2 id="遍历序列的元素和元素下标"><a href="#遍历序列的元素和元素下标" class="headerlink" title="遍历序列的元素和元素下标"></a>遍历序列的元素和元素下标</h2><p>常规方法：使用 for 循环进行遍历元素和下标。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class="line">for i in range(len(L)):</span><br><span class="line">    print(i, &apos;:&apos;, L[i])</span><br><span class="line">结果</span><br><span class="line">0 : math</span><br><span class="line">1 : English</span><br><span class="line">2 : computer</span><br><span class="line">3 : Physics</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用 enumerate 函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class="line">for k,v in enumerate(L):</span><br><span class="line">    print(k, &apos;:&apos;, v)</span><br><span class="line">结果</span><br><span class="line">0 : math</span><br><span class="line">1 : English</span><br><span class="line">2 : computer</span><br><span class="line">3 : Physics</span><br></pre></td></tr></table></figure></p><h2 id="循环语句优化"><a href="#循环语句优化" class="headerlink" title="循环语句优化"></a>循环语句优化</h2><p>之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。<br>常规方法：使用简单的 for 循环可以达到目的。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">L = []</span><br><span class="line">for i in range(1, 6):</span><br><span class="line">    L.append(i*i)</span><br><span class="line">print(L) </span><br><span class="line">结果：</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p><p>优雅方法：使用列表生成式，一行代码搞定。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">print([x*x for x in range(1, 6)]) </span><br><span class="line">结果：</span><br><span class="line">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p><h2 id="将list中的所有元素转为单个字符串"><a href="#将list中的所有元素转为单个字符串" class="headerlink" title="将list中的所有元素转为单个字符串"></a>将list中的所有元素转为单个字符串</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]</span><br><span class="line">print(&quot; &quot;,join(a))</span><br></pre></td></tr></table></figure><h2 id="字符串倒转"><a href="#字符串倒转" class="headerlink" title="字符串倒转"></a>字符串倒转</h2><p>方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。<br>方法二：用Python自带reversed()函数，它可被用于list倒转。<br>方法三：第三种是通过倒转数据类型和切片倒转整数.</p><h2 id="链式调用"><a href="#链式调用" class="headerlink" title="链式调用"></a>链式调用</h2><p>在python 中实现链式调用只需在函数返回对象自己就行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def product(a, b):</span><br><span class="line">    return a * b</span><br><span class="line">def add(a, b):</span><br><span class="line">    return a + b</span><br><span class="line">b = True</span><br><span class="line">print((product if b else add)(5, 7))</span><br></pre></td></tr></table></figure></p><h2 id="复制list"><a href="#复制list" class="headerlink" title="复制list"></a>复制list</h2><p>在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：<br>方法一：b=a[:]。<br>方法二：b=list(a)。<br>方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。<br>方法四：使用copy.deepcopy()。</p><h2 id="按value排序字典"><a href="#按value排序字典" class="headerlink" title="按value排序字典"></a>按value排序字典</h2><p>Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：<br>方法一：用sorted函数排序，其中key参数是lamda表达式。<br>方法二：用operator.itemgetter而不是lamda表达式进行排序。<br>方法三：如果只需得到排序后的key，可用.get。</p><h2 id="for-…-else语法"><a href="#for-…-else语法" class="headerlink" title="for … else语法"></a>for … else语法</h2><h2 id="合并字典"><a href="#合并字典" class="headerlink" title="合并字典"></a>合并字典</h2><p>方法一：Python 3.5可以存在重复键值，print({<strong>d1 ,</strong>d2})。<br>方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。<br>方法三：d1.update()。</p><h2 id="从list中删除重复项"><a href="#从list中删除重复项" class="headerlink" title="从list中删除重复项"></a>从list中删除重复项</h2><p>方法一：把list转成set，去除重复项，再转回list。<br>方法二：调用collections里的OrderedDict，和set差不多。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;为多个变量赋值&quot;&gt;&lt;a href=&quot;#为多个变量赋值&quot; class=&quot;headerlink&quot; title=&quot;为多个变量赋值&quot;&gt;&lt;/a&gt;为多个变量赋值&lt;/h2&gt;&lt;p&gt;有时，有多个变量需要赋值，这时你会怎么赋值呢？&lt;br&gt;常规方法：常规方法是给变量逐个赋值。&lt;br&gt;&lt;
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python函数</title>
    <link href="https://hubhack.github.io/book/python%E5%87%BD%E6%95%B0/"/>
    <id>https://hubhack.github.io/book/python函数/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<h1 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h1><p>数学定义<br>y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)<br>python函数:<br>是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元<br>完成一定的功能<br>函数的作用<br>结构化编程对代码的最基本的封装, 一般按照功能组织一段代码<br>封装的目的为了复用,减少冗余代码<br>代码更加简洁美观,可读易懂</p><p>函数的分类:<br>内建函数,如max()<br>库函数,如math.ceil<br>自定义函数,使用def关键字定义</p><p>函数定义<br>def 函数名(参数列表):<br>    函数体(代码块)<br>    [return 返回值]<br>函数名就是标识符,命名要求一样<br>语句块必须缩进,约定4个空格<br>函数名就是标识符就是变量python的函数没有return,会返回none<br>定义中的参数列表称为形式参数,只是一种标识符占位置的<br>函数的标识符就是指向函数对象<br>函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参<br>不定义会报nameERREO</p><p>传参方式:</p><ul><li>位置传参<br>按照参数定义顺序传入实参</li><li>关键字<br>使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同<br>要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的<br>参数缺省值<br>缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:<br>参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值<br>参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用</li></ul><p>可变位置参数<br>在形参使用* 表示该形参是可变位置参数, 可以接受多个实参<br>它将收集来的实参组织到一个tuple中<br>tuple 有序按位置传参<br>可变关键字参数<br>在形参使用<strong>表示该形参是可变关键字参数,可以接受多个关键字参数<br>它将收集来的实参的名称和值,组织到一个dict中<br>可变的关键字传参</strong> kwargs</p><p>有可变位置参数和可变关键字参数<br>可变位置参数在形参前使用一个*号<br>可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple<br>可变关键字参数收集形成一个dict<br>混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面<br>要在可变关键字参数之前.</p><h1 id="keyword-only-参数"><a href="#keyword-only-参数" class="headerlink" title="keyword-only 参数"></a>keyword-only 参数</h1><p>def fn(<em>args, x, y, **kwargs):<br>    print(x, y, args, kwargs, sep=’\n’, end=’\n\n’)<br>fn(3, 5)<br>fn(3, ,5, 7)<br>在python3之后,新增了keyword-only参数<br>keyword-only参数:在形参定义时,在一个</em>星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数<br>keyword-only参数,言下之意就是这个参数必须采取关键字传参<br>可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.<em>星号后所有的普通参数都成了keyword-only参数<br>参数的混合使用<br>参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数<br>代码应该易读易懂, 而不是为难别人<br>请按照书写习惯定义函数参数.<br>参数解构:<br>在给函数提供实参的时候,可以在可迭代对象前使用</em>或者<strong>来进行的解构,提取出其中所有元素作为函数的实参.<br>使用*解构成位置参数<br>使用</strong>解构成位置 传参<br>提取出来的元素数目要和参数的要求匹配</p><p>python函数使用return语句返回”返回值”<br>所有函数都有返回值,如果没有return语句, 隐式调用return None<br>return语句并不一定是函数的语句块的最后一条语句<br>一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None<br>如果有必要,可以显示调用return None ,可以简写return<br>如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行<br>返回值的作用: 结束函数调用,返回返回值<br>函数不能同时返回多个值.</p><h1 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h1><p>一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域<br>注意:每一个函数都会开辟一个作用域<br>分类:<br>全局作用域:<br>在整个程序运行环境中都可见<br>全局作用域中的变量称为全局变量<br>局部作用域:<br>在函数 ,类等内部可见<br>局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域<br>函数嵌套<br>在一个函数中定义了另一个函数<br>内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见</p><p>global语句<br>使用global关键字的变量,将声明为外部的全局作用域中定义的<br>使用了global 不再是局部变量,它是全局变量<br>global使用原则<br>外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离<br>如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决<br>一句话:不要global,学习他就是深入理解变量作用域</p><h1 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h1><p>自由变量:未在本地作用域中定义的变量<br>闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript</p><p>nonlocal语句<br>将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义<br>内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义<br>代码中内层函数引到外部局部作用域中的自由变量,形成闭包</p><p>函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联<br>python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期<br>查看<strong>default</strong>属性,他是个元组</p><h1 id="变量名解析原则LEGB"><a href="#变量名解析原则LEGB" class="headerlink" title="变量名解析原则LEGB***"></a>变量名解析原则LEGB***</h1><p>local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡<br>Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间<br>global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡<br>build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡<br>所以一个名词的查找顺序就是LEGB.</p><p>|</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;基本概念&quot;&gt;&lt;a href=&quot;#基本概念&quot; class=&quot;headerlink&quot; title=&quot;基本概念&quot;&gt;&lt;/a&gt;基本概念&lt;/h1&gt;&lt;p&gt;数学定义&lt;br&gt;y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)&lt;br&gt;python函数:&lt;br
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>python知识框架</title>
    <link href="https://hubhack.github.io/book/python%E7%9F%A5%E8%AF%86%E6%A1%86%E6%9E%B6/"/>
    <id>https://hubhack.github.io/book/python知识框架/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="python基础"><a href="#python基础" class="headerlink" title="python基础"></a>python基础</h1><p>python是一种动态的强类型语言,底层是用C语言开发的.</p><p>平台：*nix平台<br>系统：线程、进程、Shell编程<br>网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发<br>算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写<br>数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个<br>中间件：消息队列原理和应用，例如8曲bitMQ<br>WEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一<br>可视化：WEB的前端开发多一些HTML、jS要会<br>数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用</p><p>python学习路线:<br>基础：操作系统、网络基础、数据库基础、python语言基础..<br>进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..<br>高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).<br>新前端开发(ES6、React、Antd）…<br>实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..<br>高端：数据清洗、企业数据分析、预测准荐、机器视觉．</p><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><p>python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none</p><h3 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p><p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p><p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p><p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p><p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p><p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p><p>字母A用ASCII编码是十进制的65，二进制的01000001；</p><p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p><p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p><p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p><p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p><p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.</p><h3 id="字符串的格式化"><a href="#字符串的格式化" class="headerlink" title="字符串的格式化"></a>字符串的格式化</h3><p>format函数或 格式符</p><h3 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h3><p>字符串与bytes<br>字符串是字符组成的有序序列，字符可以使用编码来理解<br>bytes是字节组成的有序的不可变序列<br>bytearray是字节组成的有序的可变序列</p><p>编码与解码：<br>字符串按照不同的字符集编码encode返回字节序列bytes<br>encode（encoding=‘utf-8’，errors=‘strict’）<br>字节序列按照不同的字符集解码decode返回字符串<br>bytes.decode（encoding=“utf-8”，errors=“strict”）<br>ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统</p><p>要熟记31 41 61 的ascii表</p><p>字节序：<br>大端模式，big-endian；小端模式，little-endian<br>intel x86cpu使用小端 模式<br>网络传输更多使用大端模式<br>windows，linux 使用小端模式<br>mac os使用大端模式<br>java 虚拟机是大端模式</p><h2 id="数字"><a href="#数字" class="headerlink" title="数字"></a>数字</h2><p>有整数 浮点数 复数等</p><h2 id="true-false"><a href="#true-false" class="headerlink" title="true false"></a>true false</h2><p>主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。</p><p>None：Python里面特殊的空值，不能理解为0。</p><h2 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h2><p>list（列表） tuple（元组） set（集合） dictionary（字典）<br>这些都是可以迭代的</p><h3 id="list"><a href="#list" class="headerlink" title="list"></a>list</h3><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。</p><h3 id="tuple"><a href="#tuple" class="headerlink" title="tuple"></a>tuple</h3><p>元组和列表类似，但是不同的是元组不能修改，元组使用小括号。</p><h3 id="dict"><a href="#dict" class="headerlink" title="dict"></a>dict</h3><h2 id="判断结构"><a href="#判断结构" class="headerlink" title="判断结构"></a>判断结构</h2><h3 id="if"><a href="#if" class="headerlink" title="if"></a>if</h3><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p><p>elif 语句</p><p>elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。</p><p>if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。</p><h3 id="for"><a href="#for" class="headerlink" title="for"></a>for</h3><p>for循环可以遍历任何序列的项目：</p><h3 id="while"><a href="#while" class="headerlink" title="while"></a>while</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环：</p><p>break和continue语句：</p><p>break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。</p><p>continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;python基础&quot;&gt;&lt;a href=&quot;#python基础&quot; class=&quot;headerlink&quot; title=&quot;python基础&quot;&gt;&lt;/a&gt;python基础&lt;/h1&gt;&lt;p&gt;python是一种动态的强类型语言,底层是用C语言开发的.&lt;/p&gt;
&lt;p&gt;平台：*
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>二分法</title>
    <link href="https://hubhack.github.io/book/%E4%BA%8C%E5%88%86%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/二分法/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>练习</p><p>有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。<br>分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。<br>思路<br>排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。<br>查找插入点，使用二分查找完成。<br>假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。<br>直到中点就是</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(orderlist, i)</span>:</span>    </span><br><span class="line">    ret = orderlist[:]    </span><br><span class="line">    low = <span class="number">0</span>    </span><br><span class="line">    high = len(ret) - <span class="number">1</span>    </span><br><span class="line">    <span class="keyword">while</span> low &lt; high: </span><br><span class="line">        mid = (low + high) // <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> ret[mid] &lt; i: </span><br><span class="line">            low = mid + <span class="number">1</span> </span><br><span class="line">            <span class="comment"># 说明i大，往右找，调整下限 else: high = mid </span></span><br><span class="line">            <span class="comment"># 说明i小于等于，往左找，调整上限    </span></span><br><span class="line">            print(low, i) </span><br><span class="line">            <span class="comment"># low为插入点    </span></span><br><span class="line">            ret.insert(low, i)    </span><br><span class="line">            <span class="keyword">return</span> ret</span><br><span class="line"><span class="comment"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class="line">newlst = sorted(lst) </span><br><span class="line"><span class="comment"># 升序 </span></span><br><span class="line">print(newlst) <span class="comment">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">40</span>, <span class="number">20</span>, <span class="number">41</span>):    </span><br><span class="line">    newlst = insert_sort(newlst, x)    </span><br><span class="line">    print(newlst)</span><br></pre></td></tr></table></figure><p>看似上面代码不错，请测试插入100。<br>问题来了，100插入的位置不对，为什么？</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">insert_sort</span><span class="params">(orderlist, i)</span>:</span>    </span><br><span class="line">    ret = orderlist[:]    </span><br><span class="line">    low = <span class="number">0</span>    </span><br><span class="line">    high = len(ret) <span class="comment"># 去掉减1    </span></span><br><span class="line">    <span class="keyword">while</span> low &lt; high: </span><br><span class="line">        mid = (low + high) // <span class="number">2</span> </span><br><span class="line">        <span class="keyword">if</span> ret[mid] &lt; i: </span><br><span class="line">            low = mid + <span class="number">1</span> <span class="comment"># 说明i大，往右找，调整下限 </span></span><br><span class="line">            <span class="keyword">else</span>:</span><br><span class="line">                high = mid <span class="comment"># 说明i小于等于，往左找，调整上限    </span></span><br><span class="line">     print(low, i) <span class="comment"># low为插入点    </span></span><br><span class="line">     ret.insert(low, i)    </span><br><span class="line">     <span class="keyword">return</span> ret</span><br><span class="line"> </span><br><span class="line"><span class="comment"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class="line"> </span><br><span class="line">newlst = sorted(lst) <span class="comment"># 升序</span></span><br><span class="line">print(newlst) <span class="comment">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">40</span>, <span class="number">20</span>, <span class="number">41</span>, <span class="number">100</span>):    </span><br><span class="line">    newlst = insert_sort(newlst, x)    </span><br><span class="line">    print(newlst)</span><br></pre></td></tr></table></figure><p> high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。<br>如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。</p><h3 id="二分"><a href="#二分" class="headerlink" title="二分"></a>二分</h3><p>二分前提是有序，否则不可以二分。<br>二分查找算法的时间复杂度O(log n)</p><h3 id="bisect模块"><a href="#bisect模块" class="headerlink" title="bisect模块"></a>bisect模块</h3><p>bisect模块提供的函数有：</p><ul><li>bisect.bisect_left(a,x, lo=0, hi=len(a))<br>查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。</li><li>bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))<br>在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。</li><li>bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。<br>函数可以分2类： bisect系，用于查找index。<br>Insort系，用于实际插入。默认重复时从右边插入。</li></ul><p>应用<br>判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> bisect</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_grade</span><span class="params">(score)</span>:</span>    </span><br><span class="line">    breakpoints = [<span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>]    </span><br><span class="line">    grades = <span class="string">'EDCBA'</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">return</span> grades[bisect.bisect(breakpoints, score)]</span><br><span class="line"> </span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> (<span class="number">91</span>, <span class="number">82</span>, <span class="number">77</span>, <span class="number">65</span>, <span class="number">50</span>, <span class="number">60</span>, <span class="number">70</span>, <span class="number">80</span>, <span class="number">90</span>):    </span><br><span class="line">    print(<span class="string">'&#123;&#125; =&gt; &#123;&#125;'</span>.format(x, get_grade(x)))</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;练习&lt;/p&gt;
&lt;p&gt;有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。&lt;br&gt;分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。&lt;br&gt;思路&lt;br&gt;排序后二分查找到适当位置插入数值。排序使用
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>web路由</title>
    <link href="https://hubhack.github.io/book/web%E8%B7%AF%E7%94%B1/"/>
    <id>https://hubhack.github.io/book/web路由/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>web开发中路由route和路由器router到底是什么</p><h3 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h3><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p><h3 id="2-router和route的区别"><a href="#2-router和route的区别" class="headerlink" title="2. router和route的区别"></a>2. router和route的区别</h3><p>route就是一条路由，它将一个URL路径和一个函数进行映射，例如：</p><blockquote><p>/users -&gt; getAllUsers()</p><p>/users/count -&gt; getUsersCount()</p></blockquote><p>这就是两条路由，当访问<code>/users</code>的时候，会执行<code>getAllUsers()</code>函数；当访问<code>/users/count</code>的时候，会执行<code>getUsersCount()</code>函数。</p><p>而router可以理解为一个容器，或者说一种机制，它管理了一组<code>route</code>。简单来说，<code>route</code>只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由<code>router</code>来处理的。一句话概括就是 “The router routes you to a route”。</p><h3 id="3-服务器端路由"><a href="#3-服务器端路由" class="headerlink" title="3. 服务器端路由"></a>3. 服务器端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。</p><p>以Express为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(&apos;index&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&apos;/users&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  db.queryAllUsers()</span><br><span class="line">    .then(data =&gt; res.send(data))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里定义了两条路由：</p><ul><li>当访问/的时候，会返回index页面</li><li>当访问/users的时候，会从数据库中取出所有用户数据并返回</li></ul><blockquote><p>不仅仅是URL</p><p>在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。</p></blockquote><h3 id="4-客户端路由"><a href="#4-客户端路由" class="headerlink" title="4. 客户端路由"></a>4. 客户端路由</h3><p>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：</p><ul><li>基于Hash</li><li>基于History API</li></ul><h4 id="1-基于Hash"><a href="#1-基于Hash" class="headerlink" title="(1) 基于Hash"></a>(1) 基于Hash</h4><p>我们知道，URL中#及其后面的部分为hash。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line">var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)</span><br><span class="line">console.log(a.hash)</span><br><span class="line">// =&gt; #/foo/bar</span><br></pre></td></tr></table></figure><p>hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。</p><p>通过监听window对象的hashChange事件，可以实现简单的路由。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function() &#123;</span><br><span class="line">  var hash = window.location.hash</span><br><span class="line">  var path = hash.substring(1)</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-基于History-API"><a href="#2-基于History-API" class="headerlink" title="(2) 基于History API"></a>(2) 基于History API</h4><p>通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考：</p><p>Manipulating the browser history<br>Using the HTML5 History API<br>我们可以通过监听window对象的popstate事件，来实现简单的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = function() &#123;</span><br><span class="line">  var path = window.location.pathname</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pushState = history.pushState</span><br><span class="line">history.pushState = function() &#123;</span><br><span class="line">  pushState.apply(history, arguments)</span><br><span class="line"></span><br><span class="line">  // emit a event or just run a callback</span><br><span class="line">  emitEventOrRunCallback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，最好的方法还是使用实现好的history库。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="(3) 两种实现的比较"></a>(3) 两种实现的比较</h4><p>总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。</p><p>但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。</p><p>假设服务器只有如下文件（script.js被index.html所引用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line"> |- index.html</span><br><span class="line"> |- script.js</span><br></pre></td></tr></table></figure><p>基于Hash的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/#/foobar</span><br></pre></td></tr></table></figure><p>基于History API的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/foobar</span><br></pre></td></tr></table></figure><p>当直接访问<code>http://example.com/</code>的时候，两者的行为是一致的，都是返回了<code>index.html</code>文件。</p><p>当从<code>http://example.com/</code>跳转到<code>http://example.com/#/foobar</code>或者<code>http://example.com/foobar</code>的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。</p><p>当直接访问<code>http://example.com/#/foobar</code>的时候，实际上向服务器发起的请求是<code>http://example.com/</code>，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。</p><p>当直接访问<code>http://example.com/foobar</code>的时候，实际上向服务器发起的请求也是<code>http://example.com/foobar</code>，然而服务器端只能匹配<code>/</code>而无法匹配<code>/foobar</code>，因此会出现404错误。</p><p>因此如果使用了基于History API的路由，需要改造服务器端，使得访问<code>/foobar</code>的时候也能返回<code>index.html</code>文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。</p><h4 id="5-动态路由"><a href="#5-动态路由" class="headerlink" title="5. 动态路由"></a>5. 动态路由</h4><p>上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。</p><p>例如在Express中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">  // ... ...</span><br><span class="line">&#125;)</span><br><span class="line">在Flask中：</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/user/&lt;user_id&gt;&apos;)</span><br><span class="line">def get_user_info(user_id):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h4 id="6-严格路由"><a href="#6-严格路由" class="headerlink" title="6. 严格路由"></a>6. 严格路由</h4><p>在很多情况下，会遇到<code>/foobar</code>和<code>/foobar/</code>的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。</p><p>在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到<code>/foobar/</code>，而反过来则不会。</p><p>如果使用的是<code>Express</code>，默认这两者是一样的，也可以通过<code>app.set</code>来设置<code>strict routing</code>，来区别对待这两种情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web开发中路由route和路由器router到底是什么&lt;/p&gt;
&lt;h3 id=&quot;1-什么是路由&quot;&gt;&lt;a href=&quot;#1-什么是路由&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是路由&quot;&gt;&lt;/a&gt;1. 什么是路由&lt;/h3&gt;&lt;p&gt;在Web开发过程中，经常
      
    
    </summary>
    
      <category term="web" scheme="https://hubhack.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://hubhack.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>python面试题</title>
    <link href="https://hubhack.github.io/book/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hubhack.github.io/book/python面试题/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>重点知识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重点知识&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>处理异常</title>
    <link href="https://hubhack.github.io/book/%E5%A4%84%E7%90%86%E5%BC%82%E5%B8%B8/"/>
    <id>https://hubhack.github.io/book/处理异常/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<h2 id="异常处理-Exception"><a href="#异常处理-Exception" class="headerlink" title="异常处理(Exception)"></a>异常处理(Exception)</h2><h4 id="错误Error"><a href="#错误Error" class="headerlink" title="错误Error"></a>错误Error</h4><p>逻辑错误:算法写错了, 例如加法写成了减法</p><p>笔误:例如变量名写错了,语法错误</p><p>函数或类使用错误, 其实这也属于逻辑错误</p><p>总之,错误是可以避免的</p><h4 id="异常Eception"><a href="#异常Eception" class="headerlink" title="异常Eception"></a>异常Eception</h4><p>本意就是意外情况</p><p>这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.</p><p>例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.</p><h4 id="错误和异常"><a href="#错误和异常" class="headerlink" title="错误和异常"></a>错误和异常</h4><p>在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'tetsabcd'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"><span class="comment"># 异常</span></span><br></pre></td></tr></table></figure><h2 id="产生异常"><a href="#产生异常" class="headerlink" title="产生异常"></a>产生异常</h2><p>产生:</p><ul><li>raise语句显示的抛出异常</li><li>Python解释器自己检测异常并引发它<br>程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)</li></ul><h2 id="异常的捕获"><a href="#异常的捕获" class="headerlink" title="异常的捕获"></a>异常的捕获</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    待捕获异常的代码块</span><br><span class="line"><span class="keyword">except</span> [异常类型]</span><br><span class="line">异常的处理代码块</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;异常处理-Exception&quot;&gt;&lt;a href=&quot;#异常处理-Exception&quot; class=&quot;headerlink&quot; title=&quot;异常处理(Exception)&quot;&gt;&lt;/a&gt;异常处理(Exception)&lt;/h2&gt;&lt;h4 id=&quot;错误Error&quot;&gt;&lt;a hre
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法</title>
    <link href="https://hubhack.github.io/book/%E6%96%B9%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/方法/</id>
    <published>2019-08-22T04:48:52.414Z</published>
    <updated>2019-08-22T04:48:52.414Z</updated>
    
    <content type="html"><![CDATA[<p>魔术方法</p><table><thead><tr><th>类别</th><th>方法名</th></tr></thead><tbody><tr><td>可视化</td><td>__str__, __repr__, __format__, __bytes__</td></tr><tr><td>数值转换</td><td>__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__</td></tr><tr><td>容器模拟</td><td>__len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__</td></tr><tr><td>迭代枚举</td><td>__iter__, __reversed__, __next__</td></tr><tr><td>可调用模拟</td><td>__call__</td></tr><tr><td>上下文管理</td><td>__enter__, __exit__</td></tr><tr><td>实例创建和销毁</td><td>__new__, __init__, __del__</td></tr><tr><td>属性管理(反射)</td><td>__dir__, __getattr__, __setattr__, __delattr__, __getattribute__</td></tr><tr><td>属性描述符(描述器)</td><td>__get__, __set__, __delete__</td></tr><tr><td>特殊属性</td><td>__name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__</td></tr><tr><td>比较运算符</td><td>__eq__,__lt__, __le__, __gt__, __ge__, __ne__</td></tr><tr><td>算数运算符</td><td>__add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__</td></tr><tr><td>增量运算符</td><td>__iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__</td></tr><tr><td>反向运算符</td><td>__radd__, __rsub__</td></tr><tr><td>其他</td><td>__slots__</td></tr></tbody></table><p>内置函数</p><table><thead><tr><th>内置函数名</th><th>方法名</th></tr></thead><tbody><tr><td>数学运算</td><td>abs, divmod,max,min,pow, round, sum</td></tr><tr><td>类型转换</td><td>bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex</td></tr><tr><td>序列操作</td><td>all, any, filter, map,next,reversed, sorted, zip</td></tr><tr><td>对象操作</td><td>help,dir,id,hash, type,len, ascii,format, vars,</td></tr><tr><td>反射操作</td><td>__import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable</td></tr><tr><td>变量操作</td><td>globals, locals,</td></tr><tr><td>交互操作</td><td>print,input</td></tr><tr><td>文件操作</td><td>open</td></tr><tr><td>编译执行</td><td>compile, eval,exec, repr</td></tr><tr><td>装饰器</td><td>property,classmethod, staticmethod,</td></tr><tr><td>数据结构</td><td>tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object</td></tr></tbody></table><p>标识符:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="literal">False</span>      <span class="keyword">await</span>      <span class="keyword">else</span>       <span class="keyword">import</span>     <span class="keyword">pass</span></span><br><span class="line"><span class="literal">None</span>       <span class="keyword">break</span>      <span class="keyword">except</span>     <span class="keyword">in</span>         <span class="keyword">raise</span></span><br><span class="line"><span class="literal">True</span>       <span class="class"><span class="keyword">class</span>      <span class="title">finally</span>    <span class="title">is</span>         <span class="title">return</span></span></span><br><span class="line"><span class="class"><span class="title">and</span>        <span class="title">continue</span>   <span class="title">for</span>        <span class="title">lambda</span>     <span class="title">try</span></span></span><br><span class="line"><span class="class"><span class="title">as</span>         <span class="title">def</span>        <span class="title">from</span>       <span class="title">nonlocal</span>   <span class="title">while</span></span></span><br><span class="line"><span class="class"><span class="title">assert</span>     <span class="title">del</span>        <span class="title">global</span>     <span class="title">not</span>        <span class="title">with</span></span></span><br><span class="line"><span class="class"><span class="title">async</span>      <span class="title">elif</span>       <span class="title">if</span>         <span class="title">or</span>         <span class="title">yield</span></span></span><br></pre></td></tr></table></figure><p>模块常用方法</p><table><thead><tr><th>内置模块</th><th>方法名</th></tr></thead><tbody><tr><td>re</td><td>compile, search, match, fullmatch,split,findall, sub,</td></tr><tr><td>string</td><td>ascii_letters,ascii_lowercase.digits</td></tr><tr><td>datetime</td><td>datetime</td></tr><tr><td>collections</td><td>nametuple, deque, OrderdDict, defaultdict,</td></tr><tr><td>bisect</td><td>bisect_left,bisect_right,</td></tr><tr><td>math</td><td>ceil</td></tr><tr><td>random</td><td>randint, choice, randrange,shuffle, sample</td></tr><tr><td>functools</td><td>reduce, partial,lru_cache</td></tr><tr><td>pathlib</td><td></td></tr><tr><td>os</td><td></td></tr><tr><td>shutil</td><td>copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move,</td></tr><tr><td>pickle</td><td></td></tr><tr><td>csv</td><td>reader</td></tr><tr><td>time</td><td></td></tr><tr><td>threading</td><td></td></tr><tr><td>queue</td><td></td></tr><tr><td>json</td><td></td></tr><tr><td>base64</td><td></td></tr><tr><td>sys</td><td></td></tr><tr><td>inspect</td><td>signature(callable)获取签名,</td></tr><tr><td>ConfigParser</td><td></td></tr><tr><td>argparse</td><td></td></tr><tr><td>heapq</td><td>hea</td></tr></tbody></table>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;魔术方法&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;类别&lt;/th&gt;
&lt;th&gt;方法名&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;可视化&lt;/td&gt;
&lt;td&gt;__str__, __repr__, __format__, __byte
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
</feed>
