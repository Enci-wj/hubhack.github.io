<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>千分无言</title>
  
  <subtitle>人生苦短 我用python</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://hubhack.github.io/"/>
  <updated>2019-08-22T01:21:59.720Z</updated>
  <id>https://hubhack.github.io/</id>
  
  <author>
    <name>mwq</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>python面试题</title>
    <link href="https://hubhack.github.io/book/python%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
    <id>https://hubhack.github.io/book/python面试题/</id>
    <published>2019-08-22T01:21:59.718Z</published>
    <updated>2019-08-22T01:21:59.720Z</updated>
    
    <content type="html"><![CDATA[<p>重点知识</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;重点知识&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hubhack.github.io/book/git%E4%BD%BF%E7%94%A8/"/>
    <id>https://hubhack.github.io/book/git使用/</id>
    <published>2019-08-21T08:05:47.951Z</published>
    <updated>2019-08-21T08:05:47.955Z</updated>
    
    <content type="html"><![CDATA[<p>变基rebase</p><p>rebase, 有垫底的意思, git rebase我们称它为git变基, 即在当前分支外另一结点重新应用当前分支的提交历史, 变基是git整合变更的一种方式, 另一中方式是合并(merge).</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;变基rebase&lt;/p&gt;
&lt;p&gt;rebase, 有垫底的意思, git rebase我们称它为git变基, 即在当前分支外另一结点重新应用当前分支的提交历史, 变基是git整合变更的一种方式, 另一中方式是合并(merge).&lt;/p&gt;

      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hubhack.github.io/book/flask%E7%AC%94%E8%AE%B0/"/>
    <id>https://hubhack.github.io/book/flask笔记/</id>
    <published>2019-08-21T02:50:07.733Z</published>
    <updated>2019-08-22T02:47:21.724Z</updated>
    
    <content type="html"><![CDATA[<hr><p>title: flask</p><p>categories: </p><ul><li>框架<br>tags:</li><li>python</li></ul><p>—下载示例代码, 安装到当前目录的flasky文件夹下.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/miguelgrinberg/flasky.git</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">git checkout 1a</span><br><span class="line">git reset --hard</span><br><span class="line">git fetch --all</span><br><span class="line">git fetch --tags</span><br><span class="line">git reset --hard orign/master</span><br><span class="line">git diff 2a 2b</span><br></pre></td></tr></table></figure><h3 id="flask"><a href="#flask" class="headerlink" title="flask"></a>flask</h3><p>在大多数标准中, flask都算小型框架, 小到可以称为”微框架”.它具有一个包含接班服务的强健核心, 其他功能则可通过扩展实现.</p><p>flask有3个主要依赖: 路由,调试, web服务网关接口(wsgi)子系统由werkzeug提供, 模板系统由jinja2提供, 命令行集成有click提供.</p><p>创建应用目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git clone https://github.com/miguelgrinberg/flasky.git</span><br><span class="line">cd flasky</span><br></pre></td></tr></table></figure><p>初始化</p><p>所有的Flask应用都必须创建一个应用实例.web服务器使用一种名为web服务器网关接口(wsgi)的协议.把接收自客户端的所有请求都转交给这个对象处理.应用实例是Flask类的对象.通常有下列代码创建.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from flask import Flask</span><br><span class="line">app = Flask(__name__)</span><br></pre></td></tr></table></figure><hr><p>在flask中有两种上下文: 应用上下文和请求上下文.</p><p>钩子函数:有时在处理请求之前或之后执行代码会很有用.</p><p>before_request</p><p>注册一个函数, 在每次请求之前运行</p><p>before_first_request</p><p>注册一个函数, 只在处理第一个请求之前运行,可以通过这个钩子函数添加服务器初始化任务.</p><p>after_request注册一个函数, 如果没有未处理的异常抛出, 在每次请求之后运行.</p><p>teardown_request</p><p>注册一个函数, 即使有未处理的异常抛出, 也在每次请求之后运行.</p><p>在请求钩子函数和视图函数之间共享数据一般使用上下文全局变量g, </p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;p&gt;title: flask&lt;/p&gt;
&lt;p&gt;categories: &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;框架&lt;br&gt;tags:&lt;/li&gt;
&lt;li&gt;python&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;—下载示例代码, 安装到当前目录的flasky文件夹下.&lt;/p&gt;
&lt;figure cla
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>ansible</title>
    <link href="https://hubhack.github.io/book/andible/"/>
    <id>https://hubhack.github.io/book/andible/</id>
    <published>2019-08-19T07:41:55.554Z</published>
    <updated>2019-08-19T07:48:39.676Z</updated>
    
    <content type="html"><![CDATA[<p>ansible简介<br>安装ansible<br>yun install -y ansible</p><h2 id="todo"><a href="#todo" class="headerlink" title="todo"></a>todo</h2><p>ansible 文档<a href="https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#foreword" target="_blank" rel="noopener">https://docs.ansible.com/ansible/latest/user_guide/intro_getting_started.html#foreword</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;ansible简介&lt;br&gt;安装ansible&lt;br&gt;yun install -y ansible&lt;/p&gt;
&lt;h2 id=&quot;todo&quot;&gt;&lt;a href=&quot;#todo&quot; class=&quot;headerlink&quot; title=&quot;todo&quot;&gt;&lt;/a&gt;todo&lt;/h2&gt;&lt;p&gt;ansibl
      
    
    </summary>
    
      <category term="ansible" scheme="https://hubhack.github.io/categories/ansible/"/>
    
    
      <category term="运维" scheme="https://hubhack.github.io/tags/%E8%BF%90%E7%BB%B4/"/>
    
  </entry>
  
  <entry>
    <title>数据分析</title>
    <link href="https://hubhack.github.io/book/Pandas%E8%AF%A6%E8%A7%A3/"/>
    <id>https://hubhack.github.io/book/Pandas详解/</id>
    <published>2019-08-04T02:38:10.309Z</published>
    <updated>2019-08-19T03:15:02.408Z</updated>
    
    <content type="html"><![CDATA[<p>Pandas:最流行的Python数据分析库</p><p>基于Numpy, 专用于数据预处理和数据分析的Python第三方库, 最适合处理大型结构化表格数据.</p><p>Pandas两大数据类型</p><ul><li>Series: 一维</li><li>DataFrame: 二维</li></ul><p>Series数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a = pd.Series([3, 4, 5, 6, 7])</span><br><span class="line">a</span><br></pre></td></tr></table></figure><p>DataFrame数据类型</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">b = pd.DataFrame([3, 4, 5], [6, ,7, 8], [9, 10, 11])</span><br><span class="line">b</span><br></pre></td></tr></table></figure><p>抽象和维度</p><p>维度: 观察事物的角度</p><p>日常保存数据的数据格式:</p><ul><li>0维: 字符串, 单值变量</li><li>1维: 列表, 字典(1成括号)</li><li>2维: Excel表格, Mysql数据库</li><li>3维或以上: JSON, MongoDB, HTML</li></ul><p>Pandas各个数据类型的关系：</p><blockquote><p>0维单值变量 -&gt; 1维Series -&gt; 2维DataFrame -&gt; 3维层次化DataFrame</p></blockquote><h3 id="Series"><a href="#Series" class="headerlink" title="Series"></a>Series</h3><p>列表创建Series</p><blockquote><p> a = pd.Series([2, 3, 5])</p></blockquote><p>字典创建Series</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 索引就是字典字典的键</span><br><span class="line">d = pd.Series(&#123;&apos;name&apos;: &apos;张三&apos;, &apos;age&apos;: 18, &apos;gander&apos;:True&#125;)</span><br><span class="line">d</span><br></pre></td></tr></table></figure><p>其他方式</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 标量创建</span><br><span class="line">pd.Series(5)</span><br><span class="line">pd.Series(5, index=[1,2, 3, 4, 5])</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Numpy的序列函数创建</span></span><br><span class="line"></span><br><span class="line">np.arange(<span class="number">5</span>)</span><br><span class="line">np.arange(<span class="number">2</span>, <span class="number">5</span>)</span><br><span class="line">np.arange(<span class="number">9</span>, <span class="number">5</span>, <span class="number">-1</span>)</span><br></pre></td></tr></table></figure><p>查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class1 = pd.Series([95, 25, 59, 61], index=[&apos;ming&apos;, &apos;hua&apos;, &apos;hong&apos;,&apos;huang&apos;, &apos;bai&apos;])</span><br></pre></td></tr></table></figure><p>查询数据形状</p><p>1维数据的形状就是它的值个数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">class1.shape, class1.shape[0]</span><br></pre></td></tr></table></figure><p>查询值(values) 和索引(index)</p><p>一个Series数据是由2个ndarray数组组成的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 查询值</span><br><span class="line">class1.values</span><br></pre></td></tr></table></figure><p>查询值</p><p>根据索引查询值</p><ul><li>索引查询</li><li>切片插叙</li></ul><p>根据条件反查索引</p><ul><li>布尔查询</li></ul><p>索引查询</p><p>索引和切片都是根据索引查询值</p><p>class1</p><p>查询单值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># Series有两套索引：默认索引，自定义索引</span><br><span class="line">class1[&apos;hong&apos;]  # 自定义索引</span><br><span class="line">class1[2]  # 默认索引</span><br></pre></td></tr></table></figure><p>查询多值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">class1[[&apos;hua&apos;, &apos;bai&apos;]]</span><br><span class="line">class1[[1, 4]]</span><br></pre></td></tr></table></figure><p>切片查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># 默认索引：包含起始值，不包含结束值</span><br><span class="line">class1[:3]  </span><br><span class="line">class1[2:]</span><br><span class="line">class1[1:4]</span><br></pre></td></tr></table></figure><p>布尔查询</p><p>根据值反查索引</p><p>根据条件反查索引</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔查询</span></span><br><span class="line">class1[[<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>]]</span><br></pre></td></tr></table></figure><h3 id="向量化运算"><a href="#向量化运算" class="headerlink" title="向量化运算"></a>向量化运算</h3><p>矢量运算, 并行运算</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a = pd.Series(x)</span><br><span class="line">a</span><br><span class="line">a + <span class="number">5</span> <span class="comment"># 向量化运算, 不需要遍历, 速度快效率高</span></span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Pandas向量化方式</span></span><br><span class="line">a.sum()  <span class="comment"># Pandas方法</span></span><br><span class="line">np.sum(class1)  <span class="comment"># Numpy方法</span></span><br></pre></td></tr></table></figure><h3 id="类Numpy数组操作-和类Python字典的操作"><a href="#类Numpy数组操作-和类Python字典的操作" class="headerlink" title="类Numpy数组操作, 和类Python字典的操作"></a>类Numpy数组操作, 和类Python字典的操作</h3><ul><li>Pandas数据可以执行全部Numpy数据操作(因为Pandas底层基于Numpy, 所以通用)</li><li>也可以执行部分Python原生列表或字典操作(仅限于Pandas实现的操作)</li></ul><p>类Numpy数组操作</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">np.mean(class1) # Numpy方法</span><br></pre></td></tr></table></figure><p>类Python字典操作</p><ul><li>in关键字: 判断某索引是否存在</li><li>get方法:判断某索引是否存在, 存在则直接输出值, 不存在则输出定义值</li></ul><h3 id="DataFrame对象-创建"><a href="#DataFrame对象-创建" class="headerlink" title="DataFrame对象 - 创建"></a>DataFrame对象 - 创建</h3><p>DataFrame对象是Pandas最常用的数据类型</p><p>DataFrame对象是由多个Series增加一个索引后组成一种表格类型数据结构</p><p>DataFrame对象既有行索引, 又有列索引</p><ul><li>行索引,表明不同行, 横向索引, 叫index, 0轴, axis=0</li><li>列索引, 表名不同列, 纵向索引, 叫colums, 1轴, axis=1</li></ul><hr><p>列表创建</p><ul><li><p>ndarry数组创建</p></li><li><p>字典内嵌套列表：要求内部列表等长</p></li><li>字典内嵌套字典：内部字典不需要等长<ul><li>字典内嵌套Series：等同嵌套字典</li></ul></li></ul><p>列表创建</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 默认索引</span><br><span class="line">pd.DataFrame([[1,2,3],[4,5,6],[7,8,9]])</span><br></pre></td></tr></table></figure><p>使用Numpy数组创建</p><p>Numpy数组类似一个高级版的Python列表</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.arange(10)</span><br><span class="line"></span><br><span class="line">np.arange(10).reshape(2, 5)</span><br></pre></td></tr></table></figure><p>字典创建</p><p>字典内嵌套列表</p><p>列表值需要等长, 否则报错</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'姓名'</span>: [<span class="string">'张三'</span>, <span class="string">'李四'</span>, <span class="string">'王五'</span>],</span><br><span class="line">        <span class="string">'年龄'</span>: [<span class="number">18</span>, <span class="number">28</span>, <span class="number">38</span>],</span><br><span class="line">        <span class="string">'性别'</span>: [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>],</span><br><span class="line">        <span class="string">'分数'</span>: [<span class="number">85.5</span>, <span class="number">59</span>, <span class="number">78</span>],</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br></pre></td></tr></table></figure><h3 id="字典嵌套字典"><a href="#字典嵌套字典" class="headerlink" title="字典嵌套字典"></a>字典嵌套字典</h3><p>字典不要求等长</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">pd.DataFrame(</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">'name'</span>: &#123;<span class="number">1</span>: <span class="string">'张三'</span>, <span class="number">2</span>: <span class="string">'李四'</span>, <span class="number">3</span>: <span class="string">'王五'</span>&#125;,</span><br><span class="line">        <span class="string">'age'</span>: &#123;<span class="number">1</span>: <span class="number">18</span>, <span class="number">2</span>: <span class="number">28</span>, <span class="number">3</span>: <span class="number">38</span>&#125;,</span><br><span class="line">        <span class="string">'gender'</span>: &#123;<span class="number">1</span>: <span class="literal">True</span>, <span class="number">2</span>: <span class="literal">True</span>, <span class="number">3</span>: <span class="literal">False</span>&#125;,</span><br><span class="line">        <span class="string">'grade'</span>: &#123;<span class="number">1</span>: <span class="number">85.5</span>, <span class="number">3</span>: <span class="number">78</span>&#125;,  <span class="comment"># 不等长也不报错</span></span><br><span class="line">    &#125;,</span><br><span class="line">)</span><br></pre></td></tr></table></figure><p>DataFrame整体查询</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">a.shape  # 表格形状，行数 列数</span><br><span class="line">a.dtypes  # 列数据类型</span><br><span class="line"></span><br><span class="line">a.index  # 行索引</span><br><span class="line">a.columns  # 列索引</span><br><span class="line">a.values  # 对象值，二维ndarray数组</span><br></pre></td></tr></table></figure><p>整体数据情况</p><ul><li>a.info()整体信息, 查看:数据是否异常<ul><li>有没有缺失值</li><li>列数据类型是否正确</li></ul></li><li>a.describe()整体统计指标</li><li>a.head() 前5行</li><li>a.tail() 后5行</li></ul><p>内容查询</p><p>类列表/字典/ndarray数组的查询方式</p><p>功能简陋, 一般仅用于查询单列</p><p><strong>Pandas专用查询方式</strong>：经过优化，推荐</p><p>三种查询方式：</p><ul><li>索引</li><li>切片</li><li>过滤</li></ul><p><strong>索引和切片查询，两种查询方式：</strong></p><ul><li>a.loc[行,列]，标签索引，自定义索引</li><li>a.iloc[行,列]，位置索引，默认索引</li></ul><p>参数书写顺序都是都是先行后列</p><h2 id="索引查询"><a href="#索引查询" class="headerlink" title="索引查询"></a>索引查询</h2><p>用于不连续(行列有间隔)行列区块查询</p><p>查询单行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 自定义索引查询</span></span><br><span class="line">a.loc[<span class="number">3</span>]  <span class="comment"># 简写</span></span><br><span class="line">a.loc[<span class="number">3</span>, :]  <span class="comment"># 完整写法</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 默认索引</span></span><br><span class="line">a.iloc[<span class="number">2</span>]</span><br><span class="line">a.iloc[<span class="number">2</span>, :]</span><br></pre></td></tr></table></figure><p>查询多行</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">a.loc[[<span class="number">2</span>, <span class="number">4</span>]]  <span class="comment"># 选中所有列，省略了列条件</span></span><br><span class="line">a.loc[[<span class="number">2</span>, <span class="number">4</span>], :]  <span class="comment"># 完整写法</span></span><br><span class="line"></span><br><span class="line">a.iloc[[<span class="number">1</span>, <span class="number">3</span>]]</span><br></pre></td></tr></table></figure><h2 id="索引查询和切片查询的区别"><a href="#索引查询和切片查询的区别" class="headerlink" title="索引查询和切片查询的区别"></a>索引查询和切片查询的区别</h2><ul><li>索引查询更适合查询不连续的行列数据</li><li>切片查询适合查询连续行和列数据</li></ul><p>索引查询可以实现切片查询的所有功能，只是有个书写效率问题</p><ul><li>用索引查询查连续数据，需要将每个索引都写上，效率低</li><li>切片查询连续数据，只要写起始和结束索引即可。<ul><li>切片不能查询不连续数据</li></ul></li></ul><blockquote><p>查询时：优先使用切片查询，无法实现功能时再使用索引查询</p></blockquote><h3 id="专用查询：过滤查询"><a href="#专用查询：过滤查询" class="headerlink" title="专用查询：过滤查询"></a>专用查询：过滤查询</h3><p>索引查询和切片查询, 都是通过索引查询值</p><p>过滤查询(布尔查询) : 通过值查询索引</p><ul><li>过滤查询不通过索引, 而是通过值查询</li><li>用于结果索引不确定的查询</li><li>通过运算所得布尔值对查询结果进行过滤</li></ul><p>类list/字典查询方式</p><p>专用查询方式的布尔查询</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 布尔查询</span></span><br><span class="line">a.loc[[<span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>], [<span class="literal">True</span>, <span class="literal">True</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">False</span>, <span class="literal">True</span>, <span class="literal">False</span>]]</span><br></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查询不及格同学的姓名、年龄和成绩</span></span><br><span class="line">a.loc[a[<span class="string">'grade'</span>] &lt; <span class="number">60</span>, [<span class="string">'name'</span>, <span class="string">'age'</span>, <span class="string">'grade'</span>]]</span><br></pre></td></tr></table></figure><h3 id="where过滤（了解）"><a href="#where过滤（了解）" class="headerlink" title="where过滤（了解）"></a>where过滤（了解）</h3><p>另一种简洁的布尔查询写法</p><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>原生的布尔查询，需要每列单独判断条件，然后用逻辑运算符组合条件，得出最终结果</li><li>where过滤过滤：先将所有需要判断条件的列抽出来，整体判断，得出最终结果<ul><li>优点：写法简洁</li><li>缺点：where过滤所有列的判断条件，只能有一个，使用受限</li></ul></li></ul><ul><li>视图模式<ul><li>将一个对象整体赋值给另一个变量</li><li>修改一个变量，另一个变量值也会变</li><li>多个变量数据指向同一内存数据</li></ul></li><li><p>副本模式</p><ul><li>将一个对象查询的一部分值赋值给另一个变量</li><li>修改一个变量，另一个变量值不会变</li></ul></li><li><p>当将一个对象整体赋值给另一个变量时，<strong>视图模式</strong>，两个变量对应的内存地址相同，修改一个变量，另一个变量也会改变。</p></li><li>当使用copy()将一个对象赋值给另一个变量时<ul><li>或者使用查询赋值，查询数据的一部分并赋值给其他变量</li><li>当赋值为原数据查询的一部分时，是<strong>副本模式</strong>，修改一个变量不会影响另一个变量</li></ul></li></ul><h3 id="变量查询一部分数据"><a href="#变量查询一部分数据" class="headerlink" title="变量查询一部分数据"></a>变量查询一部分数据</h3><p>理论上是副本模式，但实际上，直接修改赋值变量时会报警告（能修改成功）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a[[<span class="string">'name'</span>, <span class="string">'sex'</span>, <span class="string">'address'</span>]]</span><br></pre></td></tr></table></figure><p>数据操作</p><ul><li>创建：C,Create</li><li>查询：R,Read</li><li>增加：I,Insert</li><li>修改：U,Update</li><li>删除：D,Delete</li></ul><p>pandas数据操作: 其他操作</p><p>pandas对象的命名: name</p><p>pandas对象的遍历</p><p>Pandas对象的命名:name</p><p>Series和Dataframe对象本身, 索引都可以命名</p><p>数据的输入和输出是Pandas的基础操作</p><p>Pandas可以存取多种介质类型数据：常见的有：</p><ul><li>文本类数据<ul><li>csv</li><li>JSON</li></ul></li><li>二进制磁盘数据<ul><li>Excel</li><li>pkl</li><li>HDF5</li></ul></li><li>数据库<ul><li>SQL（略）</li></ul></li><li>Web API数据<ul><li>HTML</li></ul></li><li>其他<ul><li>内存</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">文本类数据文件读入Pandas时会自动推断每列数据类型（类型推断）和数据编码并转化。</span><br><span class="line">二进制类数据文件没有编码问题，且部分文件会在格式中存储数据类型不需转化</span><br><span class="line"></span><br><span class="line">对Pandas不能直接支持或不方便使用的数据格式，</span><br><span class="line">可以使用支持软件将其转为csv或xlsx格式后使用Pandas读写，如SPSS文件</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pandas:最流行的Python数据分析库&lt;/p&gt;
&lt;p&gt;基于Numpy, 专用于数据预处理和数据分析的Python第三方库, 最适合处理大型结构化表格数据.&lt;/p&gt;
&lt;p&gt;Pandas两大数据类型&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Series: 一维&lt;/li&gt;
&lt;li&gt;Dat
      
    
    </summary>
    
      <category term="数据分析" scheme="https://hubhack.github.io/categories/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
    
      <category term="数据分析" scheme="https://hubhack.github.io/tags/%E6%95%B0%E6%8D%AE%E5%88%86%E6%9E%90/"/>
    
  </entry>
  
  <entry>
    <title></title>
    <link href="https://hubhack.github.io/book/PyUnit%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/"/>
    <id>https://hubhack.github.io/book/PyUnit单元测试/</id>
    <published>2019-08-04T02:29:55.553Z</published>
    <updated>2019-08-04T02:36:40.307Z</updated>
    
    <content type="html"><![CDATA[<p>Pyunit(unittest) 是python 自带的单元测试框架, 用于编写和运行可重复的测试.pyunit是xunit体系的一个成员, xunit是众多测试框架的总称,pyunit主要用于进行白盒测试和回归测试.</p><p>通过Pyunit可以让测试具有持久性, 测试与开发同步进行, 测试代码与开发代码一同发布.使用PyUnit具有如下好处:</p><p>可以是测试代码与产品代码分离.</p><p>针对某一个类的测试代码只需进行较少的改动, 便可以应用于另一个类的测试.</p><p>PyUnit开放源代码, 可以进行二次开发, 方便对Pyunit的扩展.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Pyunit(unittest) 是python 自带的单元测试框架, 用于编写和运行可重复的测试.pyunit是xunit体系的一个成员, xunit是众多测试框架的总称,pyunit主要用于进行白盒测试和回归测试.&lt;/p&gt;
&lt;p&gt;通过Pyunit可以让测试具有持久性, 
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>RabbitMQ</title>
    <link href="https://hubhack.github.io/book/RabbitMQ/"/>
    <id>https://hubhack.github.io/book/RabbitMQ/</id>
    <published>2019-07-28T12:00:14.075Z</published>
    <updated>2019-07-28T12:12:07.801Z</updated>
    
    <summary type="html">
    
    </summary>
    
      <category term="消息中间件" scheme="https://hubhack.github.io/categories/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
    
      <category term="消息中间件" scheme="https://hubhack.github.io/tags/%E6%B6%88%E6%81%AF%E4%B8%AD%E9%97%B4%E4%BB%B6/"/>
    
  </entry>
  
  <entry>
    <title>理解restful</title>
    <link href="https://hubhack.github.io/book/%E7%90%86%E8%A7%A3restful/"/>
    <id>https://hubhack.github.io/book/理解restful/</id>
    <published>2019-07-25T03:08:06.618Z</published>
    <updated>2019-07-25T06:09:00.713Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Restful-API"><a href="#Restful-API" class="headerlink" title="Restful API"></a>Restful API</h3><p>越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件.</p><p>这种”互联网软件”采用客户端/服务器模式, 建立在分布式体系上, 通过互联网通信, 具有高延时(high latency) , 高并发等特点.</p><p>网站开发, 完全可以采用软件开发的模式, 但是传统上, 软件和网络是两个不同的领域, 很少有交集. 软件开发主要针对单机环境, 网络则主要研究系统之间的通信.</p><p>RESTful架构，就是目前最流行的一种互联网软件架构。它结构清晰、符合标准、易于理解、扩展方便，所以正得到越来越多网站的采用。</p><p>但是，到底什么是RESTful架构，并不是一个容易说清楚的问题。下面，我就谈谈我理解的RESTful架构。</p><h3 id="resources"><a href="#resources" class="headerlink" title="resources"></a>resources</h3><p>rest的名称”表现层状态转化” 中, 省略了主语, “ 表现层” 其实指的是”资源”(resource) 的”表现层”.</p><p><strong>所谓”资源”，就是网络上的一个实体，或者说是网络上的一个具体信息。</strong>它可以是一段文本、一张图片、一首歌曲、一种服务，总之就是一个具体的实在。你可以用一个URI（统一资源定位符）指向它，每种资源对应一个特定的URI。要获取这个资源，访问它的URI就可以，因此URI就成了每一个资源的地址或独一无二的识别符。</p><p>所谓”上网”，就是与互联网上一系列的”资源”互动，调用它的URI。</p><h3 id="表现层-representation"><a href="#表现层-representation" class="headerlink" title="表现层(representation)"></a>表现层(representation)</h3><p>“资源”是一种信息实体, 他可以有多种外在表现形式. 我们把”资源” 具体呈现出来的形式. 叫做它的”表现层”(representation).</p><p>比如, 文本可以用txt格式表现, 也可以用html格式, xml格式,JSON格式表现，甚至可以采用二进制格式；图片可以用JPG格式表现，也可以用PNG格式表现。</p><p>URI只代表资源的实体，不代表它的形式。严格地说，有些网址最后的”.html”后缀名是不必要的，因为这个后缀名表示格式，属于”表现层”范畴，而URI应该只代表”资源”的位置。它的具体表现形式，应该在HTTP请求的头信息中用Accept和Content-Type字段指定，这两个字段才是对”表现层”的描述。</p><p>访问一个网站，就代表了客户端和服务器的一个互动过程。在这个过程中，势必涉及到数据和状态的变化。</p><p>互联网通信协议HTTP协议，是一个无状态协议。这意味着，所有的状态都保存在服务器端。因此，<strong>如果客户端想要操作服务器，必须通过某种手段，让服务器端发生”状态转化”（State Transfer）。而这种转化是建立在表现层之上的，所以就是”表现层状态转化”。</strong></p><p>客户端用到的手段，只能是HTTP协议。具体来说，就是HTTP协议里面，四个表示操作方式的动词：GET、POST、PUT、DELETE。它们分别对应四种基本操作：<strong>GET用来获取资源，POST用来新建资源（也可以用于更新资源），PUT用来更新资源，DELETE用来删除资源。</strong></p><p>注意:资源不能是动词.</p><p>在RESTful架构中, 每个网址代表一种资源(resource), 所以网址中不能有动词, 只能有名词, 而且所用的名词往往与数据库的表格名对应.一般来说, 数据库中的表都是同种记录的”集合”, 所以api中的名词也应该使用复数.</p><h3 id="http方法"><a href="#http方法" class="headerlink" title="http方法"></a>http方法</h3><p>对于资源的具体操作类型, 由http动词表示.</p><p>常用的http动词有下面五个, (括号里对应的sql命令).</p><ul><li>GET（SELECT）：从服务器取出资源（一项或多项）。</li><li>POST（CREATE）：在服务器新建一个资源。</li><li>PUT（UPDATE）：在服务器更新资源（客户端提供改变后的完整资源）。</li><li>PATCH（UPDATE）：在服务器更新资源（客户端提供改变的属性）。</li><li>DELETE（DELETE）：从服务器删除资源。</li></ul><p>还有两个不常用的http动词.</p><p>HEAD:获取资源的元数据.</p><p>OPTIONS:获取信息, 关于资源的那些属性是客户端可以改变的.</p><p>下面是一些例子:</p><ul><li>GET /zoos：列出所有动物园</li><li>POST /zoos：新建一个动物园</li><li>GET /zoos/ID：获取某个指定动物园的信息</li><li>PUT /zoos/ID：更新某个指定动物园的信息（提供该动物园的全部信息）</li><li>PATCH /zoos/ID：更新某个指定动物园的信息（提供该动物园的部分信息）</li><li>DELETE /zoos/ID：删除某个动物园</li><li>GET /zoos/ID/animals：列出某个指定动物园的所有动物</li><li>DELETE /zoos/ID/animals/ID：删除某个指定动物园的指定动物</li></ul><p>过滤信息(filtering)</p><p>如果记录信息很多, 服务器不可能都将他们返回给用户, API应该提供参数, 过滤返回结果.</p><p>下面是一些常见的参数.</p><ul><li>?limit=10：指定返回记录的数量</li><li>?offset=10：指定返回记录的开始位置。</li><li>?page=2&amp;per_page=100：指定第几页，以及每页的记录数。</li><li>?sortby=name&amp;order=asc：指定返回结果按照哪个属性排序，以及排序顺序。</li><li>?animal_type_id=1：指定筛选条件</li></ul><p>参数的设计允许存在冗余, 即允许api路径和url参数偶尔有重复.比如，GET /zoo/ID/animals 与 GET /animals?zoo_id=ID 的含义是相同的。</p><p>api的身份认证应该使用oauth 2.0框架.</p><p>服务器返回的数据格式, 应该尽量使用json, 避免使用xml.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Restful-API&quot;&gt;&lt;a href=&quot;#Restful-API&quot; class=&quot;headerlink&quot; title=&quot;Restful API&quot;&gt;&lt;/a&gt;Restful API&lt;/h3&gt;&lt;p&gt;越来越多的人开始意识到, 网站即软件, 而且是一种新型的软件.&lt;/p
      
    
    </summary>
    
      <category term="理解restful" scheme="https://hubhack.github.io/categories/%E7%90%86%E8%A7%A3restful/"/>
    
    
      <category term="理解restful" scheme="https://hubhack.github.io/tags/%E7%90%86%E8%A7%A3restful/"/>
    
  </entry>
  
  <entry>
    <title>python部署</title>
    <link href="https://hubhack.github.io/book/%E9%83%A8%E7%BD%B2/"/>
    <id>https://hubhack.github.io/book/部署/</id>
    <published>2019-07-22T01:25:33.385Z</published>
    <updated>2019-07-25T06:12:13.941Z</updated>
    
    <content type="html"><![CDATA[<p>Django打包</p><p>构建setup.py文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">useradd python</span><br><span class="line">echo python | passwd python --stdin</span><br><span class="line">yum install git python-devel mysql-devel</span><br><span class="line">yum -y install gcc make patch gdbm-devel openssl-devel sqlite-devel readline-devel zlib-devel bzip2-devel</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">curl -L https://github.com/pyenv/pyenv-installer/raw/master/bin/pyenv-installer | bash</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">export PATH=&quot;$HOME/.pyenv/bin:$PATH&quot;</span><br><span class="line">eval &quot;$(pyenv init -)&quot;</span><br><span class="line">eval &quot;$(pyenv virtualenv-init -)&quot;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">source .bashrc </span><br><span class="line"></span><br><span class="line">[global]</span><br><span class="line">index-url = https://mirrors.aliyun.com/pypi/simple/</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host=mirrors.aliyun.com</span><br></pre></td></tr></table></figure><p>python setup.py sdist –formats=gztar</p><p>ln -sv blog-1.0 web</p><p>/root/blog/projects/web</p><p>uwsgi -d –ini blog.ini  后台启动服务, </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">import &#123; resolve &#125; from &quot;url&quot;;</span><br><span class="line"></span><br><span class="line">let p = new Promise((resolve, reject) =&gt; &#123;</span><br><span class="line">    //做一些事情</span><br><span class="line">    //然后再某些条件下resolve, 或者reject</span><br><span class="line">    if(/*条件随便写*/) &#123;</span><br><span class="line">        resolve()</span><br><span class="line"></span><br><span class="line">    &#125;else&#123;</span><br><span class="line">        reject()</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;)</span><br><span class="line">p.then(() =&gt; &#123;</span><br><span class="line">    //如果p的状态被resolve, 就进入这里</span><br><span class="line">&#125;), () =&gt; &#123;</span><br><span class="line">    //如果p的状态被reject,进入这里</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>第一段调用了Promise构造函数, 第二段是调用了promise实例的.then方法</p><p>构造实例</p><p>构造函数接受一个参数作为参数</p><p>调用构造函数得到实例p的同时,作为参数的函数会立即执行.</p><p>参数函数接受两个回调函数参数resolve和reject</p><p>在参数函数被执行的过程中, 如果在其内部调用resolve, 会被p的状态变为fulfilled, 或者调用reject, 会将p的状态变为rejected.</p><p>调用.then</p><p>调用.then可以为实例p注册两种状态回调函数</p><p>当实例p的状态为fulfilled, 会触发第一个函数执行</p><p>当实例p的状态为rejected, 则会触发第二个函数执行.</p><p>总结</p><p>上面这样构造promise实例, 然后调用.then.then.then的编写代码方式, 就是promise.</p><p>其基本模式是:</p><p>将异步过程转换成promise对象.</p><p>对象有三种状态, </p><p>通过.then注册状态的回调.</p><p>已完成的状态能触发回调.</p><p>采用这种方式来处理编程中的异步任务, 就是在使用promise了.</p><p>所以promise就是一种异步编程模式.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;Django打包&lt;/p&gt;
&lt;p&gt;构建setup.py文件&lt;/p&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span 
      
    
    </summary>
    
      <category term="项目部署" scheme="https://hubhack.github.io/categories/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
    
      <category term="项目部署" scheme="https://hubhack.github.io/tags/%E9%A1%B9%E7%9B%AE%E9%83%A8%E7%BD%B2/"/>
    
  </entry>
  
  <entry>
    <title>理解js中的promise</title>
    <link href="https://hubhack.github.io/book/%E7%90%86%E8%A7%A3js%20%E7%9A%84promise/"/>
    <id>https://hubhack.github.io/book/理解js 的promise/</id>
    <published>2019-07-10T08:08:50.783Z</published>
    <updated>2019-07-10T09:47:50.633Z</updated>
    
    <content type="html"><![CDATA[<h3 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h3><p>ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.</p><p>简单说, 就是处理异步请求的.之所以叫做Promise, 就是我承诺,如果成功则怎么处理, 失败则怎么处理.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//语法</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(</span><br><span class="line"><span class="comment">/*下面定义的函数是executor*/</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;...&#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure><p>executor是一个带有resolve和reject 两个参数的函数.</p><p>executor函数在promise构造函数执行时立即执行, 被传递resolve和reject函数(executor函数在Promise构造函数返回新建对象前被调用).executor内部通常会执行一些异步操作, 一旦完成,可以调用resolve函数来讲promise状态改成fulfilled即完成, 或者在发生错误时将他的状态改为rejected即失败.</p><p>如果在executor函数中抛出一个错误, 那么该promise状态为rejected.executor函数的返回值被忽略.</p><p>executor中, resolve或reject只能执行其中一个函数.</p><p>promise的状态</p><ul><li>fulfilled:意味着操作成功完成</li><li>pending:初始状态,不是成功或失败状态</li></ul><ul><li>rejected: 意味着操作失败.</li></ul><p><strong>Promise.then(onfilled, onRejected)</strong></p><p>参数是2个函数, 根据Promise的状态来调用不同的函数, fulfilled走onFulfilled函数,rejected走onRejected函数.then的返回值是一个新的promise对象, 执行任意一个函数, 对这个promise对象来说就是其返回值.调用任何一个函数, 其返回值可以被后续的then方法继续捕捉.</p><p><strong>catch(onRejected)</strong></p><p>为当前Promise对象添加一个拒绝回调,返回一个新的Promise对象.</p><p>Promise提供2个方法:</p><ul><li>Promise.resolve(value)返回 状态为fulfilled的Promise对象</li><li>Promise.reject(reason)返回 状态为rejected状态的Promise对象.</li></ul><p>catch其实是then(undefined, () =&gt; {})的语法糖,如下:</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> p = <span class="built_in">Promise</span>.reject(<span class="string">'error'</span>);</span><br><span class="line">p.catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'catch'</span> + err);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>Promise对象内部其实自带了try catch, 当同步代码发生运行时错误时, 会自动将错误对象作为值reject, 这样就会触发catch注册的回调.</p><p>实例</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">runAsync</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>)</span>&#123;</span><br><span class="line">        setInterval(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">            <span class="built_in">console</span>.log(<span class="string">'do sth ----'</span>)</span><br><span class="line">            resolve(<span class="string">'ok----'</span>)</span><br><span class="line"></span><br><span class="line">        &#125;, <span class="number">3000</span>);</span><br><span class="line">    &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//调用</span></span><br><span class="line">runAsync().then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.reject(value + <span class="string">'*'</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">).catch(</span><br><span class="line">    reason =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(reason);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Promise</span>.resolve(reason + <span class="string">'*'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">).then(</span><br><span class="line">    value =&gt; &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(value);</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'Promise end'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">)</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'========='</span>)</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;概念&quot;&gt;&lt;a href=&quot;#概念&quot; class=&quot;headerlink&quot; title=&quot;概念&quot;&gt;&lt;/a&gt;概念&lt;/h3&gt;&lt;p&gt;ES6开始支持.promise对象用于一个异步操作的最终完成(包括成功和失败)及结果值的表示.&lt;/p&gt;
&lt;p&gt;简单说, 就是处理异步请求的.
      
    
    </summary>
    
      <category term="js" scheme="https://hubhack.github.io/categories/js/"/>
    
    
      <category term="js" scheme="https://hubhack.github.io/tags/js/"/>
    
  </entry>
  
  <entry>
    <title>序列化与json</title>
    <link href="https://hubhack.github.io/book/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8Ejson/"/>
    <id>https://hubhack.github.io/book/序列化与json/</id>
    <published>2019-07-04T02:31:22.966Z</published>
    <updated>2019-07-04T02:45:41.237Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序列化与反序列化"><a href="#序列化与反序列化" class="headerlink" title="序列化与反序列化"></a>序列化与反序列化</h3><p>内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.</p><p>如果是自己定义的类的实例, 如何保存到一个文件中.</p><p>如何从文件中读取数据,并让他们再内存中再次恢复成自己对应的类的实例.</p><p>要设计一套协议, 按照某种规则,把内存中的数据保存到文件中. 文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件.这就是序列化, 反之, 从文件的字节序列恢复到内存并且还是原来的类型,就是反序列化.</p><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><p>serialization 序列化</p><p>将内存中的对象存储下来,把它变成一个个字节.-&gt;二进制</p><p>deserialization 反序列化</p><p>将文件的一个个字节恢复成内存中对象 &lt;-二进制</p><p>序列化保存到文件就是持久化.</p><p>可以将数据序列化后持久化,或者网络传输; 也可以将从文件中或者网络收到的字节序列反序列化.</p><h3 id="json"><a href="#json" class="headerlink" title="json"></a>json</h3><p>JSON是JavaScript Object Notation的缩写，中文译为JavaScript对象表示法。用来作为数据交换的文本格式，作用类似于XML，而2001年Douglas Crockford提出的目的就是为了取代XML，它不是一种编程语言，仅用来描述数据结构。</p><p>json是对js对象文本的一个描述， 相比xml来说更轻在web中流行广泛，因为是js的一部分，所以在浏览器中直接被被解析，网页传输中应用广泛。</p><h2 id="1、JSON语法规则"><a href="#1、JSON语法规则" class="headerlink" title="1、JSON语法规则"></a>1、JSON语法规则</h2><p>JSON的语法可以表示以下三种类型的值：简单值、JSON对象和数组。</p><p><strong>（1）简单值</strong></p><p>简单值使用与JavaScript相同的语法，可以在JSON中表示字符串、数值、布尔值和null。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 简单值</span></span><br><span class="line"><span class="string">"Hello World!"</span> <span class="comment">// 字符串</span></span><br><span class="line"><span class="number">99</span> <span class="comment">// 数值</span></span><br><span class="line"><span class="literal">true</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">false</span> <span class="comment">// 布尔型</span></span><br><span class="line"><span class="literal">null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 在JSON中不能使用的值</span></span><br><span class="line"><span class="literal">NaN</span> <span class="comment">// 数值不能是NaN</span></span><br><span class="line"><span class="literal">Infinity</span> <span class="comment">// 数值不能是Infinity</span></span><br><span class="line"><span class="literal">undefined</span> <span class="comment">// 在JSON也不可以使用JavaScript中的undefined</span></span><br><span class="line"><span class="string">'Hello World!'</span> <span class="comment">// 字符串必须使用双引号表示，不能使用单引号</span></span><br><span class="line"><span class="number">0x1</span> <span class="comment">// 数值必须以十进制表示，不能使用十六进制</span></span><br></pre></td></tr></table></figure><p><strong>（2）对象</strong></p><p>对象是一组有序的键值对的数据组成的数据类型。键值对中，值可以是简单值，也可以是对象和数组（数组也是用来表示JSON的数据类型，见接下来内容）。一般很多刚入门的同学都在JavaScript中使用JSON所以经常会和JSON对象混淆，要十分注意。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 对象，对象的属性名必须使用双引号，值要是字符串也必须使用双引号</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"name"</span>: <span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"age"</span>: <span class="number">18</span>,</span><br><span class="line">  <span class="string">"isStudent"</span>: <span class="literal">true</span>,</span><br><span class="line">  <span class="string">"isLeader"</span>: <span class="literal">false</span>,</span><br><span class="line">  <span class="string">"mark"</span>: <span class="literal">null</span>,</span><br><span class="line">  <span class="string">"school"</span>: &#123;</span><br><span class="line">    <span class="string">"name"</span>: <span class="string">"BIT"</span>,</span><br><span class="line">    <span class="string">"region"</span>: <span class="string">"Beijing"</span> <span class="comment">// 这个地方不能有逗号，因为是对象的最后一个属性成员</span></span><br><span class="line">  &#125; <span class="comment">// 这个地方也不可以有逗号，因为也是对象的最后一个属性成员</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>（3）数组</strong></p><p>数组是由一组有序的数组组成的列表。在数组中，值可以是简单值，也可以是对象和数组。记住，记住，再记住，在JSON中数组最后一个元素一定不要有逗号。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 示例一</span></span><br><span class="line">[<span class="string">"Andy"</span>, <span class="string">"Ruby"</span>, <span class="string">"Danny"</span>, <span class="string">"Peter"</span>, <span class="string">"Lisa"</span>]</span><br><span class="line"><span class="comment">// 示例二</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>, <span class="number">0</span>]</span><br><span class="line"><span class="comment">// 示例三</span></span><br><span class="line">[</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Andy"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Ruby"</span>, <span class="string">"age"</span>: <span class="number">18</span>&#125;,</span><br><span class="line">  &#123;<span class="string">"name"</span>: <span class="string">"Danny"</span>, <span class="string">"age"</span>: <span class="number">20</span>&#125;</span><br><span class="line">]</span><br><span class="line"><span class="comment">// 示例四</span></span><br><span class="line">[</span><br><span class="line">  [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>],</span><br><span class="line">  [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>],</span><br><span class="line">  [<span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h2 id="2、JSON字符串和JSON对象"><a href="#2、JSON字符串和JSON对象" class="headerlink" title="2、JSON字符串和JSON对象"></a>2、JSON字符串和JSON对象</h2><p><strong>（1）JSON字符串</strong></p><p>JSON字符串与普通的字符串没有任何特殊的地方，但是之所以称为JSON字符串是因为，这个字符串符合我们前面介绍的语法规则。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure><p><strong>（2）JSON对象</strong></p><p>JSON对象主要是在JavaScript的说法。在面向对象编程中，类的实例化叫做对象，对象拥有不同的属性，键值对就是对象的属性和值。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// JSON对象</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><strong>（3）JSON字符串和JSON对象互相转换</strong></p><p>JavaScript中有一个全局的对象，JSON。JSON中有两个方法 <em>stringify() 和 parse()。</em></p><p><em>JSON.parse()</em> 把JSON字符串解析为JSON对象</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON字符串通过parse转化为JSON对象</span></span><br><span class="line"><span class="keyword">var</span> p =<span class="string">'&#123;"name":"Andy","gender":"男","age":"18"&#125;'</span>;</span><br><span class="line">person = <span class="built_in">JSON</span>.parse(p)</span><br><span class="line"><span class="built_in">console</span>.log(person.name);<span class="comment">// 在控制台输出Andy，可以通过点运算直接访问对象属性</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(person));<span class="comment">// object</span></span><br></pre></td></tr></table></figure><p><em>JSON.stringify()</em> 用于把JSON对象序列化为JSON字符串。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//JSON对象通过stringify转化为JSON字符串</span></span><br><span class="line"><span class="keyword">var</span> person=&#123;</span><br><span class="line">  <span class="string">"name"</span>:<span class="string">"Andy"</span>,</span><br><span class="line">  <span class="string">"gender"</span>:<span class="string">"男"</span>,</span><br><span class="line">  <span class="string">"age"</span>:<span class="string">"18"</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> p = <span class="built_in">JSON</span>.stringify(person)</span><br><span class="line"><span class="built_in">console</span>.log(p); <span class="comment">// &#123;"name":"Andy","gender":"男","age":"18"&#125;</span></span><br><span class="line">alert(<span class="keyword">typeof</span>(p));<span class="comment">// string</span></span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;序列化与反序列化&quot;&gt;&lt;a href=&quot;#序列化与反序列化&quot; class=&quot;headerlink&quot; title=&quot;序列化与反序列化&quot;&gt;&lt;/a&gt;序列化与反序列化&lt;/h3&gt;&lt;p&gt;内存中的字典,列表,集合以及各种对象,如何保存到一个文件中.&lt;/p&gt;
&lt;p&gt;如果是自己定义的
      
    
    </summary>
    
      <category term="json" scheme="https://hubhack.github.io/categories/json/"/>
    
    
      <category term="序列化" scheme="https://hubhack.github.io/tags/%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    
  </entry>
  
  <entry>
    <title>编程的4门功课</title>
    <link href="https://hubhack.github.io/book/%E8%AE%A1%E7%AE%97%E6%9C%BA4%E7%A7%91/"/>
    <id>https://hubhack.github.io/book/计算机4科/</id>
    <published>2019-07-01T08:29:49.176Z</published>
    <updated>2019-07-01T08:57:33.031Z</updated>
    
    <content type="html"><![CDATA[<h3 id="计算机组成原理"><a href="#计算机组成原理" class="headerlink" title="计算机组成原理"></a>计算机组成原理</h3><p>首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：可以通过电流的变化，实现电路的切换。比如计算机最基础的与或非运算，都可以通过晶体管组成的电子元件实现。而通过晶体管的电位差不同，就可以体现”二进制数据”，即0和1。再加上电容和电阻，就能把这种二进制数据临时保存起来。<br>综合这些特性，大牛们发现把晶体管用作精密的数学计算，可以极大的提高运算的效率。比如我有2个电容，分别是充满电和没有电，对他们同时释放电信号，电容就会把其中的电子放出来，经过特定的逻辑电路，如与门，得到了0的结果。要计算1+1，实际上也是类似的原理。我先设计一个加法电路，把若干电容组合成的”数字”流过这个电路，把结果存入目标电容，就得到了结果。大规模的复杂运算以此类推。<br>最早期的计算机真的就是用许多结晶体管实现的复杂电路结构，通过控制输入电流得到希望的输出结果。后来人们发现，这种计算可以用某些形式抽象成多种指令，不用针对每次计算设计复杂的电路，只要调用指令就可以实现任何一种计算组合，于是诞生了cpu。只有cpu，每次都要自己配置输入信号，实在太痛苦，就做了纸带输入给计算机。后来又发现纸带还是很麻烦，于是发明了输入终端和对应的存储设备。后来又发现很多数据要临时保存起来，供连续计算使用，于是发明了内存。再后来pc的发展经历了无数次的变革，让计算机一步步到了今天的地步，也就是你现在看到的这样。<br>其中的历程非常曲折，也许有机构能够把他们全部组织成一本漫长的历史，但个人肯定是无能为力的。</p><h3 id="操作系统原理"><a href="#操作系统原理" class="headerlink" title="操作系统原理"></a>操作系统原理</h3><p>综上所述，计算机发展到一定程度，什么东西都靠人工也未免太累了。<br>比如通过输入设备组织指令给cpu去计算，你希望能够找一个快速的输入设备(比如键盘)，在能看到结果的地方输入(比如屏幕)，然后再用很方便的方式提交给cpu(比如按键或者指令)，让cpu去算好了，再把结果展示出来(比如屏幕)。<br>理想很美好，但是这么复杂的流程，人工管理起来不还是很麻烦吗？除非我构造一个设备，把这些所有设备都管理起来，于是主板就诞生了。</p><p>现在主板解决了我们大量的问题，但是我发觉我的需求还远远不够！<br>我希望我写过的程序能在任何一台机上运行。<br>我希望我能边听音乐边干活——即同一时间可以运行多个程序。<br>我希望别人写的傻×东西不要影响到我的工作——即多任务控制。<br>我希望计算机里面的各种资源都能得到良好的组织，更快的访问。<br>我希望我的用户界面更好看，使用更方便，功能更强大！<br>我是个小白用户，啥都不懂，别跟我扯这些有的没的，我就像随便操作两下就能达到我想要的！<br>如果这些需求全部都做在主板bios里面，那将是一场灾难！除非bios经过极大的调整和改动，划分出一大块区域存放操作系统，并且完成复杂的体系结构改革。<br>计算机发展到这种程度，早就已经有很多的机构和厂商介入其中，试图从中渔利。他们当然不会求着计算机标准委员会和主板生产厂商去做所谓的主板改革，而是编写自己的程序——操作系统，来解决这些所有的问题。</p><p>而操作系统问世之后，一方面接管了主板对于系统资源的管理，加入了自己的中间层——驱动程序，另一方面又充分发挥了人机交互的接口——gui界面，成为了计算机必不可少的组成部分。<br>操作系统通过bios引导，即作为应用程序开始运行。我们知道程序的本质上就是在cpu上运行种种指令，比如操作系统需要把硬盘上的模块放入内存，实际上就是运行了一系列复杂的cpu指令，cpu指令通过主板bus（实际上就是传递指令的电路）发送指令给硬盘（比如从哪个扇区偏移多少读多少数据），硬盘再通过芯片组转动磁头，把数据读到缓存中，完成后给cpu发送一个信号（即中断），cpu收到这个信号，就在寄存器中寻址该信号对应的地址（即我们说的中断向量表），运行该地址中的指令，发现该指令是发送拷贝指令给主板芯片组，主板就会在cpu的指导下不断的发送信号，告诉硬盘缓存放电，再把接收的电信号存到指定的内存位置去，如此反复，直到完成cpu的一系列指令为止。<br>操作系统说白了，就是这样通过种种cpu指令，实现自身的所有功能。<br>当然这些指令也不是一条条写进去的，而是通过编程语言完成人类较容易识别的逻辑，然后再通过编译器把这些逻辑翻译成cpu指令，这就涉及编译原理的东西了。</p><p>既然操作系统对硬件的访问都是通过cpu指令来完成的，那为什么大家都感觉是操作掌管了硬件呢？这就涉及操作系统最本质的功能之一：对系统资源的管控了。<br>我们运行的所有程序，实际上都是操作系统帮我们运行的。操作系统背后进行了很多的工作，如虚拟地址空间的分配，cpu分时调度，硬件中断信号的响应等。这样对于硬件资源的访问，也是通过操作系统安排的。比如操作系统会通过把短时间内硬盘读写合并成顺序的方式，以提高磁头的利用率，降低磁头转向的时间。再比如对内存地址的访问也是由操作系统管控的，某个程序中的内存地址具体落到内存条的哪个位置，还是硬盘中的虚拟内存，就看操作系统的心情了。</p><p>至此，操作系统和硬件的交互也介绍的差不多了，更详细的东西建议参考操作系统相关的书籍吧，比如《深入理解计算机系统》，《linux内核设计与实现》，《unix环境高级编程》之类的。</p><h3 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h3><p>数据结构的作用, 就是为了提高硬件利用率.</p><p>比如操作系统需要查找用户应用程序”office”在硬盘的那个位置, 盲目的搜索一遍硬盘肯定是低效的,这时候搞个b+树,作为索引，搜索office这个单词就很快，然后就能很快的定位office这个应用程序的文件信息，再找到文件信息中对应的磁盘位置了。</p><p>数据结构的东西找本《算法导论》，《数据结构与算法分析》之类的看吧。</p><h3 id="计算机网络"><a href="#计算机网络" class="headerlink" title="计算机网络"></a><strong>计算机网络</strong></h3><p>计算机网络分为3块：</p><p>硬件<br>网卡，网线，交换机这些，用来处理数据的。</p><p>协议<br>数据在网络中通信如何组织？如何识别？如何保证数据的正确性？<br>这2块我就不多说了。</p><p>操作系统<br>这就是如何把计算机网络和操作系统结合起来的问题了。<br>对于操作系统来说，网卡也是一种硬件资源。但是网络不单只是一种硬件，而是一种媒体入口。比如操作系统管理硬盘，当然不是简单的记一下硬盘有多大，然后一切操作都交给硬盘芯片去做，更多的需要组织硬盘的扇区，分区，记录文件和扇区/偏移的关系等等。<br>操作系统对于网络来说也是如此，要记录自身在网络的标识（ip），可被他人访问的入口（port），以及对方的信息（remote ip/port）。连接，断开，数据确认等操作也是由协议控制。<br>传递自身消息给对方，类似访问硬盘一样把内存中的数据传递给网卡缓存，再发消息给网卡让网卡去传数据，而是否发送成功这些保证不再由硬件中断信号反馈，而是通过网络协议完成。接收对方消息，也是接收到网卡中断，再把数据从网卡缓存移动到内存中，再通过协议给予对方反馈。</p><p>网络方面的就推荐《tcp/ip详解》，《uinx网络高级编程》吧。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;计算机组成原理&quot;&gt;&lt;a href=&quot;#计算机组成原理&quot; class=&quot;headerlink&quot; title=&quot;计算机组成原理&quot;&gt;&lt;/a&gt;计算机组成原理&lt;/h3&gt;&lt;p&gt;首先，我们可以把计算机分解成最原始的部件——晶体管。晶体管是一种半导体材料，其最重要的作用就是半导：
      
    
    </summary>
    
      <category term="计算机" scheme="https://hubhack.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
    
      <category term="计算机" scheme="https://hubhack.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA/"/>
    
  </entry>
  
  <entry>
    <title>web路由</title>
    <link href="https://hubhack.github.io/book/web%E8%B7%AF%E7%94%B1/"/>
    <id>https://hubhack.github.io/book/web路由/</id>
    <published>2019-07-01T02:02:08.604Z</published>
    <updated>2019-07-01T02:24:12.031Z</updated>
    
    <content type="html"><![CDATA[<p>web开发中路由route和路由器router到底是什么</p><h3 id="1-什么是路由"><a href="#1-什么是路由" class="headerlink" title="1. 什么是路由"></a>1. 什么是路由</h3><p>在Web开发过程中，经常会遇到『路由』的概念。那么，到底什么是路由？简单来说，路由就是URL到函数的映射。</p><h3 id="2-router和route的区别"><a href="#2-router和route的区别" class="headerlink" title="2. router和route的区别"></a>2. router和route的区别</h3><p>route就是一条路由，它将一个URL路径和一个函数进行映射，例如：</p><blockquote><p>/users -&gt; getAllUsers()</p><p>/users/count -&gt; getUsersCount()</p></blockquote><p>这就是两条路由，当访问<code>/users</code>的时候，会执行<code>getAllUsers()</code>函数；当访问<code>/users/count</code>的时候，会执行<code>getUsersCount()</code>函数。</p><p>而router可以理解为一个容器，或者说一种机制，它管理了一组<code>route</code>。简单来说，<code>route</code>只是进行了URL和函数的映射，而在当接收到一个URL之后，去路由映射表中查找相应的函数，这个过程是由<code>router</code>来处理的。一句话概括就是 “The router routes you to a route”。</p><h3 id="3-服务器端路由"><a href="#3-服务器端路由" class="headerlink" title="3. 服务器端路由"></a>3. 服务器端路由</h3><p>对于服务器来说，当接收到客户端发来的HTTP请求，会根据请求的URL，来找到相应的映射函数，然后执行该函数，并将函数的返回值发送给客户端。对于最简单的静态资源服务器，可以认为，所有URL的映射函数就是一个文件读取操作。对于动态资源，映射函数可能是一个数据库读取操作，也可能是进行一些数据的处理，等等。</p><p>以Express为例，</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  res.sendFile(&apos;index&apos;)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">app.get(&apos;/users&apos;, (req, res) =&gt; &#123;</span><br><span class="line">  db.queryAllUsers()</span><br><span class="line">    .then(data =&gt; res.send(data))</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>这里定义了两条路由：</p><ul><li>当访问/的时候，会返回index页面</li><li>当访问/users的时候，会从数据库中取出所有用户数据并返回</li></ul><blockquote><p>不仅仅是URL</p><p>在router匹配route的过程中，不仅会根据URL来匹配，还会根据请求的方法来看是否匹配。例如上面的例子，如果通过POST方法来访问/users，就会找不到正确的路由。</p></blockquote><h3 id="4-客户端路由"><a href="#4-客户端路由" class="headerlink" title="4. 客户端路由"></a>4. 客户端路由</h3><p>对于客户端（通常为浏览器）来说，路由的映射函数通常是进行一些DOM的显示和隐藏操作。这样，当访问不同的路径的时候，会显示不同的页面组件。客户端路由最常见的有以下两种实现方案：</p><ul><li>基于Hash</li><li>基于History API</li></ul><h4 id="1-基于Hash"><a href="#1-基于Hash" class="headerlink" title="(1) 基于Hash"></a>(1) 基于Hash</h4><p>我们知道，URL中#及其后面的部分为hash。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const url = require(&apos;url&apos;)</span><br><span class="line">var a = url.parse(&apos;http://example.com/a/b/#/foo/bar&apos;)</span><br><span class="line">console.log(a.hash)</span><br><span class="line">// =&gt; #/foo/bar</span><br></pre></td></tr></table></figure><p>hash仅仅是客户端的一个状态，也就是说，当向服务器发请求的时候，hash部分并不会发过去。</p><p>通过监听window对象的hashChange事件，可以实现简单的路由。例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">window.onhashchange = function() &#123;</span><br><span class="line">  var hash = window.location.hash</span><br><span class="line">  var path = hash.substring(1)</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="2-基于History-API"><a href="#2-基于History-API" class="headerlink" title="(2) 基于History API"></a>(2) 基于History API</h4><p>通过HTML5 History API可以在不刷新页面的情况下，直接改变当前URL。详细用法可以参考：</p><p>Manipulating the browser history<br>Using the HTML5 History API<br>我们可以通过监听window对象的popstate事件，来实现简单的路由：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">window.onpopstate = function() &#123;</span><br><span class="line">  var path = window.location.pathname</span><br><span class="line"></span><br><span class="line">  switch (path) &#123;</span><br><span class="line">    case &apos;/&apos;:</span><br><span class="line">      showHome()</span><br><span class="line">      break</span><br><span class="line">    case &apos;/users&apos;:</span><br><span class="line">      showUsersList()</span><br><span class="line">      break</span><br><span class="line">    default:</span><br><span class="line">      show404NotFound()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是这种方法只能捕获前进或后退事件，无法捕获pushState和replaceState，一种最简单的解决方法是替换pushState方法，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var pushState = history.pushState</span><br><span class="line">history.pushState = function() &#123;</span><br><span class="line">  pushState.apply(history, arguments)</span><br><span class="line"></span><br><span class="line">  // emit a event or just run a callback</span><br><span class="line">  emitEventOrRunCallback()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>不过，最好的方法还是使用实现好的history库。</p><h4 id="3-两种实现的比较"><a href="#3-两种实现的比较" class="headerlink" title="(3) 两种实现的比较"></a>(3) 两种实现的比较</h4><p>总的来说，基于Hash的路由，兼容性更好；基于History API的路由，更加直观和正式。</p><p>但是，有一点很大的区别是，基于Hash的路由不需要对服务器做改动，基于History API的路由需要对服务器做一些改造。下面来详细分析。</p><p>假设服务器只有如下文件（script.js被index.html所引用）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">/-</span><br><span class="line"> |- index.html</span><br><span class="line"> |- script.js</span><br></pre></td></tr></table></figure><p>基于Hash的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/#/foobar</span><br></pre></td></tr></table></figure><p>基于History API的路径有：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">http://example.com/</span><br><span class="line">http://example.com/foobar</span><br></pre></td></tr></table></figure><p>当直接访问<code>http://example.com/</code>的时候，两者的行为是一致的，都是返回了<code>index.html</code>文件。</p><p>当从<code>http://example.com/</code>跳转到<code>http://example.com/#/foobar</code>或者<code>http://example.com/foobar</code>的时候，也都是正常的，因为此时已经加载了页面以及脚本文件，所以路由跳转正常。</p><p>当直接访问<code>http://example.com/#/foobar</code>的时候，实际上向服务器发起的请求是<code>http://example.com/</code>，因此会首先加载页面及脚本文件，接下来脚本执行路由跳转，一切正常。</p><p>当直接访问<code>http://example.com/foobar</code>的时候，实际上向服务器发起的请求也是<code>http://example.com/foobar</code>，然而服务器端只能匹配<code>/</code>而无法匹配<code>/foobar</code>，因此会出现404错误。</p><p>因此如果使用了基于History API的路由，需要改造服务器端，使得访问<code>/foobar</code>的时候也能返回<code>index.html</code>文件，这样当浏览器加载了页面及脚本之后，就能进行路由跳转了。</p><h4 id="5-动态路由"><a href="#5-动态路由" class="headerlink" title="5. 动态路由"></a>5. 动态路由</h4><p>上面提到的例子都是静态路由，也就是说，路径都是固定的。但是有时候我们需要在路径中传入参数，例如获取某个用户的信息，我们不可能为每个用户创建一条路由，而是在通过捕获路径中的参数（例如用户id）来实现。</p><p>例如在Express中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">app.get(&apos;/user/:id&apos;, (req, res, next) =&gt; &#123;</span><br><span class="line">  // ... ...</span><br><span class="line">&#125;)</span><br><span class="line">在Flask中：</span><br><span class="line"></span><br><span class="line">@app.route(&apos;/user/&lt;user_id&gt;&apos;)</span><br><span class="line">def get_user_info(user_id):</span><br><span class="line">    pass</span><br></pre></td></tr></table></figure><h4 id="6-严格路由"><a href="#6-严格路由" class="headerlink" title="6. 严格路由"></a>6. 严格路由</h4><p>在很多情况下，会遇到<code>/foobar</code>和<code>/foobar/</code>的情况，它们看起来非常类似，然而实际上有所区别，具体的行为也是视服务器设置而定。</p><p>在Flask的文档中，提到，末尾有斜线的路径，类比于文件系统的一个目录；末尾没有斜线的路径，类比于一个文件。因此访问/foobar的时候，可能会重定向到<code>/foobar/</code>，而反过来则不会。</p><p>如果使用的是<code>Express</code>，默认这两者是一样的，也可以通过<code>app.set</code>来设置<code>strict routing</code>，来区别对待这两种情况。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;web开发中路由route和路由器router到底是什么&lt;/p&gt;
&lt;h3 id=&quot;1-什么是路由&quot;&gt;&lt;a href=&quot;#1-什么是路由&quot; class=&quot;headerlink&quot; title=&quot;1. 什么是路由&quot;&gt;&lt;/a&gt;1. 什么是路由&lt;/h3&gt;&lt;p&gt;在Web开发过程中，经常
      
    
    </summary>
    
      <category term="web" scheme="https://hubhack.github.io/categories/web/"/>
    
    
      <category term="web" scheme="https://hubhack.github.io/tags/web/"/>
    
  </entry>
  
  <entry>
    <title>yaml语言</title>
    <link href="https://hubhack.github.io/book/Yaml%E8%AF%AD%E8%A8%80%E7%BC%96%E7%A8%8B/"/>
    <id>https://hubhack.github.io/book/Yaml语言编程/</id>
    <published>2019-07-01T02:00:31.456Z</published>
    <updated>2019-07-12T14:12:06.062Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Yaml语言编程"><a href="#Yaml语言编程" class="headerlink" title="Yaml语言编程"></a>Yaml语言编程</h3><p>Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便.</p><h2 id="一、简介"><a href="#一、简介" class="headerlink" title="一、简介"></a>一、简介</h2><p>YAML 语言（发音 /ˈjæməl/ ）的设计目标，就是方便人类读写。它实质上是一种通用的数据串行化格式。</p><p>它的基本语法规则如下。</p><blockquote><ul><li>大小写敏感</li><li>使用缩进表示层级关系</li><li>缩进时不允许使用Tab键，只允许使用空格。</li><li>缩进的空格数目不重要，只要相同层级的元素左侧对齐即可</li></ul></blockquote><p><code>#</code> 表示注释，从这个字符一直到行尾，都会被解析器忽略。</p><p>YAML 支持的数据结构有三种。</p><blockquote><ul><li>对象：键值对的集合，又称为映射（mapping）/ 哈希（hashes） / 字典（dictionary）</li><li>数组：一组按次序排列的值，又称为序列（sequence） / 列表（list）</li><li>纯量（scalars）：单个的、不可再分的值</li></ul></blockquote><p>以下分别介绍这三种数据结构。</p><h2 id="二、对象"><a href="#二、对象" class="headerlink" title="二、对象"></a>二、对象</h2><p>对象的一组键值对，使用冒号结构表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; animal: pets</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">animal</span>: <span class="string">'pets'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>Yaml 也允许另一种写法，将所有键值对写成一个行内对象。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; hash: &#123; <span class="attr">name</span>: Steve, <span class="attr">foo</span>: bar &#125; </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">hash</span>: &#123; <span class="attr">name</span>: <span class="string">'Steve'</span>, <span class="attr">foo</span>: <span class="string">'bar'</span> &#125; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="三、数组"><a href="#三、数组" class="headerlink" title="三、数组"></a>三、数组</h2><p>一组连词线开头的行，构成一个数组。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; - Cat</span><br><span class="line">&gt; - Dog</span><br><span class="line">&gt; - Goldfish</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>数据结构的子成员是一个数组，则可以在该项下面缩进一个空格。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&gt; -</span><br><span class="line">&gt;  - Cat</span><br><span class="line">&gt;  - Dog</span><br><span class="line">&gt;  - Goldfish</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span>, <span class="string">'Goldfish'</span> ] ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>数组也可以采用行内表示法。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; animal: [Cat, Dog]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">animal</span>: [ <span class="string">'Cat'</span>, <span class="string">'Dog'</span> ] &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="四、复合结构"><a href="#四、复合结构" class="headerlink" title="四、复合结构"></a>四、复合结构</h2><p>对象和数组可以结合使用，形成复合结构。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; languages:</span><br><span class="line">&gt;  - Ruby</span><br><span class="line">&gt;  - Perl</span><br><span class="line">&gt;  - Python </span><br><span class="line">&gt; websites:</span><br><span class="line">&gt;  YAML: yaml.org </span><br><span class="line">&gt;  Ruby: ruby-lang.org </span><br><span class="line">&gt;  Python: python.org </span><br><span class="line">&gt;  Perl: use.perl.org </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">languages</span>: [ <span class="string">'Ruby'</span>, <span class="string">'Perl'</span>, <span class="string">'Python'</span> ],</span><br><span class="line">&gt;   websites: </span><br><span class="line">&gt;    &#123; <span class="attr">YAML</span>: <span class="string">'yaml.org'</span>,</span><br><span class="line">&gt;      Ruby: <span class="string">'ruby-lang.org'</span>,</span><br><span class="line">&gt;      Python: <span class="string">'python.org'</span>,</span><br><span class="line">&gt;      Perl: <span class="string">'use.perl.org'</span> &#125; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="五、纯量"><a href="#五、纯量" class="headerlink" title="五、纯量"></a>五、纯量</h2><p>纯量是最基本的、不可再分的值。以下数据类型都属于 JavaScript 的纯量。</p><blockquote><ul><li>字符串</li><li>布尔值</li><li>整数</li><li>浮点数</li><li>Null</li><li>时间</li><li>日期</li></ul></blockquote><p>数值直接以字面量的形式表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; number: <span class="number">12.30</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">number</span>: <span class="number">12.30</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>布尔值用<code>true</code>和<code>false</code>表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; isSet: <span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">isSet</span>: <span class="literal">true</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>null</code>用<code>~</code>表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; parent: ~ </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">parent</span>: <span class="literal">null</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>时间采用 ISO8601 格式。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; iso8601: <span class="number">2001</span><span class="number">-12</span><span class="number">-14</span>t21:<span class="number">59</span>:<span class="number">43.10</span><span class="number">-05</span>:<span class="number">00</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">iso8601</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'2001-12-14t21:59:43.10-05:00'</span>) &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>日期采用复合 iso8601 格式的年、月、日表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; date: <span class="number">1976</span><span class="number">-07</span><span class="number">-31</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>(<span class="string">'1976-07-31'</span>) &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>YAML 允许使用两个感叹号，强制转换数据类型。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; e: !!str <span class="number">123</span></span><br><span class="line">&gt; f: !!str <span class="literal">true</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">e</span>: <span class="string">'123'</span>, <span class="attr">f</span>: <span class="string">'true'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="六、字符串"><a href="#六、字符串" class="headerlink" title="六、字符串"></a>六、字符串</h2><p>字符串是最常见，也是最复杂的一种数据类型。</p><p>字符串默认不使用引号表示。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: 这是一行字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'这是一行字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>如果字符串之中包含空格或特殊字符，需要放在引号之中。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: <span class="string">'内容： 字符串'</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'内容: 字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>单引号和双引号都可以使用，双引号不会对特殊字符转义。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; s1: <span class="string">'内容\n字符串'</span></span><br><span class="line">&gt; s2: <span class="string">"内容\n字符串"</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">s1</span>: <span class="string">'内容\\n字符串'</span>, <span class="attr">s2</span>: <span class="string">'内容\n字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>单引号之中如果还有单引号，必须连续使用两个单引号转义。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: <span class="string">'labor'</span><span class="string">'s day'</span> </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'labor\'s day'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>字符串可以写成多行，从第二行开始，必须有一个单空格缩进。换行符会被转为空格。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; str: 这是一段</span><br><span class="line">&gt;   多行</span><br><span class="line">&gt;   字符串</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">str</span>: <span class="string">'这是一段 多行 字符串'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>多行字符串可以使用<code>|</code>保留换行符，也可以使用<code>&gt;</code>折叠换行。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">this</span>: |</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;   Bar</span><br><span class="line">&gt; that: &gt;</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;   Bar</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">this</span>: <span class="string">'Foo\nBar\n'</span>, <span class="attr">that</span>: <span class="string">'Foo Bar\n'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>+</code>表示保留文字块末尾的换行，<code>-</code>表示删除字符串末尾的换行。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt; s1: |</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt; </span><br><span class="line">&gt; s2: |+</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt; </span><br><span class="line">&gt; </span><br><span class="line">&gt; s3: |-</span><br><span class="line">&gt;   Foo</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">s1</span>: <span class="string">'Foo\n'</span>, <span class="attr">s2</span>: <span class="string">'Foo\n\n\n'</span>, <span class="attr">s3</span>: <span class="string">'Foo'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>字符串之中可以插入 HTML 标记。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; message: |</span><br><span class="line">&gt; </span><br><span class="line">&gt;   &lt;p style="color: red"&gt;</span><br><span class="line">&gt;     段落</span><br><span class="line">&gt;   &lt;/p&gt;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; &#123; <span class="attr">message</span>: <span class="string">'\n&lt;p style="color: red"&gt;\n  段落\n&lt;/p&gt;\n'</span> &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="七、引用"><a href="#七、引用" class="headerlink" title="七、引用"></a>七、引用</h2><p>锚点<code>&amp;</code>和别名<code>*</code>，可以用来引用。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; defaults: &amp;defaults</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; development:</span><br><span class="line">&gt;   database: myapp_development</span><br><span class="line">&gt;   &lt;&lt;: *defaults</span><br><span class="line">&gt; </span><br><span class="line">&gt; test:</span><br><span class="line">&gt;   database: myapp_test</span><br><span class="line">&gt;   &lt;&lt;: *defaults</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>等同于下面的代码。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">&gt; defaults:</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; development:</span><br><span class="line">&gt;   database: myapp_development</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt; </span><br><span class="line">&gt; test:</span><br><span class="line">&gt;   database: myapp_test</span><br><span class="line">&gt;   adapter:  postgres</span><br><span class="line">&gt;   host:     localhost</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p><code>&amp;</code>用来建立锚点（<code>defaults</code>），<code>&lt;&lt;</code>表示合并到当前数据，<code>*</code>用来引用锚点。</p><p>下面是另一个例子。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&gt; - &amp;showell Steve </span><br><span class="line">&gt; - Clark </span><br><span class="line">&gt; - Brian </span><br><span class="line">&gt; - Oren </span><br><span class="line">&gt; - *showell </span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>转为 JavaScript 代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; [ <span class="string">'Steve'</span>, <span class="string">'Clark'</span>, <span class="string">'Brian'</span>, <span class="string">'Oren'</span>, <span class="string">'Steve'</span> ]</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><h2 id="八、函数和正则表达式的转换"><a href="#八、函数和正则表达式的转换" class="headerlink" title="八、函数和正则表达式的转换"></a>八、函数和正则表达式的转换</h2><p>这是 <a href="https://github.com/nodeca/js-yaml" target="_blank" rel="noopener">JS-YAML</a> 库特有的功能，可以把函数和正则表达式转为字符串。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; # example.yml</span><br><span class="line">&gt; fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&gt; reg: <span class="regexp">/test/</span></span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>解析上面的 yml 文件的代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> yaml = <span class="built_in">require</span>(<span class="string">'js-yaml'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;   <span class="keyword">var</span> doc = yaml.load(</span><br><span class="line">&gt;     fs.readFileSync(<span class="string">'./example.yml'</span>, <span class="string">'utf8'</span>)</span><br><span class="line">&gt;   );</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(doc);</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(e);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote><p>从 JavaScript 对象还原到 yaml 文件的代码如下。</p><blockquote><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> yaml = <span class="built_in">require</span>(<span class="string">'js-yaml'</span>);</span><br><span class="line">&gt; <span class="keyword">var</span> fs   = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">var</span> obj = &#123;</span><br><span class="line">&gt;   fn: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;,</span><br><span class="line">&gt;   reg: <span class="regexp">/test/</span></span><br><span class="line">&gt; &#125;;</span><br><span class="line">&gt; </span><br><span class="line">&gt; <span class="keyword">try</span> &#123;</span><br><span class="line">&gt;   fs.writeFileSync(</span><br><span class="line">&gt;     <span class="string">'./example.yml'</span>,</span><br><span class="line">&gt;     yaml.dump(obj),</span><br><span class="line">&gt;     <span class="string">'utf8'</span></span><br><span class="line">&gt;   );</span><br><span class="line">&gt; &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">&gt;   <span class="built_in">console</span>.log(e);</span><br><span class="line">&gt; &#125;</span><br><span class="line">&gt;</span><br></pre></td></tr></table></figure></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;Yaml语言编程&quot;&gt;&lt;a href=&quot;#Yaml语言编程&quot; class=&quot;headerlink&quot; title=&quot;Yaml语言编程&quot;&gt;&lt;/a&gt;Yaml语言编程&lt;/h3&gt;&lt;p&gt;Yaml是专门用来写配置文件的语言, 非常简洁和强大.远比json格式方便.&lt;/p&gt;
&lt;h2
      
    
    </summary>
    
      <category term="yaml" scheme="https://hubhack.github.io/categories/yaml/"/>
    
    
      <category term="yaml" scheme="https://hubhack.github.io/tags/yaml/"/>
    
  </entry>
  
  <entry>
    <title>js基础</title>
    <link href="https://hubhack.github.io/book/js%E5%9F%BA%E7%A1%80/"/>
    <id>https://hubhack.github.io/book/js基础/</id>
    <published>2019-06-30T11:53:54.879Z</published>
    <updated>2019-07-01T08:24:16.708Z</updated>
    
    <content type="html"><![CDATA[<h3 id="js基础语法"><a href="#js基础语法" class="headerlink" title="js基础语法"></a>js基础语法</h3><hr><h4 id="常量和变量"><a href="#常量和变量" class="headerlink" title="常量和变量"></a>常量和变量</h4><p>标识符: 标识符必须是字母, 下划线, 美元符号$和数字, 但必须是字母, 下划线,美元符号开头,依然是不能数字开头就行.标识符区分大小写.</p><p>声明</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var声明一个变量</span><br><span class="line"></span><br><span class="line">let声明一个块作用域中的局部变量</span><br><span class="line"></span><br><span class="line">const声明一个常量</span><br><span class="line"></span><br><span class="line">js中的变量声明和初始化时可以分开的.</span><br><span class="line"></span><br><span class="line">var会把变量提升到全局或函数作用域,如果明确知道一个标识符定义后不再修改,应该声明成const常量,减少被修改的风险,减少bug.</span><br></pre></td></tr></table></figure><p>数据类型</p><table><thead><tr><th>序号</th><th>名称</th><th>说明</th></tr></thead><tbody><tr><td>1</td><td>number</td><td>数值型,包括整型和浮点型</td></tr><tr><td>2</td><td>boolean</td><td>布尔型,true和false</td></tr><tr><td>3</td><td>string</td><td>字符串</td></tr><tr><td>4</td><td>null</td><td>只有一个值null</td></tr><tr><td>5</td><td>undefined</td><td>变量声明未赋值的;对象未定义的属性</td></tr><tr><td>6</td><td>symbol</td><td>ES6新引入类型</td></tr><tr><td>7</td><td>object</td><td>是以上基本类型的复合类型,是容器</td></tr></tbody></table><p>弱类型,不需要强制类型转换, 会隐式类型转换.</p><p>NaN,即Not a Number,转换数字失败, 它和任何值都不等,和自己也不等, 只能使用Number.isNaN</p><p>总结:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">遇到字符串, 加号就是拼接字符串,所有非字符串隐式转换为字符串.</span><br><span class="line"></span><br><span class="line">如果没有字符串, 加号把其他所有类型都当做数字处理, 非数字类型隐式转换为数字, undefined特殊, 因为它都没有定义值, 所以转换数字失败得到一个特殊值NaN.</span><br><span class="line"></span><br><span class="line">如果运算符是逻辑运算符, 短路符, 返回就是短路时的类型, 没有隐式转换.</span><br><span class="line"></span><br><span class="line">除非你十分明确, 否则不要依赖隐式转换. 写代码的时候, 往往为了程序的健壮,请隐式转换.</span><br></pre></td></tr></table></figure><h3 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h3><p>条件表达式?真值:假值</p><p>等价于简单的if…else结构</p><p>函数, 匿名函数,函数表达式的差异</p><p>函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数由自己的标识符—函数名, 匿名函数u需要借助其他的标识符而已.</p><p>区别在于, 函数会声明提升, 函数表达式不会 .</p><p>高阶函数: 函数作为参数或返回 一个函数.</p><h4 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> 函数名(<span class="params">参数列表</span>)</span>&#123;</span><br><span class="line">函数体;</span><br><span class="line"><span class="keyword">return</span> 返回值;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line"><span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">3</span>, <span class="number">5</span>));</span><br></pre></td></tr></table></figure><h4 id="函数-匿名函数-函数表达式的差异"><a href="#函数-匿名函数-函数表达式的差异" class="headerlink" title="函数, 匿名函数, 函数表达式的差异"></a>函数, 匿名函数, 函数表达式的差异</h4><p>函数和匿名函数, 本质上都是一样的, 都是函数对象, 只不过函数有自己的标识符 – 函数名, 匿名函数需要借助其他的标识符而已.</p><p>区别在于, 函数会申明提升, 函数表达式不会.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(add(<span class="number">4</span>, <span class="number">6</span>));</span><br><span class="line"><span class="comment">// 匿名函数</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">const</span> sub = <span class="function"><span class="keyword">function</span> (<span class="params">x, y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x -y;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(sub(<span class="number">5</span>, <span class="number">6</span>));</span><br></pre></td></tr></table></figure><p>高阶函数</p><p>高阶函数: 函数作为参数或返回一个函数</p><h3 id="箭头函数"><a href="#箭头函数" class="headerlink" title="箭头函数"></a>箭头函数</h3><p>箭头函数就是匿名函数,它是一种更加精简的格式.</p><p>箭头函数参数</p><ul><li><p>如果一个函数没有参数,使用()</p></li><li><p>如果只有一个参数,参数列表可以省略小括号()</p></li><li><p>多个参数不能省略小括号,且使用逗号间隔.</p></li></ul><p><strong>箭头函数返回值.</strong></p><p>如果函数体部分有多行,就需要使用{}, 如果有返回值使用return.</p><p>如果只有一行语句, 可以同时省略大括号和return.</p><p>只有return语句, 就不能省略大括号, </p><p>如果只有一条非return语句, 加上大括号, 函数就成了无返回值, </p><h4 id="函数参数"><a href="#函数参数" class="headerlink" title="函数参数"></a>函数参数</h4><h5 id="普通参数"><a href="#普通参数" class="headerlink" title="普通参数"></a>普通参数</h5><p>一个参数占一个位置,支持默认参数.</p><p>可变参数(rest parameters剩余参数)</p><p>js使用…表示可变参数(python用*手机多个参数)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">...args</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">let</span> result = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> x <span class="keyword">in</span> args)&#123;</span><br><span class="line">result += args[x]</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(sum(<span class="number">3</span>, <span class="number">6</span>, <span class="number">9</span>))</span><br></pre></td></tr></table></figure><h4 id="arguments对象"><a href="#arguments对象" class="headerlink" title="arguments对象"></a>arguments对象</h4><p>函数的所有参数会被保存在一个arguments的键值对对象中.</p><h4 id="参数解构"><a href="#参数解构" class="headerlink" title="参数解构"></a>参数解构</h4><p>和python类似, js提供了参数解构, 依然使用了…符号来结构.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> add = <span class="function">(<span class="params">x, y</span>) =&gt;</span>&#123;<span class="built_in">console</span>.log(x, y); <span class="keyword">return</span> x + y&#125;;</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>, <span class="number">200</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>, <span class="number">200</span>, <span class="number">300</span>]))</span><br><span class="line"><span class="built_in">console</span>.log(add(...[<span class="number">100</span>]))</span><br></pre></td></tr></table></figure><h4 id="函数返回值"><a href="#函数返回值" class="headerlink" title="函数返回值"></a>函数返回值</h4><p>python中可以使用return 1, 2 返回多值, 本质也是一个值, 就是一个元组.</p><p>表达式的值</p><p>类c的语言,都有一个概念 – 表达式的值</p><p>赋值表达式的值: 等号右边的值</p><p>逗号表达式的值:类c语言, 都支持逗号表达式, 逗号表达式的值, 就是最后一个表达式的值.</p><h3 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h3><p>抛出异常</p><p>js的异常语法和java相同, 使用throw关键字抛出.</p><p>使用throw关键字可以抛出任意对象的异常.</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'new error'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">ReferenceError</span>(<span class="string">'Ref Error'</span>);</span><br><span class="line"><span class="keyword">throw</span> <span class="number">1</span>;</span><br><span class="line"><span class="keyword">throw</span> <span class="string">'not ok'</span>;</span><br></pre></td></tr></table></figure><h4 id="捕获异常"><a href="#捕获异常" class="headerlink" title="捕获异常"></a>捕获异常</h4><p>try…catch语句捕获异常</p><p>try …catch…finally 语句捕获异常, finally保证最终一定执行.</p><h4 id="问题-null和undefined的异同"><a href="#问题-null和undefined的异同" class="headerlink" title="问题: null和undefined的异同"></a>问题: null和undefined的异同</h4><p>1.undefined：是所有没有赋值变量的默认值，自动赋值。</p><p>2.null：主动释放一个变量引用的对象，表示一个变量不再指向任何对象地址。</p><p>当使用完一个比较大的对象时，需要对其进行释放内存时，设置为 null。</p><p><strong>共同点</strong>：都是原始类型，保存在栈中变量本地。</p><p>不同点：</p><p>undefined——表示变量声明过但并未赋过值。</p><p>它是所有未赋值变量默认值，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var a;    // a 自动被赋值为 undefined</span><br></pre></td></tr></table></figure><p>null——表示一个变量将来可能指向一个对象。</p><p>一般用于主动释放指向对象的引用，例如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var emps = [&apos;ss&apos;,&apos;nn&apos;];</span><br><span class="line"> emps = null;     // 释放指向数组的引用</span><br></pre></td></tr></table></figure><p>它是专门释放对象内存的一个程序。</p><ul><li>在底层，后台伴随当前程序同时运行；引擎会定时自动调用垃圾回收期；</li><li>总有一个对象不再被任何变量引用时，才释放</li></ul>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;js基础语法&quot;&gt;&lt;a href=&quot;#js基础语法&quot; class=&quot;headerlink&quot; title=&quot;js基础语法&quot;&gt;&lt;/a&gt;js基础语法&lt;/h3&gt;&lt;hr&gt;
&lt;h4 id=&quot;常量和变量&quot;&gt;&lt;a href=&quot;#常量和变量&quot; class=&quot;headerlink&quot; t
      
    
    </summary>
    
      <category term="前端" scheme="https://hubhack.github.io/categories/%E5%89%8D%E7%AB%AF/"/>
    
    
      <category term="JavaScrript" scheme="https://hubhack.github.io/tags/JavaScrript/"/>
    
  </entry>
  
  <entry>
    <title>魔术方法</title>
    <link href="https://hubhack.github.io/book/%E9%AD%94%E6%9C%AF%E6%96%B9%E6%B3%95/"/>
    <id>https://hubhack.github.io/book/魔术方法/</id>
    <published>2019-06-23T14:04:28.585Z</published>
    <updated>2019-06-19T14:49:09.429Z</updated>
    
    <content type="html"><![CDATA[<h3 id="特殊属性"><a href="#特殊属性" class="headerlink" title="特殊属性"></a>特殊属性</h3><table><thead><tr><th>属性</th><th>含义</th></tr></thead><tbody><tr><td>__name__</td><td>类,函数,方法等名字</td></tr><tr><td>__module__</td><td>类定义所在的模块名</td></tr><tr><td>__class__</td><td>对象或类所属的类</td></tr><tr><td>__base__</td><td>类的基类的元组,顺序为他们在基类中出现的顺序</td></tr><tr><td>__doc__</td><td>类, 函数的文档字符串, 如果没有定义则为None</td></tr><tr><td>__mro__</td><td>类的mro, class.mro()返回的结果的保存在__mro__ 中</td></tr><tr><td>__dict__</td><td>类或实例的属性, 可写的字典</td></tr></tbody></table><h3 id="查看属性"><a href="#查看属性" class="headerlink" title="查看属性"></a>查看属性</h3><p>__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.</p><p>如果dir()参数obj包括方法_<em>dir__(), 该方法将被调用.如果参数obj不包含\</em>_dir__(), 该方法将最大限度地收集属性信息.</p><p>dir(obj)对于不同类型的对象obj具有不同的行为:</p><ul><li>如果对象是模块对象, 返回的列表包含模块的属性名和变量名</li><li>如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名</li><li>如果是类的实例<ul><li>有__dir__方法, 返回可迭代对象的返回值</li><li>没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名</li></ul></li><li>如果obj不写, 返回列表包含内容不同<ul><li>在模块中, 返回模块的属性和变量名</li><li>在函数中, 返回本地作用域的变量名</li><li>在方法中,  返回本地作用域的变量名</li></ul></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># animal.py</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Animal</span>:</span></span><br><span class="line">    x = <span class="number">123</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name)</span>:</span></span><br><span class="line">self._name = name</span><br><span class="line">        self.__age = <span class="number">10</span></span><br><span class="line">        self.weight = <span class="number">20</span></span><br><span class="line"> </span><br><span class="line">print(<span class="string">'animal Module\ s names = &#123;&#125;'</span>.format(dir()))<span class="comment"># 模块的属性 )</span></span><br></pre></td></tr></table></figure><h3 id="魔术方法"><a href="#魔术方法" class="headerlink" title="魔术方法***"></a>魔术方法***</h3><hr><ul><li><p>分类:</p><ul><li><p>创建, 初始化与销毁</p></li><li><p>可视化</p></li><li>hash</li><li>bool</li><li>运算符重载</li><li>容器和大小</li><li>可调用对象</li><li>上下文管理</li><li>反射</li><li>描述器</li><li>其他杂项</li></ul></li></ul><h4 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__new__</td><td>实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法</td></tr></tbody></table><p>__new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回</p><h4 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h4><hr><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__str__</td><td>str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息</td></tr><tr><td>__repr__</td><td>内建函数repr()对一个对象获取<strong>字符串</strong>表达</td></tr><tr><td>__bytes__</td><td>bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象</td></tr></tbody></table><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, age = <span class="number">18</span>)</span>:</span></span><br><span class="line">self.name = name</span><br><span class="line">        self.age = age</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__repr__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">'repr:&#123;&#125;&#123;&#125;'</span>.format(self.name, self.age)</span><br></pre></td></tr></table></figure><h4 id="hash"><a href="#hash" class="headerlink" title="hash"></a>hash</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__hash__</td><td>内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash</td></tr><tr><td>__eq__</td><td>对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了</td></tr></tbody></table><h4 id="bool"><a href="#bool" class="headerlink" title="bool"></a>bool</h4><table><thead><tr><th>方法</th><th>意义</th></tr></thead><tbody><tr><td>__bool__</td><td>内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真</td></tr></tbody></table><h3 id="上下文管理"><a href="#上下文管理" class="headerlink" title="上下文管理"></a>上下文管理</h3><p>文件IO操作可以对文件对象使用上下文管理，使用with。。as语法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'test'</span>) <span class="keyword">as</span> f:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>仿照上例写一个自己的泪，实现上下文管理</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span>:</span></span><br><span class="line"><span class="keyword">pass</span></span><br><span class="line"><span class="keyword">with</span> Point <span class="keyword">as</span> p:</span><br><span class="line"><span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>提示属性错误，没有__exit__，看了需要这个属性</p><p>某些版本会显示没有__enter__</p><p>上下文管理对象</p><p>当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象</p><p>__enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上</p><p>__exit__退出与此对象相关的上下文</p><p>with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作</p><p>注意,with 并不开启一个新的作用域</p><p>上下文管理是安全的</p><p>上下文应用场景</p><p>1.增强功能</p><p>在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能</p><p>2.资源管理</p><p>打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等</p><p>3.权限验证</p><p>在执行代码之前,做权限验证,在__enter__</p><h4 id="contextilb-contextmanager"><a href="#contextilb-contextmanager" class="headerlink" title="contextilb.contextmanager"></a>contextilb.contextmanager</h4><p>他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法</p><p>对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.</p><p>也就是这个装饰器接受一个生成器对象作为参数.</p><p>总结</p><p>如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便</p><h3 id="反射"><a href="#反射" class="headerlink" title="反射"></a>反射</h3><p>概述</p><p>运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候</p><p>反射,  reflection, 指的是运行时获取类型定义信息</p><p>一个对象能够在运行时,像照镜子一样,反射出其类型信息</p><p>简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身</p><p>具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等</p><h4 id="反射相关的函数和方法"><a href="#反射相关的函数和方法" class="headerlink" title="反射相关的函数和方法"></a>反射相关的函数和方法</h4><table><thead><tr><th>getattar</th><th>通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串.</th></tr></thead><tbody><tr><td>setattar</td><td>object的属性存在,这覆盖, 不存在,新增</td></tr><tr><td>hasattat</td><td>判断对象是否有这个名字的属性,name必须为字符串</td></tr></tbody></table><h4 id="反射相关的魔术方法"><a href="#反射相关的魔术方法" class="headerlink" title="反射相关的魔术方法"></a>反射相关的魔术方法</h4><p>__getattr__(), __setattr__(), __delattr__(), 三个魔术方法</p><p>实例属性会按照继承关系找,  如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出</p><p>AttributeError异常表示找不到属性.</p><p>查找属性顺序为:</p><p>instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;特殊属性&quot;&gt;&lt;a href=&quot;#特殊属性&quot; class=&quot;headerlink&quot; title=&quot;特殊属性&quot;&gt;&lt;/a&gt;特殊属性&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;属性&lt;/th&gt;
&lt;th&gt;含义&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbod
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>面向对象</title>
    <link href="https://hubhack.github.io/book/%E9%9D%A2%E5%90%91%E5%AF%B9%E8%B1%A1/"/>
    <id>https://hubhack.github.io/book/面向对象/</id>
    <published>2019-06-23T14:04:28.568Z</published>
    <updated>2019-06-19T14:48:56.747Z</updated>
    
    <content type="html"><![CDATA[<h2 id="语言的分类"><a href="#语言的分类" class="headerlink" title="语言的分类"></a>语言的分类</h2><p>面向机器:抽象成机器指令, 机器容易理解.<br>代表:汇编语言<br>面向过程:<br>做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.<br>问题规模小, 可以步骤化.按部就班处理.<br>代表:c语言<br>面向对象OOP<br>随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.<br>代表:C++, java, python等</p><h2 id="面向对象"><a href="#面向对象" class="headerlink" title="面向对象"></a>面向对象</h2><p>类:class<br>类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.<br>用计算机语言来描述类,是属性和方法的集合.<br>对象:instance, object<br>对象是类的具象, 是一个实体.<br>对于我们每个人这个个体, 都是抽象概念人类不同的实体.</p><p>属性:它是对象状态的抽象,用数据结构来描述.<br>操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.<br>哲学:<br>一切皆对象<br>对象是数据和操作的封装.<br>对象是独立的,但是对象之间可以相互作用.<br>目前OOP是最接近人类认知的编程范式.</p><h2 id="三要素"><a href="#三要素" class="headerlink" title="三要素"></a>三要素</h2><p>1.封装<br>组装:将数据和操作组装到一起.<br>隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的<br>构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.<br>2.继承<br>多复用,继承来的就不用了自己写了<br>多继承少修改,OCP,使用继承来改变,来体现个性.<br>3.多态<br>面向对象编程最灵活的地方,动态绑定<br>人类就是封装<br>人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:<br>多态,继承自动物类的人类,猫类的操作’吃’不同.</p><p>python的类:<br>1.必须使用class关键字<br>2.类名必须使用大驼峰命名<br>3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.</p><h2 id="类对象及类属性"><a href="#类对象及类属性" class="headerlink" title="类对象及类属性"></a>类对象及类属性</h2><p>类对象,类的定义执行后会生成一个类对象.<br>类的属性,类定义中的变量和类中定义的方法都是类的属性.<br>类变量,<br>self指代当前实例本身.</p><h2 id="实例化"><a href="#实例化" class="headerlink" title="实例化"></a>实例化</h2><p>a = Myclass() # 实例化<br>使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.<br>实例化就真正创建一个该类的对象<br>tom = Person()<br>jerry = Person()<br>每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.<br>python类实例化后, 会调用<strong>init</strong>方法,这个方法第一个形式参数必须留给self,其他参数随意.<br><strong>init</strong>方法</p><p>注意:<strong>init</strong>()方法不能有返回值,也就是只能是return None</p><p>实例对象instance<br>类实例化后一定会获得一个类的实例,就是实例对象<br><strong>init</strong>方法的第一参数self就是指代某一个实例自身.<br>类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.</p><p>实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.</p><p>总结:<br>是类的,也就是这个类所有实例的,器实例都可以访问到:<br>是实例的,就是这个实例自己的,通过类访问不到.<br>类变量是属于类的变量,这个类的所有实例可以共享这个变量.<br>对象可以动态的给自己增加一个属性.<br>实例属性的查找顺序<br>指的是实例使用,.点号来访问属性.会先找自己的<strong>dict</strong>,如果没有,然后通过属性<strong>class</strong>找到自家的类, 再去类的<strong>dict</strong>中找.<br>注意:如果实例使用<strong>dict</strong>访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.</p><p>一般来说, 类变量可使用全大写来命名.</p><h2 id="类方法和静态方法"><a href="#类方法和静态方法" class="headerlink" title="类方法和静态方法"></a>类方法和静态方法</h2><p>类方法:<br>1.在类定义中,使用@classmethod装饰器的方法<br>2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.<br>3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改<br>4.通过cls可以直接操作类的属性.<br>静态方法:<br>在类定义中, 使用@staticmethod装饰器的方法<br>2在调用时, 不会隐式的传入参数.<br>静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.</p><p>类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,<br>原因是第一参数必须是类的实例.<br>总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.<br>实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.<br>实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.</p><p>访问控制:<br>私有属性<br>私有属性,使用双下划线开头的属性名就是私有属性.</p><p>私有属性的本质:<br>类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.</p><p>保护变量:<br>在变量名前使用一个下划线,称为保护变量<br>这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.<br>私有方法:<br>参照保护变量,私有变量,使用单下划线,双下化线的命名方法,</p><h2 id="补丁"><a href="#补丁" class="headerlink" title="补丁"></a>补丁</h2><p>可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变<br>猴子补丁:<br>在运行时,对属性,方法,函数,等进行动态替换<br>其目的往往是为了通过替换,修改来增强,扩展原有代码的能力</p><h2 id="属性装饰器"><a href="#属性装饰器" class="headerlink" title="属性装饰器"></a>属性装饰器</h2><p>一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.</p><p>property装饰器</p><p>后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性<br>setter装饰器<br>可以控制是否删除属性,很少用<br>deleter装饰器<br>可以控制是否删除属性,很少用<br>property装饰器必须在前,setter deleter装饰器在后,<br>property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.</p><h2 id="对象的销毁"><a href="#对象的销毁" class="headerlink" title="对象的销毁"></a>对象的销毁</h2><p>类中可以定义<strong>del</strong>方法 ,称为析构函数.<br>作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.<br>注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.<br>使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用<strong>del</strong>方法.<br>由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.<br>封装:<br>将数据和操作组织到类中,即属性和方法.<br>将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.<br>通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;语言的分类&quot;&gt;&lt;a href=&quot;#语言的分类&quot; class=&quot;headerlink&quot; title=&quot;语言的分类&quot;&gt;&lt;/a&gt;语言的分类&lt;/h2&gt;&lt;p&gt;面向机器:抽象成机器指令, 机器容易理解.&lt;br&gt;代表:汇编语言&lt;br&gt;面向过程:&lt;br&gt;做一件事,排出个步骤,第一
      
    
    </summary>
    
      <category term="python" scheme="https://hubhack.github.io/categories/python/"/>
    
    
      <category term="python" scheme="https://hubhack.github.io/tags/python/"/>
    
  </entry>
  
  <entry>
    <title>草稿</title>
    <link href="https://hubhack.github.io/book/%E8%8D%89%E7%A8%BF/"/>
    <id>https://hubhack.github.io/book/草稿/</id>
    <published>2019-06-23T14:04:28.545Z</published>
    <updated>2019-07-25T06:09:46.636Z</updated>
    
    <content type="html"><![CDATA[<p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p><p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;none 与NUll的区别&lt;br&gt;表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为&lt;br&gt;0,因为0是有意义的,而none是一个特殊的空值&lt;br&gt;判断的时候 均是false&lt;br&gt;属性不同:使用dir()函数返回参数的属性,方法列表
      
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>网络协议</title>
    <link href="https://hubhack.github.io/book/%E7%BD%91%E7%BB%9C%E5%8D%8F%E8%AE%AE/"/>
    <id>https://hubhack.github.io/book/网络协议/</id>
    <published>2019-06-23T14:04:28.528Z</published>
    <updated>2019-07-25T06:33:42.653Z</updated>
    
    <content type="html"><![CDATA[<h3 id="OSI参考模型"><a href="#OSI参考模型" class="headerlink" title="OSI参考模型"></a>OSI参考模型</h3><table><thead><tr><th>模型</th><th>说明</th></tr></thead><tbody><tr><td>应用层</td><td>访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等.</td></tr><tr><td>表示层</td><td>提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码.</td></tr><tr><td>会话层</td><td>建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传.</td></tr><tr><td>传输层</td><td>提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket).</td></tr><tr><td>网络层</td><td>为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF.</td></tr><tr><td>链路层</td><td>在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 .</td></tr><tr><td>物理层</td><td>为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准.</td></tr></tbody></table><h3 id="网络协议"><a href="#网络协议" class="headerlink" title="网络协议"></a>网络协议</h3><table><thead><tr><th>链路层和物理层</th><th>描述</th></tr></thead><tbody><tr><td>ARP(地址解析协议)</td><td>IP地址——-&gt;MAC地址</td></tr><tr><td>RARP</td><td>MAC地址——&gt;IP地址（逆向的）</td></tr><tr><td>PPP协议</td><td>拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样</td></tr><tr><td>MAC地址</td><td>48位全球唯一,网络设备的身份识别</td></tr></tbody></table><table><thead><tr><th>网络层</th><th>描述</th></tr></thead><tbody><tr><td>IP协议</td><td>IP:（分为IPV4（168….）和IPV6（16进制用：隔开））</td></tr><tr><td>ICMP（Internet控制管理协议）</td><td>ping命令属于ICMP</td></tr><tr><td>IGMP（Internet分组管理协议）</td><td>广播，组播</td></tr></tbody></table><table><thead><tr><th>传输层</th><th>描述</th></tr></thead><tbody><tr><td>TCP（传输控制协议)</td><td>面向连接，可靠,效率低，一对一的可靠数据传输的协议</td></tr><tr><td>UDP（用户数据报协议）</td><td>面向无连接，不可靠，效率高，提供不可靠的数据尽力传输</td></tr><tr><td>SCTP</td><td>是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信</td></tr></tbody></table><table><thead><tr><th>应用层</th><th>描述</th></tr></thead><tbody><tr><td>网页访问协议</td><td>HTTP HTTPS(S是安全)</td></tr><tr><td>邮件发送接收协议</td><td>POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件）</td></tr><tr><td>FTP</td><td>文件传输协议</td></tr><tr><td>Telnet（明文传输）/SSH（安全）</td><td>远程登录</td></tr></tbody></table><table><thead><tr><th>嵌入式</th><th>描述</th></tr></thead><tbody><tr><td>NTP</td><td>网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的）</td></tr><tr><td>SNMP(开源（SNMP.NET）)</td><td>简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置</td></tr><tr><td>RTP/RTSP</td><td>用传输音视频传输（监控等）</td></tr></tbody></table><h3 id="中继系统"><a href="#中继系统" class="headerlink" title="中继系统"></a>中继系统</h3><p>中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。</p><h3 id="中继系统之集线器"><a href="#中继系统之集线器" class="headerlink" title="中继系统之集线器"></a>中继系统之集线器</h3><p>光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。</p><p>这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。</p><h3 id="中继系统之交换机"><a href="#中继系统之交换机" class="headerlink" title="中继系统之交换机"></a>中继系统之交换机</h3><p>还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：<strong>有记忆功能</strong>。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？</p><p>交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。</p><p>如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。</p><h3 id="中继系统之路由器"><a href="#中继系统之路由器" class="headerlink" title="中继系统之路由器"></a>中继系统之路由器</h3><p>路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。</p><h3 id="端口"><a href="#端口" class="headerlink" title="端口"></a>端口</h3><p>IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。</p><p><strong><em>这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。</em></strong></p><h3 id="socket"><a href="#socket" class="headerlink" title="socket"></a>socket</h3><p>socket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.</p><h3 id="arp协议"><a href="#arp协议" class="headerlink" title="arp协议"></a>arp协议</h3><p>因为ip数据包是在以太网数据包里发送, 所以我们必须同时知道两个地址, 一个是对方的MAC地址, 另一个是对方的IP地址, 通常情况下, 对方的IP地址是已知的, 但是我们不知道它的mac地址.<br>所以, 我们需要一种地址, 能够从ip地址得到mac地址.<br>这里又可以分成两种情况。第一种情况，如果两台主机不在同一个子网络，那么事实上没有办法得到对方的MAC地址，只能把数据包传送到两个子网络连接处的”网关”（gateway），让网关去处理。</p><p>第二种情况，如果两台主机在同一个子网络，那么我们可以用ARP协议，得到对方的MAC地址。ARP协议也是发出一个数据包（包含在以太网数据包中），其中包含它所要查询主机的IP地址，在对方的MAC地址这一栏，填的是FF:FF:FF:FF:FF:FF，表示这是一个”广播”地址。它所在子网络的每一台主机，都会收到这个数据包，从中取出IP地址，与自身的IP地址进行比较。如果两者相同，都做出回复，向对方报告自己的MAC地址，否则就丢弃这个包。</p><p>总之，有了ARP协议之后，我们就可以得到同一个子网络内的主机MAC地址，可以把数据包发送到任意一台主机之上了。</p><h3 id="路由Routing"><a href="#路由Routing" class="headerlink" title="路由Routing"></a>路由Routing</h3><p>跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.</p><p>路由器上维护着路由表,他知道如何将数据包发往另外的网络.</p><p>windows使用route print, liunx使用route -n可以查看路由表.</p><p>路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.</p><p>静态路由:有管理员手动配置的固定的路由信息</p><p>动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h3 id=&quot;OSI参考模型&quot;&gt;&lt;a href=&quot;#OSI参考模型&quot; class=&quot;headerlink&quot; title=&quot;OSI参考模型&quot;&gt;&lt;/a&gt;OSI参考模型&lt;/h3&gt;&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;模型&lt;/th&gt;
&lt;th&gt;说明&lt;/th&gt;
&lt;/tr&gt;
&lt;/
      
    
    </summary>
    
      <category term="网络原理" scheme="https://hubhack.github.io/categories/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
    
      <category term="网络原理" scheme="https://hubhack.github.io/tags/%E7%BD%91%E7%BB%9C%E5%8E%9F%E7%90%86/"/>
    
  </entry>
  
  <entry>
    <title>深入理解计算机系统</title>
    <link href="https://hubhack.github.io/book/%E6%B7%B1%E5%85%A5%E7%90%86%E8%A7%A3%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%B3%BB%E7%BB%9F/"/>
    <id>https://hubhack.github.io/book/深入理解计算机系统/</id>
    <published>2019-06-23T14:04:28.491Z</published>
    <updated>2019-06-19T14:48:44.301Z</updated>
    
    <content type="html"><![CDATA[<p>源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.<br>源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制<br>堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.<br>内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.</p><h1 id="程序结构和执行"><a href="#程序结构和执行" class="headerlink" title="程序结构和执行"></a>程序结构和执行</h1><h2 id="信息存储"><a href="#信息存储" class="headerlink" title="信息存储"></a>信息存储</h2><p>大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.<br>一个字节包括8位,在二进制表示法中,00000000<code>11111111  0</code>255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.<br>2进制</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.&lt;br&gt;源程序 -&amp;gt;预处理器(cpp) -&amp;gt;编译器(cc1)-&amp;gt;汇编器-&amp;gt;链接器-可执行二进制&lt;br&gt;堆:代码和数据去后紧随着的是运行时堆.代码和
      
    
    </summary>
    
      <category term="系统" scheme="https://hubhack.github.io/categories/%E7%B3%BB%E7%BB%9F/"/>
    
    
      <category term="系统" scheme="https://hubhack.github.io/tags/%E7%B3%BB%E7%BB%9F/"/>
    
  </entry>
  
</feed>
