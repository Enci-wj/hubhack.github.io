{"meta":{"version":1,"warehouse":"2.2.0"},"models":{"Asset":[{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/README.md","path":"lib/canvas-nest/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest-nomobile.min.js","path":"lib/canvas-nest/canvas-nest-nomobile.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","path":"lib/canvas-nest/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/muse.js","path":"js/src/schemes/muse.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"3228a58ed0ece9f85e1e3136352094080b8dece1","modified":1551403681000},{"_id":"themes/next/.eslintrc.json","hash":"cc5f297f0322672fe3f684f823bc4659e4a54c41","modified":1551403681000},{"_id":"themes/next/.all-contributorsrc","hash":"e32dc4075e304af04b98d0726d489081bea722c0","modified":1551403681000},{"_id":"themes/next/.gitattributes","hash":"44bd4729c74ccb88110804f41746fec07bf487d4","modified":1551403681000},{"_id":"themes/next/LICENSE.md","hash":"18144d8ed58c75af66cb419d54f3f63374cd5c5b","modified":1551403681000},{"_id":"themes/next/.editorconfig","hash":"792fd2bd8174ece1a75d5fd24ab16594886f3a7f","modified":1551403681000},{"_id":"themes/next/README.md","hash":"b4f780a96b0e5d3737eb93bc00da6de91f042c4b","modified":1551403681000},{"_id":"themes/next/.stylintrc","hash":"b28e24704a5d8de08346c45286574c8e76cc109f","modified":1551403681000},{"_id":"themes/next/bower.json","hash":"a5ffaa8d88f0f66d15158917b3798e5e38363262","modified":1551403681000},{"_id":"themes/next/.travis.yml","hash":"3d1dc928c4a97933e64379cfde749dedf62f252c","modified":1551403681000},{"_id":"themes/next/.gitignore","hash":"a18c2e83bb20991b899b58e6aeadcb87dd8aa16e","modified":1551403681000},{"_id":"themes/next/package.json","hash":"f3b4ef65214cec9c37acd10ef080526fb1ea14bb","modified":1551403681000},{"_id":"themes/next/crowdin.yml","hash":"e026078448c77dcdd9ef50256bb6635a8f83dca6","modified":1551403681000},{"_id":"themes/next/_config.yml","hash":"4d9773ef84a47d94ec1c635851649971965883a1","modified":1553930837303},{"_id":"themes/next/gulpfile.coffee","hash":"48d2f9fa88a4210308fc41cc7d3f6d53989f71b7","modified":1551403681000},{"_id":"source/_posts/1 (1).md","hash":"799e85fb78ddb77e07dd4c47562897c60c5a55b5","modified":1560955784230},{"_id":"source/_posts/1 (10).md","hash":"956edbe0a4d488b9b79598a2d9516025d2041fdc","modified":1560955499257},{"_id":"source/_posts/1 (12).md","hash":"16a6e75047f294ba399d1c1325ec9426599a7da5","modified":1560955702337},{"_id":"source/_posts/1 (14).md","hash":"bd11c629d8364ac907a4959766a78e924e4c5987","modified":1560955555339},{"_id":"source/_posts/1 (13).md","hash":"bb874aafc0f46750558cf2aa1671a10089009226","modified":1560955668442},{"_id":"source/_posts/1 (11).md","hash":"f43416f02499f1757fc0f4acce5dbdaa696d5b6f","modified":1560955755394},{"_id":"source/_posts/1 (16).md","hash":"4c2b8923eab2e76e1dfebcfdca1023c18c34596d","modified":1560955695380},{"_id":"source/_posts/1 (15).md","hash":"431f9d2cbe5f20abc822e17a097f548dfbb3acaf","modified":1560955708808},{"_id":"source/_posts/1 (17).md","hash":"bca48f38a92ecdbf39b0d3859c4945f0eddb32e6","modified":1560955716385},{"_id":"source/_posts/1 (18).md","hash":"8d81d53b1d2f7df3028ecb42580737c4a0fe55a2","modified":1560955682388},{"_id":"source/_posts/1 (2).md","hash":"8296a6a96f3b6862f6ca3fb322637cdab145ce7f","modified":1560955661472},{"_id":"source/_posts/1 (19).md","hash":"bdde389ce728ab0750dd07690f0de4cb29f33d62","modified":1560955630292},{"_id":"source/_posts/1 (20).md","hash":"60b592897600b1a5ecdb067f13add856c9e14bf0","modified":1560955618076},{"_id":"source/_posts/1 (21).md","hash":"9643887c51faa5667ccb046683c7eab006dfa683","modified":1560955743134},{"_id":"source/_posts/1 (22).md","hash":"8c5d66c8f88699612929e6c031c359b6dc046679","modified":1560955761051},{"_id":"source/_posts/1 (23).md","hash":"19508e7a9d77ad13f6bc67b2fb7001b55f4d483b","modified":1560955804679},{"_id":"source/_posts/1 (24).md","hash":"592e7130740ae0eb4cfd06df6297a5631c6724eb","modified":1560955736747},{"_id":"source/_posts/1 (25).md","hash":"558b0e65e08788dda19d91f55675f6f9472d3db9","modified":1560955766925},{"_id":"source/_posts/1 (27).md","hash":"53a96a62fbe8b4606f592ab6f62b70f0ba07aa3b","modified":1560955724301},{"_id":"source/_posts/1 (3).md","hash":"87ab94e9a35e783fee422375982de36e6919514f","modified":1560955790767},{"_id":"source/_posts/1 (4).md","hash":"f44a0bd9188a879b6cabc8bfa249b47d9d77f77a","modified":1560955730730},{"_id":"source/_posts/1 (26).md","hash":"8a9b3dce0f295604e05dea79dad518893db7b7fe","modified":1560955749429},{"_id":"source/_posts/1 (5).md","hash":"9462df420a79fe9f09358e5ba28aecf4fe040e7c","modified":1560955596504},{"_id":"source/_posts/1 (7).md","hash":"239fb62d288a8c4aff543a6bbf1ddd66dea71e15","modified":1560955567833},{"_id":"source/_posts/1 (6).md","hash":"d5a414c96768014889e14d48d9a647f88fe46ad4","modified":1560955637090},{"_id":"source/_posts/1 (8).md","hash":"682497f30a3bb310f86e0e90991a2b5fe579fbbf","modified":1560955644952},{"_id":"source/categories/index.md","hash":"457748624fb50ff0deda839c88c21c0e3350f09d","modified":1553661344892},{"_id":"source/_posts/1 (9).md","hash":"a3f4e318c33df50a535739df92d398e084d53b30","modified":1560955651806},{"_id":"source/about/index.md","hash":"9262aaa7b74d970d462bcb950a97688f7368ecd9","modified":1553661280473},{"_id":"source/tags/index.md","hash":"dfee9637471fd485759cfcffe5929e9aae76291e","modified":1553661352040},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"a5335a99377069ae76fd993d488bc3eaf48f3a05","modified":1551403681000},{"_id":"source/archives/index.md","hash":"5071f9db6d18066bb61043f322d1c17752cee16d","modified":1553661314218},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"00c25366764e6b9ccb40b877c60dc13b2916bbf7","modified":1551403681000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1cb29a0e54ef390f73cb85f254000d4b57460dae","modified":1551403681000},{"_id":"themes/next/.github/CODE_OF_CONDUCT.md","hash":"b63696d41f022525e40d7e7870c3785b6bc7536b","modified":1551403681000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1551403681000},{"_id":"themes/next/docs/AUTHORS.md","hash":"7b24be2891167bdedb9284a682c2344ec63e50b5","modified":1551403681000},{"_id":"themes/next/docs/ALGOLIA-SEARCH.md","hash":"141e989844d0b5ae2e09fb162a280715afb39b0d","modified":1551403681000},{"_id":"themes/next/docs/AGPL3.md","hash":"0d2b8c5fa8a614723be0767cc3bca39c49578036","modified":1551403681000},{"_id":"themes/next/docs/DATA-FILES.md","hash":"8e1962dd3e1b700169b3ae5bba43992f100651ce","modified":1551403681000},{"_id":"themes/next/docs/INSTALLATION.md","hash":"2bbdd6c1751b2b42ce9b9335da420c6026a483e9","modified":1551403681000},{"_id":"themes/next/docs/LICENSE.txt","hash":"368bf2c29d70f27d8726dd914f1b3211cae4bbab","modified":1551403681000},{"_id":"themes/next/docs/LEANCLOUD-COUNTER-SECURITY.md","hash":"212a36d57495990b5f56e46ca8dce1d76c199660","modified":1551403681000},{"_id":"themes/next/docs/UPDATE-FROM-5.1.X.md","hash":"ad57c168d12ba01cf144a1ea0627b2ffd1847d3e","modified":1551403681000},{"_id":"themes/next/docs/MATH.md","hash":"e6023505dcccaef0b856102543585a13fc6af0b1","modified":1551403681000},{"_id":"themes/next/.github/stale.yml","hash":"a782ac925201a8fe07959bba0d7696c7b2b5fd2d","modified":1551403681000},{"_id":"themes/next/languages/en.yml","hash":"c540c3a0d7db2d4239293c8783881962640b6c34","modified":1551403681000},{"_id":"themes/next/languages/default.yml","hash":"ea5e6aee4cb14510793ac4593a3bddffe23e530c","modified":1551403681000},{"_id":"themes/next/languages/de.yml","hash":"fb478c5040a4e58a4c1ad5fb52a91e5983d65a3a","modified":1551403681000},{"_id":"themes/next/languages/fr.yml","hash":"0162a85ae4175e66882a9ead1249fedb89200467","modified":1551403681000},{"_id":"themes/next/languages/it.yml","hash":"62ef41d0a9a3816939cb4d93a524e6930ab9c517","modified":1551403681000},{"_id":"themes/next/languages/ko.yml","hash":"fae155018ae0efdf68669b2c7dd3f959c2e45cc9","modified":1551403681000},{"_id":"themes/next/languages/ja.yml","hash":"e331b15b1fda0f2285d25853f834682ab8dc3c39","modified":1551403681000},{"_id":"themes/next/languages/id.yml","hash":"e7fb582e117a0785036dcdbb853a6551263d6aa6","modified":1551403681000},{"_id":"themes/next/languages/nl.yml","hash":"bb9ce8adfa5ee94bc6b5fac6ad24ba4605d180d3","modified":1551403681000},{"_id":"themes/next/languages/pt-BR.yml","hash":"bfc80c8a363fa2e8dde38ea2bc85cd19e15ab653","modified":1551403681000},{"_id":"themes/next/languages/tr.yml","hash":"c5f0c20743b1dd52ccb256050b1397d023e6bcd9","modified":1551403681000},{"_id":"themes/next/languages/pt.yml","hash":"3cb51937d13ff12fcce747f972ccb664840a9ef3","modified":1551403681000},{"_id":"themes/next/languages/ru.yml","hash":"db0644e738d2306ac38567aa183ca3e859a3980f","modified":1551403681000},{"_id":"themes/next/languages/vi.yml","hash":"8da921dd8335dd676efce31bf75fdd4af7ce6448","modified":1551403681000},{"_id":"themes/next/languages/zh-CN.yml","hash":"fbbf3a0b664ae8e927c700b0a813692b94345156","modified":1551403681000},{"_id":"themes/next/languages/uk.yml","hash":"1eb59e581568da9a81d6e20541b4ada5fc1c55c0","modified":1551403681000},{"_id":"themes/next/languages/zh-HK.yml","hash":"7903b96912c605e630fb695534012501b2fad805","modified":1551403681000},{"_id":"themes/next/languages/zh-TW.yml","hash":"6e6d2cd8f4244cb1b349b94904cb4770935acefd","modified":1551403681000},{"_id":"themes/next/layout/archive.swig","hash":"2b6450c6b6d2bcbcd123ad9f59922a5e323d77a5","modified":1551403681000},{"_id":"themes/next/layout/_layout.swig","hash":"10094ecf246ce7ca2a97dae27b77bc28066bff48","modified":1553611528379},{"_id":"themes/next/layout/category.swig","hash":"5d955284a42f802a48560b4452c80906a5d1da02","modified":1551403681000},{"_id":"themes/next/layout/index.swig","hash":"c2a3896c64e96790edc10426ef586b6186a87f46","modified":1551403681000},{"_id":"themes/next/layout/schedule.swig","hash":"3268dd3d90d8b0e142cfa1a2ebb23355baeda148","modified":1551403681000},{"_id":"themes/next/layout/post.swig","hash":"f74929fd792541916eb25c2addfb35431be071ba","modified":1551403681000},{"_id":"themes/next/layout/page.swig","hash":"2d0e80e8a4dcba665704882b9dc5858c187acc31","modified":1551403681000},{"_id":"themes/next/layout/tag.swig","hash":"ba402ce8fd55e80b240e019e8d8c48949b194373","modified":1551403681000},{"_id":"themes/next/scripts/merge-configs.js","hash":"33afe97284d34542015d358a720823feeebef120","modified":1551403681000},{"_id":"themes/next/scripts/merge.js","hash":"9130dabe6a674c54b535f322b17d75fe6081472f","modified":1551403681000},{"_id":"themes/next/test/helpers.js","hash":"a1f5de25154c3724ffc24a91ddc576cdbd60864f","modified":1551403681000},{"_id":"themes/next/test/.jshintrc","hash":"19f93d13d1689fe033c82eb2d5f3ce30b6543cc0","modified":1551403681000},{"_id":"themes/next/test/intern.js","hash":"11fa8a4f5c3b4119a179ae0a2584c8187f907a73","modified":1551403681000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"source/_posts/.vscode/c_cpp_properties.json","hash":"855c35df1e0f95d95e42d39b49d80211cd2e30e1","modified":1554341840575},{"_id":"themes/next/docs/ru/INSTALLATION.md","hash":"6c5d69e94961c793da156217ecf1179e868d7ba1","modified":1551403681000},{"_id":"themes/next/docs/ru/DATA-FILES.md","hash":"d6d20f60f77a76c77f8e65d0c9adbd79d0274557","modified":1551403681000},{"_id":"themes/next/docs/ru/UPDATE-FROM-5.1.X.md","hash":"b1dd18d9b890b21718883ea1832e7e02a773104a","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/ALGOLIA-SEARCH.md","hash":"6855402e2ef59aae307e8bd2a990647d3a605eb8","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/CODE_OF_CONDUCT.md","hash":"a45a791b49954331390d548ac34169d573ea5922","modified":1551403681000},{"_id":"themes/next/docs/ru/README.md","hash":"953deb732e0b3b22c423122a189d6847d908c4b8","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/DATA-FILES.md","hash":"f3eec572a7d83542e2710a7404082014aaa1a5e7","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/CONTRIBUTING.md","hash":"bd2c955d9b7b1b45bd74a4536717d547e03fcde3","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/INSTALLATION.md","hash":"b19a6e0ae96eb7c756fb5b1ba03934c7f9cbb3c3","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/README.md","hash":"15e55eb77616500fa4c64982d6bad9ac17a46e2a","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/LEANCLOUD-COUNTER-SECURITY.md","hash":"115ffbde2b3ce01ef1f8c2b3833e6f6794650132","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/MATH.md","hash":"b76ccbc658024e86639cfa5f8a3817647fc8d651","modified":1551403681000},{"_id":"themes/next/docs/zh-CN/UPDATE-FROM-5.1.X.md","hash":"5da70d7fa0c988a66a469b9795d33d471a4a4433","modified":1551403681000},{"_id":"themes/next/layout/_custom/header.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1551403681000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"adc83b19e793491b1c6ea0fd8b46cd9f32e592fc","modified":1551403681000},{"_id":"themes/next/layout/_custom/head.swig","hash":"9e1b9666efa77f4cf8d8261bcfa445a9ac608e53","modified":1551403681000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"89b0a0e64637bf5b0cfea0a23642df3d95eedfa4","modified":1551403681000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"07340f3a4c8d8a9dd491d1eba18d985ecc0855a2","modified":1551403681000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"500ccd7f2d3df5cb408980f6ed46720419fbe34d","modified":1551403681000},{"_id":"themes/next/layout/_partials/github-banner.swig","hash":"a6ed0b4d6140bdfc5ea4995bb13d969cce50e74a","modified":1551403681000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"07f88421bda86d9d5ff32d130b1cb1196b99a326","modified":1551403681000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"dbe321bcf3cf45917cc11a3e3f50d8572bac2c70","modified":1551403681000},{"_id":"themes/next/layout/_partials/post-edit.swig","hash":"06dac109504812b63766a80ede9ddacbd42d227d","modified":1551403681000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"d01881f8056203c4b6920328db8c2ae8fa662a08","modified":1551403681000},{"_id":"themes/next/layout/_macro/post.swig","hash":"870e220950eb49fd459d5eab026daf189c19d326","modified":1551403681000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"d66bc7ec3cc03f60fcc7d555368a5b9b010f7f11","modified":1551403681000},{"_id":"themes/next/layout/_scripts/noscript.swig","hash":"edaff4766e0c05fd5c889d9dd32884d376bef9d9","modified":1551403681000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"c4c58ea2bd4cf10372a5e46dbec1b9a2e0e69f0f","modified":1551403681000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"d359e638a86bd9664101c48e9344f21ec96e6a15","modified":1551403681000},{"_id":"themes/next/layout/_third-party/bookmark.swig","hash":"10b61a8bac671e375916a4d234c120117098a78f","modified":1551403681000},{"_id":"themes/next/layout/_third-party/baidu-push.swig","hash":"4ccf2abbfd070874265b0436a3eff21f7c998dfb","modified":1551403681000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"2c4a66be4677d3e4dec3f169ac8a769098dad1fe","modified":1551403681000},{"_id":"themes/next/layout/_third-party/copy-code.swig","hash":"7c306e3296d90c3765fb681d24c6fe4cb5e274a0","modified":1551403681000},{"_id":"themes/next/layout/_third-party/pangu.swig","hash":"c28f9dc96ab735daeb7f599f86470aa5a83c03cf","modified":1551403681000},{"_id":"themes/next/layout/_third-party/quicklink.swig","hash":"87b91b8812fcb7963525625796fd02217dc7ed60","modified":1551403681000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"1b250c1b7945cb1029b9e855edb09854f7c8250a","modified":1551403681000},{"_id":"themes/next/scripts/filters/exturl.js","hash":"79ad823ca803cb00e0bfc648aa6c9d59711e0519","modified":1551403681000},{"_id":"themes/next/layout/_third-party/pdf.swig","hash":"5453d76e00bfcd1d732fc5f41828a90eb681f645","modified":1551403681000},{"_id":"themes/next/scripts/helpers/next-url.js","hash":"799a042bbf497a4c7a2981aa2014ff28fa1bb382","modified":1551403681000},{"_id":"themes/next/scripts/helpers/engine.js","hash":"60eb1554456d9d0e5afc4a2d16f1580a0aa02da8","modified":1551403681000},{"_id":"themes/next/scripts/tags/button.js","hash":"08d5dfe05335f57d3e8392a74315766dafa52538","modified":1551403681000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"f13430d9d1c9773b390787c2f046bb1f12a79878","modified":1551403681000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"7ded3e7a78380b32de3e12f156e0978ef5c2890a","modified":1551403681000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"22de989163c4678278c8a112160be6977f570234","modified":1551403681000},{"_id":"themes/next/scripts/tags/include-raw.js","hash":"5db59d56f4f4082382bf1c16722e6c383892b0c5","modified":1551403681000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"cbe40cb67dad15ade967b0f396c1a95b6871f76a","modified":1551403681000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"4775fffa526f1f7b40aa1f1c0a171dbcf5963df7","modified":1551403681000},{"_id":"themes/next/scripts/tags/label.js","hash":"76735c88cfba2e53649387a7fa5176706c2d3c0c","modified":1551403681000},{"_id":"themes/next/scripts/tags/note.js","hash":"84ce2d2c0646baafc82083e261b093b1c515f63c","modified":1551403681000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"8b1e9043db8f19ea4a12c473b3f729bd3b5bcb0e","modified":1551403681000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1551403681000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1551403681000},{"_id":"themes/next/source/css/main.styl","hash":"e010ec8ac73268a0f137204c89e0080ab8d59b3d","modified":1551403681000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1551403681000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1551403681000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1551403681000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1551403681000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"2398e5cd0cb466953b6e7a42c2b2caddebf3c348","modified":1551403681000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1551403681000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1551403681000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1551403681000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1551403681000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1551403681000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551403681000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1551403681000},{"_id":"themes/next/source/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1551403681000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1551403681000},{"_id":"themes/next/source/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1551403681000},{"_id":"themes/next/source/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1551403681000},{"_id":"themes/next/source/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1551403681000},{"_id":"themes/next/layout/_macro/menu/menu-badge.swig","hash":"65c5e585982dae7ae1542cada71858b4ea1f73d6","modified":1551403681000},{"_id":"themes/next/layout/_macro/menu/menu-item.swig","hash":"fb33f499022cd02722f834fcef1a0e193362cfde","modified":1551403681000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"fc6bafc8c633afadc538c5afa5620ea2a1cdcb84","modified":1551403681000},{"_id":"themes/next/layout/_partials/head/head-unique.swig","hash":"dc53a41196b675268bfd2a944f6258c57ed44e91","modified":1551403681000},{"_id":"themes/next/layout/_partials/header/brand.swig","hash":"58e2e153e8b67e643b24453a1e1cceaae3323647","modified":1551403681000},{"_id":"themes/next/layout/_partials/header/sub-menu.swig","hash":"5adc60100e129c1d0307bdcaa0c7b8e8375a6ea4","modified":1551403681000},{"_id":"themes/next/layout/_partials/header/index.swig","hash":"2082f5077551123e695e8afec471c9c44b436acb","modified":1551403681000},{"_id":"themes/next/layout/_partials/header/menu.swig","hash":"71af31fea5913fd30c233e555ef13cf2c9768f72","modified":1551403681000},{"_id":"themes/next/layout/_partials/page/breadcrumb.swig","hash":"69722be16ce5eae5c027168f9b2fded4776e1b53","modified":1551403681000},{"_id":"themes/next/layout/_partials/head/head.swig","hash":"ee17da81594a5682a158c9d18829e974e4542dfc","modified":1553932554972},{"_id":"themes/next/layout/_partials/post/post-copyright.swig","hash":"3615db591dd910fb9fa96542734c7ec0ef05019c","modified":1551403681000},{"_id":"themes/next/layout/_partials/page/page-header.swig","hash":"2940df694fff28e8bf71b6546b4162f1e38227db","modified":1551403681000},{"_id":"themes/next/layout/_partials/post/reward.swig","hash":"c33691d9b4ff3a69603ad04c9ab264eb68ea43a9","modified":1551403681000},{"_id":"themes/next/layout/_partials/post/post-related.swig","hash":"eea95b785c9c36d28e1839619793f66e89773bee","modified":1551403681000},{"_id":"themes/next/layout/_partials/post/wechat-subscriber.swig","hash":"ef11b5be5bfb2f0affe82cf521c002b37fef9819","modified":1551403681000},{"_id":"themes/next/layout/_partials/search/algolia-search.swig","hash":"ba698f49dd3a868c95b240d802f5b1b24ff287e4","modified":1551403681000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"957701729b85fb0c5bfcf2fb99c19d54582f91ed","modified":1551403681000},{"_id":"themes/next/layout/_partials/search/index.swig","hash":"7d1693416a5dc098f4723a53da2e2d1fc2d6e075","modified":1551403681000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"15b542f5b06b7532234af367340b9ed9fcebb0ac","modified":1551403681000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"c7f2855f19dfdf18aba8c58d55b7489e631ed035","modified":1551403681000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a5587bd1f60d35e58618576cec45e662aa44ea1f","modified":1551403681000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"ffc8e8836714ea79abeb77b75859634615652877","modified":1551403681000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"108b157fbd1ac3baaf19ae87234fa8728ab79556","modified":1551403681000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"be24f204a515d5211bf3ba98a030e3bf61d4cc16","modified":1551403681000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"94e106755c5fb6f40431b621beeba0bd33877e57","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"a5723950c343d220270bfd27bd30050eda6c3fb3","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"8eadb929c9e50e58502ccad2dc2657746f8c592a","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"798d67e4a736613ab899eabe6529091bbcda7850","modified":1551403681000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"6f181cc188ecbe5e607fd989756e470d4cb9765d","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"08cd47ef8572121b7811342d3c9a84a338a18191","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"591b2ccd9713ccb922b9fcf5e278b6de9c5ec30b","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"050ea01f25cfe492be9bb77b409644d623fdf2dc","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"c9172b9498bac4a4551dc0191855abee3bb192fc","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/growingio.swig","hash":"4a966b7ffe2d80ff1b3dd0fd14b355766dc5c70f","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"438c6f5e6665d72f4ea7ee206011d669246f6102","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"fae69a0e1a1d42f7bb44e594a29857d94594698b","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"f240a50cd9b627620d9a374a29cf95f0c5e99d7c","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"92e04a2b9e0c3df594bc22235d1894e5ad458dfc","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"cbf620cf2a78e3ac736cdd7e768513cfd6946e83","modified":1551403681000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"c754f699c90f6278b9159eff1855c17bc713ee96","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"dbe94dd94678ee8e4002b06bb1e9ead2e59e44bf","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"3cfeafefc672d9a7704650ebfb2f9d8668b38d9a","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"a4ab8095bf60def5823bf6b7b91a92a356a4c098","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"197207078ff0f4d46417b4413493e02cda0b85f4","modified":1551403681000},{"_id":"themes/next/layout/_third-party/math/index.swig","hash":"a7e304b05a44279d3e4f611908d7faef9dc14d7c","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"3533167c4295637b91d90f3bae7c651cd128bb6e","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"5856d5f701e51dfae1fd6fb486cefde67effd555","modified":1551403681000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"210f0c152bc4a9375ed364398ce309f09ebafd10","modified":1551403681000},{"_id":"themes/next/layout/_third-party/math/katex.swig","hash":"c2cb2f384bc30d31cdccf9794a729c03e687b45c","modified":1551403681000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"ea94aa85034c6d1b6bb865aecea55c73f8a14501","modified":1551403681000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"328d9a9696cc2ccf59c67d3c26000d569f46344c","modified":1553611395246},{"_id":"themes/next/layout/_third-party/search/algolia-search.swig","hash":"cd86bed852fec6e6933898067122a03755bc17f0","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"2aa5b7166a85a8aa34b17792ae4f58a5a96df6cc","modified":1551403681000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"a8aa41625b94cf17a7f473ed10dcbe683b1db705","modified":1551403681000},{"_id":"themes/next/layout/_third-party/math/mathjax.swig","hash":"e47d928451c6d31a29f7da30ad37bc2dbc531e11","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"2640a54fa63bdd4c547eab7ce2fc1192cf0ccec8","modified":1551403681000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"be087dcc060e8179f7e7f60ab4feb65817bd3d9f","modified":1551403681000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"086f5979b3de091c3378512e6c5c2f8fcb4f6298","modified":1551403681000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"fc15e277d1504532a09b7b1bd31f900ad95ec4b8","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"dcf470ab3a358103bb896a539cc03caeda10fa8b","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"a2aaaf12378db56bd10596ba3daae30950eac051","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"279a8a718ab6c930a67c41237f0aac166c1b9440","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"69d152fa46b517141ec3b1114dd6134724494d83","modified":1551403681000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"d0e97b205d3320421c380f2eee445457430c8152","modified":1551403681000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"b3eaab6a269aa3fcbafe24fd06f0c9206dc12716","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/README.md","hash":"28bc2250a16e22c705cba7b3c17fcc15081e50f2","modified":1553929816701},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"6b4437a9cd8aa04329cc6220a595acfe1fb9b598","modified":1553929816701},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1553929816702},{"_id":"themes/next/source/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1551403681000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1551403681000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1551403681000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1551403681000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1551403681000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1551403681000},{"_id":"themes/next/source/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1551403681000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1551403681000},{"_id":"themes/next/source/js/src/motion.js","hash":"7933a30382a84b655238f6e78d42ea1b99af4de6","modified":1551403681000},{"_id":"themes/next/source/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1551403681000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1551403681000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1551403681000},{"_id":"themes/next/source/js/src/utils.js","hash":"da28f07763faa35b1f84f22e5c7f0c02a7d5a575","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1553929816700},{"_id":"themes/next/source/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"837ff3718cb5a63eb01a451e35989fd1dfe4218c","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"471f1627891aca5c0e1973e09fbcb01e1510d193","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"31050fc7a25784805b4843550151c93bfa55c9c8","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"7e509c7c28c59f905b847304dd3d14d94b6f3b8e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"a6bb5256be6195e76addbda12f4ed7c662d65e7a","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"c5d48863f332ff8ce7c88dec2c893f709d7331d3","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"61ca40856e5cacd48e0fa9728fde4605c7dd4c94","modified":1551403681000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"7e51ea64611ab5d678c112b4688d4db4fd2737e2","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"8c68d36d1c74628be58cb61e66948868a8c7588d","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"e3ad313825d7ad03e24bb76d036deeb50587022b","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"4fd38490b01af4f977b53aefc433cd2f981cde14","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"ece571f38180febaf02ace8187ead8318a300ea7","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"0bef9f0dc134215bc4d0984ba3a16a1a0b6f87ec","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"6f1a0fe6b45eb8849114b8b60ba600767d08b6df","modified":1551403681000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a280a583b7615e939aaddbf778f5c108ef8a2a6c","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"9a5e3c6da76f6d5bed70c38fdf5796faa759d473","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"fe03041c387347e0bcf8efd1b4cf205ece66c339","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"38e5df90c8689a71c978fd83ba74af3d4e4e5386","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"a5bef4fdde80951f3b8c154d79cb1e581638a988","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"fa33213aceed7bf4bf25437ca9c1a00f7734ae65","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"fe2dc74726a515549956d233becda188da64f948","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"2dd866817d0bc7d179e81855f8fbcbb5d3c883fc","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"fc160583f742c94316a0fee05c18468033173534","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"a5bef4fdde80951f3b8c154d79cb1e581638a988","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"0efa036a15c18f5abb058b7c0fad1dd9ac5eed4c","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"936132428a0d35b3947ccedd4c379940abcf223a","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"09b5054ae34ba83c0d614821e574da265af55a14","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"d5e8ea6336bc2e237d501ed0d5bbcbbfe296c832","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"9b076c92abdadcf9acee75da64592ff3badd69b8","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"2f878213cb24c5ddc18877f6d15ec5c5f57745ac","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"74c7dccf0a3ee9fc2ca25ad8e998243191813a0e","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"5779cc8086b1cfde9bc4f1afdd85223bdc45f0a0","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"fd54eb599d5003bbb1aabc08596bc24a3fa3294f","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Pisces/_sub-menu.styl","hash":"b5b936dddb7b4de4720cd1e8428b30a2f06d63fb","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.github/stale.yml","hash":"dbd5e6bf89b76ad1f2b081578b239c7ae32755af","modified":1553929816699},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/HEAD","hash":"acbaef275e46a7f14c1ef456fff2c8bbe8c84724","modified":1553929816679},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/FETCH_HEAD","hash":"bf066def09a1de2e618eafd5a43ddd7fefe6c75f","modified":1553931399842},{"_id":"themes/next/source/lib/canvas-nest/.git/ORIG_HEAD","hash":"42b96d49f5eae1a58b8413a60a0c2699e94df28d","modified":1553930663029},{"_id":"themes/next/source/lib/canvas-nest/.git/config","hash":"78c4459d066ad795856608d603d780b53488073d","modified":1553929816688},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1551403681000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1551403681000},{"_id":"themes/next/source/js/src/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/description","hash":"9635f1b7e12c045212819dd934d809ef07efa2f4","modified":1553929814057},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/index","hash":"db9288df5bfbe3d4195d5bf7930e5411ff80ce84","modified":1553929816703},{"_id":"themes/next/source/lib/canvas-nest/.git/packed-refs","hash":"949c61b7ce3b6e582b7d47f985a3d13ddfbb82ca","modified":1553929816670},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"4cfeec9434a72d5efc6ca225d3445d084d4590f7","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"7cc3f36222494c9a1325c5347d7eb9ae53755a32","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d27448f199fc2f9980b601bc22b87f08b5d64dd1","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/github-banner.styl","hash":"9e0f215868df17cb27a4a522fd31156c66428c2d","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"c0d9e18a9210fdcaf33e488518b3b288eb58c0a1","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"49c2b2c14a1e7fcc810c6be4b632975d0204c281","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"05e68adae13f4d99a6ac6493daab39c92e39a6bd","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"9c59dbc1a6f2b4f15d8ae499f7aa227d9b0e3058","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"96f32ea6c3265a3889e6abe57587f6e2a2a40dfb","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/breadcrumb.styl","hash":"2d142c6f39853916256ad8fc79eb6b85f4001ae8","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"b76387934fb6bb75212b23c1a194486892cc495e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"4eff5b252d7b614e500fc7d52c97ce325e57d3ab","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"6904fd7ea6455e008d9884558b68254608af9a3c","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"fb451dc4cc0355b57849c27d3eb110c73562f794","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"9bf4362a4d0ae151ada84b219d39fbe5bb8c790e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"61af2f656f6e916f9920277bd048c5d58ff32a60","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"2356226157e8068b0e9bbe2f7d0f74e1ab49199b","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"e72a89e0f421444453e149ba32c77a64bd8e44e8","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"3b5a37ba5e70f92c1ee707c8053524e38adbb710","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"300491cf0e80c34faf5f83a2846c177759ac653f","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"0bf899fab331add63f0c8ead31ca3a3db2ad74d9","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"2bbdf4b59117b54482dda6ea82a5286c8a3fe267","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"42a0769311856a7ea3ede1c8656fb5646994a238","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"1cf64afd4b49143972f7617869539be3adb91a5e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-reading_progress.styl","hash":"0e8294d042d7d28c680ead48baa9e3c777d407c5","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"017074ef58166e2d69c53bb7590a0e7a8947a1ed","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"b5e5aa7074a965e396229c5bd263fb406770ce5f","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"a352ae5b1f8857393bf770d2e638bf15f0c9585d","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"a6c24393dffbdd94dd5c01cdbec5e180b0bfbbbd","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"10251257aceecb117233c9554dcf8ecfef8e2104","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"8e058c99dd7d41f0bd34c7c28b6ac9fbb17dcb5e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"35c0350096921dd8e2222ec41b6c17a4ea6b44f2","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"8f923b53a25d29b86a62d56f4d446f2720a9de56","modified":1553610009579},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"b34bb2ea4d16e47e6fdc06cd4feb32d93ccbd779","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"cee0e70d1a6ea963bfd707bf9cedb8a4637f64c2","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"f9837075189e37c100675211076b5053788e7ba5","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"b964782056658ac785ec6070e747c97a5e234ddb","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"e7e064bfe8ff9b9f172a9662662380b4c6699d6e","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"9a3bfc878ca797946815bed23cd6f92b24a16358","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"671a7f8aa138259172e7c6268d82d7a62a1e036a","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"9ab4e05e7b78af755ebdcbb71731fd723ed2d7f5","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"7059e24235b7c57a07f3f8abaa06b0bd6a7eda2f","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"c11ef42781111d061ed5b6c14dd4359e2cba88be","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"7d2222f66a1c1a0a3cc90bfd5d817d9b859f4a68","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"c415729e0f0d2439e63b93cec7ae32df54db87b4","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/gitalk.styl","hash":"ac7753d536341aa824d7bce0332735e838916995","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"d89c4b562b528e4746696b2ad8935764d133bdae","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"a5e3e6b4b4b814a9fe40b34d784fed67d6d977fa","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/related-posts.styl","hash":"2d4f318644bf37c50e5b1fab8d62b2673fbab9e8","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"190ad18f45b8a69cef13b2fdd2254893d06ec2c3","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"c2abe4d87148e23e15d49ee225bc650de60baf46","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"4851b981020c5cbc354a1af9b831a2dcb3cf9d39","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"6ec8ea7b11a146777b6b8da0f71f0cc1dbd129df","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"4a457d265d62f287c63d48764ce45d9bcfc9ec5a","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"070251836b57027c8240c51e41cb8e8c999c4525","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"0e760758221d4919902bda7c4d3bb96c94a678db","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"5e340ee2407a4e39cd708794cfcc718a5f398d7b","modified":1551403681000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"75f7876136fe1cae9b42d2c220e7f8b37b8d2f55","modified":1551403681000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"5dc4859c66305f871e56cba78f64bfe3bf1b5f01","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1551403681000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"817587e46df49e819858c8ecbafa08b53d5ff040","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/applypatch-msg.sample","hash":"4de88eb95a5e93fd27e78b5fb3b5231a8d8917dd","modified":1553929814058},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/commit-msg.sample","hash":"ee1ed5aad98a435f2020b6de35c173b75d9affac","modified":1553929814059},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/post-update.sample","hash":"b614c2f63da7dca9f1db2e7ade61ef30448fc96c","modified":1553929814060},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-applypatch.sample","hash":"f208287c1a92525de9f5462e905a9d31de1e2d75","modified":1553929814060},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/fsmonitor-watchman.sample","hash":"f7c0aa40cb0d620ff0bca3efe3521ec79e5d7156","modified":1553929814059},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-commit.sample","hash":"33729ad4ce51acda35094e581e4088f3167a0af8","modified":1553929814061},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-push.sample","hash":"5c8518bfd1d1d3d2c1a7194994c0a16d8a313a41","modified":1553929814061},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/prepare-commit-msg.sample","hash":"2584806ba147152ae005cb675aa4f01d5d068456","modified":1553929814064},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-rebase.sample","hash":"288efdc0027db4cfd8b7c47c4aeddba09b6ded12","modified":1553929814062},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/pre-receive.sample","hash":"705a17d259e7896f0082fe2e9f2c0c3b127be5ac","modified":1553929814063},{"_id":"themes/next/source/lib/canvas-nest/.git/info/exclude","hash":"c879df015d97615050afa7b9641e3352a1e701ac","modified":1553929814065},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1551403681000},{"_id":"themes/next/source/lib/canvas-nest/.git/hooks/update.sample","hash":"e729cd61b27c128951d139de8e7c63d1a3758dde","modified":1553929814065},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/HEAD","hash":"c3ebd40b6c4970fc89cc951fb252f12388c8e10b","modified":1553929816683},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/0c/dada082d621dbfdd00f7020c33dc751129167f","hash":"b490c11cdefde6b331a7d4ddb055e34ad08459d8","modified":1553929816596},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/2f/9eba51ec174b1e0c719d12cafa7c3c07140471","hash":"fc994d9d8b3b21ec7c941eea7e3862970e297e9b","modified":1553929816599},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/45/9262fe92f0115707bf8d8764f1886bc5e7c9e0","hash":"36040483f8af76775b7e4b6d87cec53729625399","modified":1553929816639},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/2a/f622a4d7df40a2708946e91d6d7a0df1dc468c","hash":"3da7207fb18d361b83c56f4e35f67e9e945abd82","modified":1553929816633},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/46/cad4f872aa93e813aed99547c4705322ca483f","hash":"b0465d3186e2d58a8a99c56c6e68aa2965a396d4","modified":1553929816566},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/44/6ddf9b6c0e5ade17ca5cb99f9b3a5300919c57","hash":"fb72799ff98445f72fda041337da4cf105d9dcba","modified":1553929816614},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/50/dd2a6539498a70226c81a587db486b47e839ff","hash":"3844b0c815d0b4b32c6312c751a826bf9dc2c945","modified":1553929816570},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/5a/69ce9c2e4a1a34f6063ae9a121af1555669c69","hash":"dad25cc0f450e2827b5676975f4a70636e3fd2c8","modified":1553929816605},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/51/7c5eb7dcc2cb9769efea2e7375ff6e04123150","hash":"ec53157077d47430f4729bf164999d18d370aeab","modified":1553929816617},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/a20d65d83035fdb01734a8eabe3340f740a4cb","hash":"9e95b02d8e43ec92e06bee3f60dffb74e8e7b9fa","modified":1553929816602},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/69/39233ece53c9bdb9a1faf3271ed5768b034aad","hash":"5a770d418c1bb7b0f031f4d5416530002032fcf3","modified":1553929816612},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/5e/8ae972c99b04af7dd56dabfc485e8fdae5094d","hash":"791b3349c5696ccacae00bffbdbb8d88a03e61a9","modified":1553929816573},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/75/de2b8fa62d52690de32c351c63ab6446104ed5","hash":"52d10122d633ce4895a0690c5955e1b356f5a391","modified":1553929816636},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/86/1c9f4241fe0eb6af02ad770d5ce04c1f68972b","hash":"7005c3e36015a4af30d4b91bd5a849a7861a073e","modified":1553929816630},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/7b/c7e3186212b6f2e06d3370502565e2c6326890","hash":"379f3c6486f589fc9c1ab07d0382adacf4f655a2","modified":1553929816576},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/91/f99a0c53b26dd54f56b9e452c68f56b06f8f7e","hash":"3dca8a5629e66599b6e0f146aa32f1b7ce023d89","modified":1553929816628},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/98/67d1132e0e50bbb7df754a63358d70741df6d5","hash":"3cb710a1faee73c08036f5e2df7df3a7ce29e9dd","modified":1553929816580},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/aa/da83ad9aa55faa2b34ede31b1d41e16966f80b","hash":"b304541ab95b7969a63ba2ec4f60f5391bd8bb44","modified":1553929816583},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/90/f6477118d05f5f96ce0a63c6f18b7b2baea200","hash":"385f58e92981f27fa54eb52bf60424e87c70a9d8","modified":1553929816586},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/99/be66a33ab4ebc34f62f2880a0e0cc6d334d0f2","hash":"f2346fe8ddd7d7abf38f2946f3083d8150f502d2","modified":1553929816593},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/b1/bb278ca2e50dff1b343f9d5ca025272859432f","hash":"74f0afa72a30268d84613fb0d1d893bba866f01d","modified":1553929816625},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/bb/5755c22b6c1b7461319624f0f000bc947882ee","hash":"2b87a2a354a0fa77cbddf461b03b0b8e43c16a4f","modified":1553929816608},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/heads/master","hash":"42b96d49f5eae1a58b8413a60a0c2699e94df28d","modified":1553929816683},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/d4/95d28a8fab74d23908f6ccef9e4db2625fbacb","hash":"59e6067b0a806deee7bda6460b36c0f63e2e1db5","modified":1553929816620},{"_id":"themes/next/source/lib/canvas-nest/.git/objects/ca/3466a8cbf05c2982c58199d6ee71ec6d0271ca","hash":"a9b80b5d827b5e84229b1afd7920d9218dce610f","modified":1553929816589},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/heads/master","hash":"c3ebd40b6c4970fc89cc951fb252f12388c8e10b","modified":1553929816685},{"_id":"themes/next/source/lib/canvas-nest/.git/refs/remotes/origin/HEAD","hash":"d9427cda09aba1cdde5c69c2b13c905bddb0bc51","modified":1553929816677},{"_id":"themes/next/source/lib/canvas-nest/.git/logs/refs/remotes/origin/HEAD","hash":"c3ebd40b6c4970fc89cc951fb252f12388c8e10b","modified":1553929816677},{"_id":"public/search.xml","hash":"e5acf230bf0f62a521cb61d5201ca765bd1760ca","modified":1561297942302},{"_id":"public/atom.xml","hash":"b7c8a04166ac9d4a8e2b2df2ad45180b11764ede","modified":1561297942302},{"_id":"public/categories/index.html","hash":"ced67a3d208fd1d8ef46d10b43efa1bf9c7c3033","modified":1561297942459},{"_id":"public/tags/index.html","hash":"79f2cd62516ab894eddcf2803511a6888c658126","modified":1561297942459},{"_id":"public/1 (3)/index.html","hash":"f3973db06ac49c3bae54e05650f19d331f9aff58","modified":1561297942460},{"_id":"public/about/index.html","hash":"548e1ea4ae8032cfe7d050c8cc68601a0a9992ae","modified":1561297942460},{"_id":"public/1 (1)/index.html","hash":"5ae8e05912cf7f73a1904fcfcd72c99563f6d147","modified":1561297942460},{"_id":"public/archives/index.html","hash":"fe545d7fd079fdeacc0c249af7b8a79c51f876d3","modified":1561297942461},{"_id":"public/1 (25)/index.html","hash":"94707f090d5908b2a5b7cc19b27a70a116842879","modified":1561297942461},{"_id":"public/1 (22)/index.html","hash":"cfb4899fe33cf55fbbac22daf3272545dbae3df9","modified":1561297942461},{"_id":"public/1 (23)/index.html","hash":"9bcd2c9fc9b6b38b8d738a87aed2e851d05dbd77","modified":1561297942461},{"_id":"public/1 (11)/index.html","hash":"443a8d52bcb76a76974fa66e5281a092eb523f59","modified":1561297942461},{"_id":"public/1 (26)/index.html","hash":"084f1213478c6edb8602f321d24eb73c09ba3f01","modified":1561297942461},{"_id":"public/1 (21)/index.html","hash":"30c5f03e36d2520e5c6306bee55997594cf3a32a","modified":1561297942461},{"_id":"public/1 (24)/index.html","hash":"94994ff75af3d49b204cd77652e250ec16c7248c","modified":1561297942461},{"_id":"public/1 (27)/index.html","hash":"111a39407635f986c5c950655dff0224b3d4ba0a","modified":1561297942462},{"_id":"public/1 (4)/index.html","hash":"9d664b671aa526e95e2fc4b39eec67402dd416bf","modified":1561297942462},{"_id":"public/1 (17)/index.html","hash":"16ba04a678167d23ebcc56414dd12fa21515527f","modified":1561297942462},{"_id":"public/1 (15)/index.html","hash":"2522a3c0546d1a9918eac3b189d316abbf3f887f","modified":1561297942462},{"_id":"public/1 (12)/index.html","hash":"c97d9791b8a1d1d09c1a20377ff228d298fe27cf","modified":1561297942462},{"_id":"public/1 (16)/index.html","hash":"160a0f9e0e85e38fbdd6c9bb4a8fae9b49f8cea8","modified":1561297942462},{"_id":"public/1 (18)/index.html","hash":"592c29772973daba804aab563da4d9f9d30e3b2c","modified":1561297942462},{"_id":"public/1 (13)/index.html","hash":"0a378459c56cf6a7a8f9903c62cc8551de65b336","modified":1561297942462},{"_id":"public/1 (9)/index.html","hash":"812c41efa7d8fcbf863a2196763d76539276287f","modified":1561297942463},{"_id":"public/1 (2)/index.html","hash":"444784bcbca9f0ccdb6f2484c724f3fa9db35004","modified":1561297942463},{"_id":"public/1 (8)/index.html","hash":"2f16447ad27ddcc694d27846478eb035561f688d","modified":1561297942463},{"_id":"public/1 (6)/index.html","hash":"3f12a8df201aeabb09173449c88787cf7c2c817a","modified":1561297942463},{"_id":"public/1 (19)/index.html","hash":"37f0b6c60891ad1f984187d65f976276817df6cc","modified":1561297942463},{"_id":"public/1 (20)/index.html","hash":"4657b8f49cb49734489ba72bb5734b701cc32360","modified":1561297942463},{"_id":"public/1 (5)/index.html","hash":"f9b47709fcd3619dea23240b5f4f41da17b6e8f2","modified":1561297942463},{"_id":"public/1 (7)/index.html","hash":"36ced2286ff56ff1065f16f2b945555a1535fb17","modified":1561297942463},{"_id":"public/1 (14)/index.html","hash":"ef9b466f9743e7b16268a61ea8681f35ae90d406","modified":1561297942464},{"_id":"public/1 (10)/index.html","hash":"1b4cb682f4db89d34e930c9e608d7a81c5c95351","modified":1561297942464},{"_id":"public/archives/page/2/index.html","hash":"b38b7da830ad10311915fe0f10bcb1fa25e5f62a","modified":1561297942464},{"_id":"public/archives/page/3/index.html","hash":"8d1d8f2486f605d8c4941d1b8215206038ca2803","modified":1561297942464},{"_id":"public/archives/2019/index.html","hash":"ac9066041c1aaec6eae55e6caff3354a8291d1a5","modified":1561297942464},{"_id":"public/archives/2019/page/3/index.html","hash":"db17a7c68ee3550bbf78b1f7f18a6484d1286294","modified":1561297942464},{"_id":"public/archives/2019/page/2/index.html","hash":"e136af5021bb2f057e2d05f4eeca09d7ed01b167","modified":1561297942464},{"_id":"public/archives/2019/04/index.html","hash":"a79dcb1ddfd68fa24051ee8e9e933e8108a7cf31","modified":1561297942465},{"_id":"public/archives/2019/04/page/2/index.html","hash":"d8ac7d5e29e73f37a7a9ceb0f009987823d1a686","modified":1561297942465},{"_id":"public/archives/2019/05/index.html","hash":"1e12cf990f06c40031827c2409fa7ac18548a723","modified":1561297942465},{"_id":"public/archives/2019/06/index.html","hash":"e80407c8c64b8ae2157479970e2f9f24c8e9fd53","modified":1561297942465},{"_id":"public/categories/c语言/index.html","hash":"049e671093f2176f0a27b02809cbd7effb8cd671","modified":1561297942465},{"_id":"public/categories/python/index.html","hash":"fe9f5441beceb221cac6b6e5bba94ec899cdccd4","modified":1561297942465},{"_id":"public/categories/python/page/2/index.html","hash":"b57fcb8adb9f7dacb92f53808b2c6e85b7e55624","modified":1561297942465},{"_id":"public/categories/算法习题/index.html","hash":"f029dd5b67520318cfdd33807add1d38c1e519cc","modified":1561297942465},{"_id":"public/categories/系统/index.html","hash":"70146fc4d04cfbb3914d2719def453d62b7d0b4f","modified":1561297942465},{"_id":"public/categories/算法/index.html","hash":"a5284054059b9ed0f6c24a821c72617ac55fce26","modified":1561297942466},{"_id":"public/categories/数据结构/index.html","hash":"7760e8a3a8521563634d29bfc1b4c4af337afefa","modified":1561297942466},{"_id":"public/categories/网络原理/index.html","hash":"bec9a86b08e30a39cf5d548c47e386ae21a1159c","modified":1561297942466},{"_id":"public/categories/linux/index.html","hash":"9c0bc7f2b08949e149b550476585306c71d23bc4","modified":1561297942466},{"_id":"public/tags/c语言/index.html","hash":"e30c9cdfbf84ae54c32b69215fad6180e5042c37","modified":1561297942466},{"_id":"public/tags/python/index.html","hash":"d6864fe53b7a40f848ec706832dd72a03a856a18","modified":1561297942466},{"_id":"public/tags/python/page/2/index.html","hash":"b1110c75255537a28220969d4b3f2421c747d898","modified":1561297942466},{"_id":"public/tags/系统/index.html","hash":"dd1b4b99bd41ae668e1ca1099e6ad6e19b83d722","modified":1561297942466},{"_id":"public/tags/算法习题/index.html","hash":"97eac9e9d5bb4515b8fe6d584e4a0b3f1e025686","modified":1561297942466},{"_id":"public/tags/算法/index.html","hash":"ed838dbee02ec6c9374baa9b8993a95991830ee2","modified":1561297942467},{"_id":"public/tags/数据结构/index.html","hash":"26fdbbf552ea781d1490aed9480d4a9cf98274c4","modified":1561297942467},{"_id":"public/tags/网络原理/index.html","hash":"8b615c2c4f2d3fe975831d7dce17cbcb2f0fd113","modified":1561297942467},{"_id":"public/tags/linux基础/index.html","hash":"1af7bd5d6dc3e1b38aaba2b32fd32898ca9055be","modified":1561297942467},{"_id":"public/index.html","hash":"4f104c7b33affad40694eba706ec45ad702ab586","modified":1561297942467},{"_id":"public/page/2/index.html","hash":"98ca25ee21f0538286f5fa59fc499412a75e867e","modified":1561297942467},{"_id":"public/page/3/index.html","hash":"4691d1551ef1a6e7156bc9cc66c854ce3ec03c3b","modified":1561297942476},{"_id":"public/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1561297942476},{"_id":"public/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1561297942476},{"_id":"public/images/cc-by-nc-sa.svg","hash":"3031be41e8753c70508aa88e84ed8f4f653f157e","modified":1561297942476},{"_id":"public/images/algolia_logo.svg","hash":"ec119560b382b2624e00144ae01c137186e91621","modified":1561297942477},{"_id":"public/images/cc-by-nc.svg","hash":"8d39b39d88f8501c0d27f8df9aae47136ebc59b7","modified":1561297942477},{"_id":"public/images/cc-by-nc-nd.svg","hash":"c6524ece3f8039a5f612feaf865d21ec8a794564","modified":1561297942477},{"_id":"public/images/cc-by-nd.svg","hash":"c563508ce9ced1e66948024ba1153400ac0e0621","modified":1561297942477},{"_id":"public/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1561297942477},{"_id":"public/images/cc-zero.svg","hash":"87669bf8ac268a91d027a0a4802c92a1473e9030","modified":1561297942477},{"_id":"public/images/favicon-32x32-next.png","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1561297942477},{"_id":"public/images/favicon-16x16-next.png","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1561297942477},{"_id":"public/images/cc-by-sa.svg","hash":"aa4742d733c8af8d38d4c183b8adbdcab045872e","modified":1561297942477},{"_id":"public/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1561297942477},{"_id":"public/images/cc-by.svg","hash":"28a0a4fe355a974a5e42f68031652b76798d4f7e","modified":1561297942477},{"_id":"public/images/quote-r.svg","hash":"e60ae504f9d99b712c793c3740c6b100d057d4ec","modified":1561297942477},{"_id":"public/images/logo.svg","hash":"d29cacbae1bdc4bbccb542107ee0524fe55ad6de","modified":1561297942477},{"_id":"public/images/quote-l.svg","hash":"94e870b4c8c48da61d09522196d4dd40e277a98f","modified":1561297942478},{"_id":"public/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1561297942478},{"_id":"public/lib/font-awesome/HELP-US-OUT.txt","hash":"4f7bf961f1bed448f6ba99aeb9219fabf930ba96","modified":1561297942478},{"_id":"public/lib/canvas-nest/LICENSE","hash":"336611e76f0638d3d8aeca6b1b97138d2a07523f","modified":1561297942478},{"_id":"public/lib/blog-encrypt.js","hash":"ebf4ce2a0389fe8184668508ba9c730cd2c38f97","modified":1561297942478},{"_id":"public/css/blog-encrypt.css","hash":"262922c3f49cb8cca7b3ea982c49b57de2af53d6","modified":1561297942478},{"_id":"public/lib/font-awesome/css/font-awesome.css.map","hash":"0189d278706509412bac4745f96c83984e1d59f4","modified":1561297943664},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1561297943667},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1561297943667},{"_id":"public/lib/canvas-nest/canvas-nest-nomobile.min.js","hash":"956eada198babd00f028e8908767cb158926c3f3","modified":1561297943675},{"_id":"public/lib/font-awesome/bower.json","hash":"64394a2a9aa00f8e321d8daa5e51a420f0e96dad","modified":1561297943675},{"_id":"public/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1561297943676},{"_id":"public/js/src/bootstrap.js","hash":"1c41508b83cb0c4512e64b4d63afa1be954ce8ef","modified":1561297943676},{"_id":"public/js/src/affix.js","hash":"a2aab233d99297435a5274bf512c3c753fe08e80","modified":1561297943676},{"_id":"public/js/src/post-details.js","hash":"0dde5e6d4547587662a3256317a9d5d1db507692","modified":1561297943676},{"_id":"public/js/src/scroll-cookie.js","hash":"d07b3776708d4ae79ed2037c4c7391d5c9b06b19","modified":1561297943676},{"_id":"public/js/src/js.cookie.js","hash":"9b37973a90fd50e71ea91682265715e45ae82c75","modified":1561297943676},{"_id":"public/js/src/algolia-search.js","hash":"1f7f10c579e7703d0f6acb8b73f3d78a07d0c623","modified":1561297943676},{"_id":"public/js/src/scrollspy.js","hash":"fa3c92968bcdbcb8d95a1729f7659d9753cbd077","modified":1561297943677},{"_id":"public/js/src/exturl.js","hash":"54825acc8de4793feac415be227b965428f4e97d","modified":1561297943677},{"_id":"public/js/src/schemes/muse.js","hash":"e9bfa6b343b67625f58757efce46ccdaac8f308c","modified":1561297943677},{"_id":"public/js/src/schemes/pisces.js","hash":"9eb63cba0327d3d11b6cbfcbe40b88e97a8378a3","modified":1561297943677},{"_id":"public/lib/canvas-nest/README.html","hash":"dac952f5cf0e6eedfb8d33bab710356798bb0ca5","modified":1561297943677},{"_id":"public/css/main.css","hash":"ab735e2b74de253a5acb169008948afef8e78dd8","modified":1561297943677},{"_id":"public/lib/velocity/velocity.ui.min.js","hash":"ed5e534cd680a25d8d14429af824f38a2c7d9908","modified":1561297943682},{"_id":"public/js/src/motion.js","hash":"7933a30382a84b655238f6e78d42ea1b99af4de6","modified":1561297943682},{"_id":"public/js/src/utils.js","hash":"da28f07763faa35b1f84f22e5c7f0c02a7d5a575","modified":1561297943682},{"_id":"public/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"214dad442a92d36af77ed0ca1d9092b16687f02f","modified":1561297943682},{"_id":"public/lib/ua-parser-js/dist/ua-parser.min.js","hash":"38628e75e4412cc6f11074e03e1c6d257aae495b","modified":1561297943682},{"_id":"public/lib/crypto-js.js","hash":"3dd73b6f13dc818a3a9c5c7424c1c4a9649b00a2","modified":1561297943683},{"_id":"public/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1561297943686},{"_id":"public/lib/font-awesome/css/font-awesome.min.css","hash":"512c7d79033e3028a9be61b540cf1a6870c896f8","modified":1561297943687},{"_id":"public/lib/velocity/velocity.ui.js","hash":"6a1d101eab3de87527bb54fcc8c7b36b79d8f0df","modified":1561297943693},{"_id":"public/lib/font-awesome/css/font-awesome.css","hash":"0140952c64e3f2b74ef64e050f2fe86eab6624c8","modified":1561297943699},{"_id":"public/lib/velocity/velocity.min.js","hash":"2f1afadc12e4cf59ef3b405308d21baa97e739c6","modified":1561297943699},{"_id":"public/lib/jquery/index.js","hash":"41b4bfbaa96be6d1440db6e78004ade1c134e276","modified":1561297943719},{"_id":"public/lib/velocity/velocity.js","hash":"9f08181baea0cc0e906703b7e5df9111b9ef3373","modified":1561297943724}],"Category":[{"name":"c语言","_id":"cjx90h80j0004jkufkb1v3uk6"},{"name":"python","_id":"cjx90h80y000bjkufujbdfmts"},{"name":"算法习题","_id":"cjx90h81x0014jkufxxk58i25"},{"name":"系统","_id":"cjx90h825001cjkufwbcrwmci"},{"name":"算法","_id":"cjx90h82d001mjkuf0r23wx6g"},{"name":"数据结构","_id":"cjx90h8c20023jkuf8p4ld7l3"},{"name":"网络原理","_id":"cjx90h8ck002fjkuffhrh97ty"},{"name":"linux","_id":"cjx90h8cn002ijkufl7dkmb5r"}],"Data":[],"Page":[{"title":"","date":"2019-03-26T18:04:05.000Z","type":"categories","_content":"","source":"categories/index.md","raw":"---\ntitle: \ndate: 2019-03-27 02:04:05\ntype: \"categories\"\n---\n","updated":"2019-03-27T04:35:44.892Z","path":"categories/index.html","comments":1,"layout":"page","_id":"cjx90h80a0001jkuf4kui79dp","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"","date":"2019-03-26T18:05:46.000Z","_content":"<center>学习之路</center>\n\n- 笔者也是菜鸟一枚,但偏爱代码.在学习的路上希望与各位一起交流进步.该博客会不定时与各位分享一点经验\n  和方法,也会分享一些比较好玩的东西.大爱python.\n- 学习之路本是痛苦的,但在学会之后慢慢应用于实际中是很有成就感的一件事.学习python也是如此,初期入门\n  可以做点自己感兴趣的项目加以练习.慢慢就会变成编程大神. 这个过程总结为:从看会别人的代码变为自己可\n  以讲述给别人的知识,最后反复专研达到企业应用的技能(一万小时定律). 在逐渐学习中要循序渐进,前期以看\n  视频和书为主,中期去网上找一些感兴趣的项目练习,到后面反复锤炼专研达到行业领域的专家级别水准.\n- 笔者会把自己学习的路程每天记录下来,希望可以在慢慢学习的时间里让自己变得更强大.\n- 平时以培养编程思维为主,代码次之,一定要细心,不可急躁.注重培养企业工程思维(每天做文档归类总结).不\n  要害怕各种困难要知难而上.做事情也和编程一样,这个编程模块逻辑没写完,下一个功能就不要做.要一点一点\n  来.不要看到以后知识有多难而心生畏惧.打败你的敌人永远是你自己.所有的编程语言做开发都是希望可以让\n  电脑来代替人的工作,切勿本末倒置.\n- 人生路漫漫,选择自己喜欢的事.\n- 祝各位朋友早日找到自己满意的工作.","source":"about/index.md","raw":"---\ntitle: \ndate: 2019-03-27 02:05:46\n---\n<center>学习之路</center>\n\n- 笔者也是菜鸟一枚,但偏爱代码.在学习的路上希望与各位一起交流进步.该博客会不定时与各位分享一点经验\n  和方法,也会分享一些比较好玩的东西.大爱python.\n- 学习之路本是痛苦的,但在学会之后慢慢应用于实际中是很有成就感的一件事.学习python也是如此,初期入门\n  可以做点自己感兴趣的项目加以练习.慢慢就会变成编程大神. 这个过程总结为:从看会别人的代码变为自己可\n  以讲述给别人的知识,最后反复专研达到企业应用的技能(一万小时定律). 在逐渐学习中要循序渐进,前期以看\n  视频和书为主,中期去网上找一些感兴趣的项目练习,到后面反复锤炼专研达到行业领域的专家级别水准.\n- 笔者会把自己学习的路程每天记录下来,希望可以在慢慢学习的时间里让自己变得更强大.\n- 平时以培养编程思维为主,代码次之,一定要细心,不可急躁.注重培养企业工程思维(每天做文档归类总结).不\n  要害怕各种困难要知难而上.做事情也和编程一样,这个编程模块逻辑没写完,下一个功能就不要做.要一点一点\n  来.不要看到以后知识有多难而心生畏惧.打败你的敌人永远是你自己.所有的编程语言做开发都是希望可以让\n  电脑来代替人的工作,切勿本末倒置.\n- 人生路漫漫,选择自己喜欢的事.\n- 祝各位朋友早日找到自己满意的工作.","updated":"2019-03-27T04:34:40.473Z","path":"about/index.html","comments":1,"layout":"page","_id":"cjx90h80f0003jkufm8w5jdy8","content":"<center>学习之路</center>\n\n<ul>\n<li>笔者也是菜鸟一枚,但偏爱代码.在学习的路上希望与各位一起交流进步.该博客会不定时与各位分享一点经验<br>和方法,也会分享一些比较好玩的东西.大爱python.</li>\n<li>学习之路本是痛苦的,但在学会之后慢慢应用于实际中是很有成就感的一件事.学习python也是如此,初期入门<br>可以做点自己感兴趣的项目加以练习.慢慢就会变成编程大神. 这个过程总结为:从看会别人的代码变为自己可<br>以讲述给别人的知识,最后反复专研达到企业应用的技能(一万小时定律). 在逐渐学习中要循序渐进,前期以看<br>视频和书为主,中期去网上找一些感兴趣的项目练习,到后面反复锤炼专研达到行业领域的专家级别水准.</li>\n<li>笔者会把自己学习的路程每天记录下来,希望可以在慢慢学习的时间里让自己变得更强大.</li>\n<li>平时以培养编程思维为主,代码次之,一定要细心,不可急躁.注重培养企业工程思维(每天做文档归类总结).不<br>要害怕各种困难要知难而上.做事情也和编程一样,这个编程模块逻辑没写完,下一个功能就不要做.要一点一点<br>来.不要看到以后知识有多难而心生畏惧.打败你的敌人永远是你自己.所有的编程语言做开发都是希望可以让<br>电脑来代替人的工作,切勿本末倒置.</li>\n<li>人生路漫漫,选择自己喜欢的事.</li>\n<li>祝各位朋友早日找到自己满意的工作.</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<center>学习之路</center>\n\n<ul>\n<li>笔者也是菜鸟一枚,但偏爱代码.在学习的路上希望与各位一起交流进步.该博客会不定时与各位分享一点经验<br>和方法,也会分享一些比较好玩的东西.大爱python.</li>\n<li>学习之路本是痛苦的,但在学会之后慢慢应用于实际中是很有成就感的一件事.学习python也是如此,初期入门<br>可以做点自己感兴趣的项目加以练习.慢慢就会变成编程大神. 这个过程总结为:从看会别人的代码变为自己可<br>以讲述给别人的知识,最后反复专研达到企业应用的技能(一万小时定律). 在逐渐学习中要循序渐进,前期以看<br>视频和书为主,中期去网上找一些感兴趣的项目练习,到后面反复锤炼专研达到行业领域的专家级别水准.</li>\n<li>笔者会把自己学习的路程每天记录下来,希望可以在慢慢学习的时间里让自己变得更强大.</li>\n<li>平时以培养编程思维为主,代码次之,一定要细心,不可急躁.注重培养企业工程思维(每天做文档归类总结).不<br>要害怕各种困难要知难而上.做事情也和编程一样,这个编程模块逻辑没写完,下一个功能就不要做.要一点一点<br>来.不要看到以后知识有多难而心生畏惧.打败你的敌人永远是你自己.所有的编程语言做开发都是希望可以让<br>电脑来代替人的工作,切勿本末倒置.</li>\n<li>人生路漫漫,选择自己喜欢的事.</li>\n<li>祝各位朋友早日找到自己满意的工作.</li>\n</ul>\n"},{"title":"","date":"2019-03-26T18:06:17.000Z","type":"tags","_content":"","source":"tags/index.md","raw":"---\ntitle: \ndate: 2019-03-27 02:06:17\ntype: \"tags\"\n---\n","updated":"2019-03-27T04:35:52.040Z","path":"tags/index.html","comments":1,"layout":"page","_id":"cjx90h80p0007jkuf9ox6v6o1","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"","date":"2019-03-26T18:06:32.000Z","_content":"","source":"archives/index.md","raw":"---\ntitle: \ndate: 2019-03-27 02:06:32\n---\n","updated":"2019-03-27T04:35:14.218Z","path":"archives/index.html","comments":1,"layout":"page","_id":"cjx90h80s0009jkuflf6q7dib","content":"","site":{"data":{}},"excerpt":"","more":""}],"Post":[{"title":"深入浅出理解预处理器","_content":"\n### 预处理器\n\n编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.\n\n#### 预定义符号\n\n预处理指令\n\n| 指令     | 描述                                                    |\n| -------- | ------------------------------------------------------- |\n| #include | 包含一个源代码                                          |\n| #define  | 定义宏                                                  |\n| #undef   | 取消已定义的宏                                          |\n| #ifdef   | 如果宏已经定义,则返回真                                 |\n| #ifndef  | 如果宏没有定义,则返回真                                 |\n| #if      | 如果给定条件为真,则编译下面代码                         |\n| #else    | #if的替代方案                                           |\n| #elif    | 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 |\n| #endif   | 结束一个#if...#else 条件编译块                          |\n| #error   | 当遇到标准错误时, 输出错误消息                          |\n| #pragma  | 使用标准化方法, 向编译器发布特殊的命令道编译器中        |\n\ntypedef \n\nc语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .\n\n动态内存分配\n\n当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.\n\nc函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.\n\npython对象就是 c语言结构体在堆上申请的一块内存.\n\n在 C 语言中，字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\nc中大量操作字符串的函数\n\n| 函数    | 目的                                                         |\n| ------- | ------------------------------------------------------------ |\n| strcpy  | 复制字符串s2到字符串s1                                       |\n| strcat  | 连接s2 到字符串s1的末尾                                      |\n| strlen  | 返回字符串s1的长度                                           |\n| strcmp  | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| strchar | 返回一个指针,指向字符串s1中字符ch的第一次出现的位置          |\n| strstr  | 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置        |","source":"_posts/1 (1).md","raw":"---\ntitle: 深入浅出理解预处理器\ncategories: \n- c语言\ntags:\n- c语言\n---\n\n### 预处理器\n\n编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.\n\n#### 预定义符号\n\n预处理指令\n\n| 指令     | 描述                                                    |\n| -------- | ------------------------------------------------------- |\n| #include | 包含一个源代码                                          |\n| #define  | 定义宏                                                  |\n| #undef   | 取消已定义的宏                                          |\n| #ifdef   | 如果宏已经定义,则返回真                                 |\n| #ifndef  | 如果宏没有定义,则返回真                                 |\n| #if      | 如果给定条件为真,则编译下面代码                         |\n| #else    | #if的替代方案                                           |\n| #elif    | 如果前面的#if给定条件不为真,当前条件为真,则编译下面代码 |\n| #endif   | 结束一个#if...#else 条件编译块                          |\n| #error   | 当遇到标准错误时, 输出错误消息                          |\n| #pragma  | 使用标准化方法, 向编译器发布特殊的命令道编译器中        |\n\ntypedef \n\nc语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .\n\n动态内存分配\n\n当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.\n\nc函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.\n\npython对象就是 c语言结构体在堆上申请的一块内存.\n\n在 C 语言中，字符串实际上是使用 **null** 字符 '\\0' 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。\n\nc中大量操作字符串的函数\n\n| 函数    | 目的                                                         |\n| ------- | ------------------------------------------------------------ |\n| strcpy  | 复制字符串s2到字符串s1                                       |\n| strcat  | 连接s2 到字符串s1的末尾                                      |\n| strlen  | 返回字符串s1的长度                                           |\n| strcmp  | 如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。 |\n| strchar | 返回一个指针,指向字符串s1中字符ch的第一次出现的位置          |\n| strstr  | 返回一个指针,指向字符串s1中字符串s2的第一次出现的位置        |","slug":"1 (1)","published":1,"date":"2019-06-15T01:09:15.096Z","updated":"2019-06-19T14:49:44.230Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h7zz0000jkufynn8cds4","content":"<h3 id=\"预处理器\"><a href=\"#预处理器\" class=\"headerlink\" title=\"预处理器\"></a>预处理器</h3><p>编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.</p>\n<h4 id=\"预定义符号\"><a href=\"#预定义符号\" class=\"headerlink\" title=\"预定义符号\"></a>预定义符号</h4><p>预处理指令</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#include</td>\n<td>包含一个源代码</td>\n</tr>\n<tr>\n<td>#define</td>\n<td>定义宏</td>\n</tr>\n<tr>\n<td>#undef</td>\n<td>取消已定义的宏</td>\n</tr>\n<tr>\n<td>#ifdef</td>\n<td>如果宏已经定义,则返回真</td>\n</tr>\n<tr>\n<td>#ifndef</td>\n<td>如果宏没有定义,则返回真</td>\n</tr>\n<tr>\n<td>#if</td>\n<td>如果给定条件为真,则编译下面代码</td>\n</tr>\n<tr>\n<td>#else</td>\n<td>#if的替代方案</td>\n</tr>\n<tr>\n<td>#elif</td>\n<td>如果前面的#if给定条件不为真,当前条件为真,则编译下面代码</td>\n</tr>\n<tr>\n<td>#endif</td>\n<td>结束一个#if…#else 条件编译块</td>\n</tr>\n<tr>\n<td>#error</td>\n<td>当遇到标准错误时, 输出错误消息</td>\n</tr>\n<tr>\n<td>#pragma</td>\n<td>使用标准化方法, 向编译器发布特殊的命令道编译器中</td>\n</tr>\n</tbody>\n</table>\n<p>typedef </p>\n<p>c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .</p>\n<p>动态内存分配</p>\n<p>当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.</p>\n<p>c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.</p>\n<p>python对象就是 c语言结构体在堆上申请的一块内存.</p>\n<p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>\n<p>c中大量操作字符串的函数</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>strcpy</td>\n<td>复制字符串s2到字符串s1</td>\n</tr>\n<tr>\n<td>strcat</td>\n<td>连接s2 到字符串s1的末尾</td>\n</tr>\n<tr>\n<td>strlen</td>\n<td>返回字符串s1的长度</td>\n</tr>\n<tr>\n<td>strcmp</td>\n<td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td>\n</tr>\n<tr>\n<td>strchar</td>\n<td>返回一个指针,指向字符串s1中字符ch的第一次出现的位置</td>\n</tr>\n<tr>\n<td>strstr</td>\n<td>返回一个指针,指向字符串s1中字符串s2的第一次出现的位置</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"预处理器\"><a href=\"#预处理器\" class=\"headerlink\" title=\"预处理器\"></a>预处理器</h3><p>编译一个c程序涉及很多步骤, 其中第一个步骤被称为预处理器阶段.c预处理器在源代码编译之前对其进行一些文本性质的操作,他的主要任务包括删除注释,插入被#include指令包含的文件的内容,定义和替换#define指令定义的符号以及确定代码的部分内容是否应该根据一些条件编译指令进行编译.</p>\n<h4 id=\"预定义符号\"><a href=\"#预定义符号\" class=\"headerlink\" title=\"预定义符号\"></a>预定义符号</h4><p>预处理指令</p>\n<table>\n<thead>\n<tr>\n<th>指令</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>#include</td>\n<td>包含一个源代码</td>\n</tr>\n<tr>\n<td>#define</td>\n<td>定义宏</td>\n</tr>\n<tr>\n<td>#undef</td>\n<td>取消已定义的宏</td>\n</tr>\n<tr>\n<td>#ifdef</td>\n<td>如果宏已经定义,则返回真</td>\n</tr>\n<tr>\n<td>#ifndef</td>\n<td>如果宏没有定义,则返回真</td>\n</tr>\n<tr>\n<td>#if</td>\n<td>如果给定条件为真,则编译下面代码</td>\n</tr>\n<tr>\n<td>#else</td>\n<td>#if的替代方案</td>\n</tr>\n<tr>\n<td>#elif</td>\n<td>如果前面的#if给定条件不为真,当前条件为真,则编译下面代码</td>\n</tr>\n<tr>\n<td>#endif</td>\n<td>结束一个#if…#else 条件编译块</td>\n</tr>\n<tr>\n<td>#error</td>\n<td>当遇到标准错误时, 输出错误消息</td>\n</tr>\n<tr>\n<td>#pragma</td>\n<td>使用标准化方法, 向编译器发布特殊的命令道编译器中</td>\n</tr>\n</tbody>\n</table>\n<p>typedef </p>\n<p>c语言支持一种叫做typedef的机制, 它允许你为各种数据类型定义新名字.typedef声明的写法和普通的声明基本相同, 只是把typedef这个关键字出现在声明的前面 .</p>\n<p>动态内存分配</p>\n<p>当你声明数组时, 你必须用一个编译时常量指定数组的长度,但是,数组的长度常常在运行时才知道.这是由于他所需要的内存空间取决于输入数据.</p>\n<p>c函数库提供了两个函数,malloc 和free 分别用于执行动态内存分配和释放,这些函数维护了一个可用内存池,当一个程序另外需要一些内存时,他就调用malloc函数,,malloc从内存中提取一块合适的内存,并向该程序返回一个指向这块内存的指针.这块内存此时并没有以任何方式进行初始化.如果对这块内存进行初始化非常重要,你要么自己动手对他进行初始化,要么使用calloc函数.当一块以前分配的内存不在使用时,程序调用free函数把它归还给内存池供以后之需.</p>\n<p>python对象就是 c语言结构体在堆上申请的一块内存.</p>\n<p>在 C 语言中，字符串实际上是使用 <strong>null</strong> 字符 ‘\\0’ 终止的一维字符数组。因此，一个以 null 结尾的字符串，包含了组成字符串的字符。</p>\n<p>c中大量操作字符串的函数</p>\n<table>\n<thead>\n<tr>\n<th>函数</th>\n<th>目的</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>strcpy</td>\n<td>复制字符串s2到字符串s1</td>\n</tr>\n<tr>\n<td>strcat</td>\n<td>连接s2 到字符串s1的末尾</td>\n</tr>\n<tr>\n<td>strlen</td>\n<td>返回字符串s1的长度</td>\n</tr>\n<tr>\n<td>strcmp</td>\n<td>如果 s1 和 s2 是相同的，则返回 0；如果 s1<s2 则返回小于 0；如果 s1>s2 则返回大于 0。</s2></td>\n</tr>\n<tr>\n<td>strchar</td>\n<td>返回一个指针,指向字符串s1中字符ch的第一次出现的位置</td>\n</tr>\n<tr>\n<td>strstr</td>\n<td>返回一个指针,指向字符串s1中字符串s2的第一次出现的位置</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"python函数","_content":"\n# 基本概念\n\n数学定义\ny=f(x), y是x的函数, x是自变量. y=f(x0, x1 ...xn)\npython函数:\n是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元\n完成一定的功能\n函数的作用\n结构化编程对代码的最基本的封装, 一般按照功能组织一段代码\n封装的目的为了复用,减少冗余代码\n代码更加简洁美观,可读易懂\n\n函数的分类:\n内建函数,如max()\n库函数,如math.ceil\n自定义函数,使用def关键字定义\n\n函数定义\ndef 函数名(参数列表):\n    函数体(代码块)\n    [return 返回值]\n函数名就是标识符,命名要求一样\n语句块必须缩进,约定4个空格\n函数名就是标识符就是变量python的函数没有return,会返回none\n定义中的参数列表称为形式参数,只是一种标识符占位置的\n函数的标识符就是指向函数对象\n函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参\n不定义会报nameERREO\n\n传参方式:\n* 位置传参\n按照参数定义顺序传入实参\n* 关键字\n使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同\n要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的\n参数缺省值\n缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:\n参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值\n参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用\n\n可变位置参数\n在形参使用* 表示该形参是可变位置参数, 可以接受多个实参\n它将收集来的实参组织到一个tuple中\ntuple 有序按位置传参\n可变关键字参数\n在形参使用**表示该形参是可变关键字参数,可以接受多个关键字参数\n它将收集来的实参的名称和值,组织到一个dict中\n可变的关键字传参** kwargs\n\n有可变位置参数和可变关键字参数\n可变位置参数在形参前使用一个*号\n可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple\n可变关键字参数收集形成一个dict\n混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面\n要在可变关键字参数之前.\n\n# keyword-only 参数\n\ndef fn(*args, x, y, **kwargs):\n    print(x, y, args, kwargs, sep='\\n', end='\\n\\n')\nfn(3, 5)\nfn(3, ,5, 7)\n在python3之后,新增了keyword-only参数\nkeyword-only参数:在形参定义时,在一个*星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数\nkeyword-only参数,言下之意就是这个参数必须采取关键字传参\n可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.*星号后所有的普通参数都成了keyword-only参数\n参数的混合使用\n参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数\n代码应该易读易懂, 而不是为难别人\n请按照书写习惯定义函数参数.\n参数解构:\n在给函数提供实参的时候,可以在可迭代对象前使用*或者**来进行的解构,提取出其中所有元素作为函数的实参.\n使用*解构成位置参数\n使用**解构成位置 传参\n提取出来的元素数目要和参数的要求匹配\n\npython函数使用return语句返回\"返回值\"\n所有函数都有返回值,如果没有return语句, 隐式调用return None\nreturn语句并不一定是函数的语句块的最后一条语句\n一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None\n如果有必要,可以显示调用return None ,可以简写return\n如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行\n返回值的作用: 结束函数调用,返回返回值\n函数不能同时返回多个值.\n# 作用域\n一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域\n注意:每一个函数都会开辟一个作用域\n分类:\n全局作用域:\n在整个程序运行环境中都可见\n全局作用域中的变量称为全局变量\n局部作用域:\n在函数 ,类等内部可见\n局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域\n函数嵌套\n在一个函数中定义了另一个函数\n内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见\n\nglobal语句\n使用global关键字的变量,将声明为外部的全局作用域中定义的\n使用了global 不再是局部变量,它是全局变量\nglobal使用原则\n外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离\n如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决\n一句话:不要global,学习他就是深入理解变量作用域\n\n# 闭包\n自由变量:未在本地作用域中定义的变量\n闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript\n\nnonlocal语句\n将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义\n内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义\n代码中内层函数引到外部局部作用域中的自由变量,形成闭包\n\n函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联\npython把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期\n查看__default__属性,他是个元组\n\n# 变量名解析原则LEGB***\nlocal,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡\nEnclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间\nglobal 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡\nbuild-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡\n所以一个名词的查找顺序就是LEGB.\n\n\n\n\n|","source":"_posts/1 (13).md","raw":"---\ntitle: python函数\n\n\ncategories: \n- python\ntags:\n- python\n---\n\n# 基本概念\n\n数学定义\ny=f(x), y是x的函数, x是自变量. y=f(x0, x1 ...xn)\npython函数:\n是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元\n完成一定的功能\n函数的作用\n结构化编程对代码的最基本的封装, 一般按照功能组织一段代码\n封装的目的为了复用,减少冗余代码\n代码更加简洁美观,可读易懂\n\n函数的分类:\n内建函数,如max()\n库函数,如math.ceil\n自定义函数,使用def关键字定义\n\n函数定义\ndef 函数名(参数列表):\n    函数体(代码块)\n    [return 返回值]\n函数名就是标识符,命名要求一样\n语句块必须缩进,约定4个空格\n函数名就是标识符就是变量python的函数没有return,会返回none\n定义中的参数列表称为形式参数,只是一种标识符占位置的\n函数的标识符就是指向函数对象\n函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参\n不定义会报nameERREO\n\n传参方式:\n* 位置传参\n按照参数定义顺序传入实参\n* 关键字\n使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同\n要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的\n参数缺省值\n缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:\n参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值\n参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用\n\n可变位置参数\n在形参使用* 表示该形参是可变位置参数, 可以接受多个实参\n它将收集来的实参组织到一个tuple中\ntuple 有序按位置传参\n可变关键字参数\n在形参使用**表示该形参是可变关键字参数,可以接受多个关键字参数\n它将收集来的实参的名称和值,组织到一个dict中\n可变的关键字传参** kwargs\n\n有可变位置参数和可变关键字参数\n可变位置参数在形参前使用一个*号\n可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple\n可变关键字参数收集形成一个dict\n混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面\n要在可变关键字参数之前.\n\n# keyword-only 参数\n\ndef fn(*args, x, y, **kwargs):\n    print(x, y, args, kwargs, sep='\\n', end='\\n\\n')\nfn(3, 5)\nfn(3, ,5, 7)\n在python3之后,新增了keyword-only参数\nkeyword-only参数:在形参定义时,在一个*星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数\nkeyword-only参数,言下之意就是这个参数必须采取关键字传参\n可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.*星号后所有的普通参数都成了keyword-only参数\n参数的混合使用\n参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数\n代码应该易读易懂, 而不是为难别人\n请按照书写习惯定义函数参数.\n参数解构:\n在给函数提供实参的时候,可以在可迭代对象前使用*或者**来进行的解构,提取出其中所有元素作为函数的实参.\n使用*解构成位置参数\n使用**解构成位置 传参\n提取出来的元素数目要和参数的要求匹配\n\npython函数使用return语句返回\"返回值\"\n所有函数都有返回值,如果没有return语句, 隐式调用return None\nreturn语句并不一定是函数的语句块的最后一条语句\n一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None\n如果有必要,可以显示调用return None ,可以简写return\n如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行\n返回值的作用: 结束函数调用,返回返回值\n函数不能同时返回多个值.\n# 作用域\n一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域\n注意:每一个函数都会开辟一个作用域\n分类:\n全局作用域:\n在整个程序运行环境中都可见\n全局作用域中的变量称为全局变量\n局部作用域:\n在函数 ,类等内部可见\n局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域\n函数嵌套\n在一个函数中定义了另一个函数\n内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见\n\nglobal语句\n使用global关键字的变量,将声明为外部的全局作用域中定义的\n使用了global 不再是局部变量,它是全局变量\nglobal使用原则\n外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离\n如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决\n一句话:不要global,学习他就是深入理解变量作用域\n\n# 闭包\n自由变量:未在本地作用域中定义的变量\n闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript\n\nnonlocal语句\n将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义\n内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义\n代码中内层函数引到外部局部作用域中的自由变量,形成闭包\n\n函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联\npython把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期\n查看__default__属性,他是个元组\n\n# 变量名解析原则LEGB***\nlocal,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡\nEnclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间\nglobal 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡\nbuild-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡\n所以一个名词的查找顺序就是LEGB.\n\n\n\n\n|","slug":"1 (13)","published":1,"date":"2019-04-11T12:01:18.031Z","updated":"2019-06-19T14:47:48.442Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h80c0002jkuf1mri4n2u","content":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>数学定义<br>y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)<br>python函数:<br>是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元<br>完成一定的功能<br>函数的作用<br>结构化编程对代码的最基本的封装, 一般按照功能组织一段代码<br>封装的目的为了复用,减少冗余代码<br>代码更加简洁美观,可读易懂</p>\n<p>函数的分类:<br>内建函数,如max()<br>库函数,如math.ceil<br>自定义函数,使用def关键字定义</p>\n<p>函数定义<br>def 函数名(参数列表):<br>    函数体(代码块)<br>    [return 返回值]<br>函数名就是标识符,命名要求一样<br>语句块必须缩进,约定4个空格<br>函数名就是标识符就是变量python的函数没有return,会返回none<br>定义中的参数列表称为形式参数,只是一种标识符占位置的<br>函数的标识符就是指向函数对象<br>函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参<br>不定义会报nameERREO</p>\n<p>传参方式:</p>\n<ul>\n<li>位置传参<br>按照参数定义顺序传入实参</li>\n<li>关键字<br>使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同<br>要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的<br>参数缺省值<br>缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:<br>参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值<br>参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用</li>\n</ul>\n<p>可变位置参数<br>在形参使用* 表示该形参是可变位置参数, 可以接受多个实参<br>它将收集来的实参组织到一个tuple中<br>tuple 有序按位置传参<br>可变关键字参数<br>在形参使用<strong>表示该形参是可变关键字参数,可以接受多个关键字参数<br>它将收集来的实参的名称和值,组织到一个dict中<br>可变的关键字传参</strong> kwargs</p>\n<p>有可变位置参数和可变关键字参数<br>可变位置参数在形参前使用一个*号<br>可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple<br>可变关键字参数收集形成一个dict<br>混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面<br>要在可变关键字参数之前.</p>\n<h1 id=\"keyword-only-参数\"><a href=\"#keyword-only-参数\" class=\"headerlink\" title=\"keyword-only 参数\"></a>keyword-only 参数</h1><p>def fn(<em>args, x, y, **kwargs):<br>    print(x, y, args, kwargs, sep=’\\n’, end=’\\n\\n’)<br>fn(3, 5)<br>fn(3, ,5, 7)<br>在python3之后,新增了keyword-only参数<br>keyword-only参数:在形参定义时,在一个</em>星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数<br>keyword-only参数,言下之意就是这个参数必须采取关键字传参<br>可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.<em>星号后所有的普通参数都成了keyword-only参数<br>参数的混合使用<br>参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数<br>代码应该易读易懂, 而不是为难别人<br>请按照书写习惯定义函数参数.<br>参数解构:<br>在给函数提供实参的时候,可以在可迭代对象前使用</em>或者<strong>来进行的解构,提取出其中所有元素作为函数的实参.<br>使用*解构成位置参数<br>使用</strong>解构成位置 传参<br>提取出来的元素数目要和参数的要求匹配</p>\n<p>python函数使用return语句返回”返回值”<br>所有函数都有返回值,如果没有return语句, 隐式调用return None<br>return语句并不一定是函数的语句块的最后一条语句<br>一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None<br>如果有必要,可以显示调用return None ,可以简写return<br>如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行<br>返回值的作用: 结束函数调用,返回返回值<br>函数不能同时返回多个值.</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域<br>注意:每一个函数都会开辟一个作用域<br>分类:<br>全局作用域:<br>在整个程序运行环境中都可见<br>全局作用域中的变量称为全局变量<br>局部作用域:<br>在函数 ,类等内部可见<br>局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域<br>函数嵌套<br>在一个函数中定义了另一个函数<br>内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见</p>\n<p>global语句<br>使用global关键字的变量,将声明为外部的全局作用域中定义的<br>使用了global 不再是局部变量,它是全局变量<br>global使用原则<br>外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离<br>如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决<br>一句话:不要global,学习他就是深入理解变量作用域</p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>自由变量:未在本地作用域中定义的变量<br>闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript</p>\n<p>nonlocal语句<br>将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义<br>内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义<br>代码中内层函数引到外部局部作用域中的自由变量,形成闭包</p>\n<p>函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联<br>python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期<br>查看<strong>default</strong>属性,他是个元组</p>\n<h1 id=\"变量名解析原则LEGB\"><a href=\"#变量名解析原则LEGB\" class=\"headerlink\" title=\"变量名解析原则LEGB***\"></a>变量名解析原则LEGB***</h1><p>local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡<br>Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间<br>global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡<br>build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡<br>所以一个名词的查找顺序就是LEGB.</p>\n<p>|</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"基本概念\"><a href=\"#基本概念\" class=\"headerlink\" title=\"基本概念\"></a>基本概念</h1><p>数学定义<br>y=f(x), y是x的函数, x是自变量. y=f(x0, x1 …xn)<br>python函数:<br>是由若干语句组成的语句块,函数名称,参数列表构成,它是组织代码的最小单元<br>完成一定的功能<br>函数的作用<br>结构化编程对代码的最基本的封装, 一般按照功能组织一段代码<br>封装的目的为了复用,减少冗余代码<br>代码更加简洁美观,可读易懂</p>\n<p>函数的分类:<br>内建函数,如max()<br>库函数,如math.ceil<br>自定义函数,使用def关键字定义</p>\n<p>函数定义<br>def 函数名(参数列表):<br>    函数体(代码块)<br>    [return 返回值]<br>函数名就是标识符,命名要求一样<br>语句块必须缩进,约定4个空格<br>函数名就是标识符就是变量python的函数没有return,会返回none<br>定义中的参数列表称为形式参数,只是一种标识符占位置的<br>函数的标识符就是指向函数对象<br>函数调用,函数名后使用小括号,小括号中填入实际实实在在的参数,简称为实参,定义是形参<br>不定义会报nameERREO</p>\n<p>传参方式:</p>\n<ul>\n<li>位置传参<br>按照参数定义顺序传入实参</li>\n<li>关键字<br>使用形参的名字来传入实参的方式,如果使用了形参,传参顺序就可和定义顺序不同<br>要求位置参数必须在关键字参数之前传入,位置参数是按照位置对应的<br>参数缺省值<br>缺省值也成为默认值, 可以在函数定义是,为形参增加一个缺省值.其作用:<br>参数的默认值可以在未传入足够的实参的时候,对没有给定的参数赋值为默认值<br>参数非常多的时候,并不需要用户每次都输入所有的参数,简化函数调用</li>\n</ul>\n<p>可变位置参数<br>在形参使用* 表示该形参是可变位置参数, 可以接受多个实参<br>它将收集来的实参组织到一个tuple中<br>tuple 有序按位置传参<br>可变关键字参数<br>在形参使用<strong>表示该形参是可变关键字参数,可以接受多个关键字参数<br>它将收集来的实参的名称和值,组织到一个dict中<br>可变的关键字传参</strong> kwargs</p>\n<p>有可变位置参数和可变关键字参数<br>可变位置参数在形参前使用一个*号<br>可变关键字参数和可变关键字参数度可以收集若干个实参,可变位置参数收集形成一个tuple<br>可变关键字参数收集形成一个dict<br>混合使用参数的时候,普通参数需要放到参数列表前面, 可变参数要放到参数列表的后面<br>要在可变关键字参数之前.</p>\n<h1 id=\"keyword-only-参数\"><a href=\"#keyword-only-参数\" class=\"headerlink\" title=\"keyword-only 参数\"></a>keyword-only 参数</h1><p>def fn(<em>args, x, y, **kwargs):<br>    print(x, y, args, kwargs, sep=’\\n’, end=’\\n\\n’)<br>fn(3, 5)<br>fn(3, ,5, 7)<br>在python3之后,新增了keyword-only参数<br>keyword-only参数:在形参定义时,在一个</em>星号之后, 或一个可变位置参数之后, 出现的普通参数,就已经不是普通的参数了,称为keyword-only参数<br>keyword-only参数,言下之意就是这个参数必须采取关键字传参<br>可以认为,args可变位置参数已经截获了所有位置参数, 其后的变量x不可能通过位置传参传入了.<em>星号后所有的普通参数都成了keyword-only参数<br>参数的混合使用<br>参数规则:普通参数,缺省参数,可变位置参数,keyword-only参数,可变关键字参数<br>代码应该易读易懂, 而不是为难别人<br>请按照书写习惯定义函数参数.<br>参数解构:<br>在给函数提供实参的时候,可以在可迭代对象前使用</em>或者<strong>来进行的解构,提取出其中所有元素作为函数的实参.<br>使用*解构成位置参数<br>使用</strong>解构成位置 传参<br>提取出来的元素数目要和参数的要求匹配</p>\n<p>python函数使用return语句返回”返回值”<br>所有函数都有返回值,如果没有return语句, 隐式调用return None<br>return语句并不一定是函数的语句块的最后一条语句<br>一个函数可以存在多个return语句,但是只要一条可以被执行,如果没有一条return语句被执行,隐式调用return None<br>如果有必要,可以显示调用return None ,可以简写return<br>如果函数执行了return语句,函数就会返回,当前执行return语句之后的其他语句就不会被执行<br>返回值的作用: 结束函数调用,返回返回值<br>函数不能同时返回多个值.</p>\n<h1 id=\"作用域\"><a href=\"#作用域\" class=\"headerlink\" title=\"作用域\"></a>作用域</h1><p>一个标识符的可见范围,这就是标识符的作用域,一般常说的是常量的作用域<br>注意:每一个函数都会开辟一个作用域<br>分类:<br>全局作用域:<br>在整个程序运行环境中都可见<br>全局作用域中的变量称为全局变量<br>局部作用域:<br>在函数 ,类等内部可见<br>局部作用域中的变量称为局部变量,其使用范围不能超过所在其所在局部作用域<br>函数嵌套<br>在一个函数中定义了另一个函数<br>内部函数不能在外部直接使用,会抛NameError异常,因为它在函数外部不可见</p>\n<p>global语句<br>使用global关键字的变量,将声明为外部的全局作用域中定义的<br>使用了global 不再是局部变量,它是全局变量<br>global使用原则<br>外部作用域变量会在内部作用域可见,但也不要在这个内部的局部作用域中直接使用,应为函数的目的就是为了封装,尽量与外界隔离<br>如果函数需要使用外部全局变量,请使用函数的形参定义,并再调用传实参解决<br>一句话:不要global,学习他就是深入理解变量作用域</p>\n<h1 id=\"闭包\"><a href=\"#闭包\" class=\"headerlink\" title=\"闭包\"></a>闭包</h1><p>自由变量:未在本地作用域中定义的变量<br>闭包: 就是一个概念,出现在嵌套函数中 ,指的是内层函数引到了外层函数的自由变量, 就形成了闭包,很多语言都有这个概念,最熟悉就是javascript</p>\n<p>nonlocal语句<br>将变量标记为不在本地作用域定义, 而是上级的某一级局部作用域中定义, 但不能是全局作用域中定义<br>内部函数使用nonlocal关键字声明count变量在上级作用域而非本地作用域中定义<br>代码中内层函数引到外部局部作用域中的自由变量,形成闭包</p>\n<p>函数也是对象,每个函数定义被执行后,就生成了一个函数对象和函数名这个标识符关联<br>python把函数的默认值放在函数对象的属性中,这个属性就伴随着这个函数对象的整个生命周期<br>查看<strong>default</strong>属性,他是个元组</p>\n<h1 id=\"变量名解析原则LEGB\"><a href=\"#变量名解析原则LEGB\" class=\"headerlink\" title=\"变量名解析原则LEGB***\"></a>变量名解析原则LEGB***</h1><p>local,本地作用域,局部作用域的local命名空间,函数调用时创建,调用结束消亡<br>Enclosing,python引入了嵌套函数,实现了闭包,这个就是嵌套函数的外部函数的命名空间<br>global 全局作用域,即一个模块的命名空间 模块被import时创建,解释器退出时消亡<br>build-in,内置模块的命名空间,生命周期从python解释器启动时创建到解释器退出时消亡<br>所以一个名词的查找顺序就是LEGB.</p>\n<p>|</p>\n"},{"title":"python 三大器","_content":"\n# 装饰器\n装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.\n\n```python\ndef 炼丹炉(func):\n\tdef 变身(*args):\n        火眼金睛\n        returrn 孙悟空\n    return 变身\n@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)\ndef 孙悟空:\n    return\n```\n\n**装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper**\n\n单层的只需要function 如:注册器\n\n双层的是返回一个全新的函数 如:打印log\n\n\n\n# 迭代器\n迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代\n可迭代对象就是,实现了迭代器协议的对象.\n协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)\n使用迭代器协议访问对象.\n举个例子:\nfor n in [1, 2, 3, 4]:\n    print(n)\n\n但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象\nwith open ('/etc/passwd') as f:\n    for line in f:\n        print(line)\n\ndef gensquares(n):\n    for i in range(n):\n        yield i ** 2\nfor item in  genquares(s):\n    print(item)\n\n# 生成器\n语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.\n自动实现迭代器协议:\n\n\n\n","source":"_posts/1 (12).md","raw":"---\ntitle: python 三大器\n\n\ncategories: \n- python\ntags:\n- python\n---\n\n# 装饰器\n装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.\n\n```python\ndef 炼丹炉(func):\n\tdef 变身(*args):\n        火眼金睛\n        returrn 孙悟空\n    return 变身\n@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)\ndef 孙悟空:\n    return\n```\n\n**装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper**\n\n单层的只需要function 如:注册器\n\n双层的是返回一个全新的函数 如:打印log\n\n\n\n# 迭代器\n迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代\n可迭代对象就是,实现了迭代器协议的对象.\n协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)\n使用迭代器协议访问对象.\n举个例子:\nfor n in [1, 2, 3, 4]:\n    print(n)\n\n但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象\nwith open ('/etc/passwd') as f:\n    for line in f:\n        print(line)\n\ndef gensquares(n):\n    for i in range(n):\n        yield i ** 2\nfor item in  genquares(s):\n    print(item)\n\n# 生成器\n语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.\n自动实现迭代器协议:\n\n\n\n","slug":"1 (12)","published":1,"date":"2019-04-20T08:05:52.286Z","updated":"2019-06-19T14:48:22.337Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h80n0006jkufi78kr5o5","content":"<h1 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h1><p>装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> 炼丹炉<span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> 变身<span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">        火眼金睛</span><br><span class=\"line\">        returrn 孙悟空</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 变身</span><br><span class=\"line\"><span class=\"meta\">@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> 孙悟空:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p><strong>装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper</strong></p>\n<p>单层的只需要function 如:注册器</p>\n<p>双层的是返回一个全新的函数 如:打印log</p>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><p>迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代<br>可迭代对象就是,实现了迭代器协议的对象.<br>协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)<br>使用迭代器协议访问对象.<br>举个例子:<br>for n in [1, 2, 3, 4]:<br>    print(n)</p>\n<p>但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象<br>with open (‘/etc/passwd’) as f:<br>    for line in f:<br>        print(line)</p>\n<p>def gensquares(n):<br>    for i in range(n):<br>        yield i ** 2<br>for item in  genquares(s):<br>    print(item)</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.<br>自动实现迭代器协议:</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"装饰器\"><a href=\"#装饰器\" class=\"headerlink\" title=\"装饰器\"></a>装饰器</h1><p>装饰器本质是一个python函数,它可以让其他函数在不需要做任何代码变动的前提下增加额外功能,装饰器的返回值也是一个函数对象.它经常用于有切面需求的场景,比如:插入日志,性能测试,事务处理,缓存,权限校验等场景.装饰器是解决这类问题的绝佳设计,有了装饰器,我们就可以抽离出大量与函数功能本身无关的雷同代码并继续重用.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> 炼丹炉<span class=\"params\">(func)</span>:</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> 变身<span class=\"params\">(*args)</span>:</span></span><br><span class=\"line\">        火眼金睛</span><br><span class=\"line\">        returrn 孙悟空</span><br><span class=\"line\">    <span class=\"keyword\">return</span> 变身</span><br><span class=\"line\"><span class=\"meta\">@炼丹炉# 新孙悟空 = 炼丹炉(孙悟空)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> 孙悟空:</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span></span><br></pre></td></tr></table></figure>\n<p><strong>装饰器在包装函数的时候运行外层，在运行被包装函数的时候才运行内层wrapper</strong></p>\n<p>单层的只需要function 如:注册器</p>\n<p>双层的是返回一个全新的函数 如:打印log</p>\n<h1 id=\"迭代器\"><a href=\"#迭代器\" class=\"headerlink\" title=\"迭代器\"></a>迭代器</h1><p>迭代器协议是指:对象需要提供next方法,他要么返回迭代的下一项,要么就引起一个stopliteration异常.以终止迭代<br>可迭代对象就是,实现了迭代器协议的对象.<br>协议是一种约定,可迭代对象实现迭代器协议,python的内置工具(for循环,sum, min,max)<br>使用迭代器协议访问对象.<br>举个例子:<br>for n in [1, 2, 3, 4]:<br>    print(n)</p>\n<p>但是对python稍微熟悉一点的朋友应该知道,python的for 循环不但可以用来遍历list,还可以用来遍历文件对象<br>with open (‘/etc/passwd’) as f:<br>    for line in f:<br>        print(line)</p>\n<p>def gensquares(n):<br>    for i in range(n):<br>        yield i ** 2<br>for item in  genquares(s):<br>    print(item)</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>语法上和函数类似:生成器函数和常规函数几乎是一样的,他们都是使用def语句进行定义,差别在于,生成器使用yield语句返回一个值,而常规函数使用return语句返回一个值.<br>自动实现迭代器协议:</p>\n"},{"title":"pep","_content":"\n### PEP\n\nPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。\n每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。\nGuido van Rossum被戏称为\"仁慈的独裁者\"(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0  https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 -- PEP Purpose and Guidelines PEP协议指南\nPEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅\nimport this\nBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）\nExplicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\nSimple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\nComplex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\nFlat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\nSparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题）\n  PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148\n  PEP8016\nPython社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。\n而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。\nReadability counts. # 可读性很重要（优美的代码是可读的）\n\nSpecial cases aren't special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n\nErrors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）\n\nIn the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测\n\nThere should be one-- and preferably only one --obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n\nAlthough that way may not be obvious at first unless you're Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）\n\nNow is better than never. Although never is often better than *right* now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n\nIf the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）\n\nNamespaces are one honking great idea -- let's do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\nPEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。\n5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium","source":"_posts/1 (11).md","raw":"---\ntitle: pep\ncategories: \n- python\ntags:\n- python\n---\n\n### PEP\n\nPEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。\n每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。\nGuido van Rossum被戏称为\"仁慈的独裁者\"(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0  https://www.python.org/dev/peps/ PEP规范列表，PEP文档索引 PEP 1 -- PEP Purpose and Guidelines PEP协议指南\nPEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 https://www.python.org/dev/peps/pep-0008/ http://www.magedu.com/70951.html https://yq.aliyun.com/articles/626638 PEP 20 Python之禅\nimport this\nBeautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）\nExplicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）\nSimple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）\nComplex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）\nFlat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）\nSparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题）\n  PEP 257 文档字符串的规范 https://www.python.org/dev/peps/pep-0257/ https://my.oschina.net/LuCastiel/blog/1552148\n  PEP8016\nPython社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。\n而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。\nReadability counts. # 可读性很重要（优美的代码是可读的）\n\nSpecial cases aren't special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）\n\nErrors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）\n\nIn the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测\n\nThere should be one-- and preferably only one --obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）\n\nAlthough that way may not be obvious at first unless you're Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）\n\nNow is better than never. Although never is often better than *right* now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）\n\nIf the implementation is hard to explain, it's a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）\n\nNamespaces are one honking great idea -- let's do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）\nPEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。\n5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium","slug":"1 (11)","published":1,"date":"2019-05-26T04:12:14.407Z","updated":"2019-06-19T14:49:15.394Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h80r0008jkufnlwkdpm2","content":"<h3 id=\"PEP\"><a href=\"#PEP\" class=\"headerlink\" title=\"PEP\"></a>PEP</h3><p>PEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。<br>每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。<br>Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0  <a href=\"https://www.python.org/dev/peps/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/</a> PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南<br>PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 <a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/pep-0008/</a> <a href=\"http://www.magedu.com/70951.html\" target=\"_blank\" rel=\"noopener\">http://www.magedu.com/70951.html</a> <a href=\"https://yq.aliyun.com/articles/626638\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/626638</a> PEP 20 Python之禅<br>import this<br>Beautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）<br>Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题）<br>  PEP 257 文档字符串的规范 <a href=\"https://www.python.org/dev/peps/pep-0257/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/pep-0257/</a> <a href=\"https://my.oschina.net/LuCastiel/blog/1552148\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/LuCastiel/blog/1552148</a><br>  PEP8016<br>Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。<br>而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。<br>Readability counts. # 可读性很重要（优美的代码是可读的）</p>\n<p>Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</p>\n<p>Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）</p>\n<p>In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测</p>\n<p>There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</p>\n<p>Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</p>\n<p>Now is better than never. Although never is often better than <em>right</em> now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</p>\n<p>If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</p>\n<p>Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）<br>PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。<br>5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"PEP\"><a href=\"#PEP\" class=\"headerlink\" title=\"PEP\"></a>PEP</h3><p>PEP是每一个Python程序员必须知道的。 PEP是Python Enhancement Proposals的缩写（Python增强提案）。一个PEP是一份为Python社区提供各种增强 功能的技术规格，也是提交新特性，以便让社区指出问题，精确化技术文档的提案。<br>每一个Python版本的新特性或变化都是将PEP提案通过社区决策层讨论、投票决议，通过后才有我们看到的功能变 化。<br>Guido van Rossum被戏称为”仁慈的独裁者”(benevolent dictator for life，BDFL)。他会亲自签署并确认每一份 PEP。但在2018年7月，由于PEP 572（Assignment Expressions）这个提案，他已经卸任BDFL。没有继任者，没 有管理原则，PEP路在何方？ 注：PEP 572影响到了几乎所有的Python用户，但相当多的人不认可 PEP 0  <a href=\"https://www.python.org/dev/peps/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/</a> PEP规范列表，PEP文档索引 PEP 1 – PEP Purpose and Guidelines PEP协议指南<br>PEP 8 由Python之父等编写的Python 编码风格指导。被Python社区广泛采纳，标准库也按照这个规范编写。 <a href=\"https://www.python.org/dev/peps/pep-0008/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/pep-0008/</a> <a href=\"http://www.magedu.com/70951.html\" target=\"_blank\" rel=\"noopener\">http://www.magedu.com/70951.html</a> <a href=\"https://yq.aliyun.com/articles/626638\" target=\"_blank\" rel=\"noopener\">https://yq.aliyun.com/articles/626638</a> PEP 20 Python之禅<br>import this<br>Beautiful is better than ugly. # 优美胜于丑陋（Python以编写优美的代码为目标）<br>Explicit is better than implicit. # 明了胜于晦涩（优美的代码应当是明了的，命名规范，风格相似）<br>Simple is better than complex. # 简洁胜于复杂（优美的代码应当是简洁的，不要有复杂的内部实现）<br>Complex is better than complicated. # 复杂胜于凌乱（如果复杂不可避免，那代码间也不能有难懂的关系，要保持接口简洁）<br>Flat is better than nested. # 扁平胜于嵌套（优美的代码应当是扁平的，不能有太多的嵌套）<br>Sparse is better than dense. # 留白胜于紧凑（优美的代码有适当的空白，不要奢望一行代码解决问题）<br>  PEP 257 文档字符串的规范 <a href=\"https://www.python.org/dev/peps/pep-0257/\" target=\"_blank\" rel=\"noopener\">https://www.python.org/dev/peps/pep-0257/</a> <a href=\"https://my.oschina.net/LuCastiel/blog/1552148\" target=\"_blank\" rel=\"noopener\">https://my.oschina.net/LuCastiel/blog/1552148</a><br>  PEP8016<br>Python社区治理方案，这是Python之父卸任BDFL之后，社区从几种方案中投票胜出的方案。 PEP 8016 治理方案采用指导委员会模式，其特点是引导治理的迭代，该方案由 Nathaniel J. Smith 和 Donald Stuﬀt 提出。 PEP 8016 中提出了不信任投票，也就是弹劾机制，可将任期内的当权者赶下台；它严格限定了在委员会里，只允 许少于 50% 的成员是企业（5 人委员会里最多有 2 个）；并且关注到核心开发者的选举/淘汰、如何更新治理提案 等问题。<br>而且，PEP 8016 中也提出了新的 PEP 流程，目前的 PEP 流程是提案人确定 PEP 的选题方向，提案人负责收集与 整合来自整个社区的反馈。然后，相关领域的专家们汇总全部讨论，并开启为期 14 天的审查，之后进行社区投 票。如果一个 PEP 很有争议，任何专家成员都可发起动议来拒绝通过它，这需要超过 2/3 的票数。<br>Readability counts. # 可读性很重要（优美的代码是可读的）</p>\n<p>Special cases aren’t special enough to break the rules. Although practicality beats purity. # 即便假借特例的实用性之名，也不可违背这些规则（这些规则至高无上）</p>\n<p>Errors should never pass silently. Unless explicitly silenced. # 不要包容所有错误，除非你确定需要这样做（精准地捕获异常，不写except:pass风格的代码）</p>\n<p>In the face of ambiguity, refuse the temptation to guess. # 当存在多种可能，不要尝试去猜测</p>\n<p>There should be one– and preferably only one –obvious way to do it. # 而是尽量找一种，最好是唯一一种明显的解决方案（如果不确定，就用穷举法）</p>\n<p>Although that way may not be obvious at first unless you’re Dutch. # 虽然这并不容易，因为你不是 Python 之父（这里的Dutch是指Guido）</p>\n<p>Now is better than never. Although never is often better than <em>right</em> now. # 做也许好过不做，但不假思索就动手还不如不做（动手之前要细思量）</p>\n<p>If the implementation is hard to explain, it’s a bad idea. If the implementation is easy to explain, it may be a good idea. # 如果你无法向人描述你的方案，那肯定不是一个好方案；反之亦然（方案测评标准）</p>\n<p>Namespaces are one honking great idea – let’s do more of those! # 命名空间是一种绝妙的理念，我们应当多加利用（倡导与号召）<br>PEP 8016 的 PEP 流程：指导委员会在必要时可直接地批准/否决 PEP，但最好是设置流程来避免这样做决策，例 如，将决策权委派给团队或者 BDFL 代表。 2019年2月4日，为期2周的投票后，Python社区选出来了指导委员会的5名成员。<br>5 人分别是： Barry Warsaw：自1995年起成为核心开发者之一，荣获 2014 年的弗兰克·威利森纪念奖。目前供职于 LinkedIn（已被微软收购，也即供职于微软），业余爱好是音乐和太极。 Brett Cannon：自2003年起成为核心开发者之一，荣获 2016 年的弗兰克·威利森纪念奖。曾担任 Python 软 件基金会的执行副主席。目前供职于微软，负责 VSCode 的 Python 插件项目。 Carol Willing：Python 核心开发者，Jupyter 核心开发者及 Jupyter 的指导委员会成员。自由职业，兴趣在于 科研及教育项目。 Guido van Rossum：Python 的创始人，被称为“Python 之父”，长期领导 Python 社区的发展，直到此次的 退位风波。目前供职于 Dropbox。 Nick Coghlan：自2005年起成为核心开发者之一。目前供职于 Tritium</p>\n"},{"title":"python小技巧","_content":"\n## 为多个变量赋值\n有时，有多个变量需要赋值，这时你会怎么赋值呢？\n常规方法：常规方法是给变量逐个赋值。\n```python\na = 0  \nb = 1  \nc = 2  \n```\n优雅方法：\n直接按顺序对应一一赋值.  \na, b, c = 0, 1, 2\n## 序列解包\n需要取出列表中的元素。\n常规方法：一般我们知道可以通过下标获取具体元素。\n```python\ninfo = ['brucepk', 'man', 'python']\nname = info[0]\nsex = info[1]\ntech = info[2]\nprint(name,sex,tech)\n结果:\nbrucepk man python\n```\n优雅方法：给出对应变量接收所有元素。\n```\ninfo = ['brucepk', 'man', 'python']\nname,sex,tech = info\nprint(name,sex,tech)\n结果:\nbrucepk man python\n```\n## 优雅你的判断语句\n我们用判断语句来定义一个绝对值函数。\n常规方法：\n```python\nx = -6\nif x < 0:\n    y = -x\nelse:\n    y = x\nprint(y)\n结果:\n6\n优雅方法：\nx = -6\ny = -x if x<0 else x\nprint(y)\n结果\n6\n```\n## 区间判断\n使用 and 连续两次判断的语句，条件都符合时才执行语句。\n常规方法：\n```python\nscore = 82\nif score >=80 and score < 90:\n    level = 'B'\nprint(level)\n结果\nB\n```\n优雅方法：使用链式判断。\n```\nscore = 82\nif  80 <= score < 90:\n    level = 'B'\nprint(level)\n结果\nB\n```\n## 多个值符合条件判断\n多个值任意一个值符合条件即为 True 的情况。\n常规方法：\n```\nnum = 1\nif num == 1 or num == 3 or num == 5:\n    type = '奇数'\nprint(type)\n结果\n奇数\n```\n优雅方法：使用关键字 in，让你的语句更优雅。\n```\nnum = 1\nif num in(1,3,5):\n    type = '奇数'\nprint(type)\n结果\n奇数\n```\n## 判断是否为空\n判断元素是空还是非空。\n常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。\n```\nA,B,C =[1,3,5],{},''\nif len(A) > 0:\n    print('A 为非空')\nif len(B) > 0:\n    print('B 为非空')\nif len(C) > 0:\n    print('C 为非空')\n结果\nA 为非空\n```\n\n优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。\n\n```\nA,B,C =[1,3,5],{},''  \nif A:\n    print('A 为非空')  \nif B:\n    print('B 为非空')  \nif C:\n    print('C 为非空')  \n结果\nA 为非空\n```\n## 多条件内容判断至少一个成立\n常规方法：用 or 连接多个条件。\n```\nmath,English,computer =90,80,88\nif math<60 or English<60 or computer<60:\n    print('not pass')\n结果\nnot pass\n```\n优雅方法：使用 any 语句。\n```\nmath,English,computer =90,59,88\nif any([math<60,English<60,computer<60]):\n    print('not pass')\n结果\nnot pass\n```\n## 多条件内容判断全部成立\n常规方法：使用 and 连接条件做判断。\n```\nmath,English,computer =90,80,88\nif math>60 and English>60 and computer>60:\n    print('pass')\n结果\npass\n```\n优雅方法：使用 all 方法。\n```\nmath,English,computer =90,80,88\nif all([math>60,English>60,computer>60]):\n    print('pass')\n结果\npass\n```\n## 遍历序列的元素和元素下标\n常规方法：使用 for 循环进行遍历元素和下标。\n```\nL =['math', 'English', 'computer', 'Physics']\nfor i in range(len(L)):\n    print(i, ':', L[i])\n结果\n0 : math\n1 : English\n2 : computer\n3 : Physics\n```\n优雅方法：使用 enumerate 函数。\n```\nL =['math', 'English', 'computer', 'Physics']\nfor k,v in enumerate(L):\n    print(k, ':', v)\n结果\n0 : math\n1 : English\n2 : computer\n3 : Physics\n```\n## 循环语句优化\n之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。\n常规方法：使用简单的 for 循环可以达到目的。\n```\nL = []\nfor i in range(1, 6):\n    L.append(i*i)\nprint(L) \n结果：\n[1, 4, 9, 16, 25]\n```\n优雅方法：使用列表生成式，一行代码搞定。\n```\nprint([x*x for x in range(1, 6)]) \n结果：\n[1, 4, 9, 16, 25]\n```\n## 将list中的所有元素转为单个字符串\n\n```\na = [\"python\", \"is\", \"awesome\"]\nprint(\" \",join(a))\n```\n## 字符串倒转\n\n方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。\n方法二：用Python自带reversed()函数，它可被用于list倒转。\n方法三：第三种是通过倒转数据类型和切片倒转整数.\n\n## 链式调用\n在python 中实现链式调用只需在函数返回对象自己就行\n```\ndef product(a, b):\n    return a * b\ndef add(a, b):\n    return a + b\nb = True\nprint((product if b else add)(5, 7))\n```\n## 复制list\n\n在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：\n方法一：b=a[:]。\n方法二：b=list(a)。\n方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。\n方法四：使用copy.deepcopy()。\n\n## 按value排序字典\n\nPython的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：\n方法一：用sorted函数排序，其中key参数是lamda表达式。\n方法二：用operator.itemgetter而不是lamda表达式进行排序。\n方法三：如果只需得到排序后的key，可用.get。\n\n## for ... else语法\n\n## 合并字典\n\n方法一：Python 3.5可以存在重复键值，print({**d1 ,**d2})。\n方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。\n方法三：d1.update()。\n\n## 从list中删除重复项\n\n方法一：把list转成set，去除重复项，再转回list。\n方法二：调用collections里的OrderedDict，和set差不多。\n\n","source":"_posts/1 (18).md","raw":"---\ntitle: python小技巧\n\n\ncategories: \n- python\ntags:\n- python\n---\n\n## 为多个变量赋值\n有时，有多个变量需要赋值，这时你会怎么赋值呢？\n常规方法：常规方法是给变量逐个赋值。\n```python\na = 0  \nb = 1  \nc = 2  \n```\n优雅方法：\n直接按顺序对应一一赋值.  \na, b, c = 0, 1, 2\n## 序列解包\n需要取出列表中的元素。\n常规方法：一般我们知道可以通过下标获取具体元素。\n```python\ninfo = ['brucepk', 'man', 'python']\nname = info[0]\nsex = info[1]\ntech = info[2]\nprint(name,sex,tech)\n结果:\nbrucepk man python\n```\n优雅方法：给出对应变量接收所有元素。\n```\ninfo = ['brucepk', 'man', 'python']\nname,sex,tech = info\nprint(name,sex,tech)\n结果:\nbrucepk man python\n```\n## 优雅你的判断语句\n我们用判断语句来定义一个绝对值函数。\n常规方法：\n```python\nx = -6\nif x < 0:\n    y = -x\nelse:\n    y = x\nprint(y)\n结果:\n6\n优雅方法：\nx = -6\ny = -x if x<0 else x\nprint(y)\n结果\n6\n```\n## 区间判断\n使用 and 连续两次判断的语句，条件都符合时才执行语句。\n常规方法：\n```python\nscore = 82\nif score >=80 and score < 90:\n    level = 'B'\nprint(level)\n结果\nB\n```\n优雅方法：使用链式判断。\n```\nscore = 82\nif  80 <= score < 90:\n    level = 'B'\nprint(level)\n结果\nB\n```\n## 多个值符合条件判断\n多个值任意一个值符合条件即为 True 的情况。\n常规方法：\n```\nnum = 1\nif num == 1 or num == 3 or num == 5:\n    type = '奇数'\nprint(type)\n结果\n奇数\n```\n优雅方法：使用关键字 in，让你的语句更优雅。\n```\nnum = 1\nif num in(1,3,5):\n    type = '奇数'\nprint(type)\n结果\n奇数\n```\n## 判断是否为空\n判断元素是空还是非空。\n常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。\n```\nA,B,C =[1,3,5],{},''\nif len(A) > 0:\n    print('A 为非空')\nif len(B) > 0:\n    print('B 为非空')\nif len(C) > 0:\n    print('C 为非空')\n结果\nA 为非空\n```\n\n优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。\n\n```\nA,B,C =[1,3,5],{},''  \nif A:\n    print('A 为非空')  \nif B:\n    print('B 为非空')  \nif C:\n    print('C 为非空')  \n结果\nA 为非空\n```\n## 多条件内容判断至少一个成立\n常规方法：用 or 连接多个条件。\n```\nmath,English,computer =90,80,88\nif math<60 or English<60 or computer<60:\n    print('not pass')\n结果\nnot pass\n```\n优雅方法：使用 any 语句。\n```\nmath,English,computer =90,59,88\nif any([math<60,English<60,computer<60]):\n    print('not pass')\n结果\nnot pass\n```\n## 多条件内容判断全部成立\n常规方法：使用 and 连接条件做判断。\n```\nmath,English,computer =90,80,88\nif math>60 and English>60 and computer>60:\n    print('pass')\n结果\npass\n```\n优雅方法：使用 all 方法。\n```\nmath,English,computer =90,80,88\nif all([math>60,English>60,computer>60]):\n    print('pass')\n结果\npass\n```\n## 遍历序列的元素和元素下标\n常规方法：使用 for 循环进行遍历元素和下标。\n```\nL =['math', 'English', 'computer', 'Physics']\nfor i in range(len(L)):\n    print(i, ':', L[i])\n结果\n0 : math\n1 : English\n2 : computer\n3 : Physics\n```\n优雅方法：使用 enumerate 函数。\n```\nL =['math', 'English', 'computer', 'Physics']\nfor k,v in enumerate(L):\n    print(k, ':', v)\n结果\n0 : math\n1 : English\n2 : computer\n3 : Physics\n```\n## 循环语句优化\n之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。\n常规方法：使用简单的 for 循环可以达到目的。\n```\nL = []\nfor i in range(1, 6):\n    L.append(i*i)\nprint(L) \n结果：\n[1, 4, 9, 16, 25]\n```\n优雅方法：使用列表生成式，一行代码搞定。\n```\nprint([x*x for x in range(1, 6)]) \n结果：\n[1, 4, 9, 16, 25]\n```\n## 将list中的所有元素转为单个字符串\n\n```\na = [\"python\", \"is\", \"awesome\"]\nprint(\" \",join(a))\n```\n## 字符串倒转\n\n方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。\n方法二：用Python自带reversed()函数，它可被用于list倒转。\n方法三：第三种是通过倒转数据类型和切片倒转整数.\n\n## 链式调用\n在python 中实现链式调用只需在函数返回对象自己就行\n```\ndef product(a, b):\n    return a * b\ndef add(a, b):\n    return a + b\nb = True\nprint((product if b else add)(5, 7))\n```\n## 复制list\n\n在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：\n方法一：b=a[:]。\n方法二：b=list(a)。\n方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。\n方法四：使用copy.deepcopy()。\n\n## 按value排序字典\n\nPython的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：\n方法一：用sorted函数排序，其中key参数是lamda表达式。\n方法二：用operator.itemgetter而不是lamda表达式进行排序。\n方法三：如果只需得到排序后的key，可用.get。\n\n## for ... else语法\n\n## 合并字典\n\n方法一：Python 3.5可以存在重复键值，print({**d1 ,**d2})。\n方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。\n方法三：d1.update()。\n\n## 从list中删除重复项\n\n方法一：把list转成set，去除重复项，再转回list。\n方法二：调用collections里的OrderedDict，和set差不多。\n\n","slug":"1 (18)","published":1,"date":"2019-04-14T10:18:01.418Z","updated":"2019-06-19T14:48:02.388Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h80u000ajkufa6f1n6sb","content":"<h2 id=\"为多个变量赋值\"><a href=\"#为多个变量赋值\" class=\"headerlink\" title=\"为多个变量赋值\"></a>为多个变量赋值</h2><p>有时，有多个变量需要赋值，这时你会怎么赋值呢？<br>常规方法：常规方法是给变量逐个赋值。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">0</span>  </span><br><span class=\"line\">b = <span class=\"number\">1</span>  </span><br><span class=\"line\">c = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：<br>直接按顺序对应一一赋值.<br>a, b, c = 0, 1, 2</p>\n<h2 id=\"序列解包\"><a href=\"#序列解包\" class=\"headerlink\" title=\"序列解包\"></a>序列解包</h2><p>需要取出列表中的元素。<br>常规方法：一般我们知道可以通过下标获取具体元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info = [<span class=\"string\">'brucepk'</span>, <span class=\"string\">'man'</span>, <span class=\"string\">'python'</span>]</span><br><span class=\"line\">name = info[<span class=\"number\">0</span>]</span><br><span class=\"line\">sex = info[<span class=\"number\">1</span>]</span><br><span class=\"line\">tech = info[<span class=\"number\">2</span>]</span><br><span class=\"line\">print(name,sex,tech)</span><br><span class=\"line\">结果:</span><br><span class=\"line\">brucepk man python</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：给出对应变量接收所有元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]</span><br><span class=\"line\">name,sex,tech = info</span><br><span class=\"line\">print(name,sex,tech)</span><br><span class=\"line\">结果:</span><br><span class=\"line\">brucepk man python</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"优雅你的判断语句\"><a href=\"#优雅你的判断语句\" class=\"headerlink\" title=\"优雅你的判断语句\"></a>优雅你的判断语句</h2><p>我们用判断语句来定义一个绝对值函数。<br>常规方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    y = -x</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    y = x</span><br><span class=\"line\">print(y)</span><br><span class=\"line\">结果:</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">优雅方法：</span><br><span class=\"line\">x = <span class=\"number\">-6</span></span><br><span class=\"line\">y = -x <span class=\"keyword\">if</span> x&lt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> x</span><br><span class=\"line\">print(y)</span><br><span class=\"line\">结果</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"区间判断\"><a href=\"#区间判断\" class=\"headerlink\" title=\"区间判断\"></a>区间判断</h2><p>使用 and 连续两次判断的语句，条件都符合时才执行语句。<br>常规方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> score &gt;=<span class=\"number\">80</span> <span class=\"keyword\">and</span> score &lt; <span class=\"number\">90</span>:</span><br><span class=\"line\">    level = <span class=\"string\">'B'</span></span><br><span class=\"line\">print(level)</span><br><span class=\"line\">结果</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用链式判断。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 82</span><br><span class=\"line\">if  80 &lt;= score &lt; 90:</span><br><span class=\"line\">    level = &apos;B&apos;</span><br><span class=\"line\">print(level)</span><br><span class=\"line\">结果</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多个值符合条件判断\"><a href=\"#多个值符合条件判断\" class=\"headerlink\" title=\"多个值符合条件判断\"></a>多个值符合条件判断</h2><p>多个值任意一个值符合条件即为 True 的情况。<br>常规方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = 1</span><br><span class=\"line\">if num == 1 or num == 3 or num == 5:</span><br><span class=\"line\">    type = &apos;奇数&apos;</span><br><span class=\"line\">print(type)</span><br><span class=\"line\">结果</span><br><span class=\"line\">奇数</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用关键字 in，让你的语句更优雅。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = 1</span><br><span class=\"line\">if num in(1,3,5):</span><br><span class=\"line\">    type = &apos;奇数&apos;</span><br><span class=\"line\">print(type)</span><br><span class=\"line\">结果</span><br><span class=\"line\">奇数</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"判断是否为空\"><a href=\"#判断是否为空\" class=\"headerlink\" title=\"判断是否为空\"></a>判断是否为空</h2><p>判断元素是空还是非空。<br>常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;</span><br><span class=\"line\">if len(A) &gt; 0:</span><br><span class=\"line\">    print(&apos;A 为非空&apos;)</span><br><span class=\"line\">if len(B) &gt; 0:</span><br><span class=\"line\">    print(&apos;B 为非空&apos;)</span><br><span class=\"line\">if len(C) &gt; 0:</span><br><span class=\"line\">    print(&apos;C 为非空&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">A 为非空</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;  </span><br><span class=\"line\">if A:</span><br><span class=\"line\">    print(&apos;A 为非空&apos;)  </span><br><span class=\"line\">if B:</span><br><span class=\"line\">    print(&apos;B 为非空&apos;)  </span><br><span class=\"line\">if C:</span><br><span class=\"line\">    print(&apos;C 为非空&apos;)  </span><br><span class=\"line\">结果</span><br><span class=\"line\">A 为非空</span><br></pre></td></tr></table></figure>\n<h2 id=\"多条件内容判断至少一个成立\"><a href=\"#多条件内容判断至少一个成立\" class=\"headerlink\" title=\"多条件内容判断至少一个成立\"></a>多条件内容判断至少一个成立</h2><p>常规方法：用 or 连接多个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if math&lt;60 or English&lt;60 or computer&lt;60:</span><br><span class=\"line\">    print(&apos;not pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">not pass</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 any 语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,59,88</span><br><span class=\"line\">if any([math&lt;60,English&lt;60,computer&lt;60]):</span><br><span class=\"line\">    print(&apos;not pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">not pass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多条件内容判断全部成立\"><a href=\"#多条件内容判断全部成立\" class=\"headerlink\" title=\"多条件内容判断全部成立\"></a>多条件内容判断全部成立</h2><p>常规方法：使用 and 连接条件做判断。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if math&gt;60 and English&gt;60 and computer&gt;60:</span><br><span class=\"line\">    print(&apos;pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">pass</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 all 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if all([math&gt;60,English&gt;60,computer&gt;60]):</span><br><span class=\"line\">    print(&apos;pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">pass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历序列的元素和元素下标\"><a href=\"#遍历序列的元素和元素下标\" class=\"headerlink\" title=\"遍历序列的元素和元素下标\"></a>遍历序列的元素和元素下标</h2><p>常规方法：使用 for 循环进行遍历元素和下标。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class=\"line\">for i in range(len(L)):</span><br><span class=\"line\">    print(i, &apos;:&apos;, L[i])</span><br><span class=\"line\">结果</span><br><span class=\"line\">0 : math</span><br><span class=\"line\">1 : English</span><br><span class=\"line\">2 : computer</span><br><span class=\"line\">3 : Physics</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 enumerate 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class=\"line\">for k,v in enumerate(L):</span><br><span class=\"line\">    print(k, &apos;:&apos;, v)</span><br><span class=\"line\">结果</span><br><span class=\"line\">0 : math</span><br><span class=\"line\">1 : English</span><br><span class=\"line\">2 : computer</span><br><span class=\"line\">3 : Physics</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"循环语句优化\"><a href=\"#循环语句优化\" class=\"headerlink\" title=\"循环语句优化\"></a>循环语句优化</h2><p>之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。<br>常规方法：使用简单的 for 循环可以达到目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = []</span><br><span class=\"line\">for i in range(1, 6):</span><br><span class=\"line\">    L.append(i*i)</span><br><span class=\"line\">print(L) </span><br><span class=\"line\">结果：</span><br><span class=\"line\">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用列表生成式，一行代码搞定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print([x*x for x in range(1, 6)]) </span><br><span class=\"line\">结果：</span><br><span class=\"line\">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"将list中的所有元素转为单个字符串\"><a href=\"#将list中的所有元素转为单个字符串\" class=\"headerlink\" title=\"将list中的所有元素转为单个字符串\"></a>将list中的所有元素转为单个字符串</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]</span><br><span class=\"line\">print(&quot; &quot;,join(a))</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串倒转\"><a href=\"#字符串倒转\" class=\"headerlink\" title=\"字符串倒转\"></a>字符串倒转</h2><p>方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。<br>方法二：用Python自带reversed()函数，它可被用于list倒转。<br>方法三：第三种是通过倒转数据类型和切片倒转整数.</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>在python 中实现链式调用只需在函数返回对象自己就行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def product(a, b):</span><br><span class=\"line\">    return a * b</span><br><span class=\"line\">def add(a, b):</span><br><span class=\"line\">    return a + b</span><br><span class=\"line\">b = True</span><br><span class=\"line\">print((product if b else add)(5, 7))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"复制list\"><a href=\"#复制list\" class=\"headerlink\" title=\"复制list\"></a>复制list</h2><p>在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：<br>方法一：b=a[:]。<br>方法二：b=list(a)。<br>方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。<br>方法四：使用copy.deepcopy()。</p>\n<h2 id=\"按value排序字典\"><a href=\"#按value排序字典\" class=\"headerlink\" title=\"按value排序字典\"></a>按value排序字典</h2><p>Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：<br>方法一：用sorted函数排序，其中key参数是lamda表达式。<br>方法二：用operator.itemgetter而不是lamda表达式进行排序。<br>方法三：如果只需得到排序后的key，可用.get。</p>\n<h2 id=\"for-…-else语法\"><a href=\"#for-…-else语法\" class=\"headerlink\" title=\"for … else语法\"></a>for … else语法</h2><h2 id=\"合并字典\"><a href=\"#合并字典\" class=\"headerlink\" title=\"合并字典\"></a>合并字典</h2><p>方法一：Python 3.5可以存在重复键值，print({<strong>d1 ,</strong>d2})。<br>方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。<br>方法三：d1.update()。</p>\n<h2 id=\"从list中删除重复项\"><a href=\"#从list中删除重复项\" class=\"headerlink\" title=\"从list中删除重复项\"></a>从list中删除重复项</h2><p>方法一：把list转成set，去除重复项，再转回list。<br>方法二：调用collections里的OrderedDict，和set差不多。</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"为多个变量赋值\"><a href=\"#为多个变量赋值\" class=\"headerlink\" title=\"为多个变量赋值\"></a>为多个变量赋值</h2><p>有时，有多个变量需要赋值，这时你会怎么赋值呢？<br>常规方法：常规方法是给变量逐个赋值。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = <span class=\"number\">0</span>  </span><br><span class=\"line\">b = <span class=\"number\">1</span>  </span><br><span class=\"line\">c = <span class=\"number\">2</span></span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：<br>直接按顺序对应一一赋值.<br>a, b, c = 0, 1, 2</p>\n<h2 id=\"序列解包\"><a href=\"#序列解包\" class=\"headerlink\" title=\"序列解包\"></a>序列解包</h2><p>需要取出列表中的元素。<br>常规方法：一般我们知道可以通过下标获取具体元素。<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info = [<span class=\"string\">'brucepk'</span>, <span class=\"string\">'man'</span>, <span class=\"string\">'python'</span>]</span><br><span class=\"line\">name = info[<span class=\"number\">0</span>]</span><br><span class=\"line\">sex = info[<span class=\"number\">1</span>]</span><br><span class=\"line\">tech = info[<span class=\"number\">2</span>]</span><br><span class=\"line\">print(name,sex,tech)</span><br><span class=\"line\">结果:</span><br><span class=\"line\">brucepk man python</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：给出对应变量接收所有元素。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">info = [&apos;brucepk&apos;, &apos;man&apos;, &apos;python&apos;]</span><br><span class=\"line\">name,sex,tech = info</span><br><span class=\"line\">print(name,sex,tech)</span><br><span class=\"line\">结果:</span><br><span class=\"line\">brucepk man python</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"优雅你的判断语句\"><a href=\"#优雅你的判断语句\" class=\"headerlink\" title=\"优雅你的判断语句\"></a>优雅你的判断语句</h2><p>我们用判断语句来定义一个绝对值函数。<br>常规方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">x = <span class=\"number\">-6</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> x &lt; <span class=\"number\">0</span>:</span><br><span class=\"line\">    y = -x</span><br><span class=\"line\"><span class=\"keyword\">else</span>:</span><br><span class=\"line\">    y = x</span><br><span class=\"line\">print(y)</span><br><span class=\"line\">结果:</span><br><span class=\"line\"><span class=\"number\">6</span></span><br><span class=\"line\">优雅方法：</span><br><span class=\"line\">x = <span class=\"number\">-6</span></span><br><span class=\"line\">y = -x <span class=\"keyword\">if</span> x&lt;<span class=\"number\">0</span> <span class=\"keyword\">else</span> x</span><br><span class=\"line\">print(y)</span><br><span class=\"line\">结果</span><br><span class=\"line\"><span class=\"number\">6</span></span><br></pre></td></tr></table></figure></p>\n<h2 id=\"区间判断\"><a href=\"#区间判断\" class=\"headerlink\" title=\"区间判断\"></a>区间判断</h2><p>使用 and 连续两次判断的语句，条件都符合时才执行语句。<br>常规方法：<br><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = <span class=\"number\">82</span></span><br><span class=\"line\"><span class=\"keyword\">if</span> score &gt;=<span class=\"number\">80</span> <span class=\"keyword\">and</span> score &lt; <span class=\"number\">90</span>:</span><br><span class=\"line\">    level = <span class=\"string\">'B'</span></span><br><span class=\"line\">print(level)</span><br><span class=\"line\">结果</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用链式判断。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">score = 82</span><br><span class=\"line\">if  80 &lt;= score &lt; 90:</span><br><span class=\"line\">    level = &apos;B&apos;</span><br><span class=\"line\">print(level)</span><br><span class=\"line\">结果</span><br><span class=\"line\">B</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多个值符合条件判断\"><a href=\"#多个值符合条件判断\" class=\"headerlink\" title=\"多个值符合条件判断\"></a>多个值符合条件判断</h2><p>多个值任意一个值符合条件即为 True 的情况。<br>常规方法：<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = 1</span><br><span class=\"line\">if num == 1 or num == 3 or num == 5:</span><br><span class=\"line\">    type = &apos;奇数&apos;</span><br><span class=\"line\">print(type)</span><br><span class=\"line\">结果</span><br><span class=\"line\">奇数</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用关键字 in，让你的语句更优雅。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">num = 1</span><br><span class=\"line\">if num in(1,3,5):</span><br><span class=\"line\">    type = &apos;奇数&apos;</span><br><span class=\"line\">print(type)</span><br><span class=\"line\">结果</span><br><span class=\"line\">奇数</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"判断是否为空\"><a href=\"#判断是否为空\" class=\"headerlink\" title=\"判断是否为空\"></a>判断是否为空</h2><p>判断元素是空还是非空。<br>常规方法：一般我们想到的是 len() 方法来判断元素长度，大于 0 则为非空。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;</span><br><span class=\"line\">if len(A) &gt; 0:</span><br><span class=\"line\">    print(&apos;A 为非空&apos;)</span><br><span class=\"line\">if len(B) &gt; 0:</span><br><span class=\"line\">    print(&apos;B 为非空&apos;)</span><br><span class=\"line\">if len(C) &gt; 0:</span><br><span class=\"line\">    print(&apos;C 为非空&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">A 为非空</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：if 后面的执行条件是可以简写的，只要条件 是非零数值、非空字符串、非空 list 等，就判断为 True，否则为 False。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">A,B,C =[1,3,5],&#123;&#125;,&apos;&apos;  </span><br><span class=\"line\">if A:</span><br><span class=\"line\">    print(&apos;A 为非空&apos;)  </span><br><span class=\"line\">if B:</span><br><span class=\"line\">    print(&apos;B 为非空&apos;)  </span><br><span class=\"line\">if C:</span><br><span class=\"line\">    print(&apos;C 为非空&apos;)  </span><br><span class=\"line\">结果</span><br><span class=\"line\">A 为非空</span><br></pre></td></tr></table></figure>\n<h2 id=\"多条件内容判断至少一个成立\"><a href=\"#多条件内容判断至少一个成立\" class=\"headerlink\" title=\"多条件内容判断至少一个成立\"></a>多条件内容判断至少一个成立</h2><p>常规方法：用 or 连接多个条件。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if math&lt;60 or English&lt;60 or computer&lt;60:</span><br><span class=\"line\">    print(&apos;not pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">not pass</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 any 语句。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,59,88</span><br><span class=\"line\">if any([math&lt;60,English&lt;60,computer&lt;60]):</span><br><span class=\"line\">    print(&apos;not pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">not pass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"多条件内容判断全部成立\"><a href=\"#多条件内容判断全部成立\" class=\"headerlink\" title=\"多条件内容判断全部成立\"></a>多条件内容判断全部成立</h2><p>常规方法：使用 and 连接条件做判断。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if math&gt;60 and English&gt;60 and computer&gt;60:</span><br><span class=\"line\">    print(&apos;pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">pass</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 all 方法。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">math,English,computer =90,80,88</span><br><span class=\"line\">if all([math&gt;60,English&gt;60,computer&gt;60]):</span><br><span class=\"line\">    print(&apos;pass&apos;)</span><br><span class=\"line\">结果</span><br><span class=\"line\">pass</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"遍历序列的元素和元素下标\"><a href=\"#遍历序列的元素和元素下标\" class=\"headerlink\" title=\"遍历序列的元素和元素下标\"></a>遍历序列的元素和元素下标</h2><p>常规方法：使用 for 循环进行遍历元素和下标。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class=\"line\">for i in range(len(L)):</span><br><span class=\"line\">    print(i, &apos;:&apos;, L[i])</span><br><span class=\"line\">结果</span><br><span class=\"line\">0 : math</span><br><span class=\"line\">1 : English</span><br><span class=\"line\">2 : computer</span><br><span class=\"line\">3 : Physics</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用 enumerate 函数。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L =[&apos;math&apos;, &apos;English&apos;, &apos;computer&apos;, &apos;Physics&apos;]</span><br><span class=\"line\">for k,v in enumerate(L):</span><br><span class=\"line\">    print(k, &apos;:&apos;, v)</span><br><span class=\"line\">结果</span><br><span class=\"line\">0 : math</span><br><span class=\"line\">1 : English</span><br><span class=\"line\">2 : computer</span><br><span class=\"line\">3 : Physics</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"循环语句优化\"><a href=\"#循环语句优化\" class=\"headerlink\" title=\"循环语句优化\"></a>循环语句优化</h2><p>之前的文章 零基础学 Python 之列表生成式 中讲过列表生成时的用法，举例：生成 [1x1,2x2,3x3，4x4，5x5]。<br>常规方法：使用简单的 for 循环可以达到目的。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">L = []</span><br><span class=\"line\">for i in range(1, 6):</span><br><span class=\"line\">    L.append(i*i)</span><br><span class=\"line\">print(L) </span><br><span class=\"line\">结果：</span><br><span class=\"line\">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p>\n<p>优雅方法：使用列表生成式，一行代码搞定。<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print([x*x for x in range(1, 6)]) </span><br><span class=\"line\">结果：</span><br><span class=\"line\">[1, 4, 9, 16, 25]</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"将list中的所有元素转为单个字符串\"><a href=\"#将list中的所有元素转为单个字符串\" class=\"headerlink\" title=\"将list中的所有元素转为单个字符串\"></a>将list中的所有元素转为单个字符串</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = [&quot;python&quot;, &quot;is&quot;, &quot;awesome&quot;]</span><br><span class=\"line\">print(&quot; &quot;,join(a))</span><br></pre></td></tr></table></figure>\n<h2 id=\"字符串倒转\"><a href=\"#字符串倒转\" class=\"headerlink\" title=\"字符串倒转\"></a>字符串倒转</h2><p>方法一：最简单的切片法，a[::-1]就相当于a[尾:头:-1]。<br>方法二：用Python自带reversed()函数，它可被用于list倒转。<br>方法三：第三种是通过倒转数据类型和切片倒转整数.</p>\n<h2 id=\"链式调用\"><a href=\"#链式调用\" class=\"headerlink\" title=\"链式调用\"></a>链式调用</h2><p>在python 中实现链式调用只需在函数返回对象自己就行<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def product(a, b):</span><br><span class=\"line\">    return a * b</span><br><span class=\"line\">def add(a, b):</span><br><span class=\"line\">    return a + b</span><br><span class=\"line\">b = True</span><br><span class=\"line\">print((product if b else add)(5, 7))</span><br></pre></td></tr></table></figure></p>\n<h2 id=\"复制list\"><a href=\"#复制list\" class=\"headerlink\" title=\"复制list\"></a>复制list</h2><p>在Python中，变量指向的是某个对象的标签。也就是说，按照这种的写法，b和a指向的是内存中的同一个列表，对b操作，就相当于对a操作。所以正确的写法有以下几种：<br>方法一：b=a[:]。<br>方法二：b=list(a)。<br>方法三：使用Python 3的copy()函数，直接复制list，类似a[:]。<br>方法四：使用copy.deepcopy()。</p>\n<h2 id=\"按value排序字典\"><a href=\"#按value排序字典\" class=\"headerlink\" title=\"按value排序字典\"></a>按value排序字典</h2><p>Python的内置字典数据类型是无序的，而key可以被用来获取对应的value。有时我们需要根据value对字典中的item进行排序输出。方法如下所示：<br>方法一：用sorted函数排序，其中key参数是lamda表达式。<br>方法二：用operator.itemgetter而不是lamda表达式进行排序。<br>方法三：如果只需得到排序后的key，可用.get。</p>\n<h2 id=\"for-…-else语法\"><a href=\"#for-…-else语法\" class=\"headerlink\" title=\"for … else语法\"></a>for … else语法</h2><h2 id=\"合并字典\"><a href=\"#合并字典\" class=\"headerlink\" title=\"合并字典\"></a>合并字典</h2><p>方法一：Python 3.5可以存在重复键值，print({<strong>d1 ,</strong>d2})。<br>方法二：在内存中创建两个列表，再创建第三个列表，拷贝完成后，创建新的dict，删除掉前三个列表。<br>方法三：d1.update()。</p>\n<h2 id=\"从list中删除重复项\"><a href=\"#从list中删除重复项\" class=\"headerlink\" title=\"从list中删除重复项\"></a>从list中删除重复项</h2><p>方法一：把list转成set，去除重复项，再转回list。<br>方法二：调用collections里的OrderedDict，和set差不多。</p>\n"},{"title":"二分法","_content":"\n练习\n\n有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。 \n分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。\n思路 \n排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。 \n查找插入点，使用二分查找完成。 \n假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。 \n直到中点就是\n\n```python\ndef insert_sort(orderlist, i):    \n    ret = orderlist[:]    \n    low = 0    \n    high = len(ret) - 1    \n    while low < high: \n        mid = (low + high) // 2 \n        if ret[mid] < i: \n            low = mid + 1 \n            # 说明i大，往右找，调整下限 else: high = mid \n            # 说明i小于等于，往左找，调整上限    \n            print(low, i) \n            # low为插入点    \n            ret.insert(low, i)    \n            return ret\n# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]\nnewlst = sorted(lst) \n# 升序 \nprint(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] \nfor x in (40, 20, 41):    \n    newlst = insert_sort(newlst, x)    \n    print(newlst)\n\n```\n\n\n\n看似上面代码不错，请测试插入100。 \n问题来了，100插入的位置不对，为什么？\n\n```python\ndef insert_sort(orderlist, i):    \n    ret = orderlist[:]    \n    low = 0    \n    high = len(ret) # 去掉减1    \n    while low < high: \n        mid = (low + high) // 2 \n        if ret[mid] < i: \n            low = mid + 1 # 说明i大，往右找，调整下限 \n            else:\n                high = mid # 说明i小于等于，往左找，调整上限    \n     print(low, i) # low为插入点    \n     ret.insert(low, i)    \n     return ret\n \n# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]\n \nnewlst = sorted(lst) # 升序\nprint(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] \nfor x in (40, 20, 41, 100):    \n    newlst = insert_sort(newlst, x)    \n    print(newlst)\n\n```\n\n\n\n high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。\n如果是一个比当前有序列表最大值还大的值插入， while low < high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。\n\n### 二分\t \n\n二分前提是有序，否则不可以二分。\n二分查找算法的时间复杂度O(log n)\n\n### bisect模块\t \n\nbisect模块提供的函数有：\n\n* bisect.bisect_left(a,x, lo=0, hi=len(a)) \n  查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。\n* bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a)) \n  在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。\n* bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。\n  函数可以分2类： bisect系，用于查找index。 \n  Insort系，用于实际插入。默认重复时从右边插入。\n\n应用\t \n判断学生成绩，成绩等级A~E。其中，90分以上为'A'，80~89分为'B'，70~79分为'C'，60~69分 为'D'，60分以下为'E'\n\n```python\nimport bisect\n \ndef get_grade(score):    \n    breakpoints = [60, 70, 80, 90]    \n    grades = 'EDCBA'\n \n    return grades[bisect.bisect(breakpoints, score)]\n \nfor x in (91, 82, 77, 65, 50, 60, 70, 80, 90):    \n    print('{} => {}'.format(x, get_grade(x)))\n```\n\n\n\n \n\n \n","source":"_posts/1 (22).md","raw":"---\ntitle: 二分法\ncategories: \n- python\ntags:\n- python\n---\n\n练习\n\n有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。 \n分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。\n思路 \n排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。 \n查找插入点，使用二分查找完成。 \n假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。 \n直到中点就是\n\n```python\ndef insert_sort(orderlist, i):    \n    ret = orderlist[:]    \n    low = 0    \n    high = len(ret) - 1    \n    while low < high: \n        mid = (low + high) // 2 \n        if ret[mid] < i: \n            low = mid + 1 \n            # 说明i大，往右找，调整下限 else: high = mid \n            # 说明i小于等于，往左找，调整上限    \n            print(low, i) \n            # low为插入点    \n            ret.insert(low, i)    \n            return ret\n# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]\nnewlst = sorted(lst) \n# 升序 \nprint(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] \nfor x in (40, 20, 41):    \n    newlst = insert_sort(newlst, x)    \n    print(newlst)\n\n```\n\n\n\n看似上面代码不错，请测试插入100。 \n问题来了，100插入的位置不对，为什么？\n\n```python\ndef insert_sort(orderlist, i):    \n    ret = orderlist[:]    \n    low = 0    \n    high = len(ret) # 去掉减1    \n    while low < high: \n        mid = (low + high) // 2 \n        if ret[mid] < i: \n            low = mid + 1 # 说明i大，往右找，调整下限 \n            else:\n                high = mid # 说明i小于等于，往左找，调整上限    \n     print(low, i) # low为插入点    \n     ret.insert(low, i)    \n     return ret\n \n# 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]\n \nnewlst = sorted(lst) # 升序\nprint(newlst) #[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] \nfor x in (40, 20, 41, 100):    \n    newlst = insert_sort(newlst, x)    \n    print(newlst)\n\n```\n\n\n\n high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。\n如果是一个比当前有序列表最大值还大的值插入， while low < high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。\n\n### 二分\t \n\n二分前提是有序，否则不可以二分。\n二分查找算法的时间复杂度O(log n)\n\n### bisect模块\t \n\nbisect模块提供的函数有：\n\n* bisect.bisect_left(a,x, lo=0, hi=len(a)) \n  查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。\n* bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a)) \n  在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。\n* bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。\n  函数可以分2类： bisect系，用于查找index。 \n  Insort系，用于实际插入。默认重复时从右边插入。\n\n应用\t \n判断学生成绩，成绩等级A~E。其中，90分以上为'A'，80~89分为'B'，70~79分为'C'，60~69分 为'D'，60分以下为'E'\n\n```python\nimport bisect\n \ndef get_grade(score):    \n    breakpoints = [60, 70, 80, 90]    \n    grades = 'EDCBA'\n \n    return grades[bisect.bisect(breakpoints, score)]\n \nfor x in (91, 82, 77, 65, 50, 60, 70, 80, 90):    \n    print('{} => {}'.format(x, get_grade(x)))\n```\n\n\n\n \n\n \n","slug":"1 (22)","published":1,"date":"2019-05-26T04:15:54.238Z","updated":"2019-06-19T14:49:21.051Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h810000ejkufi8jmd5zm","content":"<p>练习</p>\n<p>有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。<br>分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。<br>思路<br>排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。<br>查找插入点，使用二分查找完成。<br>假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。<br>直到中点就是</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(orderlist, i)</span>:</span>    </span><br><span class=\"line\">    ret = orderlist[:]    </span><br><span class=\"line\">    low = <span class=\"number\">0</span>    </span><br><span class=\"line\">    high = len(ret) - <span class=\"number\">1</span>    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high: </span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ret[mid] &lt; i: </span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"comment\"># 说明i大，往右找，调整下限 else: high = mid </span></span><br><span class=\"line\">            <span class=\"comment\"># 说明i小于等于，往左找，调整上限    </span></span><br><span class=\"line\">            print(low, i) </span><br><span class=\"line\">            <span class=\"comment\"># low为插入点    </span></span><br><span class=\"line\">            ret.insert(low, i)    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"><span class=\"comment\"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class=\"line\">newlst = sorted(lst) </span><br><span class=\"line\"><span class=\"comment\"># 升序 </span></span><br><span class=\"line\">print(newlst) <span class=\"comment\">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">40</span>, <span class=\"number\">20</span>, <span class=\"number\">41</span>):    </span><br><span class=\"line\">    newlst = insert_sort(newlst, x)    </span><br><span class=\"line\">    print(newlst)</span><br></pre></td></tr></table></figure>\n<p>看似上面代码不错，请测试插入100。<br>问题来了，100插入的位置不对，为什么？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(orderlist, i)</span>:</span>    </span><br><span class=\"line\">    ret = orderlist[:]    </span><br><span class=\"line\">    low = <span class=\"number\">0</span>    </span><br><span class=\"line\">    high = len(ret) <span class=\"comment\"># 去掉减1    </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high: </span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ret[mid] &lt; i: </span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span> <span class=\"comment\"># 说明i大，往右找，调整下限 </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                high = mid <span class=\"comment\"># 说明i小于等于，往左找，调整上限    </span></span><br><span class=\"line\">     print(low, i) <span class=\"comment\"># low为插入点    </span></span><br><span class=\"line\">     ret.insert(low, i)    </span><br><span class=\"line\">     <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">newlst = sorted(lst) <span class=\"comment\"># 升序</span></span><br><span class=\"line\">print(newlst) <span class=\"comment\">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">40</span>, <span class=\"number\">20</span>, <span class=\"number\">41</span>, <span class=\"number\">100</span>):    </span><br><span class=\"line\">    newlst = insert_sort(newlst, x)    </span><br><span class=\"line\">    print(newlst)</span><br></pre></td></tr></table></figure>\n<p> high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。<br>如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。</p>\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><p>二分前提是有序，否则不可以二分。<br>二分查找算法的时间复杂度O(log n)</p>\n<h3 id=\"bisect模块\"><a href=\"#bisect模块\" class=\"headerlink\" title=\"bisect模块\"></a>bisect模块</h3><p>bisect模块提供的函数有：</p>\n<ul>\n<li>bisect.bisect_left(a,x, lo=0, hi=len(a))<br>查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。</li>\n<li>bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))<br>在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。</li>\n<li>bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。<br>函数可以分2类： bisect系，用于查找index。<br>Insort系，用于实际插入。默认重复时从右边插入。</li>\n</ul>\n<p>应用<br>判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> bisect</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_grade</span><span class=\"params\">(score)</span>:</span>    </span><br><span class=\"line\">    breakpoints = [<span class=\"number\">60</span>, <span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>]    </span><br><span class=\"line\">    grades = <span class=\"string\">'EDCBA'</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> grades[bisect.bisect(breakpoints, score)]</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">91</span>, <span class=\"number\">82</span>, <span class=\"number\">77</span>, <span class=\"number\">65</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>):    </span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; =&gt; &#123;&#125;'</span>.format(x, get_grade(x)))</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>练习</p>\n<p>有一个无序序列[37, 99, 73, 48, 47, 40, 40, 25, 99, 51]，对其先排序输出新列表。<br>分别尝试插入20、40、41到这个新序列中合适的位置，保证其有序。<br>思路<br>排序后二分查找到适当位置插入数值。排序使用sorted解决，假设升序输出。<br>查找插入点，使用二分查找完成。<br>假设全长为n，首先在大致的中点元素开始和待插入数比较，如果大则和右边的区域的中点继续比较，如果小则和左边的区域的中点进行比较，以此类推。<br>直到中点就是</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(orderlist, i)</span>:</span>    </span><br><span class=\"line\">    ret = orderlist[:]    </span><br><span class=\"line\">    low = <span class=\"number\">0</span>    </span><br><span class=\"line\">    high = len(ret) - <span class=\"number\">1</span>    </span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high: </span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ret[mid] &lt; i: </span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span> </span><br><span class=\"line\">            <span class=\"comment\"># 说明i大，往右找，调整下限 else: high = mid </span></span><br><span class=\"line\">            <span class=\"comment\"># 说明i小于等于，往左找，调整上限    </span></span><br><span class=\"line\">            print(low, i) </span><br><span class=\"line\">            <span class=\"comment\"># low为插入点    </span></span><br><span class=\"line\">            ret.insert(low, i)    </span><br><span class=\"line\">            <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"><span class=\"comment\"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class=\"line\">newlst = sorted(lst) </span><br><span class=\"line\"><span class=\"comment\"># 升序 </span></span><br><span class=\"line\">print(newlst) <span class=\"comment\">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">40</span>, <span class=\"number\">20</span>, <span class=\"number\">41</span>):    </span><br><span class=\"line\">    newlst = insert_sort(newlst, x)    </span><br><span class=\"line\">    print(newlst)</span><br></pre></td></tr></table></figure>\n<p>看似上面代码不错，请测试插入100。<br>问题来了，100插入的位置不对，为什么？</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">insert_sort</span><span class=\"params\">(orderlist, i)</span>:</span>    </span><br><span class=\"line\">    ret = orderlist[:]    </span><br><span class=\"line\">    low = <span class=\"number\">0</span>    </span><br><span class=\"line\">    high = len(ret) <span class=\"comment\"># 去掉减1    </span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> low &lt; high: </span><br><span class=\"line\">        mid = (low + high) // <span class=\"number\">2</span> </span><br><span class=\"line\">        <span class=\"keyword\">if</span> ret[mid] &lt; i: </span><br><span class=\"line\">            low = mid + <span class=\"number\">1</span> <span class=\"comment\"># 说明i大，往右找，调整下限 </span></span><br><span class=\"line\">            <span class=\"keyword\">else</span>:</span><br><span class=\"line\">                high = mid <span class=\"comment\"># 说明i小于等于，往左找，调整上限    </span></span><br><span class=\"line\">     print(low, i) <span class=\"comment\"># low为插入点    </span></span><br><span class=\"line\">     ret.insert(low, i)    </span><br><span class=\"line\">     <span class=\"keyword\">return</span> ret</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"comment\"># 测试 lst = [37, 99, 73, 48, 47, 40, 40, 25, 99, 51]</span></span><br><span class=\"line\"> </span><br><span class=\"line\">newlst = sorted(lst) <span class=\"comment\"># 升序</span></span><br><span class=\"line\">print(newlst) <span class=\"comment\">#[25, 37, 40, 40, 47, 48, 51, 73, 99, 99] </span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">40</span>, <span class=\"number\">20</span>, <span class=\"number\">41</span>, <span class=\"number\">100</span>):    </span><br><span class=\"line\">    newlst = insert_sort(newlst, x)    </span><br><span class=\"line\">    print(newlst)</span><br></pre></td></tr></table></figure>\n<p> high = len(orderlist) ，去掉减1，不影响整除2，但影响下一行判断。<br>如果是一个比当前有序列表最大值还大的值插入， while low &lt; high 这个条件退出时，就是low等于high，也就是low可以取到length了，这相当于在尾部追加。原来代码写法只能取到length-1，相当于在最后一个元素的索引处插入数据，最后一个数据被向后挤。算法的核心，就是折半至重合为止。</p>\n<h3 id=\"二分\"><a href=\"#二分\" class=\"headerlink\" title=\"二分\"></a>二分</h3><p>二分前提是有序，否则不可以二分。<br>二分查找算法的时间复杂度O(log n)</p>\n<h3 id=\"bisect模块\"><a href=\"#bisect模块\" class=\"headerlink\" title=\"bisect模块\"></a>bisect模块</h3><p>bisect模块提供的函数有：</p>\n<ul>\n<li>bisect.bisect_left(a,x, lo=0, hi=len(a))<br>查找在有序列表a中插入x的index。lo和hi用于指定列表的区间，默认是使用整个列表。如果x已经存在，在其左边插入。返回值为index。</li>\n<li>bisect.bisect_right(a,x, lo=0, hi=len(a)) 或 bisect.bisect(a, x,lo=0, hi=len(a)) 和bisect_left类似，但如果x已经存在，在其右边插入。 bisect.insort_left(a,x, lo=0, hi=len(a))<br>在有序列表a中插入x。等同于a.insert(bisect.bisect_left(a,x, lo, hi), x) 。</li>\n<li>bisect.insort_right(a,x, lo=0, hi=len(a)) 或者 bisect.insort(a, x,lo=0, hi=len(a)) 和insort_left函数类似，但如果x已经存在，在其右边插入。<br>函数可以分2类： bisect系，用于查找index。<br>Insort系，用于实际插入。默认重复时从右边插入。</li>\n</ul>\n<p>应用<br>判断学生成绩，成绩等级A~E。其中，90分以上为’A’，80~89分为’B’，70~79分为’C’，60~69分 为’D’，60分以下为’E’</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> bisect</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get_grade</span><span class=\"params\">(score)</span>:</span>    </span><br><span class=\"line\">    breakpoints = [<span class=\"number\">60</span>, <span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>]    </span><br><span class=\"line\">    grades = <span class=\"string\">'EDCBA'</span></span><br><span class=\"line\"> </span><br><span class=\"line\">    <span class=\"keyword\">return</span> grades[bisect.bisect(breakpoints, score)]</span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> (<span class=\"number\">91</span>, <span class=\"number\">82</span>, <span class=\"number\">77</span>, <span class=\"number\">65</span>, <span class=\"number\">50</span>, <span class=\"number\">60</span>, <span class=\"number\">70</span>, <span class=\"number\">80</span>, <span class=\"number\">90</span>):    </span><br><span class=\"line\">    print(<span class=\"string\">'&#123;&#125; =&gt; &#123;&#125;'</span>.format(x, get_grade(x)))</span><br></pre></td></tr></table></figure>\n"},{"title":"python知识框架","_content":"---\n# python基础\n\npython是一种动态的强类型语言,底层是用C语言开发的.\n\n平台：*nix平台\n系统：线程、进程、Shell编程\n网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发\n算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写\n数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个\n中间件：消息队列原理和应用，例如8曲bitMQ\nWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一\n可视化：WEB的前端开发多一些HTML、jS要会\n数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用\n\npython学习路线:\n基础：操作系统、网络基础、数据库基础、python语言基础..\n进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..\n高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).\n新前端开发(ES6、React、Antd）...\n实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..\n高端：数据清洗、企业数据分析、预测准荐、机器视觉．\n\n## 数据类型\n\npython中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none\n\n### 字符串\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n\n由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\nUnicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n\n字母A用ASCII编码是十进制的65，二进制的01000001；\n\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；\n\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。\n\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.\n### 字符串的格式化\nformat函数或 格式符\n\n### 编码\n\n字符串与bytes\n字符串是字符组成的有序序列，字符可以使用编码来理解\nbytes是字节组成的有序的不可变序列\nbytearray是字节组成的有序的可变序列\n\n编码与解码：\n字符串按照不同的字符集编码encode返回字节序列bytes\nencode（encoding=‘utf-8’，errors=‘strict’）  \n字节序列按照不同的字符集解码decode返回字符串\nbytes.decode（encoding=“utf-8”，errors=“strict”）\nascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统\n\n要熟记31 41 61 的ascii表\n\n字节序：\n大端模式，big-endian；小端模式，little-endian\nintel x86cpu使用小端 模式\n网络传输更多使用大端模式\nwindows，linux 使用小端模式\nmac os使用大端模式\njava 虚拟机是大端模式\n\n\n## 数字\n\n有整数 浮点数 复数等\n\n## true false\n主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。\n\nNone：Python里面特殊的空值，不能理解为0。\n## 容器\n\nlist（列表） tuple（元组） set（集合） dictionary（字典）\n这些都是可以迭代的\n### list\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。\n### tuple\n元组和列表类似，但是不同的是元组不能修改，元组使用小括号。\n### dict\n\n\n## 判断结构\n\n### if\nif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。\n\nelif 语句\n\nelif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。\n\nif...elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。\n### for\nfor循环可以遍历任何序列的项目：\n### while\nwhile循环，只要条件满足，就不断循环，条件不满足时退出循环：\n\nbreak和continue语句：\n\nbreak可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。\n\ncontinue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。","source":"_posts/1 (19).md","raw":"---\ntitle: python知识框架\n\ncategories: \n- python\ntags:\n- python\n---\n---\n# python基础\n\npython是一种动态的强类型语言,底层是用C语言开发的.\n\n平台：*nix平台\n系统：线程、进程、Shell编程\n网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发\n算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写\n数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个\n中间件：消息队列原理和应用，例如8曲bitMQ\nWEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一\n可视化：WEB的前端开发多一些HTML、jS要会\n数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用\n\npython学习路线:\n基础：操作系统、网络基础、数据库基础、python语言基础..\n进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..\n高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).\n新前端开发(ES6、React、Antd）...\n实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..\n高端：数据清洗、企业数据分析、预测准荐、机器视觉．\n\n## 数据类型\n\npython中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none\n\n### 字符串\n因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。\n\n由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。\n\n但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。\n\n你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。\n因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。\n\nUnicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。\n\n现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。\n\n字母A用ASCII编码是十进制的65，二进制的01000001；\n\n字符0用ASCII编码是十进制的48，二进制的00110000，注意字符'0'和整数0是不同的；\n\n汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。\n\n你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。\n\n新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。\n\n所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.\n### 字符串的格式化\nformat函数或 格式符\n\n### 编码\n\n字符串与bytes\n字符串是字符组成的有序序列，字符可以使用编码来理解\nbytes是字节组成的有序的不可变序列\nbytearray是字节组成的有序的可变序列\n\n编码与解码：\n字符串按照不同的字符集编码encode返回字节序列bytes\nencode（encoding=‘utf-8’，errors=‘strict’）  \n字节序列按照不同的字符集解码decode返回字符串\nbytes.decode（encoding=“utf-8”，errors=“strict”）\nascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统\n\n要熟记31 41 61 的ascii表\n\n字节序：\n大端模式，big-endian；小端模式，little-endian\nintel x86cpu使用小端 模式\n网络传输更多使用大端模式\nwindows，linux 使用小端模式\nmac os使用大端模式\njava 虚拟机是大端模式\n\n\n## 数字\n\n有整数 浮点数 复数等\n\n## true false\n主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。\n\nNone：Python里面特殊的空值，不能理解为0。\n## 容器\n\nlist（列表） tuple（元组） set（集合） dictionary（字典）\n这些都是可以迭代的\n### list\n创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。\n### tuple\n元组和列表类似，但是不同的是元组不能修改，元组使用小括号。\n### dict\n\n\n## 判断结构\n\n### if\nif语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。\n\nelif 语句\n\nelif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。\n\nif...elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。\n### for\nfor循环可以遍历任何序列的项目：\n### while\nwhile循环，只要条件满足，就不断循环，条件不满足时退出循环：\n\nbreak和continue语句：\n\nbreak可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。\n\ncontinue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。","slug":"1 (19)","published":1,"date":"2019-04-01T02:01:12.178Z","updated":"2019-06-19T14:47:10.292Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h814000fjkufyk76ff55","content":"<hr>\n<h1 id=\"python基础\"><a href=\"#python基础\" class=\"headerlink\" title=\"python基础\"></a>python基础</h1><p>python是一种动态的强类型语言,底层是用C语言开发的.</p>\n<p>平台：*nix平台<br>系统：线程、进程、Shell编程<br>网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发<br>算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写<br>数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个<br>中间件：消息队列原理和应用，例如8曲bitMQ<br>WEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一<br>可视化：WEB的前端开发多一些HTML、jS要会<br>数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用</p>\n<p>python学习路线:<br>基础：操作系统、网络基础、数据库基础、python语言基础..<br>进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..<br>高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).<br>新前端开发(ES6、React、Antd）…<br>实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..<br>高端：数据清洗、企业数据分析、预测准荐、机器视觉．</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>\n<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>\n<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>\n<p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>\n<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>\n<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>\n<p>字母A用ASCII编码是十进制的65，二进制的01000001；</p>\n<p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p>\n<p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p>\n<p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p>\n<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>\n<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.</p>\n<h3 id=\"字符串的格式化\"><a href=\"#字符串的格式化\" class=\"headerlink\" title=\"字符串的格式化\"></a>字符串的格式化</h3><p>format函数或 格式符</p>\n<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>字符串与bytes<br>字符串是字符组成的有序序列，字符可以使用编码来理解<br>bytes是字节组成的有序的不可变序列<br>bytearray是字节组成的有序的可变序列</p>\n<p>编码与解码：<br>字符串按照不同的字符集编码encode返回字节序列bytes<br>encode（encoding=‘utf-8’，errors=‘strict’）<br>字节序列按照不同的字符集解码decode返回字符串<br>bytes.decode（encoding=“utf-8”，errors=“strict”）<br>ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统</p>\n<p>要熟记31 41 61 的ascii表</p>\n<p>字节序：<br>大端模式，big-endian；小端模式，little-endian<br>intel x86cpu使用小端 模式<br>网络传输更多使用大端模式<br>windows，linux 使用小端模式<br>mac os使用大端模式<br>java 虚拟机是大端模式</p>\n<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><p>有整数 浮点数 复数等</p>\n<h2 id=\"true-false\"><a href=\"#true-false\" class=\"headerlink\" title=\"true false\"></a>true false</h2><p>主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。</p>\n<p>None：Python里面特殊的空值，不能理解为0。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>list（列表） tuple（元组） set（集合） dictionary（字典）<br>这些都是可以迭代的</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。</p>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><p>元组和列表类似，但是不同的是元组不能修改，元组使用小括号。</p>\n<h3 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h3><h2 id=\"判断结构\"><a href=\"#判断结构\" class=\"headerlink\" title=\"判断结构\"></a>判断结构</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p>\n<p>elif 语句</p>\n<p>elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。</p>\n<p>if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。</p>\n<h3 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h3><p>for循环可以遍历任何序列的项目：</p>\n<h3 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环：</p>\n<p>break和continue语句：</p>\n<p>break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。</p>\n<p>continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。</p>\n","site":{"data":{}},"excerpt":"","more":"<hr>\n<h1 id=\"python基础\"><a href=\"#python基础\" class=\"headerlink\" title=\"python基础\"></a>python基础</h1><p>python是一种动态的强类型语言,底层是用C语言开发的.</p>\n<p>平台：*nix平台<br>系统：线程、进程、Shell编程<br>网络：网络原理、HTTP协议。Socket开发、io多路复用、异步io开发<br>算法要求：转置矩阵、求质数、常见排序算法等，甚至要求现场写<br>数据库：关系型数据库至少会MYSQL，NoSQL应该了解，最好会一个<br>中间件：消息队列原理和应用，例如8曲bitMQ<br>WEB开发：偏后端，MVC框架要求会Django、Flask、Tornado之一<br>可视化：WEB的前端开发多一些HTML、jS要会<br>数据分析和A上要求掌握数据分析的数据理论，机器学习常用库使用</p>\n<p>python学习路线:<br>基础：操作系统、网络基础、数据库基础、python语言基础..<br>进阶：函数封装思想、面向对象设计、装饰器、描述器、元编程..<br>高级：网络编程、并发编程、消息中间件、ORM、传统网页开发(HTML、CSS、jQuery、ECharts).<br>新前端开发(ES6、React、Antd）…<br>实战：WEB框架（类FlaskWEB框架、Django、Flask等）、数据库建模、博客系统、任务流程系统、爬虫Scrap与数据分析..<br>高端：数据清洗、企业数据分析、预测准荐、机器视觉．</p>\n<h2 id=\"数据类型\"><a href=\"#数据类型\" class=\"headerlink\" title=\"数据类型\"></a>数据类型</h2><p>python中的数据类型可以分为5大类:字符串, 数字,容器,布尔,none</p>\n<h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>因为计算机只能处理数字，如果要处理文本，就必须先把文本转换为数字才能处理。最早的计算机在设计时采用8个比特（bit）作为一个字节（byte），所以，一个字节能表示的最大的整数就是255（二进制11111111=十进制255），如果要表示更大的整数，就必须用更多的字节。比如两个字节可以表示的最大整数是65535，4个字节可以表示的最大整数是4294967295。</p>\n<p>由于计算机是美国人发明的，因此，最早只有127个字符被编码到计算机里，也就是大小写英文字母、数字和一些符号，这个编码表被称为ASCII编码，比如大写字母A的编码是65，小写字母z的编码是122。</p>\n<p>但是要处理中文显然一个字节是不够的，至少需要两个字节，而且还不能和ASCII编码冲突，所以，中国制定了GB2312编码，用来把中文编进去。</p>\n<p>你可以想得到的是，全世界有上百种语言，日本把日文编到Shift_JIS里，韩国把韩文编到Euc-kr里，各国有各国的标准，就会不可避免地出现冲突，结果就是，在多语言混合的文本中，显示出来会有乱码。<br>因此，Unicode应运而生。Unicode把所有语言都统一到一套编码里，这样就不会再有乱码问题了。</p>\n<p>Unicode标准也在不断发展，但最常用的是用两个字节表示一个字符（如果要用到非常偏僻的字符，就需要4个字节）。现代操作系统和大多数编程语言都直接支持Unicode。</p>\n<p>现在，捋一捋ASCII编码和Unicode编码的区别：ASCII编码是1个字节，而Unicode编码通常是2个字节。</p>\n<p>字母A用ASCII编码是十进制的65，二进制的01000001；</p>\n<p>字符0用ASCII编码是十进制的48，二进制的00110000，注意字符’0’和整数0是不同的；</p>\n<p>汉字中已经超出了ASCII编码的范围，用Unicode编码是十进制的20013，二进制的01001110 00101101。</p>\n<p>你可以猜测，如果把ASCII编码的A用Unicode编码，只需要在前面补0就可以，因此，A的Unicode编码是00000000 01000001。</p>\n<p>新的问题又出现了：如果统一成Unicode编码，乱码问题从此消失了。但是，如果你写的文本基本上全部是英文的话，用Unicode编码比ASCII编码需要多一倍的存储空间，在存储和传输上就十分不划算。</p>\n<p>所以，本着节约的精神，又出现了把Unicode编码转化为“可变长编码”的UTF-8编码。UTF-8编码把一个Unicode字符根据不同的数字大小编码成1-6个字节，常用的英文字母被编码成1个字节，汉字通常是3个字节，只有很生僻的字符才会被编码成4-6个字节.</p>\n<h3 id=\"字符串的格式化\"><a href=\"#字符串的格式化\" class=\"headerlink\" title=\"字符串的格式化\"></a>字符串的格式化</h3><p>format函数或 格式符</p>\n<h3 id=\"编码\"><a href=\"#编码\" class=\"headerlink\" title=\"编码\"></a>编码</h3><p>字符串与bytes<br>字符串是字符组成的有序序列，字符可以使用编码来理解<br>bytes是字节组成的有序的不可变序列<br>bytearray是字节组成的有序的可变序列</p>\n<p>编码与解码：<br>字符串按照不同的字符集编码encode返回字节序列bytes<br>encode（encoding=‘utf-8’，errors=‘strict’）<br>字节序列按照不同的字符集解码decode返回字符串<br>bytes.decode（encoding=“utf-8”，errors=“strict”）<br>ascii 表是单字节表，实际就是内存中数据的映射表，是一套基于拉丁字母的一套单字节编码系统</p>\n<p>要熟记31 41 61 的ascii表</p>\n<p>字节序：<br>大端模式，big-endian；小端模式，little-endian<br>intel x86cpu使用小端 模式<br>网络传输更多使用大端模式<br>windows，linux 使用小端模式<br>mac os使用大端模式<br>java 虚拟机是大端模式</p>\n<h2 id=\"数字\"><a href=\"#数字\" class=\"headerlink\" title=\"数字\"></a>数字</h2><p>有整数 浮点数 复数等</p>\n<h2 id=\"true-false\"><a href=\"#true-false\" class=\"headerlink\" title=\"true false\"></a>true false</h2><p>主要应用在条件判断上面，发生即为True，未发生即为False。Python严格区分大小写，所以一定要注意不要写错。</p>\n<p>None：Python里面特殊的空值，不能理解为0。</p>\n<h2 id=\"容器\"><a href=\"#容器\" class=\"headerlink\" title=\"容器\"></a>容器</h2><p>list（列表） tuple（元组） set（集合） dictionary（字典）<br>这些都是可以迭代的</p>\n<h3 id=\"list\"><a href=\"#list\" class=\"headerlink\" title=\"list\"></a>list</h3><p>创建一个列表，只要把逗号分隔的不同的数据项使用方括号括起来即可。列表可以修改，可以用于切片、增、删、改、查。</p>\n<h3 id=\"tuple\"><a href=\"#tuple\" class=\"headerlink\" title=\"tuple\"></a>tuple</h3><p>元组和列表类似，但是不同的是元组不能修改，元组使用小括号。</p>\n<h3 id=\"dict\"><a href=\"#dict\" class=\"headerlink\" title=\"dict\"></a>dict</h3><h2 id=\"判断结构\"><a href=\"#判断结构\" class=\"headerlink\" title=\"判断结构\"></a>判断结构</h2><h3 id=\"if\"><a href=\"#if\" class=\"headerlink\" title=\"if\"></a>if</h3><p>if语句用来检验一个条件， 如果条件为真，我们运行一块语句（称为 if-块 ）， 否则我们处理另外一块语句（称为 else-块 ）。 else 从句是可选的。</p>\n<p>elif 语句</p>\n<p>elif语句可以检查多个表达式的真值，并执行一个代码块的条件之一计算结果为true。</p>\n<p>if…elif 语句是可选的。然而不像else，对此可以有最多一个语句，if语句下边可以有任意数量elif语句。</p>\n<h3 id=\"for\"><a href=\"#for\" class=\"headerlink\" title=\"for\"></a>for</h3><p>for循环可以遍历任何序列的项目：</p>\n<h3 id=\"while\"><a href=\"#while\" class=\"headerlink\" title=\"while\"></a>while</h3><p>while循环，只要条件满足，就不断循环，条件不满足时退出循环：</p>\n<p>break和continue语句：</p>\n<p>break可以用来终止当前的循环语句，即使循环没结束，执行了break语句这个循环就终止了，直接跳出整个循环。</p>\n<p>continue语句是用来告诉程序跳出本次循环，然后执行下一轮循环，不同与break，break是跳出整个循环，continue是结束这一次循环，继续下一次循环。</p>\n"},{"title":"处理异常","_content":"\n## 异常处理(Exception)\n\n#### 错误Error\n\n逻辑错误:算法写错了, 例如加法写成了减法\n\n笔误:例如变量名写错了,语法错误\n\n函数或类使用错误, 其实这也属于逻辑错误\n\n总之,错误是可以避免的\n\n#### 异常Eception\n\n本意就是意外情况\n\n这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.\n\n例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.\n\n#### 错误和异常\n\n在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.\n\n```python\nwith open('tetsabcd') as f:\n    pass\n# 异常\n```\n\n## 产生异常\n\n产生:\n\n* raise语句显示的抛出异常\n* Python解释器自己检测异常并引发它\n程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)\n\n## 异常的捕获\n\n```python\ntry:\n    待捕获异常的代码块\nexcept [异常类型]\n\t异常的处理代码块\n```\n\n\n\n\n","source":"_posts/1 (21).md","raw":"---\ntitle: 处理异常\n\ncategories: \n- python\ntags:\n- python\n---\n\n## 异常处理(Exception)\n\n#### 错误Error\n\n逻辑错误:算法写错了, 例如加法写成了减法\n\n笔误:例如变量名写错了,语法错误\n\n函数或类使用错误, 其实这也属于逻辑错误\n\n总之,错误是可以避免的\n\n#### 异常Eception\n\n本意就是意外情况\n\n这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.\n\n例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.\n\n#### 错误和异常\n\n在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.\n\n```python\nwith open('tetsabcd') as f:\n    pass\n# 异常\n```\n\n## 产生异常\n\n产生:\n\n* raise语句显示的抛出异常\n* Python解释器自己检测异常并引发它\n程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)\n\n## 异常的捕获\n\n```python\ntry:\n    待捕获异常的代码块\nexcept [异常类型]\n\t异常的处理代码块\n```\n\n\n\n\n","slug":"1 (21)","published":1,"date":"2019-05-20T11:34:17.772Z","updated":"2019-06-19T14:49:03.134Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81b000kjkufz89rpr2n","content":"<h2 id=\"异常处理-Exception\"><a href=\"#异常处理-Exception\" class=\"headerlink\" title=\"异常处理(Exception)\"></a>异常处理(Exception)</h2><h4 id=\"错误Error\"><a href=\"#错误Error\" class=\"headerlink\" title=\"错误Error\"></a>错误Error</h4><p>逻辑错误:算法写错了, 例如加法写成了减法</p>\n<p>笔误:例如变量名写错了,语法错误</p>\n<p>函数或类使用错误, 其实这也属于逻辑错误</p>\n<p>总之,错误是可以避免的</p>\n<h4 id=\"异常Eception\"><a href=\"#异常Eception\" class=\"headerlink\" title=\"异常Eception\"></a>异常Eception</h4><p>本意就是意外情况</p>\n<p>这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.</p>\n<p>例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.</p>\n<h4 id=\"错误和异常\"><a href=\"#错误和异常\" class=\"headerlink\" title=\"错误和异常\"></a>错误和异常</h4><p>在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'tetsabcd'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"comment\"># 异常</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"产生异常\"><a href=\"#产生异常\" class=\"headerlink\" title=\"产生异常\"></a>产生异常</h2><p>产生:</p>\n<ul>\n<li>raise语句显示的抛出异常</li>\n<li>Python解释器自己检测异常并引发它<br>程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)</li>\n</ul>\n<h2 id=\"异常的捕获\"><a href=\"#异常的捕获\" class=\"headerlink\" title=\"异常的捕获\"></a>异常的捕获</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    待捕获异常的代码块</span><br><span class=\"line\"><span class=\"keyword\">except</span> [异常类型]</span><br><span class=\"line\">\t异常的处理代码块</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"异常处理-Exception\"><a href=\"#异常处理-Exception\" class=\"headerlink\" title=\"异常处理(Exception)\"></a>异常处理(Exception)</h2><h4 id=\"错误Error\"><a href=\"#错误Error\" class=\"headerlink\" title=\"错误Error\"></a>错误Error</h4><p>逻辑错误:算法写错了, 例如加法写成了减法</p>\n<p>笔误:例如变量名写错了,语法错误</p>\n<p>函数或类使用错误, 其实这也属于逻辑错误</p>\n<p>总之,错误是可以避免的</p>\n<h4 id=\"异常Eception\"><a href=\"#异常Eception\" class=\"headerlink\" title=\"异常Eception\"></a>异常Eception</h4><p>本意就是意外情况</p>\n<p>这有个前提,没有出现上面的错误,也就是说程序写的没有问题,但是在某些情况下,会出现一些意外,导致程序无法正常的执行下去.</p>\n<p>例如open函数操作一个文件,文件不存在,或者创建一个文件时已经存在了,或者访问一个网络文件,突然断网了,这就是异常,是个意外的情况.</p>\n<h4 id=\"错误和异常\"><a href=\"#错误和异常\" class=\"headerlink\" title=\"错误和异常\"></a>错误和异常</h4><p>在高级编程语言中,一般都有错误和异常的概念,异常是 可以捕获,但是错误不能被捕获.</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'tetsabcd'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">    <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"comment\"># 异常</span></span><br></pre></td></tr></table></figure>\n<h2 id=\"产生异常\"><a href=\"#产生异常\" class=\"headerlink\" title=\"产生异常\"></a>产生异常</h2><p>产生:</p>\n<ul>\n<li>raise语句显示的抛出异常</li>\n<li>Python解释器自己检测异常并引发它<br>程序会在异常抛出的地方中断执行,如果不捕获,就会提前结束程序(其实是终止当前线程的执行)</li>\n</ul>\n<h2 id=\"异常的捕获\"><a href=\"#异常的捕获\" class=\"headerlink\" title=\"异常的捕获\"></a>异常的捕获</h2><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">try</span>:</span><br><span class=\"line\">    待捕获异常的代码块</span><br><span class=\"line\"><span class=\"keyword\">except</span> [异常类型]</span><br><span class=\"line\">\t异常的处理代码块</span><br></pre></td></tr></table></figure>\n"},{"title":"算素数和杨辉三角","_content":"\n# 求素数算法剖析\n* 简单解法\n\n  ```python\n  n = 100\n  for i in range(2,n):\n    for x in range(2 ,int(i**0.5)+1):\n        if i % x == 0:\n            break\n    else:\n        count +=1\n        print(x)\n  ```\n\n\n  for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.\n\n* 使用奇数\n\n```python\nn = 100\ncount = 1\nfor x in range(3,n,2):\n    for i in range(3,int(x**0.5)+1,2):\n        if x % i ==0:\n            break\n    else:\n        count += 1\nprint (count)\n```\n\n* 储存质素\n\n合数一定可以分解为几个质数的乘积,2是质数\n质数一定不能整除1和本身之内的整数\n\n```python\nn = 100\ncount = 1\npre\nfor x in range(3,n,2):\n    for i in primenumbers:\n        if x % i == 0:\n            break\n    else:\n        premenumber.append(x)\n        count +=1\nprint(count)\n```\n\n\n# 杨辉三角  \n预先构成前两行 从而推到后面的所有行\n\n```python\ntriandle = [[1],[1,1]]\nfor i in range(2,6):\n    cur = [1]\n    pre = triandle[i -1]\n    for j in range(i-1):\n        cur.append(pre[j] + pre[j + 1])\n    cur.append(1)\n    triandle.append(cur)\nprint(triandle)\n```\n\n变形\n\n```python\ntriandle = []\nn = 6\nfor i in range(n):\n    cur = [1]\n    triandle.append(cur)\n   \nif  i==0:continue\npre = triandle[i -1]\nfor  j in range(i -1):\n    cur.append(pre[j] + pre[j + 1])\ncur.append(1)\nprint(triandle)\n```\n\n补零法\n\n```python\nn = 6 \nnewline = [1]\nprint(newline)\n\nfor  i in range(1,n):\n    oldline = newline.copy()\n    oldline.append(0)\n    newline.clear()\n    \n \nfor j in range(i+1):\n    newline.append(oldline[j -1] + oldline[j])\n\nprint(newline)\n```\n\n* 对称性 \n一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.\n\n```python\ntriandle = []\nn = 6\nfor i in range(n):\n    row = [1] * (i + 1)\n    triandle.append(row)\n```\n\n    for j in range(1,i//2+1):\n        val = triandle[i-1][j-1] + triandle[i -1][j]\n        row[j]  = val\n        row[-j-1] = val\n\n```python\nprint(triandle)\ntriangle = []\nn = 6\nfor i in range(n):\n    row = [1] *(i +1)\n    triangle.append(row)\n    for  j in range(i,i//2+1):\n        val = triangle[i-1][j-1] + triangle[i -1][j]\n        row[j] = val\n        if  i != 2*j:\n            row[-j-i] = val\nprint(triangle)\n```\n\n单行覆盖法\n\n```python\nn = 6\nrow = [1] *n\nprint(row)\nprint('_' * 30)\n\nfor  i in range(n):\n    for j in range(i//2):\n        val = row[j] + row[j+1]\n        row[j+1]=val\n        if i != 2* (j+1):\n            row[i-(j+1)] =val\n    print(row[:i+1])\n```\n\n\n\n\n","source":"_posts/1 (2).md","raw":"---\ntitle: 算素数和杨辉三角\n\ncategories:\n- 算法习题\ntags:\n- 算法习题\n---\n\n# 求素数算法剖析\n* 简单解法\n\n  ```python\n  n = 100\n  for i in range(2,n):\n    for x in range(2 ,int(i**0.5)+1):\n        if i % x == 0:\n            break\n    else:\n        count +=1\n        print(x)\n  ```\n\n\n  for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.\n\n* 使用奇数\n\n```python\nn = 100\ncount = 1\nfor x in range(3,n,2):\n    for i in range(3,int(x**0.5)+1,2):\n        if x % i ==0:\n            break\n    else:\n        count += 1\nprint (count)\n```\n\n* 储存质素\n\n合数一定可以分解为几个质数的乘积,2是质数\n质数一定不能整除1和本身之内的整数\n\n```python\nn = 100\ncount = 1\npre\nfor x in range(3,n,2):\n    for i in primenumbers:\n        if x % i == 0:\n            break\n    else:\n        premenumber.append(x)\n        count +=1\nprint(count)\n```\n\n\n# 杨辉三角  \n预先构成前两行 从而推到后面的所有行\n\n```python\ntriandle = [[1],[1,1]]\nfor i in range(2,6):\n    cur = [1]\n    pre = triandle[i -1]\n    for j in range(i-1):\n        cur.append(pre[j] + pre[j + 1])\n    cur.append(1)\n    triandle.append(cur)\nprint(triandle)\n```\n\n变形\n\n```python\ntriandle = []\nn = 6\nfor i in range(n):\n    cur = [1]\n    triandle.append(cur)\n   \nif  i==0:continue\npre = triandle[i -1]\nfor  j in range(i -1):\n    cur.append(pre[j] + pre[j + 1])\ncur.append(1)\nprint(triandle)\n```\n\n补零法\n\n```python\nn = 6 \nnewline = [1]\nprint(newline)\n\nfor  i in range(1,n):\n    oldline = newline.copy()\n    oldline.append(0)\n    newline.clear()\n    \n \nfor j in range(i+1):\n    newline.append(oldline[j -1] + oldline[j])\n\nprint(newline)\n```\n\n* 对称性 \n一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.\n\n```python\ntriandle = []\nn = 6\nfor i in range(n):\n    row = [1] * (i + 1)\n    triandle.append(row)\n```\n\n    for j in range(1,i//2+1):\n        val = triandle[i-1][j-1] + triandle[i -1][j]\n        row[j]  = val\n        row[-j-1] = val\n\n```python\nprint(triandle)\ntriangle = []\nn = 6\nfor i in range(n):\n    row = [1] *(i +1)\n    triangle.append(row)\n    for  j in range(i,i//2+1):\n        val = triangle[i-1][j-1] + triangle[i -1][j]\n        row[j] = val\n        if  i != 2*j:\n            row[-j-i] = val\nprint(triangle)\n```\n\n单行覆盖法\n\n```python\nn = 6\nrow = [1] *n\nprint(row)\nprint('_' * 30)\n\nfor  i in range(n):\n    for j in range(i//2):\n        val = row[j] + row[j+1]\n        row[j+1]=val\n        if i != 2* (j+1):\n            row[i-(j+1)] =val\n    print(row[:i+1])\n```\n\n\n\n\n","slug":"1 (2)","published":1,"date":"2019-04-03T02:46:44.955Z","updated":"2019-06-19T14:47:41.472Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81e000mjkufobsn21uw","content":"<h1 id=\"求素数算法剖析\"><a href=\"#求素数算法剖析\" class=\"headerlink\" title=\"求素数算法剖析\"></a>求素数算法剖析</h1><ul>\n<li><p>简单解法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">2</span> ,int(i**<span class=\"number\">0.5</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">      <span class=\"keyword\">if</span> i % x == <span class=\"number\">0</span>:</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      count +=<span class=\"number\">1</span></span><br><span class=\"line\">      print(x)</span><br></pre></td></tr></table></figure>\n<p>for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.</p>\n</li>\n<li><p>使用奇数</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\">count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,n,<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,int(x**<span class=\"number\">0.5</span>)+<span class=\"number\">1</span>,<span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x % i ==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> (count)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>储存质素</li>\n</ul>\n<p>合数一定可以分解为几个质数的乘积,2是质数<br>质数一定不能整除1和本身之内的整数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\">count = <span class=\"number\">1</span></span><br><span class=\"line\">pre</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,n,<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> primenumbers:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        premenumber.append(x)</span><br><span class=\"line\">        count +=<span class=\"number\">1</span></span><br><span class=\"line\">print(count)</span><br></pre></td></tr></table></figure>\n<h1 id=\"杨辉三角\"><a href=\"#杨辉三角\" class=\"headerlink\" title=\"杨辉三角\"></a>杨辉三角</h1><p>预先构成前两行 从而推到后面的所有行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = [[<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,<span class=\"number\">6</span>):</span><br><span class=\"line\">    cur = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    pre = triandle[i <span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>):</span><br><span class=\"line\">        cur.append(pre[j] + pre[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">    cur.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">    triandle.append(cur)</span><br><span class=\"line\">print(triandle)</span><br></pre></td></tr></table></figure>\n<p>变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    cur = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    triandle.append(cur)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">if</span>  i==<span class=\"number\">0</span>:<span class=\"keyword\">continue</span></span><br><span class=\"line\">pre = triandle[i <span class=\"number\">-1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(i <span class=\"number\">-1</span>):</span><br><span class=\"line\">    cur.append(pre[j] + pre[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">cur.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(triandle)</span><br></pre></td></tr></table></figure>\n<p>补零法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">6</span> </span><br><span class=\"line\">newline = [<span class=\"number\">1</span>]</span><br><span class=\"line\">print(newline)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>  i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">    oldline = newline.copy()</span><br><span class=\"line\">    oldline.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    newline.clear()</span><br><span class=\"line\">    </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>):</span><br><span class=\"line\">    newline.append(oldline[j <span class=\"number\">-1</span>] + oldline[j])</span><br><span class=\"line\"></span><br><span class=\"line\">print(newline)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对称性<br>一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    row = [<span class=\"number\">1</span>] * (i + <span class=\"number\">1</span>)</span><br><span class=\"line\">    triandle.append(row)</span><br></pre></td></tr></table></figure>\n<pre><code>for j in range(1,i//2+1):\n    val = triandle[i-1][j-1] + triandle[i -1][j]\n    row[j]  = val\n    row[-j-1] = val\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(triandle)</span><br><span class=\"line\">triangle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    row = [<span class=\"number\">1</span>] *(i +<span class=\"number\">1</span>)</span><br><span class=\"line\">    triangle.append(row)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(i,i//<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">        val = triangle[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + triangle[i <span class=\"number\">-1</span>][j]</span><br><span class=\"line\">        row[j] = val</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i != <span class=\"number\">2</span>*j:</span><br><span class=\"line\">            row[-j-i] = val</span><br><span class=\"line\">print(triangle)</span><br></pre></td></tr></table></figure>\n<p>单行覆盖法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\">row = [<span class=\"number\">1</span>] *n</span><br><span class=\"line\">print(row)</span><br><span class=\"line\">print(<span class=\"string\">'_'</span> * <span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>  i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i//<span class=\"number\">2</span>):</span><br><span class=\"line\">        val = row[j] + row[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">        row[j+<span class=\"number\">1</span>]=val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">2</span>* (j+<span class=\"number\">1</span>):</span><br><span class=\"line\">            row[i-(j+<span class=\"number\">1</span>)] =val</span><br><span class=\"line\">    print(row[:i+<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"求素数算法剖析\"><a href=\"#求素数算法剖析\" class=\"headerlink\" title=\"求素数算法剖析\"></a>求素数算法剖析</h1><ul>\n<li><p>简单解法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,n):</span><br><span class=\"line\">  <span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">2</span> ,int(i**<span class=\"number\">0.5</span>)+<span class=\"number\">1</span>):</span><br><span class=\"line\">      <span class=\"keyword\">if</span> i % x == <span class=\"number\">0</span>:</span><br><span class=\"line\">          <span class=\"keyword\">break</span></span><br><span class=\"line\">  <span class=\"keyword\">else</span>:</span><br><span class=\"line\">      count +=<span class=\"number\">1</span></span><br><span class=\"line\">      print(x)</span><br></pre></td></tr></table></figure>\n<p>for else 是当迭代对象完成所有迭代后且此时的迭代对象为空时，如果存在else子句则执行else子句，没有则继续执行后续代码；如果迭代对象因为某种原因（如带有break关键字）提前退出迭代，则else子句不会被执行，程序将会直接跳过else子句继续执行后续代码.</p>\n</li>\n<li><p>使用奇数</p>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\">count = <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,n,<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,int(x**<span class=\"number\">0.5</span>)+<span class=\"number\">1</span>,<span class=\"number\">2</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x % i ==<span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        count += <span class=\"number\">1</span></span><br><span class=\"line\"><span class=\"keyword\">print</span> (count)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>储存质素</li>\n</ul>\n<p>合数一定可以分解为几个质数的乘积,2是质数<br>质数一定不能整除1和本身之内的整数</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">100</span></span><br><span class=\"line\">count = <span class=\"number\">1</span></span><br><span class=\"line\">pre</span><br><span class=\"line\"><span class=\"keyword\">for</span> x <span class=\"keyword\">in</span> range(<span class=\"number\">3</span>,n,<span class=\"number\">2</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> primenumbers:</span><br><span class=\"line\">        <span class=\"keyword\">if</span> x % i == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">break</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span>:</span><br><span class=\"line\">        premenumber.append(x)</span><br><span class=\"line\">        count +=<span class=\"number\">1</span></span><br><span class=\"line\">print(count)</span><br></pre></td></tr></table></figure>\n<h1 id=\"杨辉三角\"><a href=\"#杨辉三角\" class=\"headerlink\" title=\"杨辉三角\"></a>杨辉三角</h1><p>预先构成前两行 从而推到后面的所有行</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = [[<span class=\"number\">1</span>],[<span class=\"number\">1</span>,<span class=\"number\">1</span>]]</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>,<span class=\"number\">6</span>):</span><br><span class=\"line\">    cur = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    pre = triandle[i <span class=\"number\">-1</span>]</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i<span class=\"number\">-1</span>):</span><br><span class=\"line\">        cur.append(pre[j] + pre[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">    cur.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">    triandle.append(cur)</span><br><span class=\"line\">print(triandle)</span><br></pre></td></tr></table></figure>\n<p>变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    cur = [<span class=\"number\">1</span>]</span><br><span class=\"line\">    triandle.append(cur)</span><br><span class=\"line\">   </span><br><span class=\"line\"><span class=\"keyword\">if</span>  i==<span class=\"number\">0</span>:<span class=\"keyword\">continue</span></span><br><span class=\"line\">pre = triandle[i <span class=\"number\">-1</span>]</span><br><span class=\"line\"><span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(i <span class=\"number\">-1</span>):</span><br><span class=\"line\">    cur.append(pre[j] + pre[j + <span class=\"number\">1</span>])</span><br><span class=\"line\">cur.append(<span class=\"number\">1</span>)</span><br><span class=\"line\">print(triandle)</span><br></pre></td></tr></table></figure>\n<p>补零法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">6</span> </span><br><span class=\"line\">newline = [<span class=\"number\">1</span>]</span><br><span class=\"line\">print(newline)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>  i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,n):</span><br><span class=\"line\">    oldline = newline.copy()</span><br><span class=\"line\">    oldline.append(<span class=\"number\">0</span>)</span><br><span class=\"line\">    newline.clear()</span><br><span class=\"line\">    </span><br><span class=\"line\"> </span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i+<span class=\"number\">1</span>):</span><br><span class=\"line\">    newline.append(oldline[j <span class=\"number\">-1</span>] + oldline[j])</span><br><span class=\"line\"></span><br><span class=\"line\">print(newline)</span><br></pre></td></tr></table></figure>\n<ul>\n<li>对称性<br>一次性开辟空间,可以使用列表或者循环迭代的方式能不能减少一半的数字计算 .左右对称.</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">triandle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    row = [<span class=\"number\">1</span>] * (i + <span class=\"number\">1</span>)</span><br><span class=\"line\">    triandle.append(row)</span><br></pre></td></tr></table></figure>\n<pre><code>for j in range(1,i//2+1):\n    val = triandle[i-1][j-1] + triandle[i -1][j]\n    row[j]  = val\n    row[-j-1] = val\n</code></pre><figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">print(triandle)</span><br><span class=\"line\">triangle = []</span><br><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    row = [<span class=\"number\">1</span>] *(i +<span class=\"number\">1</span>)</span><br><span class=\"line\">    triangle.append(row)</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(i,i//<span class=\"number\">2</span>+<span class=\"number\">1</span>):</span><br><span class=\"line\">        val = triangle[i<span class=\"number\">-1</span>][j<span class=\"number\">-1</span>] + triangle[i <span class=\"number\">-1</span>][j]</span><br><span class=\"line\">        row[j] = val</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i != <span class=\"number\">2</span>*j:</span><br><span class=\"line\">            row[-j-i] = val</span><br><span class=\"line\">print(triangle)</span><br></pre></td></tr></table></figure>\n<p>单行覆盖法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">n = <span class=\"number\">6</span></span><br><span class=\"line\">row = [<span class=\"number\">1</span>] *n</span><br><span class=\"line\">print(row)</span><br><span class=\"line\">print(<span class=\"string\">'_'</span> * <span class=\"number\">30</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span>  i <span class=\"keyword\">in</span> range(n):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i//<span class=\"number\">2</span>):</span><br><span class=\"line\">        val = row[j] + row[j+<span class=\"number\">1</span>]</span><br><span class=\"line\">        row[j+<span class=\"number\">1</span>]=val</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i != <span class=\"number\">2</span>* (j+<span class=\"number\">1</span>):</span><br><span class=\"line\">            row[i-(j+<span class=\"number\">1</span>)] =val</span><br><span class=\"line\">    print(row[:i+<span class=\"number\">1</span>])</span><br></pre></td></tr></table></figure>\n"},{"title":"面向对象","_content":"## 语言的分类\n\n面向机器:抽象成机器指令, 机器容易理解.\n代表:汇编语言\n面向过程:\n做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.\n问题规模小, 可以步骤化.按部就班处理.\n代表:c语言\n面向对象OOP\n随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.\n代表:C++, java, python等\n## 面向对象\n类:class\n类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.\n用计算机语言来描述类,是属性和方法的集合.\n对象:instance, object\n对象是类的具象, 是一个实体.\n对于我们每个人这个个体, 都是抽象概念人类不同的实体.\n\n属性:它是对象状态的抽象,用数据结构来描述.\n操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.\n哲学:\n一切皆对象\n对象是数据和操作的封装.\n对象是独立的,但是对象之间可以相互作用.\n目前OOP是最接近人类认知的编程范式.\n\n## 三要素\n1.封装\n组装:将数据和操作组装到一起.\n隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的\n构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.\n2.继承\n多复用,继承来的就不用了自己写了\n多继承少修改,OCP,使用继承来改变,来体现个性.\n3.多态\n面向对象编程最灵活的地方,动态绑定\n人类就是封装\n人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:\n多态,继承自动物类的人类,猫类的操作'吃'不同.\n\npython的类:\n1.必须使用class关键字\n2.类名必须使用大驼峰命名\n3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.\n\n## 类对象及类属性\n\n类对象,类的定义执行后会生成一个类对象.\n类的属性,类定义中的变量和类中定义的方法都是类的属性.\n类变量,\nself指代当前实例本身.\n\n## 实例化\na = Myclass() # 实例化\n使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.\n实例化就真正创建一个该类的对象\ntom = Person()\njerry = Person()\n每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.\npython类实例化后, 会调用__init__方法,这个方法第一个形式参数必须留给self,其他参数随意.\n__init__方法\n\n注意:__init__()方法不能有返回值,也就是只能是return None\n\n实例对象instance\n类实例化后一定会获得一个类的实例,就是实例对象\n__init__方法的第一参数self就是指代某一个实例自身.\n类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.\n\n实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.\n\n总结:\n是类的,也就是这个类所有实例的,器实例都可以访问到:\n是实例的,就是这个实例自己的,通过类访问不到.\n类变量是属于类的变量,这个类的所有实例可以共享这个变量.\n对象可以动态的给自己增加一个属性.\n实例属性的查找顺序\n指的是实例使用,.点号来访问属性.会先找自己的__dict__,如果没有,然后通过属性__class__找到自家的类, 再去类的__dict__中找.\n注意:如果实例使用__dict__访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.\n\n一般来说, 类变量可使用全大写来命名.\n\n## 类方法和静态方法\n\n类方法:\n1.在类定义中,使用@classmethod装饰器的方法\n2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.\n3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改\n4.通过cls可以直接操作类的属性.\n静态方法:\n在类定义中, 使用@staticmethod装饰器的方法\n2在调用时, 不会隐式的传入参数.\n静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.\n\n类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,\n原因是第一参数必须是类的实例.\n总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.\n实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.\n实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.\n\n访问控制:\n私有属性\n私有属性,使用双下划线开头的属性名就是私有属性.\n\n私有属性的本质:\n类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.\n\n\n保护变量:\n在变量名前使用一个下划线,称为保护变量\n这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.\n私有方法:\n参照保护变量,私有变量,使用单下划线,双下化线的命名方法,\n\n## 补丁\n可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变\n猴子补丁:\n在运行时,对属性,方法,函数,等进行动态替换\n其目的往往是为了通过替换,修改来增强,扩展原有代码的能力\n\n## 属性装饰器\n一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.\n\nproperty装饰器\n\n后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性\nsetter装饰器\n可以控制是否删除属性,很少用\ndeleter装饰器\n可以控制是否删除属性,很少用\nproperty装饰器必须在前,setter deleter装饰器在后,\nproperty装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.\n\n## 对象的销毁\n类中可以定义__del__方法 ,称为析构函数.\n作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.\n注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.\n使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用__del__方法.\n由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.\n封装:\n将数据和操作组织到类中,即属性和方法.\n将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.\n通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.\n","source":"_posts/1 (24).md","raw":"---\ntitle: 面向对象\n\ncategories: \n- python\ntags:\n- python\n---\n## 语言的分类\n\n面向机器:抽象成机器指令, 机器容易理解.\n代表:汇编语言\n面向过程:\n做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.\n问题规模小, 可以步骤化.按部就班处理.\n代表:c语言\n面向对象OOP\n随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.\n代表:C++, java, python等\n## 面向对象\n类:class\n类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.\n用计算机语言来描述类,是属性和方法的集合.\n对象:instance, object\n对象是类的具象, 是一个实体.\n对于我们每个人这个个体, 都是抽象概念人类不同的实体.\n\n属性:它是对象状态的抽象,用数据结构来描述.\n操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.\n哲学:\n一切皆对象\n对象是数据和操作的封装.\n对象是独立的,但是对象之间可以相互作用.\n目前OOP是最接近人类认知的编程范式.\n\n## 三要素\n1.封装\n组装:将数据和操作组装到一起.\n隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的\n构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.\n2.继承\n多复用,继承来的就不用了自己写了\n多继承少修改,OCP,使用继承来改变,来体现个性.\n3.多态\n面向对象编程最灵活的地方,动态绑定\n人类就是封装\n人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:\n多态,继承自动物类的人类,猫类的操作'吃'不同.\n\npython的类:\n1.必须使用class关键字\n2.类名必须使用大驼峰命名\n3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.\n\n## 类对象及类属性\n\n类对象,类的定义执行后会生成一个类对象.\n类的属性,类定义中的变量和类中定义的方法都是类的属性.\n类变量,\nself指代当前实例本身.\n\n## 实例化\na = Myclass() # 实例化\n使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.\n实例化就真正创建一个该类的对象\ntom = Person()\njerry = Person()\n每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.\npython类实例化后, 会调用__init__方法,这个方法第一个形式参数必须留给self,其他参数随意.\n__init__方法\n\n注意:__init__()方法不能有返回值,也就是只能是return None\n\n实例对象instance\n类实例化后一定会获得一个类的实例,就是实例对象\n__init__方法的第一参数self就是指代某一个实例自身.\n类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.\n\n实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.\n\n总结:\n是类的,也就是这个类所有实例的,器实例都可以访问到:\n是实例的,就是这个实例自己的,通过类访问不到.\n类变量是属于类的变量,这个类的所有实例可以共享这个变量.\n对象可以动态的给自己增加一个属性.\n实例属性的查找顺序\n指的是实例使用,.点号来访问属性.会先找自己的__dict__,如果没有,然后通过属性__class__找到自家的类, 再去类的__dict__中找.\n注意:如果实例使用__dict__访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.\n\n一般来说, 类变量可使用全大写来命名.\n\n## 类方法和静态方法\n\n类方法:\n1.在类定义中,使用@classmethod装饰器的方法\n2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.\n3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改\n4.通过cls可以直接操作类的属性.\n静态方法:\n在类定义中, 使用@staticmethod装饰器的方法\n2在调用时, 不会隐式的传入参数.\n静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.\n\n类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,\n原因是第一参数必须是类的实例.\n总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.\n实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.\n实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.\n\n访问控制:\n私有属性\n私有属性,使用双下划线开头的属性名就是私有属性.\n\n私有属性的本质:\n类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.\n\n\n保护变量:\n在变量名前使用一个下划线,称为保护变量\n这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.\n私有方法:\n参照保护变量,私有变量,使用单下划线,双下化线的命名方法,\n\n## 补丁\n可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变\n猴子补丁:\n在运行时,对属性,方法,函数,等进行动态替换\n其目的往往是为了通过替换,修改来增强,扩展原有代码的能力\n\n## 属性装饰器\n一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.\n\nproperty装饰器\n\n后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性\nsetter装饰器\n可以控制是否删除属性,很少用\ndeleter装饰器\n可以控制是否删除属性,很少用\nproperty装饰器必须在前,setter deleter装饰器在后,\nproperty装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.\n\n## 对象的销毁\n类中可以定义__del__方法 ,称为析构函数.\n作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.\n注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.\n使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用__del__方法.\n由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.\n封装:\n将数据和操作组织到类中,即属性和方法.\n将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.\n通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.\n","slug":"1 (24)","published":1,"date":"2019-05-16T00:53:04.617Z","updated":"2019-06-19T14:48:56.747Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81j000rjkufs8pzy4gk","content":"<h2 id=\"语言的分类\"><a href=\"#语言的分类\" class=\"headerlink\" title=\"语言的分类\"></a>语言的分类</h2><p>面向机器:抽象成机器指令, 机器容易理解.<br>代表:汇编语言<br>面向过程:<br>做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.<br>问题规模小, 可以步骤化.按部就班处理.<br>代表:c语言<br>面向对象OOP<br>随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.<br>代表:C++, java, python等</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>类:class<br>类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.<br>用计算机语言来描述类,是属性和方法的集合.<br>对象:instance, object<br>对象是类的具象, 是一个实体.<br>对于我们每个人这个个体, 都是抽象概念人类不同的实体.</p>\n<p>属性:它是对象状态的抽象,用数据结构来描述.<br>操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.<br>哲学:<br>一切皆对象<br>对象是数据和操作的封装.<br>对象是独立的,但是对象之间可以相互作用.<br>目前OOP是最接近人类认知的编程范式.</p>\n<h2 id=\"三要素\"><a href=\"#三要素\" class=\"headerlink\" title=\"三要素\"></a>三要素</h2><p>1.封装<br>组装:将数据和操作组装到一起.<br>隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的<br>构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.<br>2.继承<br>多复用,继承来的就不用了自己写了<br>多继承少修改,OCP,使用继承来改变,来体现个性.<br>3.多态<br>面向对象编程最灵活的地方,动态绑定<br>人类就是封装<br>人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:<br>多态,继承自动物类的人类,猫类的操作’吃’不同.</p>\n<p>python的类:<br>1.必须使用class关键字<br>2.类名必须使用大驼峰命名<br>3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.</p>\n<h2 id=\"类对象及类属性\"><a href=\"#类对象及类属性\" class=\"headerlink\" title=\"类对象及类属性\"></a>类对象及类属性</h2><p>类对象,类的定义执行后会生成一个类对象.<br>类的属性,类定义中的变量和类中定义的方法都是类的属性.<br>类变量,<br>self指代当前实例本身.</p>\n<h2 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h2><p>a = Myclass() # 实例化<br>使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.<br>实例化就真正创建一个该类的对象<br>tom = Person()<br>jerry = Person()<br>每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.<br>python类实例化后, 会调用<strong>init</strong>方法,这个方法第一个形式参数必须留给self,其他参数随意.<br><strong>init</strong>方法</p>\n<p>注意:<strong>init</strong>()方法不能有返回值,也就是只能是return None</p>\n<p>实例对象instance<br>类实例化后一定会获得一个类的实例,就是实例对象<br><strong>init</strong>方法的第一参数self就是指代某一个实例自身.<br>类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.</p>\n<p>实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.</p>\n<p>总结:<br>是类的,也就是这个类所有实例的,器实例都可以访问到:<br>是实例的,就是这个实例自己的,通过类访问不到.<br>类变量是属于类的变量,这个类的所有实例可以共享这个变量.<br>对象可以动态的给自己增加一个属性.<br>实例属性的查找顺序<br>指的是实例使用,.点号来访问属性.会先找自己的<strong>dict</strong>,如果没有,然后通过属性<strong>class</strong>找到自家的类, 再去类的<strong>dict</strong>中找.<br>注意:如果实例使用<strong>dict</strong>访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.</p>\n<p>一般来说, 类变量可使用全大写来命名.</p>\n<h2 id=\"类方法和静态方法\"><a href=\"#类方法和静态方法\" class=\"headerlink\" title=\"类方法和静态方法\"></a>类方法和静态方法</h2><p>类方法:<br>1.在类定义中,使用@classmethod装饰器的方法<br>2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.<br>3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改<br>4.通过cls可以直接操作类的属性.<br>静态方法:<br>在类定义中, 使用@staticmethod装饰器的方法<br>2在调用时, 不会隐式的传入参数.<br>静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.</p>\n<p>类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,<br>原因是第一参数必须是类的实例.<br>总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.<br>实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.<br>实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.</p>\n<p>访问控制:<br>私有属性<br>私有属性,使用双下划线开头的属性名就是私有属性.</p>\n<p>私有属性的本质:<br>类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.</p>\n<p>保护变量:<br>在变量名前使用一个下划线,称为保护变量<br>这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.<br>私有方法:<br>参照保护变量,私有变量,使用单下划线,双下化线的命名方法,</p>\n<h2 id=\"补丁\"><a href=\"#补丁\" class=\"headerlink\" title=\"补丁\"></a>补丁</h2><p>可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变<br>猴子补丁:<br>在运行时,对属性,方法,函数,等进行动态替换<br>其目的往往是为了通过替换,修改来增强,扩展原有代码的能力</p>\n<h2 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h2><p>一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.</p>\n<p>property装饰器</p>\n<p>后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性<br>setter装饰器<br>可以控制是否删除属性,很少用<br>deleter装饰器<br>可以控制是否删除属性,很少用<br>property装饰器必须在前,setter deleter装饰器在后,<br>property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.</p>\n<h2 id=\"对象的销毁\"><a href=\"#对象的销毁\" class=\"headerlink\" title=\"对象的销毁\"></a>对象的销毁</h2><p>类中可以定义<strong>del</strong>方法 ,称为析构函数.<br>作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.<br>注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.<br>使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用<strong>del</strong>方法.<br>由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.<br>封装:<br>将数据和操作组织到类中,即属性和方法.<br>将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.<br>通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"语言的分类\"><a href=\"#语言的分类\" class=\"headerlink\" title=\"语言的分类\"></a>语言的分类</h2><p>面向机器:抽象成机器指令, 机器容易理解.<br>代表:汇编语言<br>面向过程:<br>做一件事,排出个步骤,第一步 干什么,第二步干什么,如果出现情况A,做什么处理,如果出现了情况B,做什么处理.<br>问题规模小, 可以步骤化.按部就班处理.<br>代表:c语言<br>面向对象OOP<br>随着计算机需要解决的问题的规模扩大,情况越来越复杂,需要很多人,很多部门协作,面向过程编程不太适合了.<br>代表:C++, java, python等</p>\n<h2 id=\"面向对象\"><a href=\"#面向对象\" class=\"headerlink\" title=\"面向对象\"></a>面向对象</h2><p>类:class<br>类是抽象的概念,是万事万物的抽象,是一类事物的共同特征的集合.<br>用计算机语言来描述类,是属性和方法的集合.<br>对象:instance, object<br>对象是类的具象, 是一个实体.<br>对于我们每个人这个个体, 都是抽象概念人类不同的实体.</p>\n<p>属性:它是对象状态的抽象,用数据结构来描述.<br>操作:它是对象行为的抽象, 用操作名和实现该操作的方法来描述.<br>哲学:<br>一切皆对象<br>对象是数据和操作的封装.<br>对象是独立的,但是对象之间可以相互作用.<br>目前OOP是最接近人类认知的编程范式.</p>\n<h2 id=\"三要素\"><a href=\"#三要素\" class=\"headerlink\" title=\"三要素\"></a>三要素</h2><p>1.封装<br>组装:将数据和操作组装到一起.<br>隐藏数据:对外只暴露一些接口,通过接口访问对象,比如驾驶员使用汽车,不需要了解汽车的<br>构造细节, 只需要知道使用什么部件怎么驾驶就行, 踩了油门就能跑, 可以不了解其中的机动原理.<br>2.继承<br>多复用,继承来的就不用了自己写了<br>多继承少修改,OCP,使用继承来改变,来体现个性.<br>3.多态<br>面向对象编程最灵活的地方,动态绑定<br>人类就是封装<br>人类继承自动物类, 孩子继承父母特征,分为单一继承.多继承:<br>多态,继承自动物类的人类,猫类的操作’吃’不同.</p>\n<p>python的类:<br>1.必须使用class关键字<br>2.类名必须使用大驼峰命名<br>3.类定义完成后, 就产生了一个类对象,绑定到了标识符ClassName上.</p>\n<h2 id=\"类对象及类属性\"><a href=\"#类对象及类属性\" class=\"headerlink\" title=\"类对象及类属性\"></a>类对象及类属性</h2><p>类对象,类的定义执行后会生成一个类对象.<br>类的属性,类定义中的变量和类中定义的方法都是类的属性.<br>类变量,<br>self指代当前实例本身.</p>\n<h2 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h2><p>a = Myclass() # 实例化<br>使用上面的语法,在类对象名称后面加上一个括号,就调用类的实例化方法,完成实例化.<br>实例化就真正创建一个该类的对象<br>tom = Person()<br>jerry = Person()<br>每次实例化后获得的实例,是不同的实例,即使使用同样的参数实例化,也得到不一样的对象.<br>python类实例化后, 会调用<strong>init</strong>方法,这个方法第一个形式参数必须留给self,其他参数随意.<br><strong>init</strong>方法</p>\n<p>注意:<strong>init</strong>()方法不能有返回值,也就是只能是return None</p>\n<p>实例对象instance<br>类实例化后一定会获得一个类的实例,就是实例对象<br><strong>init</strong>方法的第一参数self就是指代某一个实例自身.<br>类实例化后, 得到一个实例对象, 调用方法时采用方式, 实例对象会绑定到方法上.</p>\n<p>实例变量是每一个实力自己的变量,是自己独有的;类变量是类的变量,是类的所有实例共享的属性和方法.</p>\n<p>总结:<br>是类的,也就是这个类所有实例的,器实例都可以访问到:<br>是实例的,就是这个实例自己的,通过类访问不到.<br>类变量是属于类的变量,这个类的所有实例可以共享这个变量.<br>对象可以动态的给自己增加一个属性.<br>实例属性的查找顺序<br>指的是实例使用,.点号来访问属性.会先找自己的<strong>dict</strong>,如果没有,然后通过属性<strong>class</strong>找到自家的类, 再去类的<strong>dict</strong>中找.<br>注意:如果实例使用<strong>dict</strong>访问变量,将不会按照上面的查找顺序找变量了,这是指明字典的key查找,不是属性查找.</p>\n<p>一般来说, 类变量可使用全大写来命名.</p>\n<h2 id=\"类方法和静态方法\"><a href=\"#类方法和静态方法\" class=\"headerlink\" title=\"类方法和静态方法\"></a>类方法和静态方法</h2><p>类方法:<br>1.在类定义中,使用@classmethod装饰器的方法<br>2.必须至少有一个参数,且第一个参数留给了cls, cls指代调用者即类对象自身.<br>3.cls这个标识符可以是任意合法名称,但是为了易读,请不要修改<br>4.通过cls可以直接操作类的属性.<br>静态方法:<br>在类定义中, 使用@staticmethod装饰器的方法<br>2在调用时, 不会隐式的传入参数.<br>静态方法,只是表明这个方法属于这个名词空间,函数归在一起,方便组织管理.</p>\n<p>类几乎可以调用所有内部定义的方法,但是调用普通的方法时会报错,<br>原因是第一参数必须是类的实例.<br>总结:类除了普通方法都可以调用,普通方法需要对象的实例作为第一参数.<br>实例可以调用所有类中的方法,普通方法需要的实例作为第一参数.<br>实例可以调用所有类重定义的方法,普通方法传入实例本身,静态方法和类方法需要找到实例的类.</p>\n<p>访问控制:<br>私有属性<br>私有属性,使用双下划线开头的属性名就是私有属性.</p>\n<p>私有属性的本质:<br>类定义的时候, 如果声明一个实例变量的时候,使用双下滑线,python解释器会将其改名,转换名称为_类名__变量名的名称,所有用原来的名字访问不到了.</p>\n<p>保护变量:<br>在变量名前使用一个下划线,称为保护变量<br>这只是开发者共同的约定,看见这种变量,就如同私有变量,不要直接使用.<br>私有方法:<br>参照保护变量,私有变量,使用单下划线,双下化线的命名方法,</p>\n<h2 id=\"补丁\"><a href=\"#补丁\" class=\"headerlink\" title=\"补丁\"></a>补丁</h2><p>可以通过修改或者替换类的成员,使用者调用的方法没有改变,但是,类提供的功能已经改变<br>猴子补丁:<br>在运行时,对属性,方法,函数,等进行动态替换<br>其目的往往是为了通过替换,修改来增强,扩展原有代码的能力</p>\n<h2 id=\"属性装饰器\"><a href=\"#属性装饰器\" class=\"headerlink\" title=\"属性装饰器\"></a>属性装饰器</h2><p>一般好的设计是:把实例的某些属性保护起来,不让外部直接访问,外部使用getter读取属性和setter方法设置属性.</p>\n<p>property装饰器</p>\n<p>后面跟的函数名就是以后的属性名,他就是getter,这个必需有,有了它至少是只读属性<br>setter装饰器<br>可以控制是否删除属性,很少用<br>deleter装饰器<br>可以控制是否删除属性,很少用<br>property装饰器必须在前,setter deleter装饰器在后,<br>property装饰器能通过简单的方法,把对方法的操作变为对属性的访问,并起到了一定的隐藏效果.</p>\n<h2 id=\"对象的销毁\"><a href=\"#对象的销毁\" class=\"headerlink\" title=\"对象的销毁\"></a>对象的销毁</h2><p>类中可以定义<strong>del</strong>方法 ,称为析构函数.<br>作用,销毁类的实例的时候调用,以释放占用的资源,其中就放些清理资源的代码,比如释放连接.<br>注意这个方法不能引起对象的真正销毁,只是对象销毁的时候回自动调用他.<br>使用del语句删除实例,引用计数减1,当引用计数为0时,会自动调用<strong>del</strong>方法.<br>由于python实现了垃圾回收机制,不能确定对象何时执行垃圾回收.<br>封装:<br>将数据和操作组织到类中,即属性和方法.<br>将属性隐藏起来,给使用者提供操作,使用者通过操作就可以获取或者修改数据,getter和setter.<br>通过访问控制,暴露适当的数据和操作给用户,该隐藏的隐藏起来.</p>\n"},{"title":"深入理解计算机系统","_content":"\n源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.\n源程序 ->预处理器(cpp) ->编译器(cc1)->汇编器->链接器-可执行二进制\n堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.\n内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.\n\n# 程序结构和执行\n## 信息存储\n大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.\n一个字节包括8位,在二进制表示法中,00000000` 11111111  0`255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.\n2进制\n\n\n\n\n\n\n","source":"_posts/1 (27).md","raw":"---\ntitle: 深入理解计算机系统\n\ncategories: \n- 系统\ntags:\n- 系统\n---\n\n源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.\n源程序 ->预处理器(cpp) ->编译器(cc1)->汇编器->链接器-可执行二进制\n堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.\n内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.\n\n# 程序结构和执行\n## 信息存储\n大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.\n一个字节包括8位,在二进制表示法中,00000000` 11111111  0`255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.\n2进制\n\n\n\n\n\n\n","slug":"1 (27)","published":1,"date":"2019-05-03T01:11:24.415Z","updated":"2019-06-19T14:48:44.301Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81l000ujkuf03tm139l","content":"<p>源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.<br>源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制<br>堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.<br>内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.</p>\n<h1 id=\"程序结构和执行\"><a href=\"#程序结构和执行\" class=\"headerlink\" title=\"程序结构和执行\"></a>程序结构和执行</h1><h2 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h2><p>大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.<br>一个字节包括8位,在二进制表示法中,00000000<code>11111111  0</code>255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.<br>2进制</p>\n","site":{"data":{}},"excerpt":"","more":"<p>源程实际就是一个有0和1组成的位序列,这些位被组成8个一组,称为字节,每个字节都表示程序中某个文本字符.<br>源程序 -&gt;预处理器(cpp) -&gt;编译器(cc1)-&gt;汇编器-&gt;链接器-可执行二进制<br>堆:代码和数据去后紧随着的是运行时堆.代码和数据去是在进程一旦开始运行时被指定了大小.<br>内核是操作系统总在驻留在存储器中的部分,地址空间顶部的四分之一部分是为内核预留的.</p>\n<h1 id=\"程序结构和执行\"><a href=\"#程序结构和执行\" class=\"headerlink\" title=\"程序结构和执行\"></a>程序结构和执行</h1><h2 id=\"信息存储\"><a href=\"#信息存储\" class=\"headerlink\" title=\"信息存储\"></a>信息存储</h2><p>大多数计算机使用8位的块,叫做字节,来作为最小的可寻址的存储器单位.<br>一个字节包括8位,在二进制表示法中,00000000<code>11111111  0</code>255.使用10与位互相转换很麻烦,替代的方法以 16 为基数或hex数.<br>2进制</p>\n"},{"title":"魔术方法","_content":"\n\n魔术方法\n\n| 类别               | 方法名                                                       |\n| ------------------ | ------------------------------------------------------------ |\n| 可视化 | \\_\\_str\\_\\_, \\_\\_repr\\_\\_, \\_\\_format\\_\\_, \\_\\_bytes\\_\\_     |\n| 数值转换           | \\_\\_abs\\_\\_, \\_\\_bool\\_\\_, \\_\\_complex\\_\\_, \\_\\_int\\_\\_, \\_\\_float\\_\\_, \\_\\_hash\\_\\_, \\_\\_index\\_\\_ |\n| 容器模拟           | \\_\\_len\\_\\_, \\_\\_getitem\\_\\_, \\_\\_setitem\\_\\_, \\_\\_delitem\\_\\_, \\_\\_contains\\_\\_.\\_\\_misss\\_\\_|\n| 迭代枚举           | \\_\\_iter\\_\\_, \\_\\_reversed\\_\\_, \\_\\_next\\_\\_ |\n| 可调用模拟         | \\_\\_call\\_\\_ |\n| 上下文管理         | \\_\\_enter\\_\\_, \\_\\_exit\\_\\_ |\n| 实例创建和销毁 | \\_\\_new\\_\\_, \\_\\_init\\_\\_, \\_\\_del\\_\\_ |\n| 属性管理(反射)       | \\_\\_dir\\_\\_, \\_\\_getattr\\_\\_, \\_\\_setattr\\_\\_, \\_\\_delattr\\_\\_, \\_\\_getattribute\\_\\_ |\n| 属性描述符(描述器) | \\_\\_get\\_\\_, \\_\\_set\\_\\_, \\_\\_delete\\_\\_ |\n|特殊属性|\\_\\_name\\_\\_, \\_\\_module\\_\\_, \\_\\_class\\_\\_, \\_\\_bases\\_\\_, \\_\\_doc\\_\\_, \\_\\_mro\\_\\_, \\_\\_dir\\_\\_|\n|比较运算符| \\_\\_eq\\_\\_,\\_\\_lt\\_\\_, \\_\\_le\\_\\_, \\_\\_gt\\_\\_, \\_\\_ge\\_\\_, \\_\\_ne\\_\\_ |\n|算数运算符|\\_\\_add\\_\\_, \\_\\_sub\\_\\_, \\_\\_mul\\_\\_, \\_\\_truediv\\_\\_, \\_\\_mod\\_\\_, \\_\\_floordiv\\_\\_, \\_\\_pow\\_\\_, \\_\\_divmod\\_\\_               |\n|增量运算符| \\_\\_iadd\\_\\_, \\_\\_isub\\_\\_, \\_\\_imul\\_\\_, \\_\\_itruediv\\_\\_, \\_\\_imod\\_\\_, \\_\\_ifloordiv\\_\\_, \\_\\_ipow\\_\\_ |\n|反向运算符| \\_\\_radd\\_\\_, \\_\\_rsub\\_\\_ |\n|其他| \\_\\_slots\\_\\_                                                |\n\n内置函数\n\n| 内置函数名 | 方法名                                                       |\n| ---------- | ------------------------------------------------------------ |\n| 数学运算   | abs, divmod,max,min,pow, round, sum                          |\n| 类型转换   | bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex |\n| 序列操作   | all, any, filter, map,next,reversed, sorted, zip             |\n| 对象操作   | help,dir,id,hash, type,len, ascii,format, vars,              |\n| 反射操作   | \\_\\_import\\_\\_, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable |\n| 变量操作   | globals, locals,                                             |\n| 交互操作   | print,input                                                  |\n| 文件操作   | open                                                         |\n| 编译执行   | compile, eval,exec, repr                                     |\n| 装饰器     | property,classmethod, staticmethod,                          |\n|数据结构|tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object|\n\n标识符:\n\n```python\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n```\n\n模块常用方法\n\n| 内置模块     | 方法名                                                       |\n| ------------ | ------------------------------------------------------------ |\n| re           | compile, search, match, fullmatch,split,findall, sub,        |\n| string       | ascii_letters,ascii_lowercase.digits                         |\n| datetime     | datetime                                                     |\n| collections  | nametuple, deque, OrderdDict, defaultdict,                   |\n| bisect       | bisect_left,bisect_right,                                    |\n| math         | ceil                                                         |\n| random       | randint, choice, randrange,shuffle, sample                   |\n| functools    | reduce, partial,lru_cache                                    |\n| pathlib      |                                                              |\n| os           |                                                              |\n| shutil       | copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move, |\n| pickle       |                                                              |\n| csv          | reader                                                       |\n| time         |                                                              |\n| threading    |                                                              |\n| queue        |                                                              |\n| json         |                                                              |\n| base64       |                                                              |\n| sys          |                                                              |\n| inspect      | signature(callable)获取签名,                                 |\n| ConfigParser |                                                              |\n| argparse     |                                                              |\n| heapq        | hea                                                          |\n\n\n","source":"_posts/1 (23).md","raw":"---\ntitle: 魔术方法\ncategories: \n- python\ntags:\n- python\n---\n\n\n魔术方法\n\n| 类别               | 方法名                                                       |\n| ------------------ | ------------------------------------------------------------ |\n| 可视化 | \\_\\_str\\_\\_, \\_\\_repr\\_\\_, \\_\\_format\\_\\_, \\_\\_bytes\\_\\_     |\n| 数值转换           | \\_\\_abs\\_\\_, \\_\\_bool\\_\\_, \\_\\_complex\\_\\_, \\_\\_int\\_\\_, \\_\\_float\\_\\_, \\_\\_hash\\_\\_, \\_\\_index\\_\\_ |\n| 容器模拟           | \\_\\_len\\_\\_, \\_\\_getitem\\_\\_, \\_\\_setitem\\_\\_, \\_\\_delitem\\_\\_, \\_\\_contains\\_\\_.\\_\\_misss\\_\\_|\n| 迭代枚举           | \\_\\_iter\\_\\_, \\_\\_reversed\\_\\_, \\_\\_next\\_\\_ |\n| 可调用模拟         | \\_\\_call\\_\\_ |\n| 上下文管理         | \\_\\_enter\\_\\_, \\_\\_exit\\_\\_ |\n| 实例创建和销毁 | \\_\\_new\\_\\_, \\_\\_init\\_\\_, \\_\\_del\\_\\_ |\n| 属性管理(反射)       | \\_\\_dir\\_\\_, \\_\\_getattr\\_\\_, \\_\\_setattr\\_\\_, \\_\\_delattr\\_\\_, \\_\\_getattribute\\_\\_ |\n| 属性描述符(描述器) | \\_\\_get\\_\\_, \\_\\_set\\_\\_, \\_\\_delete\\_\\_ |\n|特殊属性|\\_\\_name\\_\\_, \\_\\_module\\_\\_, \\_\\_class\\_\\_, \\_\\_bases\\_\\_, \\_\\_doc\\_\\_, \\_\\_mro\\_\\_, \\_\\_dir\\_\\_|\n|比较运算符| \\_\\_eq\\_\\_,\\_\\_lt\\_\\_, \\_\\_le\\_\\_, \\_\\_gt\\_\\_, \\_\\_ge\\_\\_, \\_\\_ne\\_\\_ |\n|算数运算符|\\_\\_add\\_\\_, \\_\\_sub\\_\\_, \\_\\_mul\\_\\_, \\_\\_truediv\\_\\_, \\_\\_mod\\_\\_, \\_\\_floordiv\\_\\_, \\_\\_pow\\_\\_, \\_\\_divmod\\_\\_               |\n|增量运算符| \\_\\_iadd\\_\\_, \\_\\_isub\\_\\_, \\_\\_imul\\_\\_, \\_\\_itruediv\\_\\_, \\_\\_imod\\_\\_, \\_\\_ifloordiv\\_\\_, \\_\\_ipow\\_\\_ |\n|反向运算符| \\_\\_radd\\_\\_, \\_\\_rsub\\_\\_ |\n|其他| \\_\\_slots\\_\\_                                                |\n\n内置函数\n\n| 内置函数名 | 方法名                                                       |\n| ---------- | ------------------------------------------------------------ |\n| 数学运算   | abs, divmod,max,min,pow, round, sum                          |\n| 类型转换   | bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex |\n| 序列操作   | all, any, filter, map,next,reversed, sorted, zip             |\n| 对象操作   | help,dir,id,hash, type,len, ascii,format, vars,              |\n| 反射操作   | \\_\\_import\\_\\_, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable |\n| 变量操作   | globals, locals,                                             |\n| 交互操作   | print,input                                                  |\n| 文件操作   | open                                                         |\n| 编译执行   | compile, eval,exec, repr                                     |\n| 装饰器     | property,classmethod, staticmethod,                          |\n|数据结构|tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object|\n\n标识符:\n\n```python\nFalse      await      else       import     pass\nNone       break      except     in         raise\nTrue       class      finally    is         return\nand        continue   for        lambda     try\nas         def        from       nonlocal   while\nassert     del        global     not        with\nasync      elif       if         or         yield\n```\n\n模块常用方法\n\n| 内置模块     | 方法名                                                       |\n| ------------ | ------------------------------------------------------------ |\n| re           | compile, search, match, fullmatch,split,findall, sub,        |\n| string       | ascii_letters,ascii_lowercase.digits                         |\n| datetime     | datetime                                                     |\n| collections  | nametuple, deque, OrderdDict, defaultdict,                   |\n| bisect       | bisect_left,bisect_right,                                    |\n| math         | ceil                                                         |\n| random       | randint, choice, randrange,shuffle, sample                   |\n| functools    | reduce, partial,lru_cache                                    |\n| pathlib      |                                                              |\n| os           |                                                              |\n| shutil       | copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move, |\n| pickle       |                                                              |\n| csv          | reader                                                       |\n| time         |                                                              |\n| threading    |                                                              |\n| queue        |                                                              |\n| json         |                                                              |\n| base64       |                                                              |\n| sys          |                                                              |\n| inspect      | signature(callable)获取签名,                                 |\n| ConfigParser |                                                              |\n| argparse     |                                                              |\n| heapq        | hea                                                          |\n\n\n","slug":"1 (23)","published":1,"date":"2019-05-28T02:11:42.550Z","updated":"2019-06-19T14:50:04.679Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81r000zjkufboyrzrwa","content":"<p>魔术方法</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可视化</td>\n<td>__str__, __repr__, __format__, __bytes__</td>\n</tr>\n<tr>\n<td>数值转换</td>\n<td>__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__</td>\n</tr>\n<tr>\n<td>容器模拟</td>\n<td>__len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__</td>\n</tr>\n<tr>\n<td>迭代枚举</td>\n<td>__iter__, __reversed__, __next__</td>\n</tr>\n<tr>\n<td>可调用模拟</td>\n<td>__call__</td>\n</tr>\n<tr>\n<td>上下文管理</td>\n<td>__enter__, __exit__</td>\n</tr>\n<tr>\n<td>实例创建和销毁</td>\n<td>__new__, __init__, __del__</td>\n</tr>\n<tr>\n<td>属性管理(反射)</td>\n<td>__dir__, __getattr__, __setattr__, __delattr__, __getattribute__</td>\n</tr>\n<tr>\n<td>属性描述符(描述器)</td>\n<td>__get__, __set__, __delete__</td>\n</tr>\n<tr>\n<td>特殊属性</td>\n<td>__name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__</td>\n</tr>\n<tr>\n<td>比较运算符</td>\n<td>__eq__,__lt__, __le__, __gt__, __ge__, __ne__</td>\n</tr>\n<tr>\n<td>算数运算符</td>\n<td>__add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__</td>\n</tr>\n<tr>\n<td>增量运算符</td>\n<td>__iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__</td>\n</tr>\n<tr>\n<td>反向运算符</td>\n<td>__radd__, __rsub__</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>__slots__</td>\n</tr>\n</tbody>\n</table>\n<p>内置函数</p>\n<table>\n<thead>\n<tr>\n<th>内置函数名</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数学运算</td>\n<td>abs, divmod,max,min,pow, round, sum</td>\n</tr>\n<tr>\n<td>类型转换</td>\n<td>bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex</td>\n</tr>\n<tr>\n<td>序列操作</td>\n<td>all, any, filter, map,next,reversed, sorted, zip</td>\n</tr>\n<tr>\n<td>对象操作</td>\n<td>help,dir,id,hash, type,len, ascii,format, vars,</td>\n</tr>\n<tr>\n<td>反射操作</td>\n<td>__import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable</td>\n</tr>\n<tr>\n<td>变量操作</td>\n<td>globals, locals,</td>\n</tr>\n<tr>\n<td>交互操作</td>\n<td>print,input</td>\n</tr>\n<tr>\n<td>文件操作</td>\n<td>open</td>\n</tr>\n<tr>\n<td>编译执行</td>\n<td>compile, eval,exec, repr</td>\n</tr>\n<tr>\n<td>装饰器</td>\n<td>property,classmethod, staticmethod,</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object</td>\n</tr>\n</tbody>\n</table>\n<p>标识符:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">False</span>      <span class=\"keyword\">await</span>      <span class=\"keyword\">else</span>       <span class=\"keyword\">import</span>     <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"literal\">None</span>       <span class=\"keyword\">break</span>      <span class=\"keyword\">except</span>     <span class=\"keyword\">in</span>         <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"literal\">True</span>       <span class=\"class\"><span class=\"keyword\">class</span>      <span class=\"title\">finally</span>    <span class=\"title\">is</span>         <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">and</span>        <span class=\"title\">continue</span>   <span class=\"title\">for</span>        <span class=\"title\">lambda</span>     <span class=\"title\">try</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">as</span>         <span class=\"title\">def</span>        <span class=\"title\">from</span>       <span class=\"title\">nonlocal</span>   <span class=\"title\">while</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">assert</span>     <span class=\"title\">del</span>        <span class=\"title\">global</span>     <span class=\"title\">not</span>        <span class=\"title\">with</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">async</span>      <span class=\"title\">elif</span>       <span class=\"title\">if</span>         <span class=\"title\">or</span>         <span class=\"title\">yield</span></span></span><br></pre></td></tr></table></figure>\n<p>模块常用方法</p>\n<table>\n<thead>\n<tr>\n<th>内置模块</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>re</td>\n<td>compile, search, match, fullmatch,split,findall, sub,</td>\n</tr>\n<tr>\n<td>string</td>\n<td>ascii_letters,ascii_lowercase.digits</td>\n</tr>\n<tr>\n<td>datetime</td>\n<td>datetime</td>\n</tr>\n<tr>\n<td>collections</td>\n<td>nametuple, deque, OrderdDict, defaultdict,</td>\n</tr>\n<tr>\n<td>bisect</td>\n<td>bisect_left,bisect_right,</td>\n</tr>\n<tr>\n<td>math</td>\n<td>ceil</td>\n</tr>\n<tr>\n<td>random</td>\n<td>randint, choice, randrange,shuffle, sample</td>\n</tr>\n<tr>\n<td>functools</td>\n<td>reduce, partial,lru_cache</td>\n</tr>\n<tr>\n<td>pathlib</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td></td>\n</tr>\n<tr>\n<td>shutil</td>\n<td>copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move,</td>\n</tr>\n<tr>\n<td>pickle</td>\n<td></td>\n</tr>\n<tr>\n<td>csv</td>\n<td>reader</td>\n</tr>\n<tr>\n<td>time</td>\n<td></td>\n</tr>\n<tr>\n<td>threading</td>\n<td></td>\n</tr>\n<tr>\n<td>queue</td>\n<td></td>\n</tr>\n<tr>\n<td>json</td>\n<td></td>\n</tr>\n<tr>\n<td>base64</td>\n<td></td>\n</tr>\n<tr>\n<td>sys</td>\n<td></td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>signature(callable)获取签名,</td>\n</tr>\n<tr>\n<td>ConfigParser</td>\n<td></td>\n</tr>\n<tr>\n<td>argparse</td>\n<td></td>\n</tr>\n<tr>\n<td>heapq</td>\n<td>hea</td>\n</tr>\n</tbody>\n</table>\n","site":{"data":{}},"excerpt":"","more":"<p>魔术方法</p>\n<table>\n<thead>\n<tr>\n<th>类别</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>可视化</td>\n<td>__str__, __repr__, __format__, __bytes__</td>\n</tr>\n<tr>\n<td>数值转换</td>\n<td>__abs__, __bool__, __complex__, __int__, __float__, __hash__, __index__</td>\n</tr>\n<tr>\n<td>容器模拟</td>\n<td>__len__, __getitem__, __setitem__, __delitem__, __contains__.__misss__</td>\n</tr>\n<tr>\n<td>迭代枚举</td>\n<td>__iter__, __reversed__, __next__</td>\n</tr>\n<tr>\n<td>可调用模拟</td>\n<td>__call__</td>\n</tr>\n<tr>\n<td>上下文管理</td>\n<td>__enter__, __exit__</td>\n</tr>\n<tr>\n<td>实例创建和销毁</td>\n<td>__new__, __init__, __del__</td>\n</tr>\n<tr>\n<td>属性管理(反射)</td>\n<td>__dir__, __getattr__, __setattr__, __delattr__, __getattribute__</td>\n</tr>\n<tr>\n<td>属性描述符(描述器)</td>\n<td>__get__, __set__, __delete__</td>\n</tr>\n<tr>\n<td>特殊属性</td>\n<td>__name__, __module__, __class__, __bases__, __doc__, __mro__, __dir__</td>\n</tr>\n<tr>\n<td>比较运算符</td>\n<td>__eq__,__lt__, __le__, __gt__, __ge__, __ne__</td>\n</tr>\n<tr>\n<td>算数运算符</td>\n<td>__add__, __sub__, __mul__, __truediv__, __mod__, __floordiv__, __pow__, __divmod__</td>\n</tr>\n<tr>\n<td>增量运算符</td>\n<td>__iadd__, __isub__, __imul__, __itruediv__, __imod__, __ifloordiv__, __ipow__</td>\n</tr>\n<tr>\n<td>反向运算符</td>\n<td>__radd__, __rsub__</td>\n</tr>\n<tr>\n<td>其他</td>\n<td>__slots__</td>\n</tr>\n</tbody>\n</table>\n<p>内置函数</p>\n<table>\n<thead>\n<tr>\n<th>内置函数名</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>数学运算</td>\n<td>abs, divmod,max,min,pow, round, sum</td>\n</tr>\n<tr>\n<td>类型转换</td>\n<td>bool,int,float, complex, str, bytearray, bytes, memoryview, ord,chr, bin,oct,hex</td>\n</tr>\n<tr>\n<td>序列操作</td>\n<td>all, any, filter, map,next,reversed, sorted, zip</td>\n</tr>\n<tr>\n<td>对象操作</td>\n<td>help,dir,id,hash, type,len, ascii,format, vars,</td>\n</tr>\n<tr>\n<td>反射操作</td>\n<td>__import__, isinstance, issubclass, hasattr, getattr, setattr, delattr,callable</td>\n</tr>\n<tr>\n<td>变量操作</td>\n<td>globals, locals,</td>\n</tr>\n<tr>\n<td>交互操作</td>\n<td>print,input</td>\n</tr>\n<tr>\n<td>文件操作</td>\n<td>open</td>\n</tr>\n<tr>\n<td>编译执行</td>\n<td>compile, eval,exec, repr</td>\n</tr>\n<tr>\n<td>装饰器</td>\n<td>property,classmethod, staticmethod,</td>\n</tr>\n<tr>\n<td>数据结构</td>\n<td>tuple, list, dict, set,frozenset, enumerate, range,iter, slice,super, object</td>\n</tr>\n</tbody>\n</table>\n<p>标识符:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"literal\">False</span>      <span class=\"keyword\">await</span>      <span class=\"keyword\">else</span>       <span class=\"keyword\">import</span>     <span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"literal\">None</span>       <span class=\"keyword\">break</span>      <span class=\"keyword\">except</span>     <span class=\"keyword\">in</span>         <span class=\"keyword\">raise</span></span><br><span class=\"line\"><span class=\"literal\">True</span>       <span class=\"class\"><span class=\"keyword\">class</span>      <span class=\"title\">finally</span>    <span class=\"title\">is</span>         <span class=\"title\">return</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">and</span>        <span class=\"title\">continue</span>   <span class=\"title\">for</span>        <span class=\"title\">lambda</span>     <span class=\"title\">try</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">as</span>         <span class=\"title\">def</span>        <span class=\"title\">from</span>       <span class=\"title\">nonlocal</span>   <span class=\"title\">while</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">assert</span>     <span class=\"title\">del</span>        <span class=\"title\">global</span>     <span class=\"title\">not</span>        <span class=\"title\">with</span></span></span><br><span class=\"line\"><span class=\"class\"><span class=\"title\">async</span>      <span class=\"title\">elif</span>       <span class=\"title\">if</span>         <span class=\"title\">or</span>         <span class=\"title\">yield</span></span></span><br></pre></td></tr></table></figure>\n<p>模块常用方法</p>\n<table>\n<thead>\n<tr>\n<th>内置模块</th>\n<th>方法名</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>re</td>\n<td>compile, search, match, fullmatch,split,findall, sub,</td>\n</tr>\n<tr>\n<td>string</td>\n<td>ascii_letters,ascii_lowercase.digits</td>\n</tr>\n<tr>\n<td>datetime</td>\n<td>datetime</td>\n</tr>\n<tr>\n<td>collections</td>\n<td>nametuple, deque, OrderdDict, defaultdict,</td>\n</tr>\n<tr>\n<td>bisect</td>\n<td>bisect_left,bisect_right,</td>\n</tr>\n<tr>\n<td>math</td>\n<td>ceil</td>\n</tr>\n<tr>\n<td>random</td>\n<td>randint, choice, randrange,shuffle, sample</td>\n</tr>\n<tr>\n<td>functools</td>\n<td>reduce, partial,lru_cache</td>\n</tr>\n<tr>\n<td>pathlib</td>\n<td></td>\n</tr>\n<tr>\n<td>os</td>\n<td></td>\n</tr>\n<tr>\n<td>shutil</td>\n<td>copyfileobj, copyfile,  copymode, copystat,copy,copy2,copytree,rmtree,move,</td>\n</tr>\n<tr>\n<td>pickle</td>\n<td></td>\n</tr>\n<tr>\n<td>csv</td>\n<td>reader</td>\n</tr>\n<tr>\n<td>time</td>\n<td></td>\n</tr>\n<tr>\n<td>threading</td>\n<td></td>\n</tr>\n<tr>\n<td>queue</td>\n<td></td>\n</tr>\n<tr>\n<td>json</td>\n<td></td>\n</tr>\n<tr>\n<td>base64</td>\n<td></td>\n</tr>\n<tr>\n<td>sys</td>\n<td></td>\n</tr>\n<tr>\n<td>inspect</td>\n<td>signature(callable)获取签名,</td>\n</tr>\n<tr>\n<td>ConfigParser</td>\n<td></td>\n</tr>\n<tr>\n<td>argparse</td>\n<td></td>\n</tr>\n<tr>\n<td>heapq</td>\n<td>hea</td>\n</tr>\n</tbody>\n</table>\n"},{"title":"描述器","_content":"\n\n### **描述器 Descriptors**\n\n**描述器的表现**\n\n**用到3个魔术方法: \\_\\_get\\_\\_() 、 \\_\\_set\\_\\_() 、 \\_\\_delete\\_\\_()**\n\n**方法签名如下**\n\n**object.\\_\\_get\\_\\_(self, instance, owner)**\n\n**object.\\_\\_set\\_\\_(self, instance, value)**\n\n**object.\\_\\_delete\\_\\_(self, instance)**\n\n**self 指代当前实例，调用者**\n\n**instance 是owner的实例**\n\n**owner 是属性的所属的类**\n\n**请思考下面程序的执行流程是什么？**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\nprint('-'*20)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x.a1)\n\n\n\n# 运行结果\n\nA.init\n\n--------------------\n\na1\n\n====================\n\nB.init\n\na1\n```\n\n\n\n**可以看出执行的先后顺序吧？**\n\n**类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。**\n\n**然后实例化并初始化B的实例b。**\n\n**打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。**\n\n### 描述器定义\n\n**Python中，一个类实现了 \\_\\_get\\_\\_ 、 \\_\\_set\\_\\_ 、 \\_\\_delete\\_\\_ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。**\n\n> **仅实现了 \\_\\_get\\_\\_ ，就是非数据描述符 non-data descriptor**\n>\n> **实现了 \\_\\_get\\_\\_ 、 \\_\\_set\\_\\_ 就是数据描述符 data descriptor**\n\n**如果一个类的类属性设置为描述器实例，那么它被称为owner属主。**\n\n**当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。**\n\n### **属性的访问顺序**\n\n**为上例中的类B增加实例属性x**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\n\tdef __get__(self, instance, owner):\n\n\t\tprint(\"A.__get__ {} {} {}\".format(self, instance, owner))\n\n\t\treturn self\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\n\t\tself.x = 'b.x' # 增加实例属性x\n\nprint('-'*20)\n\nprint(B.x)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x)\n\nprint(b.x.a1) # AttributeError: 'str' object has no attribute 'a1'\n```\n\n\n\n**类A只实现了\\_\\_get\\_\\_()方法，b.x访问到了实例的属性，而不是描述器。**\n\n**继续修改代码，为类A增加 \\_\\_set\\_\\_ 方法。**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\n\tdef __get__(self, instance, owner):\n\n\t\tprint(\"A.__get__ {} {} {}\".format(self, instance, owner))\n\n\t\treturn self\n\n\tdef __set__(self, instance, value):\n\n\t\tprint('A.__set__ {} {} {}'.format(self, instance, value))\n\n\t\tself.data = value\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\n\t\tself.x = 'b.x' # 增加实例属性x\n\nprint('-'*20)\n\nprint(B.x)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x) # 返回什么\n\nprint(b.x.a1) # 返回什么\n\nprint(b.x.data) # 返回什么？\n```\n\n\n\n**所有的b.x就会访问描述器的\\_\\_get\\_\\_()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.\\_\\_dict\\_\\_就可以看到这些属性。**\n\n** **\n\n### **属性查找顺序**\n\n**实例的 \\_\\_dict\\_\\_ 优先于 非数据描述器**\n\n**数据描述器 优先于 实例的 \\_\\_dict\\_\\_**\n\n> **\\_\\_delete\\_\\_ 方法有同样的效果，有了这个方法，也是数据描述器。**\n\n**尝试着增加下面的2行代码，看看字典的变化**\n\n**b.x = 500**\n\n**B.x = 600**\n\n**b.x = 500，这是调用数据描述器的 \\_\\_set\\_\\_ 方法，或调用非数据描述器的实例覆盖。**\n\n**B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。**\n\n** **\n\n\n\n### \n\n**Python中的描述器**\n\n**描述器在Python中应用非常广泛。**\n\n**Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。**\n\n**property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。**\n\n```python\nclass A:\n\n    @classmethod\n\n    def foo(cls): # 非数据描述器\n\n        pass\n\n    @staticmethod # 非数据描述器\n\n    def bar():\n\n    \tpass\n\n    @property # 数据描述器\n\n    def z(self):\n\n    \treturn 5\n\n    def getfoo(self): # 非数据描述器\n\n    \treturn self.foo\n\n    def __init__(self): # 非数据描述器\n\n    \tself.foo = 100\n\n    \tself.bar = 200\n\n    #self.z = 300\n\na = A()\n\nprint(a.__dict__)\n\nprint(A.__dict__)\n```\n\n\n\n> \n\n**foo、bar都可以在实例中覆盖，但是z不可以。**\n\n** **\n\n**新增方法**\n\n**3.6新增描述器方法 \\_\\_set\\_name\\_\\_ ，它在属主类构建的时候就会调用。**\n\n```python\n class A:\n\n    def init(self):\n\n    print('A init')\n\n    def get(self, instance, owner):\n\n        print(1, self, instance, owner)\n\n    return self\n\n    def set_name(self, owner, name):\n        print(2, self, owner, name)\n\n        self.name = name\n\n class B:\n\n x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)\n\n print(B().x)\n```\n\n\n\n","source":"_posts/1 (25).md","raw":"---\ntitle: 描述器\ncategories: \n- python\ntags:\n- python\n---\n\n\n### **描述器 Descriptors**\n\n**描述器的表现**\n\n**用到3个魔术方法: \\_\\_get\\_\\_() 、 \\_\\_set\\_\\_() 、 \\_\\_delete\\_\\_()**\n\n**方法签名如下**\n\n**object.\\_\\_get\\_\\_(self, instance, owner)**\n\n**object.\\_\\_set\\_\\_(self, instance, value)**\n\n**object.\\_\\_delete\\_\\_(self, instance)**\n\n**self 指代当前实例，调用者**\n\n**instance 是owner的实例**\n\n**owner 是属性的所属的类**\n\n**请思考下面程序的执行流程是什么？**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\nprint('-'*20)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x.a1)\n\n\n\n# 运行结果\n\nA.init\n\n--------------------\n\na1\n\n====================\n\nB.init\n\na1\n```\n\n\n\n**可以看出执行的先后顺序吧？**\n\n**类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。**\n\n**然后实例化并初始化B的实例b。**\n\n**打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。**\n\n### 描述器定义\n\n**Python中，一个类实现了 \\_\\_get\\_\\_ 、 \\_\\_set\\_\\_ 、 \\_\\_delete\\_\\_ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。**\n\n> **仅实现了 \\_\\_get\\_\\_ ，就是非数据描述符 non-data descriptor**\n>\n> **实现了 \\_\\_get\\_\\_ 、 \\_\\_set\\_\\_ 就是数据描述符 data descriptor**\n\n**如果一个类的类属性设置为描述器实例，那么它被称为owner属主。**\n\n**当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。**\n\n### **属性的访问顺序**\n\n**为上例中的类B增加实例属性x**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\n\tdef __get__(self, instance, owner):\n\n\t\tprint(\"A.__get__ {} {} {}\".format(self, instance, owner))\n\n\t\treturn self\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\n\t\tself.x = 'b.x' # 增加实例属性x\n\nprint('-'*20)\n\nprint(B.x)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x)\n\nprint(b.x.a1) # AttributeError: 'str' object has no attribute 'a1'\n```\n\n\n\n**类A只实现了\\_\\_get\\_\\_()方法，b.x访问到了实例的属性，而不是描述器。**\n\n**继续修改代码，为类A增加 \\_\\_set\\_\\_ 方法。**\n\n```python\nclass A:\n\n\tdef __init__(self):\n\n\t\tself.a1 = 'a1'\n\n\t\tprint('A.init')\n\n\tdef __get__(self, instance, owner):\n\n\t\tprint(\"A.__get__ {} {} {}\".format(self, instance, owner))\n\n\t\treturn self\n\n\tdef __set__(self, instance, value):\n\n\t\tprint('A.__set__ {} {} {}'.format(self, instance, value))\n\n\t\tself.data = value\n\nclass B:\n\n\tx = A()\n\n\tdef __init__(self):\n\n\t\tprint('B.init')\n\n\t\tself.x = 'b.x' # 增加实例属性x\n\nprint('-'*20)\n\nprint(B.x)\n\nprint(B.x.a1)\n\nprint('='*20)\n\nb = B()\n\nprint(b.x) # 返回什么\n\nprint(b.x.a1) # 返回什么\n\nprint(b.x.data) # 返回什么？\n```\n\n\n\n**所有的b.x就会访问描述器的\\_\\_get\\_\\_()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.\\_\\_dict\\_\\_就可以看到这些属性。**\n\n** **\n\n### **属性查找顺序**\n\n**实例的 \\_\\_dict\\_\\_ 优先于 非数据描述器**\n\n**数据描述器 优先于 实例的 \\_\\_dict\\_\\_**\n\n> **\\_\\_delete\\_\\_ 方法有同样的效果，有了这个方法，也是数据描述器。**\n\n**尝试着增加下面的2行代码，看看字典的变化**\n\n**b.x = 500**\n\n**B.x = 600**\n\n**b.x = 500，这是调用数据描述器的 \\_\\_set\\_\\_ 方法，或调用非数据描述器的实例覆盖。**\n\n**B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。**\n\n** **\n\n\n\n### \n\n**Python中的描述器**\n\n**描述器在Python中应用非常广泛。**\n\n**Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。**\n\n**property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。**\n\n```python\nclass A:\n\n    @classmethod\n\n    def foo(cls): # 非数据描述器\n\n        pass\n\n    @staticmethod # 非数据描述器\n\n    def bar():\n\n    \tpass\n\n    @property # 数据描述器\n\n    def z(self):\n\n    \treturn 5\n\n    def getfoo(self): # 非数据描述器\n\n    \treturn self.foo\n\n    def __init__(self): # 非数据描述器\n\n    \tself.foo = 100\n\n    \tself.bar = 200\n\n    #self.z = 300\n\na = A()\n\nprint(a.__dict__)\n\nprint(A.__dict__)\n```\n\n\n\n> \n\n**foo、bar都可以在实例中覆盖，但是z不可以。**\n\n** **\n\n**新增方法**\n\n**3.6新增描述器方法 \\_\\_set\\_name\\_\\_ ，它在属主类构建的时候就会调用。**\n\n```python\n class A:\n\n    def init(self):\n\n    print('A init')\n\n    def get(self, instance, owner):\n\n        print(1, self, instance, owner)\n\n    return self\n\n    def set_name(self, owner, name):\n        print(2, self, owner, name)\n\n        self.name = name\n\n class B:\n\n x = A() # 类属性创建时调用描述器的set_name方法 print('-' * 30)\n\n print(B().x)\n```\n\n\n\n","slug":"1 (25)","published":1,"date":"2019-05-28T01:10:52.515Z","updated":"2019-06-19T14:49:26.925Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81u0012jkuf3j0nkc96","content":"<h3 id=\"描述器-Descriptors\"><a href=\"#描述器-Descriptors\" class=\"headerlink\" title=\"描述器 Descriptors\"></a><strong>描述器 Descriptors</strong></h3><p><strong>描述器的表现</strong></p>\n<p><strong>用到3个魔术方法: __get__() 、 __set__() 、 __delete__()</strong></p>\n<p><strong>方法签名如下</strong></p>\n<p><strong>object.__get__(self, instance, owner)</strong></p>\n<p><strong>object.__set__(self, instance, value)</strong></p>\n<p><strong>object.__delete__(self, instance)</strong></p>\n<p><strong>self 指代当前实例，调用者</strong></p>\n<p><strong>instance 是owner的实例</strong></p>\n<p><strong>owner 是属性的所属的类</strong></p>\n<p><strong>请思考下面程序的执行流程是什么？</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">A.init</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"></span><br><span class=\"line\">a1</span><br><span class=\"line\"></span><br><span class=\"line\">====================</span><br><span class=\"line\"></span><br><span class=\"line\">B.init</span><br><span class=\"line\"></span><br><span class=\"line\">a1</span><br></pre></td></tr></table></figure>\n<p><strong>可以看出执行的先后顺序吧？</strong></p>\n<p><strong>类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。</strong></p>\n<p><strong>然后实例化并初始化B的实例b。</strong></p>\n<p><strong>打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。</strong></p>\n<h3 id=\"描述器定义\"><a href=\"#描述器定义\" class=\"headerlink\" title=\"描述器定义\"></a>描述器定义</h3><p><strong>Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。</strong></p>\n<blockquote>\n<p><strong>仅实现了 __get__ ，就是非数据描述符 non-data descriptor</strong></p>\n<p><strong>实现了 __get__ 、 __set__ 就是数据描述符 data descriptor</strong></p>\n</blockquote>\n<p><strong>如果一个类的类属性设置为描述器实例，那么它被称为owner属主。</strong></p>\n<p><strong>当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。</strong></p>\n<h3 id=\"属性的访问顺序\"><a href=\"#属性的访问顺序\" class=\"headerlink\" title=\"属性的访问顺序\"></a><strong>属性的访问顺序</strong></h3><p><strong>为上例中的类B增加实例属性x</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">\"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;\"</span>.format(self, instance, owner))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.x = <span class=\"string\">'b.x'</span> <span class=\"comment\"># 增加实例属性x</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1) <span class=\"comment\"># AttributeError: 'str' object has no attribute 'a1'</span></span><br></pre></td></tr></table></figure>\n<p><strong>类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。</strong></p>\n<p><strong>继续修改代码，为类A增加 __set__ 方法。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">\"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;\"</span>.format(self, instance, owner))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, instance, value)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(self, instance, value))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.data = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.x = <span class=\"string\">'b.x'</span> <span class=\"comment\"># 增加实例属性x</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x) <span class=\"comment\"># 返回什么</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1) <span class=\"comment\"># 返回什么</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.data) <span class=\"comment\"># 返回什么？</span></span><br></pre></td></tr></table></figure>\n<p><strong>所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。</strong></p>\n<hr>\n<h3 id=\"属性查找顺序\"><a href=\"#属性查找顺序\" class=\"headerlink\" title=\"属性查找顺序\"></a><strong>属性查找顺序</strong></h3><p><strong>实例的 __dict__ 优先于 非数据描述器</strong></p>\n<p><strong>数据描述器 优先于 实例的 __dict__</strong></p>\n<blockquote>\n<p><strong>__delete__ 方法有同样的效果，有了这个方法，也是数据描述器。</strong></p>\n</blockquote>\n<p><strong>尝试着增加下面的2行代码，看看字典的变化</strong></p>\n<p><strong>b.x = 500</strong></p>\n<p><strong>B.x = 600</strong></p>\n<p><strong>b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。</strong></p>\n<p><strong>B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。</strong></p>\n<hr>\n<p>### </p>\n<p><strong>Python中的描述器</strong></p>\n<p><strong>描述器在Python中应用非常广泛。</strong></p>\n<p><strong>Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。</strong></p>\n<p><strong>property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(cls)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod # 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bar</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @property # 数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">z</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getfoo</span><span class=\"params\">(self)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> self.foo</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \tself.foo = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \tself.bar = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#self.z = 300</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = A()</span><br><span class=\"line\"></span><br><span class=\"line\">print(a.__dict__)</span><br><span class=\"line\"></span><br><span class=\"line\">print(A.__dict__)</span><br></pre></td></tr></table></figure>\n<blockquote>\n</blockquote>\n<p><strong>foo、bar都可以在实例中覆盖，但是z不可以。</strong></p>\n<hr>\n<p><strong>新增方法</strong></p>\n<p><strong>3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   print(<span class=\"string\">'A init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">       print(<span class=\"number\">1</span>, self, instance, owner)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_name</span><span class=\"params\">(self, owner, name)</span>:</span></span><br><span class=\"line\">       print(<span class=\"number\">2</span>, self, owner, name)</span><br><span class=\"line\"></span><br><span class=\"line\">       self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">x = A() <span class=\"comment\"># 类属性创建时调用描述器的set_name方法 print('-' * 30)</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(B().x)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"描述器-Descriptors\"><a href=\"#描述器-Descriptors\" class=\"headerlink\" title=\"描述器 Descriptors\"></a><strong>描述器 Descriptors</strong></h3><p><strong>描述器的表现</strong></p>\n<p><strong>用到3个魔术方法: __get__() 、 __set__() 、 __delete__()</strong></p>\n<p><strong>方法签名如下</strong></p>\n<p><strong>object.__get__(self, instance, owner)</strong></p>\n<p><strong>object.__set__(self, instance, value)</strong></p>\n<p><strong>object.__delete__(self, instance)</strong></p>\n<p><strong>self 指代当前实例，调用者</strong></p>\n<p><strong>instance 是owner的实例</strong></p>\n<p><strong>owner 是属性的所属的类</strong></p>\n<p><strong>请思考下面程序的执行流程是什么？</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 运行结果</span></span><br><span class=\"line\"></span><br><span class=\"line\">A.init</span><br><span class=\"line\"></span><br><span class=\"line\">--------------------</span><br><span class=\"line\"></span><br><span class=\"line\">a1</span><br><span class=\"line\"></span><br><span class=\"line\">====================</span><br><span class=\"line\"></span><br><span class=\"line\">B.init</span><br><span class=\"line\"></span><br><span class=\"line\">a1</span><br></pre></td></tr></table></figure>\n<p><strong>可以看出执行的先后顺序吧？</strong></p>\n<p><strong>类加载的时候，类变量需要先生成，而类B的x属性是类A的实例，所以类A先初始化，所以打印A.init。 然后执行到打印B.x.a1。</strong></p>\n<p><strong>然后实例化并初始化B的实例b。</strong></p>\n<p><strong>打印b.x.a1，会查找类属性b.x，指向A的实例，所以返回A实例的属性a1的值。</strong></p>\n<h3 id=\"描述器定义\"><a href=\"#描述器定义\" class=\"headerlink\" title=\"描述器定义\"></a>描述器定义</h3><p><strong>Python中，一个类实现了 __get__ 、 __set__ 、 __delete__ 三个方法中的任何一个方法，就是描述器。实现这 三个中的某些方法，就支持了描述器协议。</strong></p>\n<blockquote>\n<p><strong>仅实现了 __get__ ，就是非数据描述符 non-data descriptor</strong></p>\n<p><strong>实现了 __get__ 、 __set__ 就是数据描述符 data descriptor</strong></p>\n</blockquote>\n<p><strong>如果一个类的类属性设置为描述器实例，那么它被称为owner属主。</strong></p>\n<p><strong>当该类的该类属性被查找、设置、删除时，就会调用描述器相应的方法。</strong></p>\n<h3 id=\"属性的访问顺序\"><a href=\"#属性的访问顺序\" class=\"headerlink\" title=\"属性的访问顺序\"></a><strong>属性的访问顺序</strong></h3><p><strong>为上例中的类B增加实例属性x</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">\"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;\"</span>.format(self, instance, owner))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.x = <span class=\"string\">'b.x'</span> <span class=\"comment\"># 增加实例属性x</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1) <span class=\"comment\"># AttributeError: 'str' object has no attribute 'a1'</span></span><br></pre></td></tr></table></figure>\n<p><strong>类A只实现了__get__()方法，b.x访问到了实例的属性，而不是描述器。</strong></p>\n<p><strong>继续修改代码，为类A增加 __set__ 方法。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.a1 = <span class=\"string\">'a1'</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__get__</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">\"A.__get__ &#123;&#125; &#123;&#125; &#123;&#125;\"</span>.format(self, instance, owner))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__set__</span><span class=\"params\">(self, instance, value)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'A.__set__ &#123;&#125; &#123;&#125; &#123;&#125;'</span>.format(self, instance, value))</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.data = value</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\tx = A()</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">\t\tprint(<span class=\"string\">'B.init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">\t\tself.x = <span class=\"string\">'b.x'</span> <span class=\"comment\"># 增加实例属性x</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'-'</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x)</span><br><span class=\"line\"></span><br><span class=\"line\">print(B.x.a1)</span><br><span class=\"line\"></span><br><span class=\"line\">print(<span class=\"string\">'='</span>*<span class=\"number\">20</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">b = B()</span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x) <span class=\"comment\"># 返回什么</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.a1) <span class=\"comment\"># 返回什么</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(b.x.data) <span class=\"comment\"># 返回什么？</span></span><br></pre></td></tr></table></figure>\n<p><strong>所有的b.x就会访问描述器的__get__()方法，代码中返回的self就是描述器实例，它的实例字典中就保存着a1和data 属性，可以打印b.x.__dict__就可以看到这些属性。</strong></p>\n<hr>\n<h3 id=\"属性查找顺序\"><a href=\"#属性查找顺序\" class=\"headerlink\" title=\"属性查找顺序\"></a><strong>属性查找顺序</strong></h3><p><strong>实例的 __dict__ 优先于 非数据描述器</strong></p>\n<p><strong>数据描述器 优先于 实例的 __dict__</strong></p>\n<blockquote>\n<p><strong>__delete__ 方法有同样的效果，有了这个方法，也是数据描述器。</strong></p>\n</blockquote>\n<p><strong>尝试着增加下面的2行代码，看看字典的变化</strong></p>\n<p><strong>b.x = 500</strong></p>\n<p><strong>B.x = 600</strong></p>\n<p><strong>b.x = 500，这是调用数据描述器的 __set__ 方法，或调用非数据描述器的实例覆盖。</strong></p>\n<p><strong>B.x = 600，赋值即定义，这是覆盖类属性。把描述器给替换了。</strong></p>\n<hr>\n<p>### </p>\n<p><strong>Python中的描述器</strong></p>\n<p><strong>描述器在Python中应用非常广泛。</strong></p>\n<p><strong>Python的方法（包括staticmethod()和classmethod()）都实现为非数据描述器。因此，实例可以重新定义和覆盖 方法。这允许单个实例获取与同一类的其他实例不同的行为。</strong></p>\n<p><strong>property()函数实现为一个数据描述器。因此，实例不能覆盖属性的行为。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @classmethod</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">foo</span><span class=\"params\">(cls)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @staticmethod # 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bar</span><span class=\"params\">()</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">pass</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">    @property # 数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">z</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> <span class=\"number\">5</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">getfoo</span><span class=\"params\">(self)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \t<span class=\"keyword\">return</span> self.foo</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self)</span>:</span> <span class=\"comment\"># 非数据描述器</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \tself.foo = <span class=\"number\">100</span></span><br><span class=\"line\"></span><br><span class=\"line\">    \tself.bar = <span class=\"number\">200</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">#self.z = 300</span></span><br><span class=\"line\"></span><br><span class=\"line\">a = A()</span><br><span class=\"line\"></span><br><span class=\"line\">print(a.__dict__)</span><br><span class=\"line\"></span><br><span class=\"line\">print(A.__dict__)</span><br></pre></td></tr></table></figure>\n<blockquote>\n</blockquote>\n<p><strong>foo、bar都可以在实例中覆盖，但是z不可以。</strong></p>\n<hr>\n<p><strong>新增方法</strong></p>\n<p><strong>3.6新增描述器方法 __set_name__ ，它在属主类构建的时候就会调用。</strong></p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">init</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">   print(<span class=\"string\">'A init'</span>)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">get</span><span class=\"params\">(self, instance, owner)</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">       print(<span class=\"number\">1</span>, self, instance, owner)</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">return</span> self</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">set_name</span><span class=\"params\">(self, owner, name)</span>:</span></span><br><span class=\"line\">       print(<span class=\"number\">2</span>, self, owner, name)</span><br><span class=\"line\"></span><br><span class=\"line\">       self.name = name</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">B</span>:</span></span><br><span class=\"line\"></span><br><span class=\"line\">x = A() <span class=\"comment\"># 类属性创建时调用描述器的set_name方法 print('-' * 30)</span></span><br><span class=\"line\"></span><br><span class=\"line\">print(B().x)</span><br></pre></td></tr></table></figure>\n"},{"title":"正则表达式","_content":"\n# 正则表达式简绍\n概述:正则表达式\n正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.\n正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.\n正则表达式 Regular Expression,缩写regex, regexp ,RE等.\n分类\n1.BRE\n基本正则表达式,grep,sed,vi等软件支持.vim有扩展.\n2.ERE\n扩展正则表达式,egrep, sed -r等.\n3.PCRE\n几乎所有高级语言都是PCRE的方言或者变种.\n\n# 基本语法\n元字符 metacharacter\n转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\\转义.\n反斜杠自身,得使用\\\\ \\r \\n还是转义后代表回车,换行\n\n# 贪婪与非贪婪\n默认是贪婪模式,也就是说尽量多匹配更长的字符串,\n非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.\n\n单行模式:\n. 可以匹配所有的字符, 包括换行符.\n^ 表示整个字符串的开头, &整个字符串的结尾\n多行模式:\n. 可以匹配除了换行符之外的字符,多行不影响.点号\n^ 表示行首, &行尾, 只不过这里的行是每一行\n\n默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.\n单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &就是这一行的行尾.\n多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\\n后紧接着下一个字符;结束指的是\\n前的字符,注意最后一行可以没有\\n\n\n# re模块\nre.M多行模式\nre.S单行模式\nre.I忽略大小写\nre.X忽略表达式中的空白字符\n使用 | 位或运算开启多种选项\n方法\n编译\nre.compile(pattern, flag=0)\n设定flags, 编译模式,返回正则表达式对象regex\npattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.\n单次匹配\nre.match(pattern, string, flags=0)\nmatch匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象\n从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.\n\n全局搜索\n对整个字符串, 从左至右匹配,返回匹配项的列表.\n匹配替换\n使用pattern对字符串string进行匹配,对匹配使用repl替换.\nreplacement可以是string, bytes, function.\n\n分割字符串\n字符串的分割函数split,太难用, 不能指定多个字符进行分割.\n分组\n使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象\n如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.\n1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.\n2.如果使用了命名分组,可以使用group的方式取分组\n3.也可以使用group返回所有组.\n4.使用groupdict()返回命名的分组.\n\n\n\n\n","source":"_posts/1 (4).md","raw":"---\ntitle: 正则表达式\n\n\ncategories: \n- python\ntags:\n- python\n---\n\n# 正则表达式简绍\n概述:正则表达式\n正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.\n正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.\n正则表达式 Regular Expression,缩写regex, regexp ,RE等.\n分类\n1.BRE\n基本正则表达式,grep,sed,vi等软件支持.vim有扩展.\n2.ERE\n扩展正则表达式,egrep, sed -r等.\n3.PCRE\n几乎所有高级语言都是PCRE的方言或者变种.\n\n# 基本语法\n元字符 metacharacter\n转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\\转义.\n反斜杠自身,得使用\\\\ \\r \\n还是转义后代表回车,换行\n\n# 贪婪与非贪婪\n默认是贪婪模式,也就是说尽量多匹配更长的字符串,\n非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.\n\n单行模式:\n. 可以匹配所有的字符, 包括换行符.\n^ 表示整个字符串的开头, &整个字符串的结尾\n多行模式:\n. 可以匹配除了换行符之外的字符,多行不影响.点号\n^ 表示行首, &行尾, 只不过这里的行是每一行\n\n默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.\n单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &就是这一行的行尾.\n多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\\n后紧接着下一个字符;结束指的是\\n前的字符,注意最后一行可以没有\\n\n\n# re模块\nre.M多行模式\nre.S单行模式\nre.I忽略大小写\nre.X忽略表达式中的空白字符\n使用 | 位或运算开启多种选项\n方法\n编译\nre.compile(pattern, flag=0)\n设定flags, 编译模式,返回正则表达式对象regex\npattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.\n单次匹配\nre.match(pattern, string, flags=0)\nmatch匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象\n从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.\n\n全局搜索\n对整个字符串, 从左至右匹配,返回匹配项的列表.\n匹配替换\n使用pattern对字符串string进行匹配,对匹配使用repl替换.\nreplacement可以是string, bytes, function.\n\n分割字符串\n字符串的分割函数split,太难用, 不能指定多个字符进行分割.\n分组\n使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象\n如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.\n1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.\n2.如果使用了命名分组,可以使用group的方式取分组\n3.也可以使用group返回所有组.\n4.使用groupdict()返回命名的分组.\n\n\n\n\n","slug":"1 (4)","published":1,"date":"2019-05-07T11:09:30.662Z","updated":"2019-06-19T14:48:50.730Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h81y0017jkuftiirld7j","content":"<h1 id=\"正则表达式简绍\"><a href=\"#正则表达式简绍\" class=\"headerlink\" title=\"正则表达式简绍\"></a>正则表达式简绍</h1><p>概述:正则表达式<br>正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.<br>正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.<br>正则表达式 Regular Expression,缩写regex, regexp ,RE等.<br>分类<br>1.BRE<br>基本正则表达式,grep,sed,vi等软件支持.vim有扩展.<br>2.ERE<br>扩展正则表达式,egrep, sed -r等.<br>3.PCRE<br>几乎所有高级语言都是PCRE的方言或者变种.</p>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>元字符 metacharacter<br>转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\\转义.<br>反斜杠自身,得使用\\ \\r \\n还是转义后代表回车,换行</p>\n<h1 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h1><p>默认是贪婪模式,也就是说尽量多匹配更长的字符串,<br>非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.</p>\n<p>单行模式:<br>. 可以匹配所有的字符, 包括换行符.<br>^ 表示整个字符串的开头, &amp;整个字符串的结尾<br>多行模式:<br>. 可以匹配除了换行符之外的字符,多行不影响.点号<br>^ 表示行首, &amp;行尾, 只不过这里的行是每一行</p>\n<p>默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.<br>单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.<br>多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\\n后紧接着下一个字符;结束指的是\\n前的字符,注意最后一行可以没有\\n</p>\n<h1 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h1><p>re.M多行模式<br>re.S单行模式<br>re.I忽略大小写<br>re.X忽略表达式中的空白字符<br>使用 | 位或运算开启多种选项<br>方法<br>编译<br>re.compile(pattern, flag=0)<br>设定flags, 编译模式,返回正则表达式对象regex<br>pattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.<br>单次匹配<br>re.match(pattern, string, flags=0)<br>match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象<br>从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.</p>\n<p>全局搜索<br>对整个字符串, 从左至右匹配,返回匹配项的列表.<br>匹配替换<br>使用pattern对字符串string进行匹配,对匹配使用repl替换.<br>replacement可以是string, bytes, function.</p>\n<p>分割字符串<br>字符串的分割函数split,太难用, 不能指定多个字符进行分割.<br>分组<br>使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象<br>如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.<br>1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.<br>2.如果使用了命名分组,可以使用group的方式取分组<br>3.也可以使用group返回所有组.<br>4.使用groupdict()返回命名的分组.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"正则表达式简绍\"><a href=\"#正则表达式简绍\" class=\"headerlink\" title=\"正则表达式简绍\"></a>正则表达式简绍</h1><p>概述:正则表达式<br>正则表达式是文本处理极为重要的技术,用它可以对字符串按照某种规则进行检索,替换.<br>正则表达式应用及其广泛,shell中处理文本的命令,各种高级编程语言都支持正则表达式.<br>正则表达式 Regular Expression,缩写regex, regexp ,RE等.<br>分类<br>1.BRE<br>基本正则表达式,grep,sed,vi等软件支持.vim有扩展.<br>2.ERE<br>扩展正则表达式,egrep, sed -r等.<br>3.PCRE<br>几乎所有高级语言都是PCRE的方言或者变种.</p>\n<h1 id=\"基本语法\"><a href=\"#基本语法\" class=\"headerlink\" title=\"基本语法\"></a>基本语法</h1><p>元字符 metacharacter<br>转义 凡是在正则表达式中有特殊意义的符号,如果使用它的本意,请使用\\转义.<br>反斜杠自身,得使用\\ \\r \\n还是转义后代表回车,换行</p>\n<h1 id=\"贪婪与非贪婪\"><a href=\"#贪婪与非贪婪\" class=\"headerlink\" title=\"贪婪与非贪婪\"></a>贪婪与非贪婪</h1><p>默认是贪婪模式,也就是说尽量多匹配更长的字符串,<br>非贪婪很简单,在重复的符号后面加上一个?问号,就尽量的少匹配了.</p>\n<p>单行模式:<br>. 可以匹配所有的字符, 包括换行符.<br>^ 表示整个字符串的开头, &amp;整个字符串的结尾<br>多行模式:<br>. 可以匹配除了换行符之外的字符,多行不影响.点号<br>^ 表示行首, &amp;行尾, 只不过这里的行是每一行</p>\n<p>默认模式:可以看做待匹配的文本是一行, 不能看做多行, .点号不能匹配换行符, ^和&amp;表示行首和行尾, 而行首行尾就是整个字符串的开头和结尾.<br>单行模式:基本和默认模式一样,只是.点号终于可以匹配任意一个字符包括换行符,这时所有文本就是一个长长的只有一行的字符串. ^就是这一行字符串的行首, &amp;就是这一行的行尾.<br>多行模式:重新定义了行的概念, 但不影响.点号的行为, ^和&amp;还是行首行尾的意思,只不过因为多行模式可以识别换行符.开始指的是\\n后紧接着下一个字符;结束指的是\\n前的字符,注意最后一行可以没有\\n</p>\n<h1 id=\"re模块\"><a href=\"#re模块\" class=\"headerlink\" title=\"re模块\"></a>re模块</h1><p>re.M多行模式<br>re.S单行模式<br>re.I忽略大小写<br>re.X忽略表达式中的空白字符<br>使用 | 位或运算开启多种选项<br>方法<br>编译<br>re.compile(pattern, flag=0)<br>设定flags, 编译模式,返回正则表达式对象regex<br>pattern就是正则表达式字符串, flags是选项,正则表达式需要被编译,为了提高效率,这些编译后的结果被保存,下次使用同样的pattern的时候,就不需要再次编译.<br>单次匹配<br>re.match(pattern, string, flags=0)<br>match匹配从字符串的开头匹配,regex对象match方法可以重设开始位置.发挥match对象<br>从头搜索直到第一个匹配,regex对象seach()方法可以重设开始位置和结束位置,返回macth对象.</p>\n<p>全局搜索<br>对整个字符串, 从左至右匹配,返回匹配项的列表.<br>匹配替换<br>使用pattern对字符串string进行匹配,对匹配使用repl替换.<br>replacement可以是string, bytes, function.</p>\n<p>分割字符串<br>字符串的分割函数split,太难用, 不能指定多个字符进行分割.<br>分组<br>使用小括号的pattern捕获的match对象; findall返回字符串列表; finditer返回一个个match对象<br>如果pattern中使用了分组,如果有匹配的结果, 会在match对象中.<br>1.使用group()方式返回对应分组,1到n是对应的分组, 0返回整个匹配的字符串, N不写缺省为0.<br>2.如果使用了命名分组,可以使用group的方式取分组<br>3.也可以使用group返回所有组.<br>4.使用groupdict()返回命名的分组.</p>\n"},{"title":"魔术方法","_content":"\n###  特殊属性\n\n| 属性          | 含义                                                 |\n| ------------- | ---------------------------------------------------- |\n| _\\_name\\_\\_   | 类,函数,方法等名字                                   |\n| _\\_module\\_\\_ | 类定义所在的模块名                                   |\n| _\\_class\\_\\_  | 对象或类所属的类                                     |\n| _\\_base\\_\\_   | 类的基类的元组,顺序为他们在基类中出现的顺序          |\n| _\\_doc\\_\\_    | 类, 函数的文档字符串, 如果没有定义则为None           |\n| _\\_mro\\_\\_    | 类的mro, class.mro()返回的结果的保存在\\_\\_mro\\_\\_ 中 |\n| _\\_dict\\_\\_   | 类或实例的属性, 可写的字典                           |\n\n###  查看属性\n\n\\_\\_dir_\\_: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.\n\n如果dir()参数obj包括方法\\__dir\\__(), 该方法将被调用.如果参数obj不包含\\_\\_dir\\_\\_(), 该方法将最大限度地收集属性信息.\n\ndir(obj)对于不同类型的对象obj具有不同的行为:\n\n* 如果对象是模块对象, 返回的列表包含模块的属性名和变量名\n* 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名\n* 如果是类的实例\n  - 有\\_\\_dir\\_\\_方法, 返回可迭代对象的返回值\n  - 没有\\_\\_dir\\_\\_方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名\n* 如果obj不写, 返回列表包含内容不同\n  - 在模块中, 返回模块的属性和变量名\n  - 在函数中, 返回本地作用域的变量名\n  - 在方法中,  返回本地作用域的变量名\n\n```python\n# animal.py\nclass Animal:\n    x = 123\n    def __init__(self, name):\n\t\tself._name = name\n        self.__age = 10\n        self.weight = 20\n \nprint('animal Module\\ s names = {}'.format(dir()))# 模块的属性 )\n```\n\n### 魔术方法***\n\n------\n\n* 分类:\n\n  - 创建, 初始化与销毁\n\n  - 可视化\n  - hash\n  - bool\n  - 运算符重载\n  - 容器和大小\n  - 可调用对象\n  - 上下文管理\n  - 反射\n  - 描述器\n  - 其他杂项\n\n#### 实例化\n\n------\n\n| 方法        | 意义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| \\_\\_new\\_\\_ | 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用\\_\\_init\\_\\_该方法永远都是静态方法 |\n\n\n\n\\_\\_new\\_\\_方法很少使用,即使创建了该方法也会使用return super().\\_\\_new\\_\\_(cls)基类object的\\_\\_new\\_\\_方法来创建实例并返回\n\n#### 可视化\n\n____\n\n| 方法        | 意义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| \\_\\_str\\_\\_ | str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用\\_\\_repr\\_\\_方法返回字符串表达, 如果\\_\\_repr\\_\\_没有定义, 就直接返回对象的内存地址信息 |\n| \\_\\_repr\\_\\_ | 内建函数repr()对一个对象获取**字符串**表达 |\n| \\_\\_bytes\\_\\_ | bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 |\n\n```python\nclass A:\n    def __init__(self, name, age = 18):\n\t\tself.name = name\n        self.age = age\n    def __repr__(self):\n        return 'repr:{}{}'.format(self.name, self.age)\n    \n\n```\n\n#### hash\n\n| 方法         | 意义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| \\_\\_hash\\_\\_ | 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash |\n| \\_\\_eq\\_\\_   | 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供\\_\\_hash\\_\\_方法, 那么实例将不可hash了 |\n\n\n\n#### bool\n\n| 方法         | 意义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| \\_\\_bool\\_\\_ | 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义\\_\\_bool\\_\\_(), 就找\\_\\_len\\_\\_返回长度,非0 为真 |\n\n\n\n### 上下文管理\n\n文件IO操作可以对文件对象使用上下文管理，使用with。。as语法\n\n```python\nwith open('test') as f:\n\tpass\n```\n\n仿照上例写一个自己的泪，实现上下文管理\n\n```python\nclass Point:\n\tpass\nwith Point as p:\n\tpass\n```\n\n提示属性错误，没有\\_\\_exit\\__，看了需要这个属性\n\n某些版本会显示没有\\_\\_enter\\_\\_\n\n上下文管理对象\n\n当一个对象同时实现了\\_\\_enter\\_\\_()和exit()方法,他就属于上下文管理的对象\n\n\\_\\_enter\\_\\_ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上\n\n\\_\\_exit\\_\\_退出与此对象相关的上下文\n\n\n\nwith可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作\n\n注意,with 并不开启一个新的作用域\n\n上下文管理是安全的\n\n上下文应用场景\n\n1.增强功能\n\n在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能\n\n2.资源管理\n\n打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等\n\n3.权限验证\n\n在执行代码之前,做权限验证,在\\_\\_enter\\_\\_\n\n#### contextilb.contextmanager\n\n他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现\\_\\_enter\\_\\_he \\_\\_exit\\_\\_方法\n\n对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.\n\n也就是这个装饰器接受一个生成器对象作为参数.\n\n总结\n\n如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加\\_\\_enter\\_\\_和\\_\\_exit\\_\\_方法方便\n\n### 反射\n\n概述\n\n运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候\n\n反射,  reflection, 指的是运行时获取类型定义信息\n\n一个对象能够在运行时,像照镜子一样,反射出其类型信息\n\n简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身\n\n具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等\n\n#### 反射相关的函数和方法\n\n| getattar | 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. |\n| -------- | ------------------------------------------------------------ |\n| setattar | object的属性存在,这覆盖, 不存在,新增                         |\n| hasattat | 判断对象是否有这个名字的属性,name必须为字符串                |\n\n#### 反射相关的魔术方法\n\n\\_\\_getattr\\_\\_(), \\_\\_setattr\\_\\_(), \\_\\_delattr\\_\\_(), 三个魔术方法\n\n实例属性会按照继承关系找,  如果找不到, 就会执行\\_\\_getattar\\_\\_()方法, 如果没有这个方法, 就会抛出\n\nAttributeError异常表示找不到属性.\n\n查找属性顺序为:\n\ninstance.\\_\\_dict\\_\\_ - > instance.\\_\\_class\\_\\_.\\_\\_dict\\_\\_ -> 继承的祖先类(直到object)的\\_\\_dict\\_\\_ -- 找不到- >调用\\_\\_getattr\\_\\_()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/1 (26).md","raw":"---\ntitle: 魔术方法\ncategories: \n- python\ntags:\n- python\n---\n\n###  特殊属性\n\n| 属性          | 含义                                                 |\n| ------------- | ---------------------------------------------------- |\n| _\\_name\\_\\_   | 类,函数,方法等名字                                   |\n| _\\_module\\_\\_ | 类定义所在的模块名                                   |\n| _\\_class\\_\\_  | 对象或类所属的类                                     |\n| _\\_base\\_\\_   | 类的基类的元组,顺序为他们在基类中出现的顺序          |\n| _\\_doc\\_\\_    | 类, 函数的文档字符串, 如果没有定义则为None           |\n| _\\_mro\\_\\_    | 类的mro, class.mro()返回的结果的保存在\\_\\_mro\\_\\_ 中 |\n| _\\_dict\\_\\_   | 类或实例的属性, 可写的字典                           |\n\n###  查看属性\n\n\\_\\_dir_\\_: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.\n\n如果dir()参数obj包括方法\\__dir\\__(), 该方法将被调用.如果参数obj不包含\\_\\_dir\\_\\_(), 该方法将最大限度地收集属性信息.\n\ndir(obj)对于不同类型的对象obj具有不同的行为:\n\n* 如果对象是模块对象, 返回的列表包含模块的属性名和变量名\n* 如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名\n* 如果是类的实例\n  - 有\\_\\_dir\\_\\_方法, 返回可迭代对象的返回值\n  - 没有\\_\\_dir\\_\\_方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名\n* 如果obj不写, 返回列表包含内容不同\n  - 在模块中, 返回模块的属性和变量名\n  - 在函数中, 返回本地作用域的变量名\n  - 在方法中,  返回本地作用域的变量名\n\n```python\n# animal.py\nclass Animal:\n    x = 123\n    def __init__(self, name):\n\t\tself._name = name\n        self.__age = 10\n        self.weight = 20\n \nprint('animal Module\\ s names = {}'.format(dir()))# 模块的属性 )\n```\n\n### 魔术方法***\n\n------\n\n* 分类:\n\n  - 创建, 初始化与销毁\n\n  - 可视化\n  - hash\n  - bool\n  - 运算符重载\n  - 容器和大小\n  - 可调用对象\n  - 上下文管理\n  - 反射\n  - 描述器\n  - 其他杂项\n\n#### 实例化\n\n------\n\n| 方法        | 意义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| \\_\\_new\\_\\_ | 实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用\\_\\_init\\_\\_该方法永远都是静态方法 |\n\n\n\n\\_\\_new\\_\\_方法很少使用,即使创建了该方法也会使用return super().\\_\\_new\\_\\_(cls)基类object的\\_\\_new\\_\\_方法来创建实例并返回\n\n#### 可视化\n\n____\n\n| 方法        | 意义                                                         |\n| ----------- | ------------------------------------------------------------ |\n| \\_\\_str\\_\\_ | str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用\\_\\_repr\\_\\_方法返回字符串表达, 如果\\_\\_repr\\_\\_没有定义, 就直接返回对象的内存地址信息 |\n| \\_\\_repr\\_\\_ | 内建函数repr()对一个对象获取**字符串**表达 |\n| \\_\\_bytes\\_\\_ | bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象 |\n\n```python\nclass A:\n    def __init__(self, name, age = 18):\n\t\tself.name = name\n        self.age = age\n    def __repr__(self):\n        return 'repr:{}{}'.format(self.name, self.age)\n    \n\n```\n\n#### hash\n\n| 方法         | 意义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| \\_\\_hash\\_\\_ | 内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash |\n| \\_\\_eq\\_\\_   | 对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供\\_\\_hash\\_\\_方法, 那么实例将不可hash了 |\n\n\n\n#### bool\n\n| 方法         | 意义                                                         |\n| ------------ | ------------------------------------------------------------ |\n| \\_\\_bool\\_\\_ | 内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义\\_\\_bool\\_\\_(), 就找\\_\\_len\\_\\_返回长度,非0 为真 |\n\n\n\n### 上下文管理\n\n文件IO操作可以对文件对象使用上下文管理，使用with。。as语法\n\n```python\nwith open('test') as f:\n\tpass\n```\n\n仿照上例写一个自己的泪，实现上下文管理\n\n```python\nclass Point:\n\tpass\nwith Point as p:\n\tpass\n```\n\n提示属性错误，没有\\_\\_exit\\__，看了需要这个属性\n\n某些版本会显示没有\\_\\_enter\\_\\_\n\n上下文管理对象\n\n当一个对象同时实现了\\_\\_enter\\_\\_()和exit()方法,他就属于上下文管理的对象\n\n\\_\\_enter\\_\\_ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上\n\n\\_\\_exit\\_\\_退出与此对象相关的上下文\n\n\n\nwith可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作\n\n注意,with 并不开启一个新的作用域\n\n上下文管理是安全的\n\n上下文应用场景\n\n1.增强功能\n\n在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能\n\n2.资源管理\n\n打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等\n\n3.权限验证\n\n在执行代码之前,做权限验证,在\\_\\_enter\\_\\_\n\n#### contextilb.contextmanager\n\n他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现\\_\\_enter\\_\\_he \\_\\_exit\\_\\_方法\n\n对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.\n\n也就是这个装饰器接受一个生成器对象作为参数.\n\n总结\n\n如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加\\_\\_enter\\_\\_和\\_\\_exit\\_\\_方法方便\n\n### 反射\n\n概述\n\n运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候\n\n反射,  reflection, 指的是运行时获取类型定义信息\n\n一个对象能够在运行时,像照镜子一样,反射出其类型信息\n\n简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身\n\n具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等\n\n#### 反射相关的函数和方法\n\n| getattar | 通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串. |\n| -------- | ------------------------------------------------------------ |\n| setattar | object的属性存在,这覆盖, 不存在,新增                         |\n| hasattat | 判断对象是否有这个名字的属性,name必须为字符串                |\n\n#### 反射相关的魔术方法\n\n\\_\\_getattr\\_\\_(), \\_\\_setattr\\_\\_(), \\_\\_delattr\\_\\_(), 三个魔术方法\n\n实例属性会按照继承关系找,  如果找不到, 就会执行\\_\\_getattar\\_\\_()方法, 如果没有这个方法, 就会抛出\n\nAttributeError异常表示找不到属性.\n\n查找属性顺序为:\n\ninstance.\\_\\_dict\\_\\_ - > instance.\\_\\_class\\_\\_.\\_\\_dict\\_\\_ -> 继承的祖先类(直到object)的\\_\\_dict\\_\\_ -- 找不到- >调用\\_\\_getattr\\_\\_()\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n","slug":"1 (26)","published":1,"date":"2019-05-23T01:03:18.588Z","updated":"2019-06-19T14:49:09.429Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h823001ajkufr6umdjq0","content":"<h3 id=\"特殊属性\"><a href=\"#特殊属性\" class=\"headerlink\" title=\"特殊属性\"></a>特殊属性</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__name__</td>\n<td>类,函数,方法等名字</td>\n</tr>\n<tr>\n<td>__module__</td>\n<td>类定义所在的模块名</td>\n</tr>\n<tr>\n<td>__class__</td>\n<td>对象或类所属的类</td>\n</tr>\n<tr>\n<td>__base__</td>\n<td>类的基类的元组,顺序为他们在基类中出现的顺序</td>\n</tr>\n<tr>\n<td>__doc__</td>\n<td>类, 函数的文档字符串, 如果没有定义则为None</td>\n</tr>\n<tr>\n<td>__mro__</td>\n<td>类的mro, class.mro()返回的结果的保存在__mro__ 中</td>\n</tr>\n<tr>\n<td>__dict__</td>\n<td>类或实例的属性, 可写的字典</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看属性\"><a href=\"#查看属性\" class=\"headerlink\" title=\"查看属性\"></a>查看属性</h3><p>__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.</p>\n<p>如果dir()参数obj包括方法_<em>dir__(), 该方法将被调用.如果参数obj不包含\\</em>_dir__(), 该方法将最大限度地收集属性信息.</p>\n<p>dir(obj)对于不同类型的对象obj具有不同的行为:</p>\n<ul>\n<li>如果对象是模块对象, 返回的列表包含模块的属性名和变量名</li>\n<li>如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名</li>\n<li>如果是类的实例<ul>\n<li>有__dir__方法, 返回可迭代对象的返回值</li>\n<li>没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名</li>\n</ul>\n</li>\n<li>如果obj不写, 返回列表包含内容不同<ul>\n<li>在模块中, 返回模块的属性和变量名</li>\n<li>在函数中, 返回本地作用域的变量名</li>\n<li>在方法中,  返回本地作用域的变量名</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># animal.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>:</span></span><br><span class=\"line\">    x = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">\t\tself._name = name</span><br><span class=\"line\">        self.__age = <span class=\"number\">10</span></span><br><span class=\"line\">        self.weight = <span class=\"number\">20</span></span><br><span class=\"line\"> </span><br><span class=\"line\">print(<span class=\"string\">'animal Module\\ s names = &#123;&#125;'</span>.format(dir()))<span class=\"comment\"># 模块的属性 )</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法***\"></a>魔术方法***</h3><hr>\n<ul>\n<li><p>分类:</p>\n<ul>\n<li><p>创建, 初始化与销毁</p>\n</li>\n<li><p>可视化</p>\n</li>\n<li>hash</li>\n<li>bool</li>\n<li>运算符重载</li>\n<li>容器和大小</li>\n<li>可调用对象</li>\n<li>上下文管理</li>\n<li>反射</li>\n<li>描述器</li>\n<li>其他杂项</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h4><hr>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__new__</td>\n<td>实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p>__new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回</p>\n<h4 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h4><hr>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__str__</td>\n<td>str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息</td>\n</tr>\n<tr>\n<td>__repr__</td>\n<td>内建函数repr()对一个对象获取<strong>字符串</strong>表达</td>\n</tr>\n<tr>\n<td>__bytes__</td>\n<td>bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age = <span class=\"number\">18</span>)</span>:</span></span><br><span class=\"line\">\t\tself.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'repr:&#123;&#125;&#123;&#125;'</span>.format(self.name, self.age)</span><br></pre></td></tr></table></figure>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__hash__</td>\n<td>内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash</td>\n</tr>\n<tr>\n<td>__eq__</td>\n<td>对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__bool__</td>\n<td>内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"上下文管理\"><a href=\"#上下文管理\" class=\"headerlink\" title=\"上下文管理\"></a>上下文管理</h3><p>文件IO操作可以对文件对象使用上下文管理，使用with。。as语法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'test'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>仿照上例写一个自己的泪，实现上下文管理</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> Point <span class=\"keyword\">as</span> p:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>提示属性错误，没有__exit__，看了需要这个属性</p>\n<p>某些版本会显示没有__enter__</p>\n<p>上下文管理对象</p>\n<p>当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象</p>\n<p>__enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上</p>\n<p>__exit__退出与此对象相关的上下文</p>\n<p>with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作</p>\n<p>注意,with 并不开启一个新的作用域</p>\n<p>上下文管理是安全的</p>\n<p>上下文应用场景</p>\n<p>1.增强功能</p>\n<p>在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能</p>\n<p>2.资源管理</p>\n<p>打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等</p>\n<p>3.权限验证</p>\n<p>在执行代码之前,做权限验证,在__enter__</p>\n<h4 id=\"contextilb-contextmanager\"><a href=\"#contextilb-contextmanager\" class=\"headerlink\" title=\"contextilb.contextmanager\"></a>contextilb.contextmanager</h4><p>他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法</p>\n<p>对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.</p>\n<p>也就是这个装饰器接受一个生成器对象作为参数.</p>\n<p>总结</p>\n<p>如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便</p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>概述</p>\n<p>运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候</p>\n<p>反射,  reflection, 指的是运行时获取类型定义信息</p>\n<p>一个对象能够在运行时,像照镜子一样,反射出其类型信息</p>\n<p>简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身</p>\n<p>具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等</p>\n<h4 id=\"反射相关的函数和方法\"><a href=\"#反射相关的函数和方法\" class=\"headerlink\" title=\"反射相关的函数和方法\"></a>反射相关的函数和方法</h4><table>\n<thead>\n<tr>\n<th>getattar</th>\n<th>通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串.</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setattar</td>\n<td>object的属性存在,这覆盖, 不存在,新增</td>\n</tr>\n<tr>\n<td>hasattat</td>\n<td>判断对象是否有这个名字的属性,name必须为字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"反射相关的魔术方法\"><a href=\"#反射相关的魔术方法\" class=\"headerlink\" title=\"反射相关的魔术方法\"></a>反射相关的魔术方法</h4><p>__getattr__(), __setattr__(), __delattr__(), 三个魔术方法</p>\n<p>实例属性会按照继承关系找,  如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出</p>\n<p>AttributeError异常表示找不到属性.</p>\n<p>查找属性顺序为:</p>\n<p>instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"特殊属性\"><a href=\"#特殊属性\" class=\"headerlink\" title=\"特殊属性\"></a>特殊属性</h3><table>\n<thead>\n<tr>\n<th>属性</th>\n<th>含义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__name__</td>\n<td>类,函数,方法等名字</td>\n</tr>\n<tr>\n<td>__module__</td>\n<td>类定义所在的模块名</td>\n</tr>\n<tr>\n<td>__class__</td>\n<td>对象或类所属的类</td>\n</tr>\n<tr>\n<td>__base__</td>\n<td>类的基类的元组,顺序为他们在基类中出现的顺序</td>\n</tr>\n<tr>\n<td>__doc__</td>\n<td>类, 函数的文档字符串, 如果没有定义则为None</td>\n</tr>\n<tr>\n<td>__mro__</td>\n<td>类的mro, class.mro()返回的结果的保存在__mro__ 中</td>\n</tr>\n<tr>\n<td>__dict__</td>\n<td>类或实例的属性, 可写的字典</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"查看属性\"><a href=\"#查看属性\" class=\"headerlink\" title=\"查看属性\"></a>查看属性</h3><p>__dir__: 返回类或者对象的所有成员名称列表, dir()函数操作实例实例就是调用它.</p>\n<p>如果dir()参数obj包括方法_<em>dir__(), 该方法将被调用.如果参数obj不包含\\</em>_dir__(), 该方法将最大限度地收集属性信息.</p>\n<p>dir(obj)对于不同类型的对象obj具有不同的行为:</p>\n<ul>\n<li>如果对象是模块对象, 返回的列表包含模块的属性名和变量名</li>\n<li>如果对象是类型或者说是类对象, 返回的列表包含类的属性名, 及它的祖先类的属性名</li>\n<li>如果是类的实例<ul>\n<li>有__dir__方法, 返回可迭代对象的返回值</li>\n<li>没有__dir__方法, 则仅可能收集实例的属性名, 类的属性和祖先类的属性名</li>\n</ul>\n</li>\n<li>如果obj不写, 返回列表包含内容不同<ul>\n<li>在模块中, 返回模块的属性和变量名</li>\n<li>在函数中, 返回本地作用域的变量名</li>\n<li>在方法中,  返回本地作用域的变量名</li>\n</ul>\n</li>\n</ul>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\"># animal.py</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Animal</span>:</span></span><br><span class=\"line\">    x = <span class=\"number\">123</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name)</span>:</span></span><br><span class=\"line\">\t\tself._name = name</span><br><span class=\"line\">        self.__age = <span class=\"number\">10</span></span><br><span class=\"line\">        self.weight = <span class=\"number\">20</span></span><br><span class=\"line\"> </span><br><span class=\"line\">print(<span class=\"string\">'animal Module\\ s names = &#123;&#125;'</span>.format(dir()))<span class=\"comment\"># 模块的属性 )</span></span><br></pre></td></tr></table></figure>\n<h3 id=\"魔术方法\"><a href=\"#魔术方法\" class=\"headerlink\" title=\"魔术方法***\"></a>魔术方法***</h3><hr>\n<ul>\n<li><p>分类:</p>\n<ul>\n<li><p>创建, 初始化与销毁</p>\n</li>\n<li><p>可视化</p>\n</li>\n<li>hash</li>\n<li>bool</li>\n<li>运算符重载</li>\n<li>容器和大小</li>\n<li>可调用对象</li>\n<li>上下文管理</li>\n<li>反射</li>\n<li>描述器</li>\n<li>其他杂项</li>\n</ul>\n</li>\n</ul>\n<h4 id=\"实例化\"><a href=\"#实例化\" class=\"headerlink\" title=\"实例化\"></a>实例化</h4><hr>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__new__</td>\n<td>实例化一个对象 该方法需要返回一个值, 如果该值不是cls的实例, 则不会调用__init__该方法永远都是静态方法</td>\n</tr>\n</tbody>\n</table>\n<p>__new__方法很少使用,即使创建了该方法也会使用return super().__new__(cls)基类object的__new__方法来创建实例并返回</p>\n<h4 id=\"可视化\"><a href=\"#可视化\" class=\"headerlink\" title=\"可视化\"></a>可视化</h4><hr>\n<table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__str__</td>\n<td>str函数, format函数, print函数调用, 需要返回对象的字符串表达, 如果没有定义,就去调用__repr__方法返回字符串表达, 如果__repr__没有定义, 就直接返回对象的内存地址信息</td>\n</tr>\n<tr>\n<td>__repr__</td>\n<td>内建函数repr()对一个对象获取<strong>字符串</strong>表达</td>\n</tr>\n<tr>\n<td>__bytes__</td>\n<td>bytes()函数调用, 返回一个对象的bytes表达, 即返回bytes对象</td>\n</tr>\n</tbody>\n</table>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">A</span>:</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__init__</span><span class=\"params\">(self, name, age = <span class=\"number\">18</span>)</span>:</span></span><br><span class=\"line\">\t\tself.name = name</span><br><span class=\"line\">        self.age = age</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">__repr__</span><span class=\"params\">(self)</span>:</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"string\">'repr:&#123;&#125;&#123;&#125;'</span>.format(self.name, self.age)</span><br></pre></td></tr></table></figure>\n<h4 id=\"hash\"><a href=\"#hash\" class=\"headerlink\" title=\"hash\"></a>hash</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__hash__</td>\n<td>内建函数hash()调用的返回值,返回一个整数.如果定义这个方法该类的实例就可hash</td>\n</tr>\n<tr>\n<td>__eq__</td>\n<td>对应== 操作符, 判断2个对象是否相等, 返回bool值 定义了这个方法, 如果不提供__hash__方法, 那么实例将不可hash了</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"bool\"><a href=\"#bool\" class=\"headerlink\" title=\"bool\"></a>bool</h4><table>\n<thead>\n<tr>\n<th>方法</th>\n<th>意义</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>__bool__</td>\n<td>内建函数bool(), 或者对象放在逻辑表达式的位置, 调用这个函数返回布尔值没有定义__bool__(), 就找__len__返回长度,非0 为真</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"上下文管理\"><a href=\"#上下文管理\" class=\"headerlink\" title=\"上下文管理\"></a>上下文管理</h3><p>文件IO操作可以对文件对象使用上下文管理，使用with。。as语法</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">with</span> open(<span class=\"string\">'test'</span>) <span class=\"keyword\">as</span> f:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>仿照上例写一个自己的泪，实现上下文管理</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Point</span>:</span></span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br><span class=\"line\"><span class=\"keyword\">with</span> Point <span class=\"keyword\">as</span> p:</span><br><span class=\"line\">\t<span class=\"keyword\">pass</span></span><br></pre></td></tr></table></figure>\n<p>提示属性错误，没有__exit__，看了需要这个属性</p>\n<p>某些版本会显示没有__enter__</p>\n<p>上下文管理对象</p>\n<p>当一个对象同时实现了__enter__()和exit()方法,他就属于上下文管理的对象</p>\n<p>__enter__ 进入于此对象相关的上下文,如果存在该方法,with语法会把该方法的返回值作为绑定到as之句中指定的变量上</p>\n<p>__exit__退出与此对象相关的上下文</p>\n<p>with可以开启一个上下文运行环境,在执行前做一些准备工作,执行后做一些收尾工作</p>\n<p>注意,with 并不开启一个新的作用域</p>\n<p>上下文管理是安全的</p>\n<p>上下文应用场景</p>\n<p>1.增强功能</p>\n<p>在代码执行的前后增加代码, 以增强其功能.类似装饰器的功能</p>\n<p>2.资源管理</p>\n<p>打开了资源需要关闭, 例如文件对象, 网络连接,数据库连接等</p>\n<p>3.权限验证</p>\n<p>在执行代码之前,做权限验证,在__enter__</p>\n<h4 id=\"contextilb-contextmanager\"><a href=\"#contextilb-contextmanager\" class=\"headerlink\" title=\"contextilb.contextmanager\"></a>contextilb.contextmanager</h4><p>他是一个装饰器是实现上下文管理器, 装饰一个函数, 而不是像类一样实现__enter__he __exit__方法</p>\n<p>对下面的函数有要求:必须有yield, 也就是这个函数必须返回一个生成器,且只有yield一个值.</p>\n<p>也就是这个装饰器接受一个生成器对象作为参数.</p>\n<p>总结</p>\n<p>如果业务逻辑简单可以使用函数加contextlib.contexmanager装饰器方式,如果业务复杂,用类的方式加__enter__和__exit__方法方便</p>\n<h3 id=\"反射\"><a href=\"#反射\" class=\"headerlink\" title=\"反射\"></a>反射</h3><p>概述</p>\n<p>运行时, 区别于编译时, 指的是程序被加载到内存中执行的时候</p>\n<p>反射,  reflection, 指的是运行时获取类型定义信息</p>\n<p>一个对象能够在运行时,像照镜子一样,反射出其类型信息</p>\n<p>简单说,在python中,能够通过一个对象,找出其type, class, attribute或method的能力, 称为反射或者和自身</p>\n<p>具有反射能力的函数有type(), isinstance(), callable(), dir(), getattr()等</p>\n<h4 id=\"反射相关的函数和方法\"><a href=\"#反射相关的函数和方法\" class=\"headerlink\" title=\"反射相关的函数和方法\"></a>反射相关的函数和方法</h4><table>\n<thead>\n<tr>\n<th>getattar</th>\n<th>通过name返回object的属性值.当属性不存在,将使用default返回, 如果没有default,则抛出attrbuteerro,name必须为字符串.</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>setattar</td>\n<td>object的属性存在,这覆盖, 不存在,新增</td>\n</tr>\n<tr>\n<td>hasattat</td>\n<td>判断对象是否有这个名字的属性,name必须为字符串</td>\n</tr>\n</tbody>\n</table>\n<h4 id=\"反射相关的魔术方法\"><a href=\"#反射相关的魔术方法\" class=\"headerlink\" title=\"反射相关的魔术方法\"></a>反射相关的魔术方法</h4><p>__getattr__(), __setattr__(), __delattr__(), 三个魔术方法</p>\n<p>实例属性会按照继承关系找,  如果找不到, 就会执行__getattar__()方法, 如果没有这个方法, 就会抛出</p>\n<p>AttributeError异常表示找不到属性.</p>\n<p>查找属性顺序为:</p>\n<p>instance.__dict__ - &gt; instance.__class__.__dict__ -&gt; 继承的祖先类(直到object)的__dict__ – 找不到- &gt;调用__getattr__()</p>\n"},{"title":"99乘法表的不同解法","_content":"\n第一种方法：用先打印正方形之后打印下三角 \n\n```python\nfor i in range (1,10):\n    line = ''\n    for j in range (1,10):\n        if i >=j:\n            \n            line += str (j) +'*'+str(i) +'='+ str(i*j) + ' '\n    print(line)\n```\n\n第二种用format 格式化字符串\n\n```python\nfor i range(1,10):\n    line =''\n    for j in range(1,10):\n        line += \"{}*{}={} \".foramt(j,i,(j*i))\n    print(line)\n```\n\n\n第三种 j的取值范围是（1，i+1）\n\n```python\nfor i in range(1,10):\n    line =''\n    for j in range(1,i+1):\n         line += '{}*{}={} '.format(j,i,(i*j))\n    print(line,end='\\n')\n```\n\nrange 函数可以控制语句 可以当if\n变形\n\n```python\nfor i in range(1,10):\n    for j in range(1,i+1):\n        line = '{}*{}={} '.format(j,i,(i*j))\n        print(line, end='')\n    print()\nrow 是行 column 是列\nfor i in range(1,10):\n    for j in range(1,i+1):\n        line = '{}*{}={} '.format(j,i,(i*j))\n        print(line, end='')\n        if  i==j:\n            print()\n```\n\n\n再变形\n\n```python\nfor i in range(1,10):\n    for j in range(1,i+1):\n        if  i==j:\n            endchar = '\\n'\n        else:\n            endchar = ''\n       line = '{}*{}={} '.format(j,i,(i*j) ,end = endchar)\n    print(line, end='')\n```\n\n\n三元表达式 写法 \n\n```python\nendchar = '\\n' if  i ==j else ''\n三行 代码写出程序\n```\n\n```python\nfor i in range (1,10):\n    for j in range(1,i+1):\n        print(\"{}*{}={} \".format(j,i,i*j) ,end = '\\n' if i ==j else '')\n```\n\n\n用列表方式来写 ,最后再解构\n\n```python\nfor i in range(1,10):\n    line = []\n    for j in  range(1,i+1):\n        line.append(\"{}*{}={} \".format(j,i,i*j))\n    print(*line,sep=' ')\ntip：再括号内换行不用换行符\nfor i in range(1,10):\n    for j in range(1,i+1):\n        print(\"{}*{}={}{}\".format(j,i,j*i, '' if  j==2 and i<5 else ''),\n        end= '\\n' if  i==j else ' ')\n        \n        \n用格式符对齐方式 写\nfor i in range(1,10):\n    for  j in range(1,i+1):\n        print(\"{}*{}={:<2}\".format(j,i,i*j),\n        end='\\n' if  i == j else '\\t')\n```\n\n\n\n\n\n","source":"_posts/1 (6).md","raw":"---\ntitle: 99乘法表的不同解法\n\ncategories: \n- 算法习题\ntags:\n- 算法习题\n---\n\n第一种方法：用先打印正方形之后打印下三角 \n\n```python\nfor i in range (1,10):\n    line = ''\n    for j in range (1,10):\n        if i >=j:\n            \n            line += str (j) +'*'+str(i) +'='+ str(i*j) + ' '\n    print(line)\n```\n\n第二种用format 格式化字符串\n\n```python\nfor i range(1,10):\n    line =''\n    for j in range(1,10):\n        line += \"{}*{}={} \".foramt(j,i,(j*i))\n    print(line)\n```\n\n\n第三种 j的取值范围是（1，i+1）\n\n```python\nfor i in range(1,10):\n    line =''\n    for j in range(1,i+1):\n         line += '{}*{}={} '.format(j,i,(i*j))\n    print(line,end='\\n')\n```\n\nrange 函数可以控制语句 可以当if\n变形\n\n```python\nfor i in range(1,10):\n    for j in range(1,i+1):\n        line = '{}*{}={} '.format(j,i,(i*j))\n        print(line, end='')\n    print()\nrow 是行 column 是列\nfor i in range(1,10):\n    for j in range(1,i+1):\n        line = '{}*{}={} '.format(j,i,(i*j))\n        print(line, end='')\n        if  i==j:\n            print()\n```\n\n\n再变形\n\n```python\nfor i in range(1,10):\n    for j in range(1,i+1):\n        if  i==j:\n            endchar = '\\n'\n        else:\n            endchar = ''\n       line = '{}*{}={} '.format(j,i,(i*j) ,end = endchar)\n    print(line, end='')\n```\n\n\n三元表达式 写法 \n\n```python\nendchar = '\\n' if  i ==j else ''\n三行 代码写出程序\n```\n\n```python\nfor i in range (1,10):\n    for j in range(1,i+1):\n        print(\"{}*{}={} \".format(j,i,i*j) ,end = '\\n' if i ==j else '')\n```\n\n\n用列表方式来写 ,最后再解构\n\n```python\nfor i in range(1,10):\n    line = []\n    for j in  range(1,i+1):\n        line.append(\"{}*{}={} \".format(j,i,i*j))\n    print(*line,sep=' ')\ntip：再括号内换行不用换行符\nfor i in range(1,10):\n    for j in range(1,i+1):\n        print(\"{}*{}={}{}\".format(j,i,j*i, '' if  j==2 and i<5 else ''),\n        end= '\\n' if  i==j else ' ')\n        \n        \n用格式符对齐方式 写\nfor i in range(1,10):\n    for  j in range(1,i+1):\n        print(\"{}*{}={:<2}\".format(j,i,i*j),\n        end='\\n' if  i == j else '\\t')\n```\n\n\n\n\n\n","slug":"1 (6)","published":1,"date":"2019-04-01T07:15:09.586Z","updated":"2019-06-19T14:47:17.090Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h827001fjkuffqcsl67u","content":"<p>第一种方法：用先打印正方形之后打印下三角 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;=j:</span><br><span class=\"line\">            </span><br><span class=\"line\">            line += str (j) +<span class=\"string\">'*'</span>+str(i) +<span class=\"string\">'='</span>+ str(i*j) + <span class=\"string\">' '</span></span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<p>第二种用format 格式化字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">        line += <span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.foramt(j,i,(j*i))</span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<p>第三种 j的取值范围是（1，i+1）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">         line += <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">    print(line,end=<span class=\"string\">'\\n'</span>)</span><br></pre></td></tr></table></figure>\n<p>range 函数可以控制语句 可以当if<br>变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">        print(line, end=<span class=\"string\">''</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\">row 是行 column 是列</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">        print(line, end=<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i==j:</span><br><span class=\"line\">            print()</span><br></pre></td></tr></table></figure>\n<p>再变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i==j:</span><br><span class=\"line\">            endchar = <span class=\"string\">'\\n'</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            endchar = <span class=\"string\">''</span></span><br><span class=\"line\">       line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j) ,end = endchar)</span><br><span class=\"line\">    print(line, end=<span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>三元表达式 写法 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endchar = <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i ==j <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br><span class=\"line\">三行 代码写出程序</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.format(j,i,i*j) ,end = <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span> i ==j <span class=\"keyword\">else</span> <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>用列表方式来写 ,最后再解构</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span>  range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line.append(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.format(j,i,i*j))</span><br><span class=\"line\">    print(*line,sep=<span class=\"string\">' '</span>)</span><br><span class=\"line\">tip：再括号内换行不用换行符</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125;&#123;&#125;\"</span>.format(j,i,j*i, <span class=\"string\">''</span> <span class=\"keyword\">if</span>  j==<span class=\"number\">2</span> <span class=\"keyword\">and</span> i&lt;<span class=\"number\">5</span> <span class=\"keyword\">else</span> <span class=\"string\">''</span>),</span><br><span class=\"line\">        end= <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i==j <span class=\"keyword\">else</span> <span class=\"string\">' '</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">用格式符对齐方式 写</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;:&lt;2&#125;\"</span>.format(j,i,i*j),</span><br><span class=\"line\">        end=<span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i == j <span class=\"keyword\">else</span> <span class=\"string\">'\\t'</span>)</span><br></pre></td></tr></table></figure>\n","site":{"data":{}},"excerpt":"","more":"<p>第一种方法：用先打印正方形之后打印下三角 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line = <span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> i &gt;=j:</span><br><span class=\"line\">            </span><br><span class=\"line\">            line += str (j) +<span class=\"string\">'*'</span>+str(i) +<span class=\"string\">'='</span>+ str(i*j) + <span class=\"string\">' '</span></span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<p>第二种用format 格式化字符串</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">        line += <span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.foramt(j,i,(j*i))</span><br><span class=\"line\">    print(line)</span><br></pre></td></tr></table></figure>\n<p>第三种 j的取值范围是（1，i+1）</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line =<span class=\"string\">''</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">         line += <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">    print(line,end=<span class=\"string\">'\\n'</span>)</span><br></pre></td></tr></table></figure>\n<p>range 函数可以控制语句 可以当if<br>变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">        print(line, end=<span class=\"string\">''</span>)</span><br><span class=\"line\">    print()</span><br><span class=\"line\">row 是行 column 是列</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j))</span><br><span class=\"line\">        print(line, end=<span class=\"string\">''</span>)</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i==j:</span><br><span class=\"line\">            print()</span><br></pre></td></tr></table></figure>\n<p>再变形</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">if</span>  i==j:</span><br><span class=\"line\">            endchar = <span class=\"string\">'\\n'</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span>:</span><br><span class=\"line\">            endchar = <span class=\"string\">''</span></span><br><span class=\"line\">       line = <span class=\"string\">'&#123;&#125;*&#123;&#125;=&#123;&#125; '</span>.format(j,i,(i*j) ,end = endchar)</span><br><span class=\"line\">    print(line, end=<span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>三元表达式 写法 </p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">endchar = <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i ==j <span class=\"keyword\">else</span> <span class=\"string\">''</span></span><br><span class=\"line\">三行 代码写出程序</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range (<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.format(j,i,i*j) ,end = <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span> i ==j <span class=\"keyword\">else</span> <span class=\"string\">''</span>)</span><br></pre></td></tr></table></figure>\n<p>用列表方式来写 ,最后再解构</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    line = []</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span>  range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        line.append(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125; \"</span>.format(j,i,i*j))</span><br><span class=\"line\">    print(*line,sep=<span class=\"string\">' '</span>)</span><br><span class=\"line\">tip：再括号内换行不用换行符</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;&#125;&#123;&#125;\"</span>.format(j,i,j*i, <span class=\"string\">''</span> <span class=\"keyword\">if</span>  j==<span class=\"number\">2</span> <span class=\"keyword\">and</span> i&lt;<span class=\"number\">5</span> <span class=\"keyword\">else</span> <span class=\"string\">''</span>),</span><br><span class=\"line\">        end= <span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i==j <span class=\"keyword\">else</span> <span class=\"string\">' '</span>)</span><br><span class=\"line\">        </span><br><span class=\"line\">        </span><br><span class=\"line\">用格式符对齐方式 写</span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,<span class=\"number\">10</span>):</span><br><span class=\"line\">    <span class=\"keyword\">for</span>  j <span class=\"keyword\">in</span> range(<span class=\"number\">1</span>,i+<span class=\"number\">1</span>):</span><br><span class=\"line\">        print(<span class=\"string\">\"&#123;&#125;*&#123;&#125;=&#123;:&lt;2&#125;\"</span>.format(j,i,i*j),</span><br><span class=\"line\">        end=<span class=\"string\">'\\n'</span> <span class=\"keyword\">if</span>  i == j <span class=\"keyword\">else</span> <span class=\"string\">'\\t'</span>)</span><br></pre></td></tr></table></figure>\n"},{"title":"10大排序算法","_content":"基本入门算法有三个经典算法:冒泡,选择和插入算法\n\n\n### 选择排序\n\n简单选择排序属于选择排序\n两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端\n结果分为升序和降序排列\n\n基本思路:\n* 求出最大索引(或最小索引)并记录\n* 两两交换\n* 补充特殊情况,完善代码\n\n先用几个数做测试\n\n```python\nnums = [1, 9, 8]\nlength = len(nums)\n\nmaxindex = 0\nfor i in range(maxindex+1, length):\n    if nums[i] > nums[maxindex]:\n        maxindex = i\nprint(maxindex, nums[maxindex])\n# 结果 1,9\n# 做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]\n# 做外层循环for i in range(length)\n# 基本代码实现\nnums = [1, 9, 8]\nlength = len(nums)\n```\n\n```python\nmaxindex = 0\n\nfor j in range(length):\n    maxindex = j\n    for i in range(maxindex+1, length):\n        if nums[i] > nums[maxindex]:\n            maxindex = i # 比较先确定索引 记录maxindex为最大索引\n    if maxindex != i:\n            nums[i], nums[maxindex] = nums[maxindex], nums[i]\nprint(nums)\n```\n\n做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序\n\n第二种方法:\n\n```python\nimport random\nnums = list(range(10))\nrandom.shuffle(nums)\n\nlength = len(nums)\n```\n\n```python\nmaxindex = 0\n\nfor i in range(length // 2):\n    maxindex = i\n    minindex = -1-i\n    minorigin = length + minindex\n    for j in range(i + 1, length - i):\n        if nums[j] > nums[maxindex]:\n            maxindex = j # 比较先确定索引 记录maxindex为最大索引\n        if nums[-j-1] < nums[minindex]:\n            minindex = -j-1\n    if nums[maxindex] == nums[minindex]: break\n    minindex = length + minindex\n    if maxindex != i: # 进去 ,说明一定有交换\n        nums[i], nums[maxindex] = nums[maxindex], nums[i]\n        if minindex == i:\n            minindex = maxindex\n    if minindex != minorigin and nums[minorigin] != nums[minindex]:\n        nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]\nprint(nums)\n```\n\n### 冒泡法\n\n实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.\n下面是使用代码的实现:\n\n```python\narr = [7, 4, 3, 67, 34, 1, 8]\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for j in range(0, n - 1):\n        for i in range(0, n - 1 - j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\nbubble_sort(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n\n```\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n关键点其实在双重for循环变量的配置，我们来分析一下\n第一次循环： j = 0, i~n-2 range(0, n-1)\n第二次循环： j = 1, i~n-3 range(0, n-1-1)\n第三次循环： j = 2, i~n-4 range(0, n-1-1-1)\n—> range(0, n-1-j)\n\n理解这一点后，我们就可以换一种写法来实现了\n\n```python\ndef bubble_sort2(arr):\n    for j in range(len(arr) - 1, 0, -1):  # [n-1, n-2, ....2, 1]\n        for i in range(0, j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\nbubble_sort2(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n```\n\n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 优化\n> 写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化\n\n\n\n```python\ndef bubble_sort3(arr):\n    for j in range(len(arr)-1, 0, -1):\n        count = 0\n        for i in range(0, j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                count += 1\n        if count == 0:\n            return\n\nbubble_sort3(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)\n\n\n扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。\n\n\ndef add(x):\n    return x + 5\n\n### 插入排序\n\n在未排序序列中, 构建一个字排序序列,直至全部数据排序完成\n将待排序的数, 插入到已经排序的序列中合适的位置.\n增加一个哨兵, 放在待比较值, 让他和后面已经排好序的序列比较,找到合适的插入点.\n\n在列表前面增加哨兵位,可以是None空间复杂度为1, 时间复杂度On\n\n```python\nm_list = [1, 9, 8, 6, 5, 4, 3, 2, 2, 1]\nnums = [0] + list[0]\nlength = len(nums)\ncount_move = 0\nfor i in range(2, length):\n    nums[0] = nums[i]\n    j = i - 1 \n    if nums[j] > nums[0]:\n        while nums[j] > nums[0]:\n            nums[j+1] = nums[j]\n            j -=1\n            count_move += 1\n        nums[j+1] = nums[0]\nprint(nums[1:])\n```\n\n\n总结: 交换依次从前至后,两两依次比较,从中选出最大将这个值交换到右边,之后第二个和第三个比较,在这一趟比较出最大的放在无序区里.无序区减少,有序区增加时间复杂度为大On**2,可以提前终.\n\n选择排序: 就地排序,在这一趟选择极值,假定第一个最大,记录索引.比较完成后与真实最大的交换,有序区增加,无序区减少,优化算法一次性找出最大和最小,依次固定2个位置,复杂度高一点,不管你是升序还是降序,特殊情况,数值都是一样的.\n\n插入排序: 在未排序序列中,构建一个子排序序列,直至全部数据排序完成.\n将带排序的数,插入到已经排序的序列中合适的位置.\n增加一个哨兵,放入待比较值,让他和后面已经排好序的序列比较,找到合适的插入点.\n\n","source":"_posts/1 (5).md","raw":"---\ntitle: 10大排序算法\ncategories: \n- 算法\ntags:\n- 算法\n---\n基本入门算法有三个经典算法:冒泡,选择和插入算法\n\n\n### 选择排序\n\n简单选择排序属于选择排序\n两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端\n结果分为升序和降序排列\n\n基本思路:\n* 求出最大索引(或最小索引)并记录\n* 两两交换\n* 补充特殊情况,完善代码\n\n先用几个数做测试\n\n```python\nnums = [1, 9, 8]\nlength = len(nums)\n\nmaxindex = 0\nfor i in range(maxindex+1, length):\n    if nums[i] > nums[maxindex]:\n        maxindex = i\nprint(maxindex, nums[maxindex])\n# 结果 1,9\n# 做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]\n# 做外层循环for i in range(length)\n# 基本代码实现\nnums = [1, 9, 8]\nlength = len(nums)\n```\n\n```python\nmaxindex = 0\n\nfor j in range(length):\n    maxindex = j\n    for i in range(maxindex+1, length):\n        if nums[i] > nums[maxindex]:\n            maxindex = i # 比较先确定索引 记录maxindex为最大索引\n    if maxindex != i:\n            nums[i], nums[maxindex] = nums[maxindex], nums[i]\nprint(nums)\n```\n\n做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序\n\n第二种方法:\n\n```python\nimport random\nnums = list(range(10))\nrandom.shuffle(nums)\n\nlength = len(nums)\n```\n\n```python\nmaxindex = 0\n\nfor i in range(length // 2):\n    maxindex = i\n    minindex = -1-i\n    minorigin = length + minindex\n    for j in range(i + 1, length - i):\n        if nums[j] > nums[maxindex]:\n            maxindex = j # 比较先确定索引 记录maxindex为最大索引\n        if nums[-j-1] < nums[minindex]:\n            minindex = -j-1\n    if nums[maxindex] == nums[minindex]: break\n    minindex = length + minindex\n    if maxindex != i: # 进去 ,说明一定有交换\n        nums[i], nums[maxindex] = nums[maxindex], nums[i]\n        if minindex == i:\n            minindex = maxindex\n    if minindex != minorigin and nums[minorigin] != nums[minindex]:\n        nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]\nprint(nums)\n```\n\n### 冒泡法\n\n实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.\n下面是使用代码的实现:\n\n```python\narr = [7, 4, 3, 67, 34, 1, 8]\n\ndef bubble_sort(arr):\n    n = len(arr)\n    for j in range(0, n - 1):\n        for i in range(0, n - 1 - j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\nbubble_sort(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n\n```\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n关键点其实在双重for循环变量的配置，我们来分析一下\n第一次循环： j = 0, i~n-2 range(0, n-1)\n第二次循环： j = 1, i~n-3 range(0, n-1-1)\n第三次循环： j = 2, i~n-4 range(0, n-1-1-1)\n—> range(0, n-1-j)\n\n理解这一点后，我们就可以换一种写法来实现了\n\n```python\ndef bubble_sort2(arr):\n    for j in range(len(arr) - 1, 0, -1):  # [n-1, n-2, ....2, 1]\n        for i in range(0, j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n\nbubble_sort2(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n```\n\n> 1\n> 2\n> 3\n> 4\n> 5\n> 6\n> 7\n> 8\n> 9\n> 优化\n> 写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化\n\n\n\n```python\ndef bubble_sort3(arr):\n    for j in range(len(arr)-1, 0, -1):\n        count = 0\n        for i in range(0, j):\n            if arr[i] > arr[i + 1]:\n                arr[i], arr[i + 1] = arr[i + 1], arr[i]\n                count += 1\n        if count == 0:\n            return\n\nbubble_sort3(arr)\nprint(arr)  # [1, 3, 4, 7, 8, 34, 67]\n```\n\n\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n12\n13\n我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)\n\n\n扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。\n\n\ndef add(x):\n    return x + 5\n\n### 插入排序\n\n在未排序序列中, 构建一个字排序序列,直至全部数据排序完成\n将待排序的数, 插入到已经排序的序列中合适的位置.\n增加一个哨兵, 放在待比较值, 让他和后面已经排好序的序列比较,找到合适的插入点.\n\n在列表前面增加哨兵位,可以是None空间复杂度为1, 时间复杂度On\n\n```python\nm_list = [1, 9, 8, 6, 5, 4, 3, 2, 2, 1]\nnums = [0] + list[0]\nlength = len(nums)\ncount_move = 0\nfor i in range(2, length):\n    nums[0] = nums[i]\n    j = i - 1 \n    if nums[j] > nums[0]:\n        while nums[j] > nums[0]:\n            nums[j+1] = nums[j]\n            j -=1\n            count_move += 1\n        nums[j+1] = nums[0]\nprint(nums[1:])\n```\n\n\n总结: 交换依次从前至后,两两依次比较,从中选出最大将这个值交换到右边,之后第二个和第三个比较,在这一趟比较出最大的放在无序区里.无序区减少,有序区增加时间复杂度为大On**2,可以提前终.\n\n选择排序: 就地排序,在这一趟选择极值,假定第一个最大,记录索引.比较完成后与真实最大的交换,有序区增加,无序区减少,优化算法一次性找出最大和最小,依次固定2个位置,复杂度高一点,不管你是升序还是降序,特殊情况,数值都是一样的.\n\n插入排序: 在未排序序列中,构建一个子排序序列,直至全部数据排序完成.\n将带排序的数,插入到已经排序的序列中合适的位置.\n增加一个哨兵,放入待比较值,让他和后面已经排好序的序列比较,找到合适的插入点.\n\n","slug":"1 (5)","published":1,"date":"2019-04-01T02:01:12.167Z","updated":"2019-06-19T14:46:36.504Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h829001ijkufyrze76hl","content":"<p>基本入门算法有三个经典算法:冒泡,选择和插入算法</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>简单选择排序属于选择排序<br>两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端<br>结果分为升序和降序排列</p>\n<p>基本思路:</p>\n<ul>\n<li>求出最大索引(或最小索引)并记录</li>\n<li>两两交换</li>\n<li>补充特殊情况,完善代码</li>\n</ul>\n<p>先用几个数做测试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">length = len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(maxindex+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] &gt; nums[maxindex]:</span><br><span class=\"line\">        maxindex = i</span><br><span class=\"line\">print(maxindex, nums[maxindex])</span><br><span class=\"line\"><span class=\"comment\"># 结果 1,9</span></span><br><span class=\"line\"><span class=\"comment\"># 做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]</span></span><br><span class=\"line\"><span class=\"comment\"># 做外层循环for i in range(length)</span></span><br><span class=\"line\"><span class=\"comment\"># 基本代码实现</span></span><br><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">length = len(nums)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">    maxindex = j</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(maxindex+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; nums[maxindex]:</span><br><span class=\"line\">            maxindex = i <span class=\"comment\"># 比较先确定索引 记录maxindex为最大索引</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxindex != i:</span><br><span class=\"line\">            nums[i], nums[maxindex] = nums[maxindex], nums[i]</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure>\n<p>做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序</p>\n<p>第二种方法:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\">nums = list(range(<span class=\"number\">10</span>))</span><br><span class=\"line\">random.shuffle(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">length = len(nums)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length // <span class=\"number\">2</span>):</span><br><span class=\"line\">    maxindex = i</span><br><span class=\"line\">    minindex = <span class=\"number\">-1</span>-i</span><br><span class=\"line\">    minorigin = length + minindex</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, length - i):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[j] &gt; nums[maxindex]:</span><br><span class=\"line\">            maxindex = j <span class=\"comment\"># 比较先确定索引 记录maxindex为最大索引</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[-j<span class=\"number\">-1</span>] &lt; nums[minindex]:</span><br><span class=\"line\">            minindex = -j<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[maxindex] == nums[minindex]: <span class=\"keyword\">break</span></span><br><span class=\"line\">    minindex = length + minindex</span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxindex != i: <span class=\"comment\"># 进去 ,说明一定有交换</span></span><br><span class=\"line\">        nums[i], nums[maxindex] = nums[maxindex], nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> minindex == i:</span><br><span class=\"line\">            minindex = maxindex</span><br><span class=\"line\">    <span class=\"keyword\">if</span> minindex != minorigin <span class=\"keyword\">and</span> nums[minorigin] != nums[minindex]:</span><br><span class=\"line\">        nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure>\n<h3 id=\"冒泡法\"><a href=\"#冒泡法\" class=\"headerlink\" title=\"冒泡法\"></a>冒泡法</h3><p>实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.<br>下面是使用代码的实现:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">67</span>, <span class=\"number\">34</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n - <span class=\"number\">1</span> - j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>关键点其实在双重for循环变量的配置，我们来分析一下<br>第一次循环： j = 0, i~n-2 range(0, n-1)<br>第二次循环： j = 1, i~n-3 range(0, n-1-1)<br>第三次循环： j = 2, i~n-4 range(0, n-1-1-1)<br>—&gt; range(0, n-1-j)</p>\n<p>理解这一点后，我们就可以换一种写法来实现了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort2</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(arr) - <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):  <span class=\"comment\"># [n-1, n-2, ....2, 1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort2(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>优化<br>写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort3</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(arr)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort3(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)</p>\n<p>扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。</p>\n<p>def add(x):<br>    return x + 5</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>在未排序序列中, 构建一个字排序序列,直至全部数据排序完成<br>将待排序的数, 插入到已经排序的序列中合适的位置.<br>增加一个哨兵, 放在待比较值, 让他和后面已经排好序的序列比较,找到合适的插入点.</p>\n<p>在列表前面增加哨兵位,可以是None空间复杂度为1, 时间复杂度On</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m_list = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">nums = [<span class=\"number\">0</span>] + list[<span class=\"number\">0</span>]</span><br><span class=\"line\">length = len(nums)</span><br><span class=\"line\">count_move = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, length):</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = nums[i]</span><br><span class=\"line\">    j = i - <span class=\"number\">1</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[j] &gt; nums[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> nums[j] &gt; nums[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            nums[j+<span class=\"number\">1</span>] = nums[j]</span><br><span class=\"line\">            j -=<span class=\"number\">1</span></span><br><span class=\"line\">            count_move += <span class=\"number\">1</span></span><br><span class=\"line\">        nums[j+<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">print(nums[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<p>总结: 交换依次从前至后,两两依次比较,从中选出最大将这个值交换到右边,之后第二个和第三个比较,在这一趟比较出最大的放在无序区里.无序区减少,有序区增加时间复杂度为大On**2,可以提前终.</p>\n<p>选择排序: 就地排序,在这一趟选择极值,假定第一个最大,记录索引.比较完成后与真实最大的交换,有序区增加,无序区减少,优化算法一次性找出最大和最小,依次固定2个位置,复杂度高一点,不管你是升序还是降序,特殊情况,数值都是一样的.</p>\n<p>插入排序: 在未排序序列中,构建一个子排序序列,直至全部数据排序完成.<br>将带排序的数,插入到已经排序的序列中合适的位置.<br>增加一个哨兵,放入待比较值,让他和后面已经排好序的序列比较,找到合适的插入点.</p>\n","site":{"data":{}},"excerpt":"","more":"<p>基本入门算法有三个经典算法:冒泡,选择和插入算法</p>\n<h3 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h3><p>简单选择排序属于选择排序<br>两两比较大小,找出极值或极小值被放置在固定的位置,这个固定一般指的是某一端<br>结果分为升序和降序排列</p>\n<p>基本思路:</p>\n<ul>\n<li>求出最大索引(或最小索引)并记录</li>\n<li>两两交换</li>\n<li>补充特殊情况,完善代码</li>\n</ul>\n<p>先用几个数做测试</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">length = len(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(maxindex+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[i] &gt; nums[maxindex]:</span><br><span class=\"line\">        maxindex = i</span><br><span class=\"line\">print(maxindex, nums[maxindex])</span><br><span class=\"line\"><span class=\"comment\"># 结果 1,9</span></span><br><span class=\"line\"><span class=\"comment\"># 做交换 nums[0], nums[maxindex] = nums[maxindex], nums[0]</span></span><br><span class=\"line\"><span class=\"comment\"># 做外层循环for i in range(length)</span></span><br><span class=\"line\"><span class=\"comment\"># 基本代码实现</span></span><br><span class=\"line\">nums = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\">length = len(nums)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(length):</span><br><span class=\"line\">    maxindex = j</span><br><span class=\"line\">    <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(maxindex+<span class=\"number\">1</span>, length):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[i] &gt; nums[maxindex]:</span><br><span class=\"line\">            maxindex = i <span class=\"comment\"># 比较先确定索引 记录maxindex为最大索引</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxindex != i:</span><br><span class=\"line\">            nums[i], nums[maxindex] = nums[maxindex], nums[i]</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure>\n<p>做优化 思路:能记录最大就能记录最小 ,一次性最大最小排序</p>\n<p>第二种方法:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">import</span> random</span><br><span class=\"line\">nums = list(range(<span class=\"number\">10</span>))</span><br><span class=\"line\">random.shuffle(nums)</span><br><span class=\"line\"></span><br><span class=\"line\">length = len(nums)</span><br></pre></td></tr></table></figure>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">maxindex = <span class=\"number\">0</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(length // <span class=\"number\">2</span>):</span><br><span class=\"line\">    maxindex = i</span><br><span class=\"line\">    minindex = <span class=\"number\">-1</span>-i</span><br><span class=\"line\">    minorigin = length + minindex</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(i + <span class=\"number\">1</span>, length - i):</span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[j] &gt; nums[maxindex]:</span><br><span class=\"line\">            maxindex = j <span class=\"comment\"># 比较先确定索引 记录maxindex为最大索引</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> nums[-j<span class=\"number\">-1</span>] &lt; nums[minindex]:</span><br><span class=\"line\">            minindex = -j<span class=\"number\">-1</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[maxindex] == nums[minindex]: <span class=\"keyword\">break</span></span><br><span class=\"line\">    minindex = length + minindex</span><br><span class=\"line\">    <span class=\"keyword\">if</span> maxindex != i: <span class=\"comment\"># 进去 ,说明一定有交换</span></span><br><span class=\"line\">        nums[i], nums[maxindex] = nums[maxindex], nums[i]</span><br><span class=\"line\">        <span class=\"keyword\">if</span> minindex == i:</span><br><span class=\"line\">            minindex = maxindex</span><br><span class=\"line\">    <span class=\"keyword\">if</span> minindex != minorigin <span class=\"keyword\">and</span> nums[minorigin] != nums[minindex]:</span><br><span class=\"line\">        nums[minorigin], nums[minindex] = nums[minindex], nums[minorigin]</span><br><span class=\"line\">print(nums)</span><br></pre></td></tr></table></figure>\n<h3 id=\"冒泡法\"><a href=\"#冒泡法\" class=\"headerlink\" title=\"冒泡法\"></a>冒泡法</h3><p>实现思路： 使用双重for循环，内层变量为i， 外层为j，在内层循环中不断的比较相邻的两个值（i, i+1）的大小，如果i+1的值大于i的值，交换两者位置，每循环一次，外层的j增加1，等到j等于n-1的时候，结束循环.<br>下面是使用代码的实现:</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">arr = [<span class=\"number\">7</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">67</span>, <span class=\"number\">34</span>, <span class=\"number\">1</span>, <span class=\"number\">8</span>]</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    n = len(arr)</span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n - <span class=\"number\">1</span>):</span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, n - <span class=\"number\">1</span> - j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>关键点其实在双重for循环变量的配置，我们来分析一下<br>第一次循环： j = 0, i~n-2 range(0, n-1)<br>第二次循环： j = 1, i~n-3 range(0, n-1-1)<br>第三次循环： j = 2, i~n-4 range(0, n-1-1-1)<br>—&gt; range(0, n-1-j)</p>\n<p>理解这一点后，我们就可以换一种写法来实现了</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort2</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(arr) - <span class=\"number\">1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):  <span class=\"comment\"># [n-1, n-2, ....2, 1]</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort2(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<blockquote>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>优化<br>写到这里我们发现，无论是第一种写法还是第二种写法，他的时间复杂度都是O(n ^ 2), 第二种写法也仅仅停留在优化样式的层面，并没有带来性能的提升，想象一下，如果我们输入的本来就是一个有序序列，其实只需要一次循环就够了，所以我们需要针对特殊情况进行优化</p>\n</blockquote>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">def</span> <span class=\"title\">bubble_sort3</span><span class=\"params\">(arr)</span>:</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> j <span class=\"keyword\">in</span> range(len(arr)<span class=\"number\">-1</span>, <span class=\"number\">0</span>, <span class=\"number\">-1</span>):</span><br><span class=\"line\">        count = <span class=\"number\">0</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">0</span>, j):</span><br><span class=\"line\">            <span class=\"keyword\">if</span> arr[i] &gt; arr[i + <span class=\"number\">1</span>]:</span><br><span class=\"line\">                arr[i], arr[i + <span class=\"number\">1</span>] = arr[i + <span class=\"number\">1</span>], arr[i]</span><br><span class=\"line\">                count += <span class=\"number\">1</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> count == <span class=\"number\">0</span>:</span><br><span class=\"line\">            <span class=\"keyword\">return</span></span><br><span class=\"line\"></span><br><span class=\"line\">bubble_sort3(arr)</span><br><span class=\"line\">print(arr)  <span class=\"comment\"># [1, 3, 4, 7, 8, 34, 67]</span></span><br></pre></td></tr></table></figure>\n<p>1<br>2<br>3<br>4<br>5<br>6<br>7<br>8<br>9<br>10<br>11<br>12<br>13<br>我们在循环中定义了一个变量count，如果第一次循环后count没有变化，就说明输入的是有序序列，这时我们直接return退出循环，这时候的时间复杂度为O(n)</p>\n<p>扩展知识：冒泡排序还是一种稳定性的算法，如果序列中出现两个相同的值的时候，无论选取最大值，还是最小值进行排序，最后两个相同值的前后位置都是不变的。</p>\n<p>def add(x):<br>    return x + 5</p>\n<h3 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h3><p>在未排序序列中, 构建一个字排序序列,直至全部数据排序完成<br>将待排序的数, 插入到已经排序的序列中合适的位置.<br>增加一个哨兵, 放在待比较值, 让他和后面已经排好序的序列比较,找到合适的插入点.</p>\n<p>在列表前面增加哨兵位,可以是None空间复杂度为1, 时间复杂度On</p>\n<figure class=\"highlight python\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">m_list = [<span class=\"number\">1</span>, <span class=\"number\">9</span>, <span class=\"number\">8</span>, <span class=\"number\">6</span>, <span class=\"number\">5</span>, <span class=\"number\">4</span>, <span class=\"number\">3</span>, <span class=\"number\">2</span>, <span class=\"number\">2</span>, <span class=\"number\">1</span>]</span><br><span class=\"line\">nums = [<span class=\"number\">0</span>] + list[<span class=\"number\">0</span>]</span><br><span class=\"line\">length = len(nums)</span><br><span class=\"line\">count_move = <span class=\"number\">0</span></span><br><span class=\"line\"><span class=\"keyword\">for</span> i <span class=\"keyword\">in</span> range(<span class=\"number\">2</span>, length):</span><br><span class=\"line\">    nums[<span class=\"number\">0</span>] = nums[i]</span><br><span class=\"line\">    j = i - <span class=\"number\">1</span> </span><br><span class=\"line\">    <span class=\"keyword\">if</span> nums[j] &gt; nums[<span class=\"number\">0</span>]:</span><br><span class=\"line\">        <span class=\"keyword\">while</span> nums[j] &gt; nums[<span class=\"number\">0</span>]:</span><br><span class=\"line\">            nums[j+<span class=\"number\">1</span>] = nums[j]</span><br><span class=\"line\">            j -=<span class=\"number\">1</span></span><br><span class=\"line\">            count_move += <span class=\"number\">1</span></span><br><span class=\"line\">        nums[j+<span class=\"number\">1</span>] = nums[<span class=\"number\">0</span>]</span><br><span class=\"line\">print(nums[<span class=\"number\">1</span>:])</span><br></pre></td></tr></table></figure>\n<p>总结: 交换依次从前至后,两两依次比较,从中选出最大将这个值交换到右边,之后第二个和第三个比较,在这一趟比较出最大的放在无序区里.无序区减少,有序区增加时间复杂度为大On**2,可以提前终.</p>\n<p>选择排序: 就地排序,在这一趟选择极值,假定第一个最大,记录索引.比较完成后与真实最大的交换,有序区增加,无序区减少,优化算法一次性找出最大和最小,依次固定2个位置,复杂度高一点,不管你是升序还是降序,特殊情况,数值都是一样的.</p>\n<p>插入排序: 在未排序序列中,构建一个子排序序列,直至全部数据排序完成.<br>将带排序的数,插入到已经排序的序列中合适的位置.<br>增加一个哨兵,放入待比较值,让他和后面已经排好序的序列比较,找到合适的插入点.</p>\n"},{"title":"python入门笔记","_content":"## 计算机基础\n\n**程序是一组让计算机识别和执行的指令**\n电子计算机:能够执行程序的机器\n计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)\n为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.\n即8位 2**8=256种状态  \n\n内存 掉电易失 与晶振频率有关 临时数据 mermory\ncpu与内存速度差几个数量级 \ncpu 只认内存 io设备最慢\nCPU 缓存 cache  bus 总线\n先写源程序 通过编译程序把源程序转换成机器指令的程序\npython是跑在虚拟机上的 动态语言 做节点 集群优化\n编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样\n\n**机器语言: 是一定位数组成的0 1序列 称为机器指令  机器指令的集合就是机器语言**\n**汇编: 是用助记符替代机器指令** \n**静态语言: 是声明变量类型,不能再改变,编译需要检查**\n**动态语言: 不用声明类型 随时可以赋值为其他类型**\n**强类型: 不同类型之间操作 必须强制类型转换为同一类型**\n**弱类型: 不同类型之间操作 自动隐式转换**\n\n## python基础介绍\n\npython 的源代码需要被解释器编译成中间代码,在虚拟机上运行\n***`程序 = 算法 +数据结构**`*\n数据一切程序的核心\n数据结构是数据在计算机中的类型和组织方式\n算法是处理数据的方式,算法有优劣之分.\npython自带了一个IDLE的程序,全称是交互式开发环境.\n注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可\n只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释--不要每行都写注释,有特殊情况才需要.\n\n>import math\n>#对角线的长度\n>i = 4\n>w = 10\n>d = math.sqrt(1**2 + w**2)\n即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的\n编写尽量用pep8风格\n\n数据类型:python将数据划分为不同的类别,即数据类型.\n每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.\n对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.\n对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.\n对象的数据类型是对象所属的数据类别.\n\"hello world\"这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号\n数据类型为bool的对象被称为布尔值.\n数据类型为nonetype的对象,其值永远我none 用来表示数据缺失.\n\n**系统编程**\npython对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件\n(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.\npython的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道 \n进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展\n此外很多python的系统工具设计都考虑了其可移植性.\n\n**python解释器**\npython 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成\n当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行.\n\n## python变量和内存\n\n变量在python是表示内存的地址.\n可以用id()函数获取内存地址\n>a=5\n>id(a)\n>id(5)\n会发现这两个地址一样,都输出140720362218448\n\n即python的编程哲学 :一切皆对象,一切皆指针\n只有指针,要说变量也是指针变量\nvariable 变量是改变的值.变量由一个或多个字符组成的名称构成\n并使用赋值符 等号赋予了这个名称一个值\n变量是记住内存中 0 1数字  开始和结束的一串\n\n指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。\n\n内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n\n内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。\n\n内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。\n对于C和C++这样的没有Garbage Collection 的语言来讲\n我们主要关注两种类型的内存泄漏：\n\n堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. \n\n系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。\n\n## python虚拟机原理\n\npython不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.\npycodeobject保存字节码以及进程上下文信息.\n\n过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行\n字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象\n.pyc文件字节码在磁盘上的表现形式\npvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,\n从技术上将,他才是所谓python解释器的最后一步.\n代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式.\n\n开发环境 ----pyenv\npython多版本管理工具\npip包管理器\npip install xxx\npip list\npip search keyword 或者 pypi\npip help install\npip install redis ipython\npip install jupyter\npip -V\npip freeze > requirement\npip install-r requirement\n\n## 原码补码反码\n\n原码是给人看的,补码是给计算机用的\n127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。\n因为它是用补码的编码方式。\n正数的补码就是它的原码，也就是单纯的二进制数。负数的话，\n1111 1111这个二进制串，首先它最高位是1，明确他是个负数。\n那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001\n也就是1，再加上符号位。最终结果是-1\n\n补码 从小到大 二进制\n1000 0000—-0000 0000—-0111 1111\n首尾相连，刚好连个时钟，最大的加一到最小的\n\n______\n\n\n\n## 字符串\n\n使用单双三引号括起来的序列叫字符串\n\nr前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理\nf前缀:3.6版本开始,新增f前缀,格式化字符串\n转义序列\n\\\\ \\t \\r \\n \\' \\\"\n缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系\n约定使用4个空格缩进\n续行:在行尾使用\\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\\\nextend 魔术方法_add_()\n\n\n## 标识符\n\n一个名字,用来指代一个值\n只能是字母,下划线和数字\n只能以字母或下划线开头\n不能是python的关键字,例如def,class等\npython是大小写敏感的\n约定:\n不允许使用中文\n不要使用歧义单词,例如class_\n在python中不要随便使用下划线开头的标识符\n\n## 运算符\n\n* 算术运算符\n\n+-*/%**\n自然除/结果是浮点数,整除//\n\n* 位运算符\n\n& | ~ ^ << >>\n\n* 比较运算符\n  \n\n== != > < >= <=\n返回一个bool值\n\n* 逻辑运算符\n\n与或非 and or not\n短路运算符\n\n* 赋值运算符\n0 *? =0短路\n1+? =1短路运算 可以提高效率 可以提前算完了\n赋值运算 先算右边 和左边相连(映射)\n\na=min(3,5)\n\n运算符优先级 就记住一句话  a+b>c and\n\n折半思想可以优化程序\n\n## 程序控制\n\n顺序结构:按照先后顺序一条条执行\n分支结构:根据不同情况判断,条件满足执行某条件下的语句\n循环结构:条件满足就反复执行,不满足就不执行或不再执行\n\n## 内置类型\n\n内置对象使程序更容易编写\n内置对象使扩展的组件\n内置对象往往比定制的数据结构更有效率\n内置对象使语言的标准的一部分\npython的核心数据类型\n模式匹配\n\n## 循环\n\nwhile 语句\nwhlie condition:\n    block\n当他成立则进入循环\nwhile true:\n    pass #死循环 冒号后要形成语句块 死循环都用这个语法\n例子:\n\nflag = 10\nwhile flag:\n    print(flag)\n    flag-= 1\n\n在做循环时,一定要分析边界 边界最容易出错\nrange(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包\n\n>for i in range(10):\n>    print(i+1)\n>    i= i+10\n>循环 隐含赋值 原来有什么会被冲掉\nfor相当于遍历 不会重复拿 挨个拿 \n如果要倒着遍历 应当在range函数内加步长-1\n例子:\nfor i in range(10):\n    if i %2 == 0:\n        print(i)\n\nfor i in range(10):\n    if not i % 2:\n        print(i)\nnot 经常用\nfor i in range (10):\n    if i &1 == 0:\n        print(i)\n\nfor i in range(10):\n    if i & 1:\n        continue\n    print(i)\n\n写程序要减少循环提高效率\n\nfor i in range(10):\n    if i % 2:\n        continue\n    print(i)\n\n如果循环嵌套 continue 和break也只影响语句所在的那一层循环\n\n## 迭代器和生成器\n我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n\n一类是集合数据类型，如list、tuple、dict、set、str等；\n\n一类是generator，包括生成器和带yield的generator function。\n\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n\n可以使用isinstance()判断一个对象是否是Iterable对象：\n\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator.\n\n通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：\n\n>>> L = [x * x for x in range(10)]\n>>> L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> g = (x * x for x in range(10))\n>>> g\n<generator object <genexpr> at 0x1022ef630>\n\n## 函数\n\npython 内置了很多有用的函数,我们可以直接调用\n要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()\n调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.","source":"_posts/1 (14).md","raw":"---\ntitle: python入门笔记\n\ncategories: \n- python\ntags:\n- python\n---\n## 计算机基础\n\n**程序是一组让计算机识别和执行的指令**\n电子计算机:能够执行程序的机器\n计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)\n为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.\n即8位 2**8=256种状态  \n\n内存 掉电易失 与晶振频率有关 临时数据 mermory\ncpu与内存速度差几个数量级 \ncpu 只认内存 io设备最慢\nCPU 缓存 cache  bus 总线\n先写源程序 通过编译程序把源程序转换成机器指令的程序\npython是跑在虚拟机上的 动态语言 做节点 集群优化\n编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样\n\n**机器语言: 是一定位数组成的0 1序列 称为机器指令  机器指令的集合就是机器语言**\n**汇编: 是用助记符替代机器指令** \n**静态语言: 是声明变量类型,不能再改变,编译需要检查**\n**动态语言: 不用声明类型 随时可以赋值为其他类型**\n**强类型: 不同类型之间操作 必须强制类型转换为同一类型**\n**弱类型: 不同类型之间操作 自动隐式转换**\n\n## python基础介绍\n\npython 的源代码需要被解释器编译成中间代码,在虚拟机上运行\n***`程序 = 算法 +数据结构**`*\n数据一切程序的核心\n数据结构是数据在计算机中的类型和组织方式\n算法是处理数据的方式,算法有优劣之分.\npython自带了一个IDLE的程序,全称是交互式开发环境.\n注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可\n只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释--不要每行都写注释,有特殊情况才需要.\n\n>import math\n>#对角线的长度\n>i = 4\n>w = 10\n>d = math.sqrt(1**2 + w**2)\n即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的\n编写尽量用pep8风格\n\n数据类型:python将数据划分为不同的类别,即数据类型.\n每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.\n对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.\n对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.\n对象的数据类型是对象所属的数据类别.\n\"hello world\"这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号\n数据类型为bool的对象被称为布尔值.\n数据类型为nonetype的对象,其值永远我none 用来表示数据缺失.\n\n**系统编程**\npython对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件\n(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.\npython的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道 \n进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展\n此外很多python的系统工具设计都考虑了其可移植性.\n\n**python解释器**\npython 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成\n当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行.\n\n## python变量和内存\n\n变量在python是表示内存的地址.\n可以用id()函数获取内存地址\n>a=5\n>id(a)\n>id(5)\n会发现这两个地址一样,都输出140720362218448\n\n即python的编程哲学 :一切皆对象,一切皆指针\n只有指针,要说变量也是指针变量\nvariable 变量是改变的值.变量由一个或多个字符组成的名称构成\n并使用赋值符 等号赋予了这个名称一个值\n变量是记住内存中 0 1数字  开始和结束的一串\n\n指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。\n\n内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。\n\n内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。\n\n内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。\n对于C和C++这样的没有Garbage Collection 的语言来讲\n我们主要关注两种类型的内存泄漏：\n\n堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. \n\n系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。\n\n## python虚拟机原理\n\npython不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.\npycodeobject保存字节码以及进程上下文信息.\n\n过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行\n字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象\n.pyc文件字节码在磁盘上的表现形式\npvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,\n从技术上将,他才是所谓python解释器的最后一步.\n代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式.\n\n开发环境 ----pyenv\npython多版本管理工具\npip包管理器\npip install xxx\npip list\npip search keyword 或者 pypi\npip help install\npip install redis ipython\npip install jupyter\npip -V\npip freeze > requirement\npip install-r requirement\n\n## 原码补码反码\n\n原码是给人看的,补码是给计算机用的\n127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。\n因为它是用补码的编码方式。\n正数的补码就是它的原码，也就是单纯的二进制数。负数的话，\n1111 1111这个二进制串，首先它最高位是1，明确他是个负数。\n那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001\n也就是1，再加上符号位。最终结果是-1\n\n补码 从小到大 二进制\n1000 0000—-0000 0000—-0111 1111\n首尾相连，刚好连个时钟，最大的加一到最小的\n\n______\n\n\n\n## 字符串\n\n使用单双三引号括起来的序列叫字符串\n\nr前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理\nf前缀:3.6版本开始,新增f前缀,格式化字符串\n转义序列\n\\\\ \\t \\r \\n \\' \\\"\n缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系\n约定使用4个空格缩进\n续行:在行尾使用\\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\\\nextend 魔术方法_add_()\n\n\n## 标识符\n\n一个名字,用来指代一个值\n只能是字母,下划线和数字\n只能以字母或下划线开头\n不能是python的关键字,例如def,class等\npython是大小写敏感的\n约定:\n不允许使用中文\n不要使用歧义单词,例如class_\n在python中不要随便使用下划线开头的标识符\n\n## 运算符\n\n* 算术运算符\n\n+-*/%**\n自然除/结果是浮点数,整除//\n\n* 位运算符\n\n& | ~ ^ << >>\n\n* 比较运算符\n  \n\n== != > < >= <=\n返回一个bool值\n\n* 逻辑运算符\n\n与或非 and or not\n短路运算符\n\n* 赋值运算符\n0 *? =0短路\n1+? =1短路运算 可以提高效率 可以提前算完了\n赋值运算 先算右边 和左边相连(映射)\n\na=min(3,5)\n\n运算符优先级 就记住一句话  a+b>c and\n\n折半思想可以优化程序\n\n## 程序控制\n\n顺序结构:按照先后顺序一条条执行\n分支结构:根据不同情况判断,条件满足执行某条件下的语句\n循环结构:条件满足就反复执行,不满足就不执行或不再执行\n\n## 内置类型\n\n内置对象使程序更容易编写\n内置对象使扩展的组件\n内置对象往往比定制的数据结构更有效率\n内置对象使语言的标准的一部分\npython的核心数据类型\n模式匹配\n\n## 循环\n\nwhile 语句\nwhlie condition:\n    block\n当他成立则进入循环\nwhile true:\n    pass #死循环 冒号后要形成语句块 死循环都用这个语法\n例子:\n\nflag = 10\nwhile flag:\n    print(flag)\n    flag-= 1\n\n在做循环时,一定要分析边界 边界最容易出错\nrange(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包\n\n>for i in range(10):\n>    print(i+1)\n>    i= i+10\n>循环 隐含赋值 原来有什么会被冲掉\nfor相当于遍历 不会重复拿 挨个拿 \n如果要倒着遍历 应当在range函数内加步长-1\n例子:\nfor i in range(10):\n    if i %2 == 0:\n        print(i)\n\nfor i in range(10):\n    if not i % 2:\n        print(i)\nnot 经常用\nfor i in range (10):\n    if i &1 == 0:\n        print(i)\n\nfor i in range(10):\n    if i & 1:\n        continue\n    print(i)\n\n写程序要减少循环提高效率\n\nfor i in range(10):\n    if i % 2:\n        continue\n    print(i)\n\n如果循环嵌套 continue 和break也只影响语句所在的那一层循环\n\n## 迭代器和生成器\n我们已经知道，可以直接作用于for循环的数据类型有以下几种：\n\n一类是集合数据类型，如list、tuple、dict、set、str等；\n\n一类是generator，包括生成器和带yield的generator function。\n\n这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。\n\n可以使用isinstance()判断一个对象是否是Iterable对象：\n\n>>> from collections import Iterable\n>>> isinstance([], Iterable)\nTrue\n>>> isinstance({}, Iterable)\nTrue\n>>> isinstance('abc', Iterable)\nTrue\n>>> isinstance((x for x in range(10)), Iterable)\nTrue\n>>> isinstance(100, Iterable)\nFalse\n而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。\n\n可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator.\n\n通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。\n\n所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。\n要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：\n\n>>> L = [x * x for x in range(10)]\n>>> L\n[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]\n>>> g = (x * x for x in range(10))\n>>> g\n<generator object <genexpr> at 0x1022ef630>\n\n## 函数\n\npython 内置了很多有用的函数,我们可以直接调用\n要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()\n调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.","slug":"1 (14)","published":1,"date":"2019-04-01T02:01:12.157Z","updated":"2019-06-19T14:45:55.339Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8bq001zjkufe3d4v0yl","content":"<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><p><strong>程序是一组让计算机识别和执行的指令</strong><br>电子计算机:能够执行程序的机器<br>计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)<br>为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.<br>即8位 2**8=256种状态  </p>\n<p>内存 掉电易失 与晶振频率有关 临时数据 mermory<br>cpu与内存速度差几个数量级<br>cpu 只认内存 io设备最慢<br>CPU 缓存 cache  bus 总线<br>先写源程序 通过编译程序把源程序转换成机器指令的程序<br>python是跑在虚拟机上的 动态语言 做节点 集群优化<br>编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样</p>\n<p><strong>机器语言: 是一定位数组成的0 1序列 称为机器指令  机器指令的集合就是机器语言</strong><br><strong>汇编: 是用助记符替代机器指令</strong><br><strong>静态语言: 是声明变量类型,不能再改变,编译需要检查</strong><br><strong>动态语言: 不用声明类型 随时可以赋值为其他类型</strong><br><strong>强类型: 不同类型之间操作 必须强制类型转换为同一类型</strong><br><strong>弱类型: 不同类型之间操作 自动隐式转换</strong></p>\n<h2 id=\"python基础介绍\"><a href=\"#python基础介绍\" class=\"headerlink\" title=\"python基础介绍\"></a>python基础介绍</h2><p>python 的源代码需要被解释器编译成中间代码,在虚拟机上运行<br><strong>*`程序 = 算法 +数据结构</strong>`*<br>数据一切程序的核心<br>数据结构是数据在计算机中的类型和组织方式<br>算法是处理数据的方式,算法有优劣之分.<br>python自带了一个IDLE的程序,全称是交互式开发环境.<br>注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可<br>只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要.</p>\n<blockquote>\n<p>import math</p>\n<p>#对角线的长度<br>i = 4<br>w = 10<br>d = math.sqrt(1<strong>2 + w</strong>2)<br>即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的<br>编写尽量用pep8风格</p>\n</blockquote>\n<p>数据类型:python将数据划分为不同的类别,即数据类型.<br>每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.<br>对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.<br>对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.<br>对象的数据类型是对象所属的数据类别.<br>“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号<br>数据类型为bool的对象被称为布尔值.<br>数据类型为nonetype的对象,其值永远我none 用来表示数据缺失.</p>\n<p><strong>系统编程</strong><br>python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件<br>(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.<br>python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道<br>进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展<br>此外很多python的系统工具设计都考虑了其可移植性.</p>\n<p><strong>python解释器</strong><br>python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成<br>当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行.</p>\n<h2 id=\"python变量和内存\"><a href=\"#python变量和内存\" class=\"headerlink\" title=\"python变量和内存\"></a>python变量和内存</h2><p>变量在python是表示内存的地址.<br>可以用id()函数获取内存地址</p>\n<blockquote>\n<p>a=5<br>id(a)<br>id(5)<br>会发现这两个地址一样,都输出140720362218448</p>\n</blockquote>\n<p>即python的编程哲学 :一切皆对象,一切皆指针<br>只有指针,要说变量也是指针变量<br>variable 变量是改变的值.变量由一个或多个字符组成的名称构成<br>并使用赋值符 等号赋予了这个名称一个值<br>变量是记住内存中 0 1数字  开始和结束的一串</p>\n<p>指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。</p>\n<p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>\n<p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>对于C和C++这样的没有Garbage Collection 的语言来讲<br>我们主要关注两种类型的内存泄漏：</p>\n<p>堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. </p>\n<p>系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p>\n<h2 id=\"python虚拟机原理\"><a href=\"#python虚拟机原理\" class=\"headerlink\" title=\"python虚拟机原理\"></a>python虚拟机原理</h2><p>python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.<br>pycodeobject保存字节码以及进程上下文信息.</p>\n<p>过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行<br>字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象<br>.pyc文件字节码在磁盘上的表现形式<br>pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,<br>从技术上将,他才是所谓python解释器的最后一步.<br>代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式.</p>\n<p>开发环境 —-pyenv<br>python多版本管理工具<br>pip包管理器<br>pip install xxx<br>pip list<br>pip search keyword 或者 pypi<br>pip help install<br>pip install redis ipython<br>pip install jupyter<br>pip -V<br>pip freeze &gt; requirement<br>pip install-r requirement</p>\n<h2 id=\"原码补码反码\"><a href=\"#原码补码反码\" class=\"headerlink\" title=\"原码补码反码\"></a>原码补码反码</h2><p>原码是给人看的,补码是给计算机用的<br>127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。<br>因为它是用补码的编码方式。<br>正数的补码就是它的原码，也就是单纯的二进制数。负数的话，<br>1111 1111这个二进制串，首先它最高位是1，明确他是个负数。<br>那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001<br>也就是1，再加上符号位。最终结果是-1</p>\n<p>补码 从小到大 二进制<br>1000 0000—-0000 0000—-0111 1111<br>首尾相连，刚好连个时钟，最大的加一到最小的</p>\n<hr>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用单双三引号括起来的序列叫字符串</p>\n<p>r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理<br>f前缀:3.6版本开始,新增f前缀,格式化字符串<br>转义序列<br>\\ \\t \\r \\n \\’ \\”<br>缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系<br>约定使用4个空格缩进<br>续行:在行尾使用\\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\\<br>extend 魔术方法<em>add</em>()</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>一个名字,用来指代一个值<br>只能是字母,下划线和数字<br>只能以字母或下划线开头<br>不能是python的关键字,例如def,class等<br>python是大小写敏感的<br>约定:<br>不允许使用中文<br>不要使用歧义单词,例如class_<br>在python中不要随便使用下划线开头的标识符</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ul>\n<li>算术运算符</li>\n</ul>\n<p>+-*/%**<br>自然除/结果是浮点数,整除//</p>\n<ul>\n<li>位运算符</li>\n</ul>\n<p>&amp; | ~ ^ &lt;&lt; &gt;&gt;</p>\n<ul>\n<li>比较运算符</li>\n</ul>\n<p>== != &gt; &lt; &gt;= &lt;=<br>返回一个bool值</p>\n<ul>\n<li>逻辑运算符</li>\n</ul>\n<p>与或非 and or not<br>短路运算符</p>\n<ul>\n<li>赋值运算符<br>0 *? =0短路<br>1+? =1短路运算 可以提高效率 可以提前算完了<br>赋值运算 先算右边 和左边相连(映射)</li>\n</ul>\n<p>a=min(3,5)</p>\n<p>运算符优先级 就记住一句话  a+b&gt;c and</p>\n<p>折半思想可以优化程序</p>\n<h2 id=\"程序控制\"><a href=\"#程序控制\" class=\"headerlink\" title=\"程序控制\"></a>程序控制</h2><p>顺序结构:按照先后顺序一条条执行<br>分支结构:根据不同情况判断,条件满足执行某条件下的语句<br>循环结构:条件满足就反复执行,不满足就不执行或不再执行</p>\n<h2 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h2><p>内置对象使程序更容易编写<br>内置对象使扩展的组件<br>内置对象往往比定制的数据结构更有效率<br>内置对象使语言的标准的一部分<br>python的核心数据类型<br>模式匹配</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>while 语句<br>whlie condition:<br>    block<br>当他成立则进入循环<br>while true:<br>    pass #死循环 冒号后要形成语句块 死循环都用这个语法<br>例子:</p>\n<p>flag = 10<br>while flag:<br>    print(flag)<br>    flag-= 1</p>\n<p>在做循环时,一定要分析边界 边界最容易出错<br>range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包</p>\n<blockquote>\n<p>for i in range(10):<br>   print(i+1)<br>   i= i+10<br>循环 隐含赋值 原来有什么会被冲掉<br>for相当于遍历 不会重复拿 挨个拿<br>如果要倒着遍历 应当在range函数内加步长-1<br>例子:<br>for i in range(10):<br>    if i %2 == 0:<br>        print(i)</p>\n</blockquote>\n<p>for i in range(10):<br>    if not i % 2:<br>        print(i)<br>not 经常用<br>for i in range (10):<br>    if i &amp;1 == 0:<br>        print(i)</p>\n<p>for i in range(10):<br>    if i &amp; 1:<br>        continue<br>    print(i)</p>\n<p>写程序要减少循环提高效率</p>\n<p>for i in range(10):<br>    if i % 2:<br>        continue<br>    print(i)</p>\n<p>如果循环嵌套 continue 和break也只影响语句所在的那一层循环</p>\n<h2 id=\"迭代器和生成器\"><a href=\"#迭代器和生成器\" class=\"headerlink\" title=\"迭代器和生成器\"></a>迭代器和生成器</h2><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>\n<p>一类是集合数据类型，如list、tuple、dict、set、str等；</p>\n<p>一类是generator，包括生成器和带yield的generator function。</p>\n<p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p>\n<p>可以使用isinstance()判断一个对象是否是Iterable对象：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>from collections import Iterable<br>isinstance([], Iterable)<br>True<br>isinstance({}, Iterable)<br>True<br>isinstance(‘abc’, Iterable)<br>True<br>isinstance((x for x in range(10)), Iterable)<br>True<br>isinstance(100, Iterable)<br>False<br>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator.</p>\n<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>\n<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>L = [x <em> x for x in range(10)]<br>L<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br>g = (x </em> x for x in range(10))<br>g</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>&lt;generator object <genexpr> at 0x1022ef630&gt;</genexpr></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>python 内置了很多有用的函数,我们可以直接调用<br>要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()<br>调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"计算机基础\"><a href=\"#计算机基础\" class=\"headerlink\" title=\"计算机基础\"></a>计算机基础</h2><p><strong>程序是一组让计算机识别和执行的指令</strong><br>电子计算机:能够执行程序的机器<br>计算机中的冯诺依曼体系:控制器 运算器 存储器 输入输出(io)<br>为什么计算机用二进制是因为计算机只能用高电平和低电平来表示状态,所以用二进制1 0对应高低电平.3.5伏以上为高电平.在内存中又用一个字节表示一个储存单元.<br>即8位 2**8=256种状态  </p>\n<p>内存 掉电易失 与晶振频率有关 临时数据 mermory<br>cpu与内存速度差几个数量级<br>cpu 只认内存 io设备最慢<br>CPU 缓存 cache  bus 总线<br>先写源程序 通过编译程序把源程序转换成机器指令的程序<br>python是跑在虚拟机上的 动态语言 做节点 集群优化<br>编译语言 把源代码转换成目标机器的CPU指令 不同架构的CPU指令集不一样</p>\n<p><strong>机器语言: 是一定位数组成的0 1序列 称为机器指令  机器指令的集合就是机器语言</strong><br><strong>汇编: 是用助记符替代机器指令</strong><br><strong>静态语言: 是声明变量类型,不能再改变,编译需要检查</strong><br><strong>动态语言: 不用声明类型 随时可以赋值为其他类型</strong><br><strong>强类型: 不同类型之间操作 必须强制类型转换为同一类型</strong><br><strong>弱类型: 不同类型之间操作 自动隐式转换</strong></p>\n<h2 id=\"python基础介绍\"><a href=\"#python基础介绍\" class=\"headerlink\" title=\"python基础介绍\"></a>python基础介绍</h2><p>python 的源代码需要被解释器编译成中间代码,在虚拟机上运行<br><strong>*`程序 = 算法 +数据结构</strong>`*<br>数据一切程序的核心<br>数据结构是数据在计算机中的类型和组织方式<br>算法是处理数据的方式,算法有优劣之分.<br>python自带了一个IDLE的程序,全称是交互式开发环境.<br>注释:注释的目的是解释代码的功能程序员通过注释,使得代码更易于阅读.在注释中,可以写下任何内容,只要保持一行即可<br>只有在代码中执行特别操作,或者代码不清晰易懂的情况下,才需要写注释尽量少写注释–不要每行都写注释,有特殊情况才需要.</p>\n<blockquote>\n<p>import math</p>\n<p>#对角线的长度<br>i = 4<br>w = 10<br>d = math.sqrt(1<strong>2 + w</strong>2)<br>即使你完全理解了这段代码,也可能并不知道如何计算长方形的对角线长度,因此这里的注释就是有用的<br>编写尽量用pep8风格</p>\n</blockquote>\n<p>数据类型:python将数据划分为不同的类别,即数据类型.<br>每一个数据值被称为对象 对象拥有三个属性的数据值:唯一标识,数据类型,值.<br>对象的唯一标识,指的是在计算机内存中的地址,该地址不会变化.<br>对象的数据类型是数据所属的数据类别,这决定了对象的属性.也不会变化.<br>对象的数据类型是对象所属的数据类别.<br>“hello world”这个对象的数据类型为字符串(string),字符是类似a 或 l这样的单个符号<br>数据类型为bool的对象被称为布尔值.<br>数据类型为nonetype的对象,其值永远我none 用来表示数据缺失.</p>\n<p><strong>系统编程</strong><br>python对操作系统服务的内置接口,使其成为编写可移植的维护操作系统的管理工具和部件<br>(有时也称为shell工具)的理想工具.python程序可以搜索文件和目录树,可以运行其他程序,用进程或线程进行并行处理.<br>python的标准库绑定了posix以及其他常规操作系统os工具:环境变量 文件 套接字 管道<br>进程 多线程 正则表达式模式匹配 命令行参数 标准流接口 shell命令启动器 文件扩展<br>此外很多python的系统工具设计都考虑了其可移植性.</p>\n<p><strong>python解释器</strong><br>python 也是名为解释器的软件包,解释器是一种让其他程序运行起来的程序.当你编写一段python程序 python解释器将读取程序,并按照其中的命令执行,得出结果.实际上,解释器是代码与机器的计算机硬件的软件逻辑成<br>当python包安装在机器上后,它包含了一些最小化的组件:一个解释器和支持的库.根据使用情况的不同,python解释器可能采取可执行程序的形式,或是作为连接到另一个程序的一系列库.根据选用的python版本的不同,解释器本身可以用c程序实现,或一些java类实现,或者其他的形式.无论采取哪种形式,编写的python代码必须在解释器中运行.</p>\n<h2 id=\"python变量和内存\"><a href=\"#python变量和内存\" class=\"headerlink\" title=\"python变量和内存\"></a>python变量和内存</h2><p>变量在python是表示内存的地址.<br>可以用id()函数获取内存地址</p>\n<blockquote>\n<p>a=5<br>id(a)<br>id(5)<br>会发现这两个地址一样,都输出140720362218448</p>\n</blockquote>\n<p>即python的编程哲学 :一切皆对象,一切皆指针<br>只有指针,要说变量也是指针变量<br>variable 变量是改变的值.变量由一个或多个字符组成的名称构成<br>并使用赋值符 等号赋予了这个名称一个值<br>变量是记住内存中 0 1数字  开始和结束的一串</p>\n<p>指针的内容是存储地址在存储器中有大量的存储元，把它们按相同的位划分为组，组内所有的存储元同时进行读出或写入操作，这样的一组存储元称为一个存储单元。一个存储单元通常可以存放一个字节；存储单元是CPU访问存储器的基本单位。</p>\n<p>内存泄漏（Memory Leak）是指程序中己动态分配的堆内存由于某种原因程序未释放或无法释放，造成系统内存的浪费，导致程序运行速度减慢甚至系统崩溃等严重后果。</p>\n<p>内存溢出 out of memory，是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。</p>\n<p>内存泄露 memory leak，是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光。<br>对于C和C++这样的没有Garbage Collection 的语言来讲<br>我们主要关注两种类型的内存泄漏：</p>\n<p>堆内存泄漏（Heap leak）。对内存指的是程序执行中依据须要分配通过malloc,realloc new等从堆中分配的一块内存，再是完毕后必须通过调用相应的 free或者delete 删掉。假设程序的设计的错误导致这部分内存没有被释放，那么此后这块内存将不会被使用，就会产生Heap Leak. </p>\n<p>系统资源泄露（Resource Leak）.主要指程序使用系统分配的资源比方 Bitmap,handle ,SOCKET等没有使用对应的函数释放掉，导致系统资源的浪费，严重可导致系统效能减少，系统执行不稳定。</p>\n<h2 id=\"python虚拟机原理\"><a href=\"#python虚拟机原理\" class=\"headerlink\" title=\"python虚拟机原理\"></a>python虚拟机原理</h2><p>python不单纯是一种解释性语言,也需要编译,需要编译成字节码.然后模仿可执行文件的入栈出栈调成顺序执行.pyc文件中保存这编译而成的字节码,pvm从pycodeobject读取字节码一条一条执行.<br>pycodeobject保存字节码以及进程上下文信息.</p>\n<p>过程:python先把代码(.py)编译成字节码,交给字节码虚拟机,然后虚拟机一条一条执行字节码指令,从而完成程序的执行<br>字节码: 字节码在python虚拟机程序里对应的是pycodecbject 对象<br>.pyc文件字节码在磁盘上的表现形式<br>pvm是python的引擎,他时常表现为python系统的一部分,并且它是实际运行脚本的组件,<br>从技术上将,他才是所谓python解释器的最后一步.<br>代码在写好之后立即运行,另外一个就是,python字节码不是机器的二进制代码(intel芯片的指令)字节码特定于python的一种表现形式.</p>\n<p>开发环境 —-pyenv<br>python多版本管理工具<br>pip包管理器<br>pip install xxx<br>pip list<br>pip search keyword 或者 pypi<br>pip help install<br>pip install redis ipython<br>pip install jupyter<br>pip -V<br>pip freeze &gt; requirement<br>pip install-r requirement</p>\n<h2 id=\"原码补码反码\"><a href=\"#原码补码反码\" class=\"headerlink\" title=\"原码补码反码\"></a>原码补码反码</h2><p>原码是给人看的,补码是给计算机用的<br>127后面是-128，最大的正数加下来是最小的负数。这就跟钟表一样，12点钟后面是1点中钟一样。<br>因为它是用补码的编码方式。<br>正数的补码就是它的原码，也就是单纯的二进制数。负数的话，<br>1111 1111这个二进制串，首先它最高位是1，明确他是个负数。<br>那么其余位是111 1111，按位取反得到：000 0000，再加1就是：000 0001<br>也就是1，再加上符号位。最终结果是-1</p>\n<p>补码 从小到大 二进制<br>1000 0000—-0000 0000—-0111 1111<br>首尾相连，刚好连个时钟，最大的加一到最小的</p>\n<hr>\n<h2 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h2><p>使用单双三引号括起来的序列叫字符串</p>\n<p>r前缀:在字符串前面加上r 或者R前缀,表示该字符不做特殊的处理<br>f前缀:3.6版本开始,新增f前缀,格式化字符串<br>转义序列<br>\\ \\t \\r \\n \\’ \\”<br>缩进:未使用c等语言的花括号,而是采用缩进的方式表示层次关系<br>约定使用4个空格缩进<br>续行:在行尾使用\\ 如果使用各种括号,认为括号内是一个整体,内行跨行不用\\<br>extend 魔术方法<em>add</em>()</p>\n<h2 id=\"标识符\"><a href=\"#标识符\" class=\"headerlink\" title=\"标识符\"></a>标识符</h2><p>一个名字,用来指代一个值<br>只能是字母,下划线和数字<br>只能以字母或下划线开头<br>不能是python的关键字,例如def,class等<br>python是大小写敏感的<br>约定:<br>不允许使用中文<br>不要使用歧义单词,例如class_<br>在python中不要随便使用下划线开头的标识符</p>\n<h2 id=\"运算符\"><a href=\"#运算符\" class=\"headerlink\" title=\"运算符\"></a>运算符</h2><ul>\n<li>算术运算符</li>\n</ul>\n<p>+-*/%**<br>自然除/结果是浮点数,整除//</p>\n<ul>\n<li>位运算符</li>\n</ul>\n<p>&amp; | ~ ^ &lt;&lt; &gt;&gt;</p>\n<ul>\n<li>比较运算符</li>\n</ul>\n<p>== != &gt; &lt; &gt;= &lt;=<br>返回一个bool值</p>\n<ul>\n<li>逻辑运算符</li>\n</ul>\n<p>与或非 and or not<br>短路运算符</p>\n<ul>\n<li>赋值运算符<br>0 *? =0短路<br>1+? =1短路运算 可以提高效率 可以提前算完了<br>赋值运算 先算右边 和左边相连(映射)</li>\n</ul>\n<p>a=min(3,5)</p>\n<p>运算符优先级 就记住一句话  a+b&gt;c and</p>\n<p>折半思想可以优化程序</p>\n<h2 id=\"程序控制\"><a href=\"#程序控制\" class=\"headerlink\" title=\"程序控制\"></a>程序控制</h2><p>顺序结构:按照先后顺序一条条执行<br>分支结构:根据不同情况判断,条件满足执行某条件下的语句<br>循环结构:条件满足就反复执行,不满足就不执行或不再执行</p>\n<h2 id=\"内置类型\"><a href=\"#内置类型\" class=\"headerlink\" title=\"内置类型\"></a>内置类型</h2><p>内置对象使程序更容易编写<br>内置对象使扩展的组件<br>内置对象往往比定制的数据结构更有效率<br>内置对象使语言的标准的一部分<br>python的核心数据类型<br>模式匹配</p>\n<h2 id=\"循环\"><a href=\"#循环\" class=\"headerlink\" title=\"循环\"></a>循环</h2><p>while 语句<br>whlie condition:<br>    block<br>当他成立则进入循环<br>while true:<br>    pass #死循环 冒号后要形成语句块 死循环都用这个语法<br>例子:</p>\n<p>flag = 10<br>while flag:<br>    print(flag)<br>    flag-= 1</p>\n<p>在做循环时,一定要分析边界 边界最容易出错<br>range(1,10) # [1,10) 前包后不包 python大多函数都是前包后不包</p>\n<blockquote>\n<p>for i in range(10):<br>   print(i+1)<br>   i= i+10<br>循环 隐含赋值 原来有什么会被冲掉<br>for相当于遍历 不会重复拿 挨个拿<br>如果要倒着遍历 应当在range函数内加步长-1<br>例子:<br>for i in range(10):<br>    if i %2 == 0:<br>        print(i)</p>\n</blockquote>\n<p>for i in range(10):<br>    if not i % 2:<br>        print(i)<br>not 经常用<br>for i in range (10):<br>    if i &amp;1 == 0:<br>        print(i)</p>\n<p>for i in range(10):<br>    if i &amp; 1:<br>        continue<br>    print(i)</p>\n<p>写程序要减少循环提高效率</p>\n<p>for i in range(10):<br>    if i % 2:<br>        continue<br>    print(i)</p>\n<p>如果循环嵌套 continue 和break也只影响语句所在的那一层循环</p>\n<h2 id=\"迭代器和生成器\"><a href=\"#迭代器和生成器\" class=\"headerlink\" title=\"迭代器和生成器\"></a>迭代器和生成器</h2><p>我们已经知道，可以直接作用于for循环的数据类型有以下几种：</p>\n<p>一类是集合数据类型，如list、tuple、dict、set、str等；</p>\n<p>一类是generator，包括生成器和带yield的generator function。</p>\n<p>这些可以直接作用于for循环的对象统称为可迭代对象：Iterable。</p>\n<p>可以使用isinstance()判断一个对象是否是Iterable对象：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>from collections import Iterable<br>isinstance([], Iterable)<br>True<br>isinstance({}, Iterable)<br>True<br>isinstance(‘abc’, Iterable)<br>True<br>isinstance((x for x in range(10)), Iterable)<br>True<br>isinstance(100, Iterable)<br>False<br>而生成器不但可以作用于for循环，还可以被next()函数不断调用并返回下一个值，直到最后抛出StopIteration错误表示无法继续返回下一个值了。</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>可以被next()函数调用并不断返回下一个值的对象称为迭代器：Iterator.</p>\n<p>通过列表生成式，我们可以直接创建一个列表。但是，受到内存限制，列表容量肯定是有限的。而且，创建一个包含100万个元素的列表，不仅占用很大的存储空间，如果我们仅仅需要访问前面几个元素，那后面绝大多数元素占用的空间都白白浪费了。</p>\n<p>所以，如果列表元素可以按照某种算法推算出来，那我们是否可以在循环的过程中不断推算出后续的元素呢？这样就不必创建完整的list，从而节省大量的空间。在Python中，这种一边循环一边计算的机制，称为生成器：generator。<br>要创建一个generator，有很多种方法。第一种方法很简单，只要把一个列表生成式的[]改成()，就创建了一个generator：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>L = [x <em> x for x in range(10)]<br>L<br>[0, 1, 4, 9, 16, 25, 36, 49, 64, 81]<br>g = (x </em> x for x in range(10))<br>g</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>&lt;generator object <genexpr> at 0x1022ef630&gt;</genexpr></p>\n<h2 id=\"函数\"><a href=\"#函数\" class=\"headerlink\" title=\"函数\"></a>函数</h2><p>python 内置了很多有用的函数,我们可以直接调用<br>要调用一个函数,需要知道函数的名称和参数,比如求绝对值的函数abs()<br>调用函数的时候,如果传入的参数数量不对,会报Typeerror的错误,并且Python会明确地告诉你有且仅有一个参数.</p>\n"},{"title":"python数据结构","_content":"\n# 前言\n\n程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要.\n\n>常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表\n数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.\n数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.\n数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.\n数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.\n数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合.\n\n数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.\n数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.\n数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.\n数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型.\n\n# 抽象数据类型\n\n抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.\n抽象的意义在于数据类型的数学抽象特性.\n\n# 内存单元和地址\n计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.\n内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.\n在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,\n在计算机内存里表示数据元素之间的联系,只有两种技术:\n利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.\n在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构.\n\n数据结构是相互之间存在一种或多种特定关系的数据元素的集合.\n逻辑上分:集合结构, 线性结构, 树形结构, 图形结构\n物理结构:顺序存储结构, 链式存储结构.\n\n# 算法\n算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.\n我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.\n函数渐进式增长.\n判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.\n用O()来体现时间复杂度的记法, 我们称为大O记法.\nO(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶.\n\n\n# 线性表\n从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来.\n\n线性表的顺序存储结构\n指的是用一段地址连续的存储单元依次存储线性表的数据元素.\n插入删除的时间复杂度为O(n).\n它比较适合元素个数不太变化,而更多存取数据的应用.\n优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间.\n    可以快速地存取表中任意位置的元素.\n缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量\n造成存储空间的\"碎片\".\n\n\n线性表链式存储结构\n线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,\n以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.\n我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点.\n\n头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.\n头指针具有标识作用,所以常用头指针冠以链表的名字.\n无论链表是否为空,头指针均不为空,头指针是链表的必要元素.\n由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,\n对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显.\n\n若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构.\n\n静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法\n\n将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.\n双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针.\n\n# 栈与队列\n栈是限定仅在表尾进行插入和删除操作的线性表.\n对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表.\n\n在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,\n栈是限定仅在表尾进行插入和删除操作的线性表.\n我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.\n首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶.\n\n栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.\n栈的删除操作,也叫出栈,或弹栈栈.\n特别是插入和删除操作,我们改名为push 和pop.\n两栈共享空间\n\n栈的链式存储结构\n简称链栈\n顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些.\n\n\n对列\n对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.\n对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.\n对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出.\n\n\n\n# 串\n\n串是有零个或多个字符组成的有限序列,又名字符串.\n串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.\n他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.\n计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.\n电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.\n串的顺序存储结构\n串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.\n在计算机中存在一个自由存储区,叫做堆.\n\n模式匹配算法\n子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.\n一个字符的ASCII码可以看成是8位的二进制01串.\n\n本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.\n所谓的回文就是一个字符串的逆转显示reverse的操作.\n\n# 树\n树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n> 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树.\n\n所以我们需要研究这种一对多的数据结构--树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.\n树的定义其实就是我们在讲解栈提到的递归的方法.\n树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值.\n\n结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.\n树中结点的最大层次称为树的深度或高度.\n\n树的存储结构\n\n树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.\n主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.\n双亲表示法:\n我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其\n双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行.\n\n\n二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成.\n\n二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,\n左子树和右子树是有顺序的,次序不能任意颠倒,\n\n顺序存储结构一般只用于完全二叉树.\n二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.\n这里有两个关键词:访问和次序\n二叉树本质上,是对链表和数组的一个折中.\n每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据.\n\n压缩编码方法:赫夫曼编码\n\n\n# 图\n\n图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.\n在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.\n图是由顶点的有穷非空集合和顶点之间边的集合组成.\n图不能用简单的顺序结构来表示,而是多重链表.\n\n搜索引擎的工作原理:\n它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录.\n\n查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素.\n\n\n\n\n\n\n\n\n\n# python 对象特性\npython使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值:\n\n身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.\n类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.\n值:对象表示的数据.\n\n# python基本数据类型\npython的数据类型:\nnumber(数字), string(字符串), bool(布尔), None(空值)\n\n\n\n# python 内建数据结构\n\n## 线性结构\n### 字符串\n在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变.\n### 列表\n\n### 元组\n### bytes\n\n## 非线性结构\n### 集合set\n### 字典dict\n\n\n\n","source":"_posts/1 (15).md","raw":"---\ntitle: python数据结构\n\n\ncategories: \n- 数据结构\ntags:\n- 数据结构\n---\n\n# 前言\n\n程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要.\n\n>常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表\n数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.\n数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.\n数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.\n数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.\n数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合.\n\n数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.\n数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.\n数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.\n数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型.\n\n# 抽象数据类型\n\n抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.\n抽象的意义在于数据类型的数学抽象特性.\n\n# 内存单元和地址\n计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.\n内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.\n在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,\n在计算机内存里表示数据元素之间的联系,只有两种技术:\n利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.\n在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构.\n\n数据结构是相互之间存在一种或多种特定关系的数据元素的集合.\n逻辑上分:集合结构, 线性结构, 树形结构, 图形结构\n物理结构:顺序存储结构, 链式存储结构.\n\n# 算法\n算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.\n我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.\n函数渐进式增长.\n判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.\n用O()来体现时间复杂度的记法, 我们称为大O记法.\nO(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶.\n\n\n# 线性表\n从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来.\n\n线性表的顺序存储结构\n指的是用一段地址连续的存储单元依次存储线性表的数据元素.\n插入删除的时间复杂度为O(n).\n它比较适合元素个数不太变化,而更多存取数据的应用.\n优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间.\n    可以快速地存取表中任意位置的元素.\n缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量\n造成存储空间的\"碎片\".\n\n\n线性表链式存储结构\n线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,\n以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.\n我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点.\n\n头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.\n头指针具有标识作用,所以常用头指针冠以链表的名字.\n无论链表是否为空,头指针均不为空,头指针是链表的必要元素.\n由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,\n对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显.\n\n若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构.\n\n静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法\n\n将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.\n双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针.\n\n# 栈与队列\n栈是限定仅在表尾进行插入和删除操作的线性表.\n对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表.\n\n在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,\n栈是限定仅在表尾进行插入和删除操作的线性表.\n我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.\n首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶.\n\n栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.\n栈的删除操作,也叫出栈,或弹栈栈.\n特别是插入和删除操作,我们改名为push 和pop.\n两栈共享空间\n\n栈的链式存储结构\n简称链栈\n顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些.\n\n\n对列\n对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.\n对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.\n对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出.\n\n\n\n# 串\n\n串是有零个或多个字符组成的有限序列,又名字符串.\n串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.\n他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.\n计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.\n电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.\n串的顺序存储结构\n串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.\n在计算机中存在一个自由存储区,叫做堆.\n\n模式匹配算法\n子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.\n一个字符的ASCII码可以看成是8位的二进制01串.\n\n本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.\n所谓的回文就是一个字符串的逆转显示reverse的操作.\n\n# 树\n树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n> 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树.\n\n所以我们需要研究这种一对多的数据结构--树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.\n树的定义其实就是我们在讲解栈提到的递归的方法.\n树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值.\n\n结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.\n树中结点的最大层次称为树的深度或高度.\n\n树的存储结构\n\n树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.\n主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.\n双亲表示法:\n我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其\n双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行.\n\n\n二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成.\n\n二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,\n左子树和右子树是有顺序的,次序不能任意颠倒,\n\n顺序存储结构一般只用于完全二叉树.\n二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.\n这里有两个关键词:访问和次序\n二叉树本质上,是对链表和数组的一个折中.\n每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据.\n\n压缩编码方法:赫夫曼编码\n\n\n# 图\n\n图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.\n在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.\n图是由顶点的有穷非空集合和顶点之间边的集合组成.\n图不能用简单的顺序结构来表示,而是多重链表.\n\n搜索引擎的工作原理:\n它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录.\n\n查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素.\n\n\n\n\n\n\n\n\n\n# python 对象特性\npython使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值:\n\n身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.\n类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.\n值:对象表示的数据.\n\n# python基本数据类型\npython的数据类型:\nnumber(数字), string(字符串), bool(布尔), None(空值)\n\n\n\n# python 内建数据结构\n\n## 线性结构\n### 字符串\n在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变.\n### 列表\n\n### 元组\n### bytes\n\n## 非线性结构\n### 集合set\n### 字典dict\n\n\n\n","slug":"1 (15)","published":1,"date":"2019-04-26T12:27:21.158Z","updated":"2019-06-19T14:48:28.808Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8bv0020jkuf810rl45s","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要.</p>\n<blockquote>\n<p>常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表<br>数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.<br>数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.<br>数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.<br>数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.<br>数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合.</p>\n</blockquote>\n<p>数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.<br>数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.<br>数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.<br>数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型.</p>\n<h1 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h1><p>抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.<br>抽象的意义在于数据类型的数学抽象特性.</p>\n<h1 id=\"内存单元和地址\"><a href=\"#内存单元和地址\" class=\"headerlink\" title=\"内存单元和地址\"></a>内存单元和地址</h1><p>计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.<br>内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.<br>在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,<br>在计算机内存里表示数据元素之间的联系,只有两种技术:<br>利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.<br>在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构.</p>\n<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合.<br>逻辑上分:集合结构, 线性结构, 树形结构, 图形结构<br>物理结构:顺序存储结构, 链式存储结构.</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.<br>我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.<br>函数渐进式增长.<br>判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.<br>用O()来体现时间复杂度的记法, 我们称为大O记法.<br>O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶.</p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来.</p>\n<p>线性表的顺序存储结构<br>指的是用一段地址连续的存储单元依次存储线性表的数据元素.<br>插入删除的时间复杂度为O(n).<br>它比较适合元素个数不太变化,而更多存取数据的应用.<br>优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间.<br>    可以快速地存取表中任意位置的元素.<br>缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量<br>造成存储空间的”碎片”.</p>\n<p>线性表链式存储结构<br>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,<br>以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.<br>我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点.</p>\n<p>头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.<br>头指针具有标识作用,所以常用头指针冠以链表的名字.<br>无论链表是否为空,头指针均不为空,头指针是链表的必要元素.<br>由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,<br>对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显.</p>\n<p>若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构.</p>\n<p>静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法</p>\n<p>将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.<br>双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针.</p>\n<h1 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h1><p>栈是限定仅在表尾进行插入和删除操作的线性表.<br>对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表.</p>\n<p>在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,<br>栈是限定仅在表尾进行插入和删除操作的线性表.<br>我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.<br>首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶.</p>\n<p>栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.<br>栈的删除操作,也叫出栈,或弹栈栈.<br>特别是插入和删除操作,我们改名为push 和pop.<br>两栈共享空间</p>\n<p>栈的链式存储结构<br>简称链栈<br>顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些.</p>\n<p>对列<br>对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.<br>对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.<br>对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出.</p>\n<h1 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h1><p>串是有零个或多个字符组成的有限序列,又名字符串.<br>串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.<br>他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.<br>计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.<br>电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.<br>串的顺序存储结构<br>串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.<br>在计算机中存在一个自由存储区,叫做堆.</p>\n<p>模式匹配算法<br>子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.<br>一个字符的ASCII码可以看成是8位的二进制01串.</p>\n<p>本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.<br>所谓的回文就是一个字符串的逆转显示reverse的操作.</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树.</p>\n<p>所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.<br>树的定义其实就是我们在讲解栈提到的递归的方法.<br>树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值.</p>\n<p>结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.<br>树中结点的最大层次称为树的深度或高度.</p>\n<p>树的存储结构</p>\n<p>树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.<br>主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.<br>双亲表示法:<br>我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其<br>双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行.</p>\n<p>二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成.</p>\n<p>二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,<br>左子树和右子树是有顺序的,次序不能任意颠倒,</p>\n<p>顺序存储结构一般只用于完全二叉树.<br>二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.<br>这里有两个关键词:访问和次序<br>二叉树本质上,是对链表和数组的一个折中.<br>每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据.</p>\n<p>压缩编码方法:赫夫曼编码</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.<br>在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.<br>图是由顶点的有穷非空集合和顶点之间边的集合组成.<br>图不能用简单的顺序结构来表示,而是多重链表.</p>\n<p>搜索引擎的工作原理:<br>它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录.</p>\n<p>查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素.</p>\n<h1 id=\"python-对象特性\"><a href=\"#python-对象特性\" class=\"headerlink\" title=\"python 对象特性\"></a>python 对象特性</h1><p>python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值:</p>\n<p>身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.<br>类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.<br>值:对象表示的数据.</p>\n<h1 id=\"python基本数据类型\"><a href=\"#python基本数据类型\" class=\"headerlink\" title=\"python基本数据类型\"></a>python基本数据类型</h1><p>python的数据类型:<br>number(数字), string(字符串), bool(布尔), None(空值)</p>\n<h1 id=\"python-内建数据结构\"><a href=\"#python-内建数据结构\" class=\"headerlink\" title=\"python 内建数据结构\"></a>python 内建数据结构</h1><h2 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h2><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变.</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><h3 id=\"bytes\"><a href=\"#bytes\" class=\"headerlink\" title=\"bytes\"></a>bytes</h3><h2 id=\"非线性结构\"><a href=\"#非线性结构\" class=\"headerlink\" title=\"非线性结构\"></a>非线性结构</h2><h3 id=\"集合set\"><a href=\"#集合set\" class=\"headerlink\" title=\"集合set\"></a>集合set</h3><h3 id=\"字典dict\"><a href=\"#字典dict\" class=\"headerlink\" title=\"字典dict\"></a>字典dict</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>程序的本质就是数据结构和算法.所以学习python的过程中,理解python中数据结构至关重要.</p>\n<blockquote>\n<p>常用的8种数据结构:数组, 栈, 队列, 链表, 图, 树, 前缀树, 哈希表<br>数据结构是一门研究非数值计算的程序设计问题的操作对象的学科.<br>数据(data)是对客观事物的符号表示,在计算机科学中是指所有能输入带计算机中并被计算机程序处理的符号的总称.<br>数据元素(data element)是数据的基本单位,在计算机程序中通常作为一个整体进行考虑和处理.有时数据元素可有若干个数据项组成.<br>数据对象(data object)是性质相同的数据元素的集合,是数据的一个子集.<br>数据结构(data structure)是相互之间存在的一种或多种特定关系的数据元素的集合.</p>\n</blockquote>\n<p>数据元素之间关系的不同特性,通常有下列4类基本结构:集合,线性结构,树形结构,图状结构.<br>数据结构在计算机中的表示称为数据的物理结构,又称存储结构.它包括数据元素的表示和关系的表示.在计算机中表示信息的最小单位是二进制数的一位叫做位bit.<br>数据元素之间的关系在计算机中有两种不同的表示方法:顺序映像和非顺序映像,并由此得到两种不同的存储结构:顺序存储结构和链式存储结构.<br>数据类型(data type)是和数据结构密切相关的一个概念,用以刻画程序操作对象的特性,按值的不同特性高级程序语言中的数据类型可分为两类:一类是非结构的原子类型,一类是结构类型.</p>\n<h1 id=\"抽象数据类型\"><a href=\"#抽象数据类型\" class=\"headerlink\" title=\"抽象数据类型\"></a>抽象数据类型</h1><p>抽象数据类型:是指一个数学模型及定义在该模型上的一组操作.<br>抽象的意义在于数据类型的数学抽象特性.</p>\n<h1 id=\"内存单元和地址\"><a href=\"#内存单元和地址\" class=\"headerlink\" title=\"内存单元和地址\"></a>内存单元和地址</h1><p>计算中(程序中)直接使用的数据保存在计算机的内存储器.内存是cpu可以直接访问的数据存储设备.与之相对相应的是外存储器.<br>内存的基本结构是线性排列的一批存储单元.每个单元的大小相同,可以保存一个单位大小的数据.内存单元具有唯一编号,称为单元地址,或简称地址.单元地址从0开始排列,全部可用地址为从开始的一个连续的正整数空间.<br>在程序执行中,对内存单元的访问(存取其中数据)都通过单元的地址进行,因此,要访问一个地址,必须先掌握其地址,在许多计算机中,一次内存访问可以存取若干单元的内容.例如目前常见的64位计算机,一次存取8个字节的数据,与单元的位置或整个内存的大小无关,<br>在计算机内存里表示数据元素之间的联系,只有两种技术:<br>利用数据元素的存储位置隐式表示,由于内存是单元的线性序列,知道了前一个元素的位置及其大小,就能确定下一个元素的位置,如果存储的是一系列大小相同的元素,就可以利用前面公式直接算出序列中任何一个元素的位置.显然序列数据类型中元素的线性关系可以用这种方式表示.<br>在文档管理的数学模型中,计算机处理的对象之间通常存在着一中最简单的线性关系,这类数学模型可称为线性的数据结构.</p>\n<p>数据结构是相互之间存在一种或多种特定关系的数据元素的集合.<br>逻辑上分:集合结构, 线性结构, 树形结构, 图形结构<br>物理结构:顺序存储结构, 链式存储结构.</p>\n<h1 id=\"算法\"><a href=\"#算法\" class=\"headerlink\" title=\"算法\"></a>算法</h1><p>算法是解决特定问题求解步骤的描述,在计算机中表现为指令的有限序列,并且每条指令表示一个或多个操作.<br>我们不关心编写程序所用的程序设计语言是什么,也不关心这些程序将跑在什么样的计算机中,我们只关心她所实现的算法,最终,在分析程序的运行时间,最重要的是把程序看成独立于程序设计语言的算法或一系列步骤.<br>函数渐进式增长.<br>判断一个算法的效率时, 函数中的常数和其他次要项常常可以忽略,而更应该关注主项(最高阶项)的阶数.<br>用O()来体现时间复杂度的记法, 我们称为大O记法.<br>O(1)叫做常数阶, O(n)线性阶, O(n^2)叫做平方阶.</p>\n<h1 id=\"线性表\"><a href=\"#线性表\" class=\"headerlink\" title=\"线性表\"></a>线性表</h1><p>从名字上就能感觉到,是更具有像线一样的性质的表,如同一根线串联起来.</p>\n<p>线性表的顺序存储结构<br>指的是用一段地址连续的存储单元依次存储线性表的数据元素.<br>插入删除的时间复杂度为O(n).<br>它比较适合元素个数不太变化,而更多存取数据的应用.<br>优点:无序为表示表中元素之间的逻辑关系而增加额外的存储空间.<br>    可以快速地存取表中任意位置的元素.<br>缺点:插入和删除操作需要移动大量元素,当线性表长度变化较大时,难以确定存储空间的容量<br>造成存储空间的”碎片”.</p>\n<p>线性表链式存储结构<br>线性表的链式存储结构的特点是用一组任意的存储单元存储线性表的数据元素,这组存储单元可以是连续,也可以是不连续的,<br>以前在顺序结构中, 每个数据元素只需要存数据元素信息可以了,现在链式结构中,除了要存储数据元素信息外,还要存储它的后继元素的存储地址.<br>我们把存储数据元素信息的域称为数据域,把存储直接后继位置的域称为指针域.指针域中存储的信息称为指针或链,这两部分组成数据元素的存储映像称为结点.</p>\n<p>头指针是指链表指向第一个结点的指针,若链表有头结点,则是指向头结点的指针.<br>头指针具有标识作用,所以常用头指针冠以链表的名字.<br>无论链表是否为空,头指针均不为空,头指针是链表的必要元素.<br>由于单链表的结构中没有定义表长,所以不能事先知道循环多少次,因此也就不方便用for来控制循环,其主要核心思想就是工作指针后移,<br>对于插入或删除数据越频繁的操作,单链表的效率优势就是越明显.</p>\n<p>若线性表需要频繁查找,很少进行插入或和删除操作,采用顺序存储结构,若需要频繁插入和和删除,就采用链表结构.</p>\n<p>静态链表是为了给没有指针的高级语言设计的一种实现单链表能力的方法</p>\n<p>将单链表中终端结点的指针端由空指针指向头结点,就使整个单链表形成一个环,这种头尾相接的单链表称为单循环链表,简称循环链表.<br>双向链表是在单链表的每个结点,再设置一个指向其前驱结点的指针.</p>\n<h1 id=\"栈与队列\"><a href=\"#栈与队列\" class=\"headerlink\" title=\"栈与队列\"></a>栈与队列</h1><p>栈是限定仅在表尾进行插入和删除操作的线性表.<br>对列是只允许在一端进行插入操作而在另一端进行删除操作的线性表.</p>\n<p>在word等文档或图像编辑软件中,都有撤销undo的操作,也是用栈这种方式来实现的,<br>栈是限定仅在表尾进行插入和删除操作的线性表.<br>我们把允许插入和删除的一端称为栈顶top,另一端称为栈底bottom,不含任何数据元素的栈称为空栈,栈又称为后进先出的线性表,简称LIFO结构.<br>首先它是一个线性表,栈元素具有线性关系,即前驱后继关系,只不过它是一种特殊的线性表而已,表尾是指栈顶.</p>\n<p>栈的插入操作叫做进栈,也称压栈入栈,类似子弹入弹夹.<br>栈的删除操作,也叫出栈,或弹栈栈.<br>特别是插入和删除操作,我们改名为push 和pop.<br>两栈共享空间</p>\n<p>栈的链式存储结构<br>简称链栈<br>顺序栈与链栈他们在时间复杂度是一样的,均为O(1),对于空间性能,顺序栈需要事先确定一个固定的长度,可能会存在内存空间浪费的问题,如果栈的使用中元素变化不可预料,有时很小,有时非常大,那么最好是用链栈,反之,如果他的变化在可控范围内,建议使用顺序栈会更好一些.</p>\n<p>对列<br>对列是只允许在一端进行插入操作,而在另一端进行删除操作的线性表.<br>对列是一种先进先出的线性表,简称FIFO,允许插入的一端称为队尾,允许删除的一端称为对头.<br>对列在程序设计用的非常频繁,键盘进行各种字母或数字的输入,到显示器记事本的输出.</p>\n<h1 id=\"串\"><a href=\"#串\" class=\"headerlink\" title=\"串\"></a>串</h1><p>串是有零个或多个字符组成的有限序列,又名字符串.<br>串(string)是有零个或多个字符组成的有限序列.所谓的序列,说明串的相邻之间具有前驱和后继的关系.<br>他们在计算机的大小其实取决于他们挨个字母的前后顺序.串的比较是通过组成串的字符之间的编码来进行的,而字符的编码指的是字符串在对应字符集中的序号.<br>计算机中的常用字符是使用标准的ASCII编码,比较常见的是有16位的二进制表示一个字符.<br>电子词典查找单词实现的原理,其实就是字符串这种数据结构的典型应用.<br>串的顺序存储结构<br>串的顺序存储结构使用一组地址连续的存储单元来存储串中的字符序列.<br>在计算机中存在一个自由存储区,叫做堆.</p>\n<p>模式匹配算法<br>子串的定位操作通常称为串的模式匹配,这应该是串中最重要的操作之一.<br>一个字符的ASCII码可以看成是8位的二进制01串.</p>\n<p>本质上,它是一种线性表的扩展,但对于线性表关注的一个个元素来说, 我们对串这种机构更多的是关注它子串的应用问题,比如查找,替换.<br>所谓的回文就是一个字符串的逆转显示reverse的操作.</p>\n<h1 id=\"树\"><a href=\"#树\" class=\"headerlink\" title=\"树\"></a>树</h1><p>树是n个结点的有限集.n=0时称为空树.在任意一颗非空树中:(1)有且仅有一个特定称为树root的结点:当n&gt; 1时,其余结点可分 m个互不相交的有限集t,其中每一个集合本身又是一个棵树,并且称为根的子树.</p>\n<p>所以我们需要研究这种一对多的数据结构–树,考虑它的各种特性,来解决我们在编程中碰到的相关问题.<br>树的定义其实就是我们在讲解栈提到的递归的方法.<br>树的结点包含一个数据元素及若干指向其子树的分支.结点拥有的子树称为结点的度.度为0的结点称为叶结点或终端结点;度不为0的结点称为非终端结点或分支结点,除根结点之外,分支结点也称为内部结点.树的度是树内结点的度的最大值.</p>\n<p>结点的子树的根称为该结点的孩子,相应地,该结点称为孩子的双亲.<br>树中结点的最大层次称为树的深度或高度.</p>\n<p>树的存储结构</p>\n<p>树中某个结点的孩子可以有多个,这就意味着,无论按何种顺序将树中所有结点存储到数组中,结点的存储位置都无法直接反应逻辑关系,你想想看,数据元素挨个的存储,谁是谁的双亲,谁是谁的孩子,简单的顺序存储结构是不能满足树的实现要求的.<br>主要有三种不同的表示法:双亲表示法,孩子表示法,孩子兄弟表示法.<br>双亲表示法:<br>我们假设以一组双亲结点连续空间存储树的结点,同时在每个结点中,附设一个指示器指示其<br>双亲结点到链表中的位置,也就是说,每个结点除了知道自己是谁以为,还知道它的双亲在哪里.这样的存储结构,我们可以根据结点的parent指正很容易找到它的双亲结点,所以时间复杂度为O(1),直到parent为-1时,表示找到了树结点的根,可如果我们要知道结点的孩子是什么,对不起请遍历整个结构才行.</p>\n<p>二叉树是n各节点的有限集合,该集合或者为空集,或者由一个根结点和两颗互不相交的分别称为根结点的左子树和右子树组成.</p>\n<p>二叉树每个结点最多有两颗子树,所以二叉树不存在大于2的结点.注意不是只有两颗子树,而是最多有,没有子树或者由一颗子树都是可以的,<br>左子树和右子树是有顺序的,次序不能任意颠倒,</p>\n<p>顺序存储结构一般只用于完全二叉树.<br>二叉树的遍历是指从根结点出发,按照某种次序依次访问二叉树中所有结点,使得每个结点被访问一次仅被访问一次.<br>这里有两个关键词:访问和次序<br>二叉树本质上,是对链表和数组的一个折中.<br>每种数据结构都相当于一种容器,我们需要把数据存放在里面后供我们高效地操作这些数据.</p>\n<p>压缩编码方法:赫夫曼编码</p>\n<h1 id=\"图\"><a href=\"#图\" class=\"headerlink\" title=\"图\"></a>图</h1><p>图是有顶点的有穷非空集合和顶点之间边的集合组成,通常表示G.<br>在线性表中,数据元素之间是被串起来的,仅有线性关系,每个数据元素只有一个前驱和一个直接后驱,在树形结构中,数据元素之间有着明显的层次关系,并且每一层上的数据元素可能和下一层中多个元素相关比如我认识的朋友,可能他们之间也互相认识,这就不是简单的一对多.<br>图是由顶点的有穷非空集合和顶点之间边的集合组成.<br>图不能用简单的顺序结构来表示,而是多重链表.</p>\n<p>搜索引擎的工作原理:<br>它抓取并复制你的网页,且通过你网页,上的链接爬上更多的页面,将所有信息纳入到搜索引擎网站的索引数据库.服务器拆解你网页上的文字内容,标记关键词的位置,字体,颜色以及相关图片,音频,视屏的位置等信息,并生成庞大的索引记录.</p>\n<p>查找就是根据给定的某个值,在查找表中确定一个其关键字等于给定值的数据元素.</p>\n<h1 id=\"python-对象特性\"><a href=\"#python-对象特性\" class=\"headerlink\" title=\"python 对象特性\"></a>python 对象特性</h1><p>python使用对象模型来储存数据.构造任何类型的值都是一个对象.所有python都拥有三个特性:身份,类型,值:</p>\n<p>身份:每个对象都有一个的身份标识自己,任何对象的身份可以使用内建函数id()来得到.<br>类型:对象的类型决定了该对象可以保存什么类型的值,可以进行什么样的操作,以及遵循什么样的规则.可以使用type()函数查看python对象的类型.type()返回的是对象而不是简单的字符串.<br>值:对象表示的数据.</p>\n<h1 id=\"python基本数据类型\"><a href=\"#python基本数据类型\" class=\"headerlink\" title=\"python基本数据类型\"></a>python基本数据类型</h1><p>python的数据类型:<br>number(数字), string(字符串), bool(布尔), None(空值)</p>\n<h1 id=\"python-内建数据结构\"><a href=\"#python-内建数据结构\" class=\"headerlink\" title=\"python 内建数据结构\"></a>python 内建数据结构</h1><h2 id=\"线性结构\"><a href=\"#线性结构\" class=\"headerlink\" title=\"线性结构\"></a>线性结构</h2><h3 id=\"字符串\"><a href=\"#字符串\" class=\"headerlink\" title=\"字符串\"></a>字符串</h3><p>在内存连续排放, 类似list.也可以看成容器.只是这种容器不可变.</p>\n<h3 id=\"列表\"><a href=\"#列表\" class=\"headerlink\" title=\"列表\"></a>列表</h3><h3 id=\"元组\"><a href=\"#元组\" class=\"headerlink\" title=\"元组\"></a>元组</h3><h3 id=\"bytes\"><a href=\"#bytes\" class=\"headerlink\" title=\"bytes\"></a>bytes</h3><h2 id=\"非线性结构\"><a href=\"#非线性结构\" class=\"headerlink\" title=\"非线性结构\"></a>非线性结构</h2><h3 id=\"集合set\"><a href=\"#集合set\" class=\"headerlink\" title=\"集合set\"></a>集合set</h3><h3 id=\"字典dict\"><a href=\"#字典dict\" class=\"headerlink\" title=\"字典dict\"></a>字典dict</h3>"},{"title":"python特殊函数","_content":"\n# 匿名函数\n匿名函数 :隐藏名字,即没有名称\n匿名函数: 没有名字的函数\nlambda表达式\npython中,使用lambda表达式构建匿名函数\n使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式\n参数列表不需要小括号,无参就不写参数\n冒号用来分割参数和表达式部分\n不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.\nlambda表达式匿名函数只能写在一行上,也称为单行函数.\n\n匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.\n\n# 递归函数\n\n函数执行流程:压栈\n\n递归函数recursion\n函数直接或者间接调用自身就是递归.\n递归需要有边界条件,递归前进段,递归返回段.\n递归一定要有边界条件.\n当边界条件不满足的时候,递归前进\n当边界条件满足的时候,递归返回.\n\n递归例子:斐波那契数列 \n如果用循环写法:\n```\na = 0\nb = 1\nn = 10\nfor i in range(n -1):\n    a,b=b, a+b\nelse:\n    print(b)\n\n```\n\n递归写法:\ndef fib(n):\n    return 1 if n <3 else fib(n-1) +fib(n-2)\n\n递归要求\n递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.\n递归调用的深度不宜\npython 对递归调用的深度做了限制,以保护解释器\n超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度\nsys.getrecursionlimit()\n\n循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.\n递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.\n\n递归是一种很自然的表达,符合逻辑思维\n递归相对效率低,每一次调用都要开辟栈帧.\n递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.\n如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.\n绝大多数递归,都可以使用循环实现\n即使递归代码很简洁,但是能不用则不用递归.\n\n# 生成器\n\n生成器generator\n生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.\n生成器对象,是一个可迭代对象,是有个迭代器.\n生成器对象,是延时计算,惰性求值的.\n\n函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.\n普通函数调用,函数会立即执行直到执行完毕.\n生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.\n生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑.\n\n在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回\n再执行会执行到下一个yield语句又会暂停执行\nreturn会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.\n如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration\n生成器函数\n包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行\nnext会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.\n再次调用next函数,和上一条一样的处理过程.\n继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常.\n\n协程\n生成器的高级用法\n他比进程,线程轻量级,是在用户空间调度函数的一种实现.\n协程调度器实现思路\n协程是一种非抢占式调度.\n\nyield from 语法\nyield from就是一种简化语法的语法糖.\n\n# yield 和return的区别\n\n带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return\n\n如何生成斐波那契数列:\n斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数.\n\n```\ndef fab(max):\n    a, b = 1, 1\n    n = 1\n    while n < max:\n        print(b)\n        a, b = b, a+b\n        n +=1\nfab(20)\n```\n结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.\n要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.\n```\ndef fab(max):\n    n, a, b = 0, 0, 1\n    l = []\n    while  n < max:\n        l.append(b)\n        b = b+a\n        a = b-a\n        n = n+1\n    return l\n```\n改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,\n该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要\n用list来保存中间结果, 而是通过iterable对象来迭代.\n\n```\nclass Fab(object): \n \n   def __init__(self, max): \n       self.max = max \n       self.n, self.a, self.b = 0, 0, 1 \n \n   def __iter__(self): \n       return self \n \n   def next(self): \n       if self.n < self.max: \n           r = self.b \n           self.b = self.a + self.b\n           self.a = self.b - self.a\n           self.n = self.n + 1 \n           return r \n       raise StopIteration()\n\n```\n然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:\ndef fab(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        b =  b+a \n        a = b-a\n        n = n + 1\n\n第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果\n调用第四版的fab和第二版的fab完全一致:\n\n简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,\n而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法\n这样我们就可以清楚看到fab的执行流程.\n\n# 高阶函数\n函数也是对象, 是可调用对象\n函数可以作为普通变量,也可以作为函数的参数, 返回值.\n\n在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数\n接受一个或多个函数作为参数\n输出一个函数\n\n排序sorted\n排序函数,可以接受key作为参数进行排序,不改变序列的原有值.\n排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.\n然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素.\n\n过滤filter\n对可迭代对象进行遍历,返回一个迭代器\nfunction参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值\nfunction参数如果是None, 可迭代对象的每一个元素自身等效布尔值.\n\n映射map\n对多个可迭代对象的元素,按照指定的函数进行映射\n返回一个迭代器\n\n\n# 柯里化\n指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.\n\n\n\n","source":"_posts/1 (16).md","raw":"---\ntitle: python特殊函数\n\n\ncategories: \n- python\ntags:\n- python\n---\n\n# 匿名函数\n匿名函数 :隐藏名字,即没有名称\n匿名函数: 没有名字的函数\nlambda表达式\npython中,使用lambda表达式构建匿名函数\n使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式\n参数列表不需要小括号,无参就不写参数\n冒号用来分割参数和表达式部分\n不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.\nlambda表达式匿名函数只能写在一行上,也称为单行函数.\n\n匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.\n\n# 递归函数\n\n函数执行流程:压栈\n\n递归函数recursion\n函数直接或者间接调用自身就是递归.\n递归需要有边界条件,递归前进段,递归返回段.\n递归一定要有边界条件.\n当边界条件不满足的时候,递归前进\n当边界条件满足的时候,递归返回.\n\n递归例子:斐波那契数列 \n如果用循环写法:\n```\na = 0\nb = 1\nn = 10\nfor i in range(n -1):\n    a,b=b, a+b\nelse:\n    print(b)\n\n```\n\n递归写法:\ndef fib(n):\n    return 1 if n <3 else fib(n-1) +fib(n-2)\n\n递归要求\n递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.\n递归调用的深度不宜\npython 对递归调用的深度做了限制,以保护解释器\n超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度\nsys.getrecursionlimit()\n\n循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.\n递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.\n\n递归是一种很自然的表达,符合逻辑思维\n递归相对效率低,每一次调用都要开辟栈帧.\n递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.\n如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.\n绝大多数递归,都可以使用循环实现\n即使递归代码很简洁,但是能不用则不用递归.\n\n# 生成器\n\n生成器generator\n生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.\n生成器对象,是一个可迭代对象,是有个迭代器.\n生成器对象,是延时计算,惰性求值的.\n\n函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.\n普通函数调用,函数会立即执行直到执行完毕.\n生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.\n生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑.\n\n在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回\n再执行会执行到下一个yield语句又会暂停执行\nreturn会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.\n如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration\n生成器函数\n包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行\nnext会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.\n再次调用next函数,和上一条一样的处理过程.\n继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常.\n\n协程\n生成器的高级用法\n他比进程,线程轻量级,是在用户空间调度函数的一种实现.\n协程调度器实现思路\n协程是一种非抢占式调度.\n\nyield from 语法\nyield from就是一种简化语法的语法糖.\n\n# yield 和return的区别\n\n带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return\n\n如何生成斐波那契数列:\n斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数.\n\n```\ndef fab(max):\n    a, b = 1, 1\n    n = 1\n    while n < max:\n        print(b)\n        a, b = b, a+b\n        n +=1\nfab(20)\n```\n结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.\n要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.\n```\ndef fab(max):\n    n, a, b = 0, 0, 1\n    l = []\n    while  n < max:\n        l.append(b)\n        b = b+a\n        a = b-a\n        n = n+1\n    return l\n```\n改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,\n该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要\n用list来保存中间结果, 而是通过iterable对象来迭代.\n\n```\nclass Fab(object): \n \n   def __init__(self, max): \n       self.max = max \n       self.n, self.a, self.b = 0, 0, 1 \n \n   def __iter__(self): \n       return self \n \n   def next(self): \n       if self.n < self.max: \n           r = self.b \n           self.b = self.a + self.b\n           self.a = self.b - self.a\n           self.n = self.n + 1 \n           return r \n       raise StopIteration()\n\n```\n然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:\ndef fab(max):\n    n, a, b = 0, 0, 1\n    while n < max:\n        yield b\n        b =  b+a \n        a = b-a\n        n = n + 1\n\n第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果\n调用第四版的fab和第二版的fab完全一致:\n\n简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,\n而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法\n这样我们就可以清楚看到fab的执行流程.\n\n# 高阶函数\n函数也是对象, 是可调用对象\n函数可以作为普通变量,也可以作为函数的参数, 返回值.\n\n在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数\n接受一个或多个函数作为参数\n输出一个函数\n\n排序sorted\n排序函数,可以接受key作为参数进行排序,不改变序列的原有值.\n排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.\n然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素.\n\n过滤filter\n对可迭代对象进行遍历,返回一个迭代器\nfunction参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值\nfunction参数如果是None, 可迭代对象的每一个元素自身等效布尔值.\n\n映射map\n对多个可迭代对象的元素,按照指定的函数进行映射\n返回一个迭代器\n\n\n# 柯里化\n指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.\n\n\n\n","slug":"1 (16)","published":1,"date":"2019-04-15T12:21:42.477Z","updated":"2019-06-19T14:48:15.380Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8bz0022jkufiqcf4myk","content":"<h1 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h1><p>匿名函数 :隐藏名字,即没有名称<br>匿名函数: 没有名字的函数<br>lambda表达式<br>python中,使用lambda表达式构建匿名函数<br>使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式<br>参数列表不需要小括号,无参就不写参数<br>冒号用来分割参数和表达式部分<br>不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.<br>lambda表达式匿名函数只能写在一行上,也称为单行函数.</p>\n<p>匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.</p>\n<h1 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h1><p>函数执行流程:压栈</p>\n<p>递归函数recursion<br>函数直接或者间接调用自身就是递归.<br>递归需要有边界条件,递归前进段,递归返回段.<br>递归一定要有边界条件.<br>当边界条件不满足的时候,递归前进<br>当边界条件满足的时候,递归返回.</p>\n<p>递归例子:斐波那契数列<br>如果用循环写法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 0</span><br><span class=\"line\">b = 1</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">for i in range(n -1):</span><br><span class=\"line\">    a,b=b, a+b</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(b)</span><br></pre></td></tr></table></figure></p>\n<p>递归写法:<br>def fib(n):<br>    return 1 if n &lt;3 else fib(n-1) +fib(n-2)</p>\n<p>递归要求<br>递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.<br>递归调用的深度不宜<br>python 对递归调用的深度做了限制,以保护解释器<br>超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度<br>sys.getrecursionlimit()</p>\n<p>循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.<br>递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.</p>\n<p>递归是一种很自然的表达,符合逻辑思维<br>递归相对效率低,每一次调用都要开辟栈帧.<br>递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.<br>如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.<br>绝大多数递归,都可以使用循环实现<br>即使递归代码很简洁,但是能不用则不用递归.</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>生成器generator<br>生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.<br>生成器对象,是一个可迭代对象,是有个迭代器.<br>生成器对象,是延时计算,惰性求值的.</p>\n<p>函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.<br>普通函数调用,函数会立即执行直到执行完毕.<br>生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.<br>生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑.</p>\n<p>在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回<br>再执行会执行到下一个yield语句又会暂停执行<br>return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.<br>如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration<br>生成器函数<br>包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行<br>next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.<br>再次调用next函数,和上一条一样的处理过程.<br>继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常.</p>\n<p>协程<br>生成器的高级用法<br>他比进程,线程轻量级,是在用户空间调度函数的一种实现.<br>协程调度器实现思路<br>协程是一种非抢占式调度.</p>\n<p>yield from 语法<br>yield from就是一种简化语法的语法糖.</p>\n<h1 id=\"yield-和return的区别\"><a href=\"#yield-和return的区别\" class=\"headerlink\" title=\"yield 和return的区别\"></a>yield 和return的区别</h1><p>带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return</p>\n<p>如何生成斐波那契数列:<br>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fab(max):</span><br><span class=\"line\">    a, b = 1, 1</span><br><span class=\"line\">    n = 1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        print(b)</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">        n +=1</span><br><span class=\"line\">fab(20)</span><br></pre></td></tr></table></figure>\n<p>结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.<br>要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fab(max):</span><br><span class=\"line\">    n, a, b = 0, 0, 1</span><br><span class=\"line\">    l = []</span><br><span class=\"line\">    while  n &lt; max:</span><br><span class=\"line\">        l.append(b)</span><br><span class=\"line\">        b = b+a</span><br><span class=\"line\">        a = b-a</span><br><span class=\"line\">        n = n+1</span><br><span class=\"line\">    return l</span><br></pre></td></tr></table></figure></p>\n<p>改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,<br>该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要<br>用list来保存中间结果, 而是通过iterable对象来迭代.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fab(object): </span><br><span class=\"line\"> </span><br><span class=\"line\">   def __init__(self, max): </span><br><span class=\"line\">       self.max = max </span><br><span class=\"line\">       self.n, self.a, self.b = 0, 0, 1 </span><br><span class=\"line\"> </span><br><span class=\"line\">   def __iter__(self): </span><br><span class=\"line\">       return self </span><br><span class=\"line\"> </span><br><span class=\"line\">   def next(self): </span><br><span class=\"line\">       if self.n &lt; self.max: </span><br><span class=\"line\">           r = self.b </span><br><span class=\"line\">           self.b = self.a + self.b</span><br><span class=\"line\">           self.a = self.b - self.a</span><br><span class=\"line\">           self.n = self.n + 1 </span><br><span class=\"line\">           return r </span><br><span class=\"line\">       raise StopIteration()</span><br></pre></td></tr></table></figure>\n<p>然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:<br>def fab(max):<br>    n, a, b = 0, 0, 1<br>    while n &lt; max:<br>        yield b<br>        b =  b+a<br>        a = b-a<br>        n = n + 1</p>\n<p>第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果<br>调用第四版的fab和第二版的fab完全一致:</p>\n<p>简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,<br>而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法<br>这样我们就可以清楚看到fab的执行流程.</p>\n<h1 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h1><p>函数也是对象, 是可调用对象<br>函数可以作为普通变量,也可以作为函数的参数, 返回值.</p>\n<p>在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数<br>接受一个或多个函数作为参数<br>输出一个函数</p>\n<p>排序sorted<br>排序函数,可以接受key作为参数进行排序,不改变序列的原有值.<br>排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.<br>然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素.</p>\n<p>过滤filter<br>对可迭代对象进行遍历,返回一个迭代器<br>function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值<br>function参数如果是None, 可迭代对象的每一个元素自身等效布尔值.</p>\n<p>映射map<br>对多个可迭代对象的元素,按照指定的函数进行映射<br>返回一个迭代器</p>\n<h1 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h1><p>指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"匿名函数\"><a href=\"#匿名函数\" class=\"headerlink\" title=\"匿名函数\"></a>匿名函数</h1><p>匿名函数 :隐藏名字,即没有名称<br>匿名函数: 没有名字的函数<br>lambda表达式<br>python中,使用lambda表达式构建匿名函数<br>使用 lambda关键字定义匿名函数,格式为lambda[参数列表]:表达式<br>参数列表不需要小括号,无参就不写参数<br>冒号用来分割参数和表达式部分<br>不需要使用return,表达式的值,就是匿名函数的返回值.表达式中不能出现等号.<br>lambda表达式匿名函数只能写在一行上,也称为单行函数.</p>\n<p>匿名函数往往用在高阶函数传参时,使用lambda表达式,往往能简化代码.</p>\n<h1 id=\"递归函数\"><a href=\"#递归函数\" class=\"headerlink\" title=\"递归函数\"></a>递归函数</h1><p>函数执行流程:压栈</p>\n<p>递归函数recursion<br>函数直接或者间接调用自身就是递归.<br>递归需要有边界条件,递归前进段,递归返回段.<br>递归一定要有边界条件.<br>当边界条件不满足的时候,递归前进<br>当边界条件满足的时候,递归返回.</p>\n<p>递归例子:斐波那契数列<br>如果用循环写法:<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">a = 0</span><br><span class=\"line\">b = 1</span><br><span class=\"line\">n = 10</span><br><span class=\"line\">for i in range(n -1):</span><br><span class=\"line\">    a,b=b, a+b</span><br><span class=\"line\">else:</span><br><span class=\"line\">    print(b)</span><br></pre></td></tr></table></figure></p>\n<p>递归写法:<br>def fib(n):<br>    return 1 if n &lt;3 else fib(n-1) +fib(n-2)</p>\n<p>递归要求<br>递归一定要有退出条件,递归调用一定要执行到这个条件,没有退出条件的递归调用.<br>递归调用的深度不宜<br>python 对递归调用的深度做了限制,以保护解释器<br>超过递归深度限制,抛出recursionError:maxinum recursion depth exceeded 超过最大深度<br>sys.getrecursionlimit()</p>\n<p>循环稍微复杂一些,但是只要不是死循环, 可以多次迭代直至算出结果.<br>递归还有深度限制, 如果递归复杂, 函数反复压栈 ,栈内存很快就溢出了.</p>\n<p>递归是一种很自然的表达,符合逻辑思维<br>递归相对效率低,每一次调用都要开辟栈帧.<br>递归有深度限制,如果递归层次太深,函数反复压栈,栈内存很快就溢出了.<br>如果是有限次数的递归, 可以使用递归调用, 或者使用循环代替 ,循环代码稍微复杂一些,但是只要不是死循环,可以多次迭代直至算出结果.<br>绝大多数递归,都可以使用循环实现<br>即使递归代码很简洁,但是能不用则不用递归.</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>生成器generator<br>生成器指的是生成器对象,可以由生成器表达式得到,也可以使用yield关键字得到一个生成器函数,调用这个函数得到一个生成器.<br>生成器对象,是一个可迭代对象,是有个迭代器.<br>生成器对象,是延时计算,惰性求值的.</p>\n<p>函数体中包含yield语句的函数,就是生成器函数,调用后返回生成器对象.<br>普通函数调用,函数会立即执行直到执行完毕.<br>生成器函数的调用,并不会立即执行函数体, 而是需要使用next函数来驱动生成器函数来执行获得的生成器对象.<br>生成器表达式和生成器函数都可以得到生成器对象,只不过生成器函数可以写的更加复杂的逻辑.</p>\n<p>在生成器函数中,可以多次yield,没执行一次后会暂停执行,把yield表达式的值返回<br>再执行会执行到下一个yield语句又会暂停执行<br>return会导致当前函数返回,无法继续执行,也无法继续获取下一个值,抛出stoplteraton异常.<br>如果函数没有显示的return语句如果生成器函数执行到结尾,一样会抛出stoplterration<br>生成器函数<br>包含yield语句的生成器函数调用后,生成器对象的时候,生成器函数的函数体不会立即执行<br>next会从函数的当前位置向后执行到之后碰到的第一个yield语句,会弹出值,并暂停函数执行.<br>再次调用next函数,和上一条一样的处理过程.<br>继续调用next函数,生产器函数如果结束执行了,会抛出stoplteration异常.</p>\n<p>协程<br>生成器的高级用法<br>他比进程,线程轻量级,是在用户空间调度函数的一种实现.<br>协程调度器实现思路<br>协程是一种非抢占式调度.</p>\n<p>yield from 语法<br>yield from就是一种简化语法的语法糖.</p>\n<h1 id=\"yield-和return的区别\"><a href=\"#yield-和return的区别\" class=\"headerlink\" title=\"yield 和return的区别\"></a>yield 和return的区别</h1><p>带有yield 的函数在python被称为generator,return和yield的形式和用法很像,下面fib数列来对比一下yield 和return</p>\n<p>如何生成斐波那契数列:<br>斐波那契（Fibonacci）数列是一个非常简单的递归数列，除第一个和第二个数外，任意一个数都可由前两个数相加得到。用计算机程序输出斐波那契數列的前 N 个数是一个非常简单的问题，许多初学者都可以轻易写出如下函数.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fab(max):</span><br><span class=\"line\">    a, b = 1, 1</span><br><span class=\"line\">    n = 1</span><br><span class=\"line\">    while n &lt; max:</span><br><span class=\"line\">        print(b)</span><br><span class=\"line\">        a, b = b, a+b</span><br><span class=\"line\">        n +=1</span><br><span class=\"line\">fab(20)</span><br></pre></td></tr></table></figure>\n<p>结果没有问题, 但有经验的开发者指出,直接在fab函数中用print打印数字会导致该函数可复用性较差, 因为fab函数返回none, 其他函数无法获得该函数生成的数列.<br>要提高fab函数的可复用性, 最好不要直接打印出数列,而是返回一个list.以下fab函数改写后的第二个版本.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">def fab(max):</span><br><span class=\"line\">    n, a, b = 0, 0, 1</span><br><span class=\"line\">    l = []</span><br><span class=\"line\">    while  n &lt; max:</span><br><span class=\"line\">        l.append(b)</span><br><span class=\"line\">        b = b+a</span><br><span class=\"line\">        a = b-a</span><br><span class=\"line\">        n = n+1</span><br><span class=\"line\">    return l</span><br></pre></td></tr></table></figure></p>\n<p>改写后的fab函数通过返回list能满足复用性的要求, 但是更有经验的开发者会指出,<br>该函数在运行中占用的内存会随着参数max的增大而增大, 如果要控制内存占用,最好不要<br>用list来保存中间结果, 而是通过iterable对象来迭代.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">class Fab(object): </span><br><span class=\"line\"> </span><br><span class=\"line\">   def __init__(self, max): </span><br><span class=\"line\">       self.max = max </span><br><span class=\"line\">       self.n, self.a, self.b = 0, 0, 1 </span><br><span class=\"line\"> </span><br><span class=\"line\">   def __iter__(self): </span><br><span class=\"line\">       return self </span><br><span class=\"line\"> </span><br><span class=\"line\">   def next(self): </span><br><span class=\"line\">       if self.n &lt; self.max: </span><br><span class=\"line\">           r = self.b </span><br><span class=\"line\">           self.b = self.a + self.b</span><br><span class=\"line\">           self.a = self.b - self.a</span><br><span class=\"line\">           self.n = self.n + 1 </span><br><span class=\"line\">           return r </span><br><span class=\"line\">       raise StopIteration()</span><br></pre></td></tr></table></figure>\n<p>然而,使用class改写的这个版本,代码远远没有第一版的fab函数来的简洁,如果我们想要保持第一版fab函数的简洁性, 同时又要获得iterable的效果, yield就派上用场了:<br>def fab(max):<br>    n, a, b = 0, 0, 1<br>    while n &lt; max:<br>        yield b<br>        b =  b+a<br>        a = b-a<br>        n = n + 1</p>\n<p>第四个版本的fab和第一版相比, 仅仅把print b改为 yield b, 就在保持简洁性的同时获得了iterable的效果<br>调用第四版的fab和第二版的fab完全一致:</p>\n<p>简单地将,yield的作用就是把一个函数变为一个generator, 带有yield的函数不再是一个普通函数, python解释器会将其视为一个generator, 调用fab不会执行fab函数,而是返回一个iterable对象 在for循环执行时 ,每次循环都会执行fab函数内部的代码,执行到yield b时,fab函数就返回一个迭代值,下次迭代时,代码yield的下一条语句继续执行,<br>而函数的本地变量看起来和上次中断执行前是完全一样的.于是函数继续执行,直到再次遇到yield.也可以手动调用fab(5)的next()方法<br>这样我们就可以清楚看到fab的执行流程.</p>\n<h1 id=\"高阶函数\"><a href=\"#高阶函数\" class=\"headerlink\" title=\"高阶函数\"></a>高阶函数</h1><p>函数也是对象, 是可调用对象<br>函数可以作为普通变量,也可以作为函数的参数, 返回值.</p>\n<p>在数学和计算机科学中, 高阶函数应当是至少满足下面一个条件的函数<br>接受一个或多个函数作为参数<br>输出一个函数</p>\n<p>排序sorted<br>排序函数,可以接受key作为参数进行排序,不改变序列的原有值.<br>排序也是在程序中经常用到的算法,key指定的函数将作用于list的每一个元素上,并根据key函数返回的结果进行排序,对比原始的list和经过key=abs处理过的list.<br>然后sorted()函数按照keys进行排序,并按照对应关系返回list相应的元素.</p>\n<p>过滤filter<br>对可迭代对象进行遍历,返回一个迭代器<br>function参数是一个参数的函数, 且返回值应当是bool类型,或其返回值等效布尔值<br>function参数如果是None, 可迭代对象的每一个元素自身等效布尔值.</p>\n<p>映射map<br>对多个可迭代对象的元素,按照指定的函数进行映射<br>返回一个迭代器</p>\n<h1 id=\"柯里化\"><a href=\"#柯里化\" class=\"headerlink\" title=\"柯里化\"></a>柯里化</h1><p>指的是将原来接受两个参数的函数变为新的接受一个参数的函数的过程.新的函数返回一个以原有第二个参数为参数的函数.</p>\n"},{"title":"python文件io","_content":"# 文件io常用操作\n一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io\nopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取\nseek: 文件指针操作 tell: 指针位置\n\n打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.\n文件操作中,最常用的操作就是读和写.\n文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.\n注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.\nopen的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.\nmode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件\na: 写入打开,如果文件存在,则追加\nb:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力.\n\nopen默认是只读模式r打开已经存在的文件.\n\n文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOF\nbuffering:缓冲区\n0:只在二进制模式打开,表示关buffer\n1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush\n大于1:用于指定buffer的大小.\n\n# 上下文管理\n\n1.异常处理\n当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.\n使用finally可以保证打开的文件可以被关闭.\n2.上下文管理\n一种特殊的语法, 交给解释器去释放文件对象.\n使用with ... as关键字\n上下文管理的语句并不会开启新的作用域\nwith语句执行的时候,自动关闭文件对象.\n```\nf1 = open('text')\nwith f1:\n    f1.write('abc')\nf1.closed\n```\n对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源\nio被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题.\n\nStringIO和BytesIO\nStringIO\nio模块中的类\nfrom io import StringIO\n内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.\n当close方法被调用的时候,这个buffer被释放.\n\n好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率.\n\nBytesIO\nio模块中的类\nfrom io import BytesIO\n内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.\n当close方法被调用的时候, 这个buffer会释放.\n\n\nfile-like对象\n类文件对象,可以像文件一样操作\nsocket对象,输入输出对象都是类文件对象.\n\n\n# 路径操作\n\nfrom os import path\n3.4版本开始\n建议使用pathlib模块,提供path对象来操作.包括目录和文件\nPathlib模块\n\n目录操作初始化\n路径拼接和分解\n操作符\n分解\njoinpath\n\n\n# 通配符\nglob通配给定的模式\nrglob通配给定的模式,递归目录\n都返回一个生成器\n?代表一个字符\n*表示任意个字符\n[abc]或[a-z]表示一个字符\n\n匹配\nmatch(pattern)\n模式匹配,成功返回True\n\n文件操作\nos模块\nos.name windows是nt, linux是posix\nos.uname() *nix支持\nsys.platform windows显示win32, linux 显示linux\nos.listdir返回指定目录内容列表, 不递归\nos也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似.\n\n# shutil模块\n文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.\npython提供了一个方便的shutil(高级文件操作)\ncopy复制\ncopyfileobj(fsrc, fdst[, length])\n\n文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.\n```\nimport shutil\nwith open ('text', 'r+') as f:\n    f.write('abcd')\n    with open('text1', 'w+') as f1:\n        shutil.copyfileobj(f, f1)\n\n```\n复制文件内容,不含元数据,src,dst为文件的路径字符串.\n\n# rm删除\nshutil.rmtree(path, ignore_errors=False, oneerror=None)\n递归删除,如同rm -rf一样危险,慎用.\n他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.\nshutil.retree(\"text\") 类似rm -rf\n\n# move移动\n\n递归移动文件,目标到目标,返回目标\n本身使用的是os.rename方法\n如果不支持rename,如果是目录则copytree再删除源目录.\nshutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz\n\n# csv文件\ncsv是一个被行分隔符,列分割符划分成行和列的文本文件.\ncsv不指定字符编码.\n行分割符为\\r\\n,最后一行可以没有换行符.\n列分割符常用逗号或者制表符.\n每一行称为一条记录record.\n字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.\ncsv模块\n返回reader对象,是一个行迭代器\n默认使用excel方言.\ndelimiter列分割符,逗号.\nlineterminator行分割符\\r\\n\n\n# ini文件处理\n\n作为配置文件,ini文件格式的很流行.\n\n中括号里面的部分称为section,译作节,区, 段\n每一个section内, 都是key=value形成的键值对,key称为option选项.\n注意这里的DEFAULT是缺省section的名字,必须大写.\nconfigparser\nconfigparser模块的configparser类就是用来操作.\n可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典.\n\n# 序列化和反序列化\n\n为什么要序列化\n内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.\n要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.\nserialization序列化\n将内存中对象存储下来,把他变为一个个字节.\ndeserialization反序列化\n将文件的一个个字节恢复成内存中的对象\n序列化保存到文件就是持久化\n可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化\npython提供了pickle库\n\ndumps 对象序列化为bytes对象\ndump 对象序列化到文件对象,就是存入文件\nloads 从bytes对象反序列化\nload 对象反序列化,从文件读取数据\n\n序列化应用\n一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.\n将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用\n但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.\n但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.\n不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型\njson\njson的数据类型\n\n\nmessagepack\nmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.\n他可以像json那样,在许多语言之间交换结构对象.\n但是他比json更快速也跟轻巧.\n支持python.ruby,java等众多语言,\n兼容json 和pickle\n\n安装pip install msgpack\n\n常用方法序列化对象,提供dumps来兼容pickle和json\nunpackb反序列化对象.提供了loads来兼容.\npack序列化对象保存到文件对象,提供了dump来兼容.\nunpack反序列化对象保存到文件对象,提供了load来兼容.\nmessagepack简单易用,高效压缩,支持语言丰富.\n所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.\n\n\n\n\n\n\n\n\n\n\n\n","source":"_posts/1 (17).md","raw":"---\ntitle: python文件io\n\ncategories: \n- python\ntags:\n- python\n---\n# 文件io常用操作\n一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io\nopen:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取\nseek: 文件指针操作 tell: 指针位置\n\n打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.\n文件操作中,最常用的操作就是读和写.\n文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.\n注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.\nopen的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.\nmode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件\na: 写入打开,如果文件存在,则追加\nb:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力.\n\nopen默认是只读模式r打开已经存在的文件.\n\n文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOF\nbuffering:缓冲区\n0:只在二进制模式打开,表示关buffer\n1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush\n大于1:用于指定buffer的大小.\n\n# 上下文管理\n\n1.异常处理\n当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.\n使用finally可以保证打开的文件可以被关闭.\n2.上下文管理\n一种特殊的语法, 交给解释器去释放文件对象.\n使用with ... as关键字\n上下文管理的语句并不会开启新的作用域\nwith语句执行的时候,自动关闭文件对象.\n```\nf1 = open('text')\nwith f1:\n    f1.write('abc')\nf1.closed\n```\n对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源\nio被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题.\n\nStringIO和BytesIO\nStringIO\nio模块中的类\nfrom io import StringIO\n内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.\n当close方法被调用的时候,这个buffer被释放.\n\n好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率.\n\nBytesIO\nio模块中的类\nfrom io import BytesIO\n内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.\n当close方法被调用的时候, 这个buffer会释放.\n\n\nfile-like对象\n类文件对象,可以像文件一样操作\nsocket对象,输入输出对象都是类文件对象.\n\n\n# 路径操作\n\nfrom os import path\n3.4版本开始\n建议使用pathlib模块,提供path对象来操作.包括目录和文件\nPathlib模块\n\n目录操作初始化\n路径拼接和分解\n操作符\n分解\njoinpath\n\n\n# 通配符\nglob通配给定的模式\nrglob通配给定的模式,递归目录\n都返回一个生成器\n?代表一个字符\n*表示任意个字符\n[abc]或[a-z]表示一个字符\n\n匹配\nmatch(pattern)\n模式匹配,成功返回True\n\n文件操作\nos模块\nos.name windows是nt, linux是posix\nos.uname() *nix支持\nsys.platform windows显示win32, linux 显示linux\nos.listdir返回指定目录内容列表, 不递归\nos也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似.\n\n# shutil模块\n文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.\npython提供了一个方便的shutil(高级文件操作)\ncopy复制\ncopyfileobj(fsrc, fdst[, length])\n\n文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.\n```\nimport shutil\nwith open ('text', 'r+') as f:\n    f.write('abcd')\n    with open('text1', 'w+') as f1:\n        shutil.copyfileobj(f, f1)\n\n```\n复制文件内容,不含元数据,src,dst为文件的路径字符串.\n\n# rm删除\nshutil.rmtree(path, ignore_errors=False, oneerror=None)\n递归删除,如同rm -rf一样危险,慎用.\n他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.\nshutil.retree(\"text\") 类似rm -rf\n\n# move移动\n\n递归移动文件,目标到目标,返回目标\n本身使用的是os.rename方法\n如果不支持rename,如果是目录则copytree再删除源目录.\nshutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz\n\n# csv文件\ncsv是一个被行分隔符,列分割符划分成行和列的文本文件.\ncsv不指定字符编码.\n行分割符为\\r\\n,最后一行可以没有换行符.\n列分割符常用逗号或者制表符.\n每一行称为一条记录record.\n字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.\ncsv模块\n返回reader对象,是一个行迭代器\n默认使用excel方言.\ndelimiter列分割符,逗号.\nlineterminator行分割符\\r\\n\n\n# ini文件处理\n\n作为配置文件,ini文件格式的很流行.\n\n中括号里面的部分称为section,译作节,区, 段\n每一个section内, 都是key=value形成的键值对,key称为option选项.\n注意这里的DEFAULT是缺省section的名字,必须大写.\nconfigparser\nconfigparser模块的configparser类就是用来操作.\n可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典.\n\n# 序列化和反序列化\n\n为什么要序列化\n内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.\n要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.\nserialization序列化\n将内存中对象存储下来,把他变为一个个字节.\ndeserialization反序列化\n将文件的一个个字节恢复成内存中的对象\n序列化保存到文件就是持久化\n可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化\npython提供了pickle库\n\ndumps 对象序列化为bytes对象\ndump 对象序列化到文件对象,就是存入文件\nloads 从bytes对象反序列化\nload 对象反序列化,从文件读取数据\n\n序列化应用\n一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.\n将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用\n但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.\n但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.\n不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型\njson\njson的数据类型\n\n\nmessagepack\nmessagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.\n他可以像json那样,在许多语言之间交换结构对象.\n但是他比json更快速也跟轻巧.\n支持python.ruby,java等众多语言,\n兼容json 和pickle\n\n安装pip install msgpack\n\n常用方法序列化对象,提供dumps来兼容pickle和json\nunpackb反序列化对象.提供了loads来兼容.\npack序列化对象保存到文件对象,提供了dump来兼容.\nunpack反序列化对象保存到文件对象,提供了load来兼容.\nmessagepack简单易用,高效压缩,支持语言丰富.\n所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.\n\n\n\n\n\n\n\n\n\n\n\n","slug":"1 (17)","published":1,"date":"2019-04-28T11:41:45.128Z","updated":"2019-06-19T14:48:36.385Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8c40025jkufktmc3o5m","content":"<h1 id=\"文件io常用操作\"><a href=\"#文件io常用操作\" class=\"headerlink\" title=\"文件io常用操作\"></a>文件io常用操作</h1><p>一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io<br>open:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取<br>seek: 文件指针操作 tell: 指针位置</p>\n<p>打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.<br>文件操作中,最常用的操作就是读和写.<br>文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.<br>注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.<br>open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.<br>mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件<br>a: 写入打开,如果文件存在,则追加<br>b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力.</p>\n<p>open默认是只读模式r打开已经存在的文件.</p>\n<p>文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOF<br>buffering:缓冲区<br>0:只在二进制模式打开,表示关buffer<br>1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush<br>大于1:用于指定buffer的大小.</p>\n<h1 id=\"上下文管理\"><a href=\"#上下文管理\" class=\"headerlink\" title=\"上下文管理\"></a>上下文管理</h1><p>1.异常处理<br>当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.<br>使用finally可以保证打开的文件可以被关闭.<br>2.上下文管理<br>一种特殊的语法, 交给解释器去释放文件对象.<br>使用with … as关键字<br>上下文管理的语句并不会开启新的作用域<br>with语句执行的时候,自动关闭文件对象.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1 = open(&apos;text&apos;)</span><br><span class=\"line\">with f1:</span><br><span class=\"line\">    f1.write(&apos;abc&apos;)</span><br><span class=\"line\">f1.closed</span><br></pre></td></tr></table></figure></p>\n<p>对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源<br>io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题.</p>\n<p>StringIO和BytesIO<br>StringIO<br>io模块中的类<br>from io import StringIO<br>内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.<br>当close方法被调用的时候,这个buffer被释放.</p>\n<p>好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率.</p>\n<p>BytesIO<br>io模块中的类<br>from io import BytesIO<br>内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.<br>当close方法被调用的时候, 这个buffer会释放.</p>\n<p>file-like对象<br>类文件对象,可以像文件一样操作<br>socket对象,输入输出对象都是类文件对象.</p>\n<h1 id=\"路径操作\"><a href=\"#路径操作\" class=\"headerlink\" title=\"路径操作\"></a>路径操作</h1><p>from os import path<br>3.4版本开始<br>建议使用pathlib模块,提供path对象来操作.包括目录和文件<br>Pathlib模块</p>\n<p>目录操作初始化<br>路径拼接和分解<br>操作符<br>分解<br>joinpath</p>\n<h1 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h1><p>glob通配给定的模式<br>rglob通配给定的模式,递归目录<br>都返回一个生成器<br>?代表一个字符<br>*表示任意个字符<br>[abc]或[a-z]表示一个字符</p>\n<p>匹配<br>match(pattern)<br>模式匹配,成功返回True</p>\n<p>文件操作<br>os模块<br>os.name windows是nt, linux是posix<br>os.uname() *nix支持<br>sys.platform windows显示win32, linux 显示linux<br>os.listdir返回指定目录内容列表, 不递归<br>os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似.</p>\n<h1 id=\"shutil模块\"><a href=\"#shutil模块\" class=\"headerlink\" title=\"shutil模块\"></a>shutil模块</h1><p>文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.<br>python提供了一个方便的shutil(高级文件操作)<br>copy复制<br>copyfileobj(fsrc, fdst[, length])</p>\n<p>文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import shutil</span><br><span class=\"line\">with open (&apos;text&apos;, &apos;r+&apos;) as f:</span><br><span class=\"line\">    f.write(&apos;abcd&apos;)</span><br><span class=\"line\">    with open(&apos;text1&apos;, &apos;w+&apos;) as f1:</span><br><span class=\"line\">        shutil.copyfileobj(f, f1)</span><br></pre></td></tr></table></figure></p>\n<p>复制文件内容,不含元数据,src,dst为文件的路径字符串.</p>\n<h1 id=\"rm删除\"><a href=\"#rm删除\" class=\"headerlink\" title=\"rm删除\"></a>rm删除</h1><p>shutil.rmtree(path, ignore_errors=False, oneerror=None)<br>递归删除,如同rm -rf一样危险,慎用.<br>他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.<br>shutil.retree(“text”) 类似rm -rf</p>\n<h1 id=\"move移动\"><a href=\"#move移动\" class=\"headerlink\" title=\"move移动\"></a>move移动</h1><p>递归移动文件,目标到目标,返回目标<br>本身使用的是os.rename方法<br>如果不支持rename,如果是目录则copytree再删除源目录.<br>shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz</p>\n<h1 id=\"csv文件\"><a href=\"#csv文件\" class=\"headerlink\" title=\"csv文件\"></a>csv文件</h1><p>csv是一个被行分隔符,列分割符划分成行和列的文本文件.<br>csv不指定字符编码.<br>行分割符为\\r\\n,最后一行可以没有换行符.<br>列分割符常用逗号或者制表符.<br>每一行称为一条记录record.<br>字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.<br>csv模块<br>返回reader对象,是一个行迭代器<br>默认使用excel方言.<br>delimiter列分割符,逗号.<br>lineterminator行分割符\\r\\n</p>\n<h1 id=\"ini文件处理\"><a href=\"#ini文件处理\" class=\"headerlink\" title=\"ini文件处理\"></a>ini文件处理</h1><p>作为配置文件,ini文件格式的很流行.</p>\n<p>中括号里面的部分称为section,译作节,区, 段<br>每一个section内, 都是key=value形成的键值对,key称为option选项.<br>注意这里的DEFAULT是缺省section的名字,必须大写.<br>configparser<br>configparser模块的configparser类就是用来操作.<br>可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典.</p>\n<h1 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h1><p>为什么要序列化<br>内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.<br>要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.<br>serialization序列化<br>将内存中对象存储下来,把他变为一个个字节.<br>deserialization反序列化<br>将文件的一个个字节恢复成内存中的对象<br>序列化保存到文件就是持久化<br>可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化<br>python提供了pickle库</p>\n<p>dumps 对象序列化为bytes对象<br>dump 对象序列化到文件对象,就是存入文件<br>loads 从bytes对象反序列化<br>load 对象反序列化,从文件读取数据</p>\n<p>序列化应用<br>一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.<br>将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用<br>但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.<br>但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.<br>不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型<br>json<br>json的数据类型</p>\n<p>messagepack<br>messagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.<br>他可以像json那样,在许多语言之间交换结构对象.<br>但是他比json更快速也跟轻巧.<br>支持python.ruby,java等众多语言,<br>兼容json 和pickle</p>\n<p>安装pip install msgpack</p>\n<p>常用方法序列化对象,提供dumps来兼容pickle和json<br>unpackb反序列化对象.提供了loads来兼容.<br>pack序列化对象保存到文件对象,提供了dump来兼容.<br>unpack反序列化对象保存到文件对象,提供了load来兼容.<br>messagepack简单易用,高效压缩,支持语言丰富.<br>所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"文件io常用操作\"><a href=\"#文件io常用操作\" class=\"headerlink\" title=\"文件io常用操作\"></a>文件io常用操作</h1><p>一般说io操作,指的是文件io, 如果指的是网络io,都会直接说网络io<br>open:打开 read:读取 write:写入 close:关闭 readline: 行读取 readlines: 多行读取<br>seek: 文件指针操作 tell: 指针位置</p>\n<p>打开操作:打开一个文件,返回一个文件对象和文件描述符,打开文件失败,则返回异常.<br>文件操作中,最常用的操作就是读和写.<br>文件访问的模式有两种:文本模式和二进制模式.不同模式下,操作函数不尽相同,表现的结果也不一样.<br>注: windows中使用codepage代码页,可以认为每一个代码页就是一张编码表.cp936等同于GBK.<br>open的参数:file打开或者要创建的文件名.如果不指定路径,默认是当前路径.<br>mode模式 r:缺省,表示只读打开. w: 只写打开 x:创建并写入一个新文件<br>a: 写入打开,如果文件存在,则追加<br>b:二进制模式 t:缺省,文本模式 +: 读写打开一个文件.给原来只读,只写方式打开提供缺失的读或者写能力.</p>\n<p>open默认是只读模式r打开已经存在的文件.</p>\n<p>文件指针:mode=r, 指针起始在0, mode=a,指针起始在EOF<br>buffering:缓冲区<br>0:只在二进制模式打开,表示关buffer<br>1:只在文本模式使用, 表示使用行缓冲,意思就是见到换行符就flush<br>大于1:用于指定buffer的大小.</p>\n<h1 id=\"上下文管理\"><a href=\"#上下文管理\" class=\"headerlink\" title=\"上下文管理\"></a>上下文管理</h1><p>1.异常处理<br>当出现异常的时候,拦截异常.但是,因为很多代码都可能出现OSError异常,还不好判断异常就是应为资源限制产生的.<br>使用finally可以保证打开的文件可以被关闭.<br>2.上下文管理<br>一种特殊的语法, 交给解释器去释放文件对象.<br>使用with … as关键字<br>上下文管理的语句并不会开启新的作用域<br>with语句执行的时候,自动关闭文件对象.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">f1 = open(&apos;text&apos;)</span><br><span class=\"line\">with f1:</span><br><span class=\"line\">    f1.write(&apos;abc&apos;)</span><br><span class=\"line\">f1.closed</span><br></pre></td></tr></table></figure></p>\n<p>对于类似于文件对象的io对象,一般来说都需要在不使用的时候关闭,注销,以释放资源<br>io被打开的时候,会获得一个文件描述符,计算机资源是有限的,所以操作系统都会做限制,就是为了保护计算机的资源不要被完全耗尽,计算资源是共享的,不是独占的,一般情况下,除非特别明确的知道资源情况,否则不要提高资源的限制值来解决问题.</p>\n<p>StringIO和BytesIO<br>StringIO<br>io模块中的类<br>from io import StringIO<br>内存中,开辟的一个文本模式的buffer,可以像对象一样操作它.<br>当close方法被调用的时候,这个buffer被释放.</p>\n<p>好处:一般来说,磁盘的操作比内存的操作要慢的多,内存足够的情况下,一般的优化思路是少落地,减少磁盘io的过程,可以大大提高程序的运行效率.</p>\n<p>BytesIO<br>io模块中的类<br>from io import BytesIO<br>内存中,开辟的一个二进制模式的buffer, 可以像文件对象一样操作它.<br>当close方法被调用的时候, 这个buffer会释放.</p>\n<p>file-like对象<br>类文件对象,可以像文件一样操作<br>socket对象,输入输出对象都是类文件对象.</p>\n<h1 id=\"路径操作\"><a href=\"#路径操作\" class=\"headerlink\" title=\"路径操作\"></a>路径操作</h1><p>from os import path<br>3.4版本开始<br>建议使用pathlib模块,提供path对象来操作.包括目录和文件<br>Pathlib模块</p>\n<p>目录操作初始化<br>路径拼接和分解<br>操作符<br>分解<br>joinpath</p>\n<h1 id=\"通配符\"><a href=\"#通配符\" class=\"headerlink\" title=\"通配符\"></a>通配符</h1><p>glob通配给定的模式<br>rglob通配给定的模式,递归目录<br>都返回一个生成器<br>?代表一个字符<br>*表示任意个字符<br>[abc]或[a-z]表示一个字符</p>\n<p>匹配<br>match(pattern)<br>模式匹配,成功返回True</p>\n<p>文件操作<br>os模块<br>os.name windows是nt, linux是posix<br>os.uname() *nix支持<br>sys.platform windows显示win32, linux 显示linux<br>os.listdir返回指定目录内容列表, 不递归<br>os也有open,read,write等方法,但是太底层建议使用内建函数open,read ,write,使用方式相似.</p>\n<h1 id=\"shutil模块\"><a href=\"#shutil模块\" class=\"headerlink\" title=\"shutil模块\"></a>shutil模块</h1><p>文件拷贝:使用打开2个文件对象,源文件读取内容,写入目标文件中来完成拷贝过程,但是这样丢失stat数据信息,因为根本没有复制这些信息过去.<br>python提供了一个方便的shutil(高级文件操作)<br>copy复制<br>copyfileobj(fsrc, fdst[, length])</p>\n<p>文件对象的复制,fsrc和fdst是open打开的文件对象,复制内容.fdst要求可写.<br><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">import shutil</span><br><span class=\"line\">with open (&apos;text&apos;, &apos;r+&apos;) as f:</span><br><span class=\"line\">    f.write(&apos;abcd&apos;)</span><br><span class=\"line\">    with open(&apos;text1&apos;, &apos;w+&apos;) as f1:</span><br><span class=\"line\">        shutil.copyfileobj(f, f1)</span><br></pre></td></tr></table></figure></p>\n<p>复制文件内容,不含元数据,src,dst为文件的路径字符串.</p>\n<h1 id=\"rm删除\"><a href=\"#rm删除\" class=\"headerlink\" title=\"rm删除\"></a>rm删除</h1><p>shutil.rmtree(path, ignore_errors=False, oneerror=None)<br>递归删除,如同rm -rf一样危险,慎用.<br>他不是原子操作,有可能删除错误,就会中断,已经删除的就删除了.<br>shutil.retree(“text”) 类似rm -rf</p>\n<h1 id=\"move移动\"><a href=\"#move移动\" class=\"headerlink\" title=\"move移动\"></a>move移动</h1><p>递归移动文件,目标到目标,返回目标<br>本身使用的是os.rename方法<br>如果不支持rename,如果是目录则copytree再删除源目录.<br>shutil 还有打包功能,生成tar并压缩,支持zip,gz,bz,xz</p>\n<h1 id=\"csv文件\"><a href=\"#csv文件\" class=\"headerlink\" title=\"csv文件\"></a>csv文件</h1><p>csv是一个被行分隔符,列分割符划分成行和列的文本文件.<br>csv不指定字符编码.<br>行分割符为\\r\\n,最后一行可以没有换行符.<br>列分割符常用逗号或者制表符.<br>每一行称为一条记录record.<br>字段可以使用双引号括起来,也可以不使用.如果字段中出现了双引号,逗号,换行符必须使用双引号括起来.<br>csv模块<br>返回reader对象,是一个行迭代器<br>默认使用excel方言.<br>delimiter列分割符,逗号.<br>lineterminator行分割符\\r\\n</p>\n<h1 id=\"ini文件处理\"><a href=\"#ini文件处理\" class=\"headerlink\" title=\"ini文件处理\"></a>ini文件处理</h1><p>作为配置文件,ini文件格式的很流行.</p>\n<p>中括号里面的部分称为section,译作节,区, 段<br>每一个section内, 都是key=value形成的键值对,key称为option选项.<br>注意这里的DEFAULT是缺省section的名字,必须大写.<br>configparser<br>configparser模块的configparser类就是用来操作.<br>可以将section当做key,section存储键值对组成的字典,可以吧ini配置文件当成一个且套的字典.默认使用的是有序字典.</p>\n<h1 id=\"序列化和反序列化\"><a href=\"#序列化和反序列化\" class=\"headerlink\" title=\"序列化和反序列化\"></a>序列化和反序列化</h1><p>为什么要序列化<br>内存要中的字典,列表,集合以及各种对象,如何保存到一个文件中.<br>要设计一套协议,按照某种规则,把内存中数据保存到文件中,文件是一个字节序列,所以必须把数据转换成字节序列,输出到文件,这就是序列化,反之,把文件的字节序列恢复到内存并且还是原来的类型.就是反序列化.<br>serialization序列化<br>将内存中对象存储下来,把他变为一个个字节.<br>deserialization反序列化<br>将文件的一个个字节恢复成内存中的对象<br>序列化保存到文件就是持久化<br>可以将数据序列后持久化,或者网络传输,也可以将文件中或者网络收到的字节序列反序列化<br>python提供了pickle库</p>\n<p>dumps 对象序列化为bytes对象<br>dump 对象序列化到文件对象,就是存入文件<br>loads 从bytes对象反序列化<br>load 对象反序列化,从文件读取数据</p>\n<p>序列化应用<br>一般来说本地序列化的情况,应用较少,大多数场景都应用在网络传输中.<br>将数据序列化后通过网络传输到远程结点,远程服务器上的服务将收到数据序列化后,就可以使用<br>但是,要注意一点,大多数项目,都不是单机的,也不是单服务的,需要多个程序之间配合,需要通过网络将数据传送到其他节点上去,这就需要大量的序列化,反序列化的过程.<br>但是,问题是,python程序之间还可以都是用pickle解决序列化,反序列化,如果是跨平台,跨语言,跨协议pickle就不太适合了,就需要公共的协议.<br>不同的协议,效率不同,学习曲线不同,适合不同场景,要根据不同的情况分析选型<br>json<br>json的数据类型</p>\n<p>messagepack<br>messagepack是一个基于二进制高效的对象序列化库,可用于跨语言通信.<br>他可以像json那样,在许多语言之间交换结构对象.<br>但是他比json更快速也跟轻巧.<br>支持python.ruby,java等众多语言,<br>兼容json 和pickle</p>\n<p>安装pip install msgpack</p>\n<p>常用方法序列化对象,提供dumps来兼容pickle和json<br>unpackb反序列化对象.提供了loads来兼容.<br>pack序列化对象保存到文件对象,提供了dump来兼容.<br>unpack反序列化对象保存到文件对象,提供了load来兼容.<br>messagepack简单易用,高效压缩,支持语言丰富.<br>所以,用它序列化也是一种很好的选择,python很多大名鼎鼎的库都是用了msgpack.</p>\n"},{"title":"草稿","password":"mwq","_content":"    在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当\n你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它\n并不真正构造列表。\n我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结\n束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代\n器。list() 函数是另外一个（ 迭代器 ），\n它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，\n它能够用来遍历标准模板库容器中的部分或全部元素，\n每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，\n所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。\n然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。\n\n整理:3.29\n\n\n回顾: 整型分长短,但在python3中已经没有了\nbool 是整型的子类\nmath.sqrt 看帮助 官方文档\nbin() 返回的字符串\ntype isinstance\nlist 是可迭代对象\nindex 匹配 count 匹配的次数\nextend 魔术方法\n\"{},{}\".format(1.2)\n\n* **随机数**\ninstantiate 实例\nfields领域\nrandom模块\nimport random \nrandom.randint(1.2)\nrandom.choice随机取数字 不均匀\nfor i in range(10):\nsample 取样\n元组: 不可变\n命令元组namedtuple attribute属性特性\n例子:\nPoint = namedtuple('Point',['x','y'])\np = Point(11,y=22)\nnamespace\nexec 当python语句执行\n命名元组,返回一个元组的子类,并定义了字段\n冒泡法 重点\nmap高阶函数 映射\naplit 默认使用空白字符分隔\nmaxsplit\nreplace\nstrip 默认去掉字符两端的空白字符\nfind 时间复杂度和index一样遍历\nformat 函数格式字符串语法 \n\"{}\".format()\n参数解构*\n\"{}\".format(3**0.5)\n序列都可以用in\n内置函数 5*14 itertor迭代器\n\n冒泡法:经典排序算法\n>for i in range(n):\n>    for j in range(n-i):\n>        num[j],num[j+1] = num[j+1],num[j]\n>print()\n内置函数说明\nlen(s)\n返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）\nzip()\n创建一个聚合来自每个可迭代对象中元素的迭代器\n返回一个元组的迭代器,其中\n我们已经知道,可以直接作用于for循环的数据类型有以下几种:\n一类是集合数据类型,如list tuple dictionary set str\n一类是generator ,包括生成器和带yield的generator function\n这些可以直接作用于for循环的对象统称为可迭代对象:iterable\n而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.\n\n# pythonnic\nPython的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:\n\n# 不够Pythonic\nif a < b and a > c:\n    pass\n\n# python里却可以这么写\nif c < a < b:\n    pass\n\n# bad\ni = 0\nwhile i < mylist_length:\n    do_something(mylist[i])\n    i += 1\n\n# good\nfor element in mylist:\n   do_something(element)\n\n# bad, 不要使用默认可变对象作为默认参数\ndef f(a, b=[])\n    pass\n\n# good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题\ndef f(a, b=None):\n    if b is None:\n        b = []\nPython有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。\n\n# 列表生成式:\nlist comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式\n举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))\n但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n\n>>> L = []\n>>> for x in range(1, 11):\n...    L.append(x * x)\n...\n>>> L\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\nc 程序主要包括以下部分\n预处理指令\n函数\n变量\n语句\n注释\n# include <stdio.h>\nint main()\n{\n    print(\"hello world\");\n    return 0;\n}\n\n# python 中的对象\n对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.\nPython对象的多态性\n\n　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？\n　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject*变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject *变量来保存和维护这个对象，而是通过PyObject *，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject*)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。\n\n# python标准库\n\n文本处理服务:string re textwrap\n二进制数据服务\n数据类型\n数字和数学模块\n函数式编程模块\n文件和目录访问\n数据持久化\n数据压缩和存档\n文件格式\n加密服务\n通用操作系统服务 os io time\n并发执行 threading\n网络和进程间通信\n互联网数据处理 email json \n结构化标记处理工具 html xml\n互联网协议和支持 urllib.request http.server\n多媒体服务 imghdr\n国际化\n程序框架 cmd turtle\nTk图形用户界面 GUI\n开发工具 调试和分析\n软件打包和分发 venv\npython运行时服务 sysbuiltins   gc垃圾回收器接口\n自定义python解释器\n导入模块\npython语言服务\n杂项服务\nwindows系统相关模块\nunix专有服务\n被取代的模块\n未创建文档的模块\n\nnone 与NUll的区别\n表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为\n0,因为0是有意义的,而none是一个特殊的空值\n判断的时候 均是false\n属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被\n调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.\n\n功能性函数返回都为none\nNone是一个特殊的常量。\nNone和False不同。\nNone不是0。\nNone不是空字符串。\nNone和任何其他的数据类型比较永远返回False。\nNone有自己的数据类型NoneType。\n你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。\nL.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。\n\n单星号(*):*args 将所以参数以元组(tuple)的形式导入:\n还有解压参数\n双星号以字典的形式导入\n\n\n# 字典 \n\n字典是python的半壁江山 要熟练\n可变的 ,无序的,key不重复\nd[key]\n返回key对应的值value\nkey不存在抛出keyerror异常\n\nget(key[,defalut])\n返回key对应的值value\nkey不存在返回缺省值,如果没有设置缺省值就返回none\n\nsetdefalut(key[,default])\n返回key对应的值value\nkey不存在,添加kv对,value设置为default,并返回default\n\n字典增加和修改\n\nd[key] = value\n将key对应的值修改为value\nkey不存在添加新的kv对\n\nupdata([other])\n使用另一个字典的kv对更新本字典\nkey不存在,就添加\nkey存在,覆盖已经存在的key对应的值\n就地修改\n\n字典删除\n\npop(key[,default])\nkey不存在,移除他,并返回它的value\nkey不存在,返回给定的default\ndefault未设置,key不存在则抛出Keyerror异常\npopitem()\n移除并返回一个任意的键值对\n字典为empty,抛出KEyerror\nclear()\n清空字典\n\n字典删除\ndel语句\na = True\nb = [6]\n\n字典遍历\nfor ...in dict\n遍历key\nfor k in d:\nprint(k)\n\nkey的要求和set的元素要求一致\nset的元素可以就是看做key,set可以看做dict的简化版\nhashable可哈希才可以作为key, 可以使用hash()测试\n\ndefaultdict\n\n# 解析式\n\n列表解析list comprehension\n\n语法\n返回值 for 元素 in 可迭代 对象if 条件\n使用中括号[],内部是for循环,if条件语句可选\n返回一个新的列表\n\n列表解析式是一种语法糖\n编译器会优化,不会因为简写而影响效率,反而因优化提高了效率\n\n# 生成器\n\npython三剑客 生成器 装饰器 描述器\n熟练运用\n生成器表达式是按需计算 或惰性求值,延迟计算\n列表解析式是立即返回值\n生成器 是可迭代对象 迭代器\n\n生成器表达式**\n单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表\n生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存\n列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据\n\n计算速度\n单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长\n但是生成器本身并没有返回任何值,只返回一个生成器对象\n列表解析式构造并返回了一个新的列表,所以看起来耗时了\n\n类似:字典,集合解析式\n\n# collections 容器数据类型\n这个模块实现了特定目标的容器\nnametuple 创建命名元组子类的工厂函数\n\ncounter 字典的子类,提供了可哈希对象的计数功能\nOrderedDict 字典的子类,保存了他们被添加的顺序\ndefaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.","source":"_posts/1 (20).md","raw":"---\ntitle: 草稿\n\npassword: mwq\n---\n    在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当\n你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它\n并不真正构造列表。\n我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结\n束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代\n器。list() 函数是另外一个（ 迭代器 ），\n它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，\n它能够用来遍历标准模板库容器中的部分或全部元素，\n每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，\n所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。\n然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。\n\n整理:3.29\n\n\n回顾: 整型分长短,但在python3中已经没有了\nbool 是整型的子类\nmath.sqrt 看帮助 官方文档\nbin() 返回的字符串\ntype isinstance\nlist 是可迭代对象\nindex 匹配 count 匹配的次数\nextend 魔术方法\n\"{},{}\".format(1.2)\n\n* **随机数**\ninstantiate 实例\nfields领域\nrandom模块\nimport random \nrandom.randint(1.2)\nrandom.choice随机取数字 不均匀\nfor i in range(10):\nsample 取样\n元组: 不可变\n命令元组namedtuple attribute属性特性\n例子:\nPoint = namedtuple('Point',['x','y'])\np = Point(11,y=22)\nnamespace\nexec 当python语句执行\n命名元组,返回一个元组的子类,并定义了字段\n冒泡法 重点\nmap高阶函数 映射\naplit 默认使用空白字符分隔\nmaxsplit\nreplace\nstrip 默认去掉字符两端的空白字符\nfind 时间复杂度和index一样遍历\nformat 函数格式字符串语法 \n\"{}\".format()\n参数解构*\n\"{}\".format(3**0.5)\n序列都可以用in\n内置函数 5*14 itertor迭代器\n\n冒泡法:经典排序算法\n>for i in range(n):\n>    for j in range(n-i):\n>        num[j],num[j+1] = num[j+1],num[j]\n>print()\n内置函数说明\nlen(s)\n返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）\nzip()\n创建一个聚合来自每个可迭代对象中元素的迭代器\n返回一个元组的迭代器,其中\n我们已经知道,可以直接作用于for循环的数据类型有以下几种:\n一类是集合数据类型,如list tuple dictionary set str\n一类是generator ,包括生成器和带yield的generator function\n这些可以直接作用于for循环的对象统称为可迭代对象:iterable\n而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.\n\n# pythonnic\nPython的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:\n\n# 不够Pythonic\nif a < b and a > c:\n    pass\n\n# python里却可以这么写\nif c < a < b:\n    pass\n\n# bad\ni = 0\nwhile i < mylist_length:\n    do_something(mylist[i])\n    i += 1\n\n# good\nfor element in mylist:\n   do_something(element)\n\n# bad, 不要使用默认可变对象作为默认参数\ndef f(a, b=[])\n    pass\n\n# good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题\ndef f(a, b=None):\n    if b is None:\n        b = []\nPython有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。\n\n# 列表生成式:\nlist comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式\n举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))\n但如果要生成[1x1, 2x2, 3x3, ..., 10x10]怎么做？方法一是循环：\n\n>>> L = []\n>>> for x in range(1, 11):\n...    L.append(x * x)\n...\n>>> L\n[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]\n\nc 程序主要包括以下部分\n预处理指令\n函数\n变量\n语句\n注释\n# include <stdio.h>\nint main()\n{\n    print(\"hello world\");\n    return 0;\n}\n\n# python 中的对象\n对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.\nPython对象的多态性\n\n　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？\n　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject*变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject *变量来保存和维护这个对象，而是通过PyObject *，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject*)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。\n\n# python标准库\n\n文本处理服务:string re textwrap\n二进制数据服务\n数据类型\n数字和数学模块\n函数式编程模块\n文件和目录访问\n数据持久化\n数据压缩和存档\n文件格式\n加密服务\n通用操作系统服务 os io time\n并发执行 threading\n网络和进程间通信\n互联网数据处理 email json \n结构化标记处理工具 html xml\n互联网协议和支持 urllib.request http.server\n多媒体服务 imghdr\n国际化\n程序框架 cmd turtle\nTk图形用户界面 GUI\n开发工具 调试和分析\n软件打包和分发 venv\npython运行时服务 sysbuiltins   gc垃圾回收器接口\n自定义python解释器\n导入模块\npython语言服务\n杂项服务\nwindows系统相关模块\nunix专有服务\n被取代的模块\n未创建文档的模块\n\nnone 与NUll的区别\n表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为\n0,因为0是有意义的,而none是一个特殊的空值\n判断的时候 均是false\n属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被\n调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.\n\n功能性函数返回都为none\nNone是一个特殊的常量。\nNone和False不同。\nNone不是0。\nNone不是空字符串。\nNone和任何其他的数据类型比较永远返回False。\nNone有自己的数据类型NoneType。\n你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。\nL.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。\n\n单星号(*):*args 将所以参数以元组(tuple)的形式导入:\n还有解压参数\n双星号以字典的形式导入\n\n\n# 字典 \n\n字典是python的半壁江山 要熟练\n可变的 ,无序的,key不重复\nd[key]\n返回key对应的值value\nkey不存在抛出keyerror异常\n\nget(key[,defalut])\n返回key对应的值value\nkey不存在返回缺省值,如果没有设置缺省值就返回none\n\nsetdefalut(key[,default])\n返回key对应的值value\nkey不存在,添加kv对,value设置为default,并返回default\n\n字典增加和修改\n\nd[key] = value\n将key对应的值修改为value\nkey不存在添加新的kv对\n\nupdata([other])\n使用另一个字典的kv对更新本字典\nkey不存在,就添加\nkey存在,覆盖已经存在的key对应的值\n就地修改\n\n字典删除\n\npop(key[,default])\nkey不存在,移除他,并返回它的value\nkey不存在,返回给定的default\ndefault未设置,key不存在则抛出Keyerror异常\npopitem()\n移除并返回一个任意的键值对\n字典为empty,抛出KEyerror\nclear()\n清空字典\n\n字典删除\ndel语句\na = True\nb = [6]\n\n字典遍历\nfor ...in dict\n遍历key\nfor k in d:\nprint(k)\n\nkey的要求和set的元素要求一致\nset的元素可以就是看做key,set可以看做dict的简化版\nhashable可哈希才可以作为key, 可以使用hash()测试\n\ndefaultdict\n\n# 解析式\n\n列表解析list comprehension\n\n语法\n返回值 for 元素 in 可迭代 对象if 条件\n使用中括号[],内部是for循环,if条件语句可选\n返回一个新的列表\n\n列表解析式是一种语法糖\n编译器会优化,不会因为简写而影响效率,反而因优化提高了效率\n\n# 生成器\n\npython三剑客 生成器 装饰器 描述器\n熟练运用\n生成器表达式是按需计算 或惰性求值,延迟计算\n列表解析式是立即返回值\n生成器 是可迭代对象 迭代器\n\n生成器表达式**\n单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表\n生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存\n列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据\n\n计算速度\n单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长\n但是生成器本身并没有返回任何值,只返回一个生成器对象\n列表解析式构造并返回了一个新的列表,所以看起来耗时了\n\n类似:字典,集合解析式\n\n# collections 容器数据类型\n这个模块实现了特定目标的容器\nnametuple 创建命名元组子类的工厂函数\n\ncounter 字典的子类,提供了可哈希对象的计数功能\nOrderedDict 字典的子类,保存了他们被添加的顺序\ndefaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.","slug":"1 (20)","published":1,"date":"2019-04-01T02:01:12.172Z","updated":"2019-06-19T14:46:58.076Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8c80028jkuff1ibv2rj","content":"<pre><code>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当\n</code></pre><p>你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它<br>并不真正构造列表。<br>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结<br>束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代<br>器。list() 函数是另外一个（ 迭代器 ），<br>它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，<br>它能够用来遍历标准模板库容器中的部分或全部元素，<br>每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，<br>所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。<br>然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p>\n<p>整理:3.29</p>\n<p>回顾: 整型分长短,但在python3中已经没有了<br>bool 是整型的子类<br>math.sqrt 看帮助 官方文档<br>bin() 返回的字符串<br>type isinstance<br>list 是可迭代对象<br>index 匹配 count 匹配的次数<br>extend 魔术方法<br>“{},{}”.format(1.2)</p>\n<ul>\n<li><strong>随机数</strong><br>instantiate 实例<br>fields领域<br>random模块<br>import random<br>random.randint(1.2)<br>random.choice随机取数字 不均匀<br>for i in range(10):<br>sample 取样<br>元组: 不可变<br>命令元组namedtuple attribute属性特性<br>例子:<br>Point = namedtuple(‘Point’,[‘x’,’y’])<br>p = Point(11,y=22)<br>namespace<br>exec 当python语句执行<br>命名元组,返回一个元组的子类,并定义了字段<br>冒泡法 重点<br>map高阶函数 映射<br>aplit 默认使用空白字符分隔<br>maxsplit<br>replace<br>strip 默认去掉字符两端的空白字符<br>find 时间复杂度和index一样遍历<br>format 函数格式字符串语法<br>“{}”.format()<br>参数解构<em><br>“{}”.format(3**0.5)<br>序列都可以用in<br>内置函数 5</em>14 itertor迭代器</li>\n</ul>\n<p>冒泡法:经典排序算法</p>\n<blockquote>\n<p>for i in range(n):<br>   for j in range(n-i):<br>       num[j],num[j+1] = num[j+1],num[j]<br>print()<br>内置函数说明<br>len(s)<br>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）<br>zip()<br>创建一个聚合来自每个可迭代对象中元素的迭代器<br>返回一个元组的迭代器,其中<br>我们已经知道,可以直接作用于for循环的数据类型有以下几种:<br>一类是集合数据类型,如list tuple dictionary set str<br>一类是generator ,包括生成器和带yield的generator function<br>这些可以直接作用于for循环的对象统称为可迭代对象:iterable<br>而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.</p>\n</blockquote>\n<h1 id=\"pythonnic\"><a href=\"#pythonnic\" class=\"headerlink\" title=\"pythonnic\"></a>pythonnic</h1><p>Python的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:</p>\n<h1 id=\"不够Pythonic\"><a href=\"#不够Pythonic\" class=\"headerlink\" title=\"不够Pythonic\"></a>不够Pythonic</h1><p>if a &lt; b and a &gt; c:<br>    pass</p>\n<h1 id=\"python里却可以这么写\"><a href=\"#python里却可以这么写\" class=\"headerlink\" title=\"python里却可以这么写\"></a>python里却可以这么写</h1><p>if c &lt; a &lt; b:<br>    pass</p>\n<h1 id=\"bad\"><a href=\"#bad\" class=\"headerlink\" title=\"bad\"></a>bad</h1><p>i = 0<br>while i &lt; mylist_length:<br>    do_something(mylist[i])<br>    i += 1</p>\n<h1 id=\"good\"><a href=\"#good\" class=\"headerlink\" title=\"good\"></a>good</h1><p>for element in mylist:<br>   do_something(element)</p>\n<h1 id=\"bad-不要使用默认可变对象作为默认参数\"><a href=\"#bad-不要使用默认可变对象作为默认参数\" class=\"headerlink\" title=\"bad, 不要使用默认可变对象作为默认参数\"></a>bad, 不要使用默认可变对象作为默认参数</h1><p>def f(a, b=[])<br>    pass</p>\n<h1 id=\"good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题\"><a href=\"#good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题\" class=\"headerlink\" title=\"good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题\"></a>good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题</h1><p>def f(a, b=None):<br>    if b is None:<br>        b = []<br>Python有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。</p>\n<h1 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式:\"></a>列表生成式:</h1><p>list comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式<br>举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))<br>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>L = []<br>for x in range(1, 11):<br>…    L.append(x * x)<br>…<br>L<br>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>c 程序主要包括以下部分<br>预处理指令<br>函数<br>变量<br>语句<br>注释</p>\n<h1 id=\"include-lt-stdio-h-gt\"><a href=\"#include-lt-stdio-h-gt\" class=\"headerlink\" title=\"include &lt;stdio.h&gt;\"></a>include &lt;stdio.h&gt;</h1><p>int main()<br>{<br>    print(“hello world”);<br>    return 0;<br>}</p>\n<h1 id=\"python-中的对象\"><a href=\"#python-中的对象\" class=\"headerlink\" title=\"python 中的对象\"></a>python 中的对象</h1><p>对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.<br>Python对象的多态性</p>\n<p>　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？<br>　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject<em>变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject </em>变量来保存和维护这个对象，而是通过PyObject <em>，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject</em>)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。</p>\n<h1 id=\"python标准库\"><a href=\"#python标准库\" class=\"headerlink\" title=\"python标准库\"></a>python标准库</h1><p>文本处理服务:string re textwrap<br>二进制数据服务<br>数据类型<br>数字和数学模块<br>函数式编程模块<br>文件和目录访问<br>数据持久化<br>数据压缩和存档<br>文件格式<br>加密服务<br>通用操作系统服务 os io time<br>并发执行 threading<br>网络和进程间通信<br>互联网数据处理 email json<br>结构化标记处理工具 html xml<br>互联网协议和支持 urllib.request http.server<br>多媒体服务 imghdr<br>国际化<br>程序框架 cmd turtle<br>Tk图形用户界面 GUI<br>开发工具 调试和分析<br>软件打包和分发 venv<br>python运行时服务 sysbuiltins   gc垃圾回收器接口<br>自定义python解释器<br>导入模块<br>python语言服务<br>杂项服务<br>windows系统相关模块<br>unix专有服务<br>被取代的模块<br>未创建文档的模块</p>\n<p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p>\n<p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p>\n<p>单星号(<em>):</em>args 将所以参数以元组(tuple)的形式导入:<br>还有解压参数<br>双星号以字典的形式导入</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><p>字典是python的半壁江山 要熟练<br>可变的 ,无序的,key不重复<br>d[key]<br>返回key对应的值value<br>key不存在抛出keyerror异常</p>\n<p>get(key[,defalut])<br>返回key对应的值value<br>key不存在返回缺省值,如果没有设置缺省值就返回none</p>\n<p>setdefalut(key[,default])<br>返回key对应的值value<br>key不存在,添加kv对,value设置为default,并返回default</p>\n<p>字典增加和修改</p>\n<p>d[key] = value<br>将key对应的值修改为value<br>key不存在添加新的kv对</p>\n<p>updata([other])<br>使用另一个字典的kv对更新本字典<br>key不存在,就添加<br>key存在,覆盖已经存在的key对应的值<br>就地修改</p>\n<p>字典删除</p>\n<p>pop(key[,default])<br>key不存在,移除他,并返回它的value<br>key不存在,返回给定的default<br>default未设置,key不存在则抛出Keyerror异常<br>popitem()<br>移除并返回一个任意的键值对<br>字典为empty,抛出KEyerror<br>clear()<br>清空字典</p>\n<p>字典删除<br>del语句<br>a = True<br>b = [6]</p>\n<p>字典遍历<br>for …in dict<br>遍历key<br>for k in d:<br>print(k)</p>\n<p>key的要求和set的元素要求一致<br>set的元素可以就是看做key,set可以看做dict的简化版<br>hashable可哈希才可以作为key, 可以使用hash()测试</p>\n<p>defaultdict</p>\n<h1 id=\"解析式\"><a href=\"#解析式\" class=\"headerlink\" title=\"解析式\"></a>解析式</h1><p>列表解析list comprehension</p>\n<p>语法<br>返回值 for 元素 in 可迭代 对象if 条件<br>使用中括号[],内部是for循环,if条件语句可选<br>返回一个新的列表</p>\n<p>列表解析式是一种语法糖<br>编译器会优化,不会因为简写而影响效率,反而因优化提高了效率</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>python三剑客 生成器 装饰器 描述器<br>熟练运用<br>生成器表达式是按需计算 或惰性求值,延迟计算<br>列表解析式是立即返回值<br>生成器 是可迭代对象 迭代器</p>\n<p>生成器表达式**<br>单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表<br>生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存<br>列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据</p>\n<p>计算速度<br>单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长<br>但是生成器本身并没有返回任何值,只返回一个生成器对象<br>列表解析式构造并返回了一个新的列表,所以看起来耗时了</p>\n<p>类似:字典,集合解析式</p>\n<h1 id=\"collections-容器数据类型\"><a href=\"#collections-容器数据类型\" class=\"headerlink\" title=\"collections 容器数据类型\"></a>collections 容器数据类型</h1><p>这个模块实现了特定目标的容器<br>nametuple 创建命名元组子类的工厂函数</p>\n<p>counter 字典的子类,提供了可哈希对象的计数功能<br>OrderedDict 字典的子类,保存了他们被添加的顺序<br>defaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.</p>\n","site":{"data":{}},"excerpt":"","more":"<pre><code>在不同方面 range() 函数返回的对象表现为它是一个列表，但事实上它并不是。当\n</code></pre><p>你迭代它时，它是一个能够像期望的序列返回连续项的对象；但为了节省空间，它<br>并不真正构造列表。<br>我们称此类对象是 可迭代的，即适合作为那些期望从某些东西中获得连续项直到结<br>束的函数或结构的一个目标（参数）。我们已经见过的 for 语句就是这样一个迭代<br>器。list() 函数是另外一个（ 迭代器 ），<br>它从可迭代（对象）中创建列表:迭代器（iterator）是一种对象，<br>它能够用来遍历标准模板库容器中的部分或全部元素，<br>每个迭代器对象代表容器中的确定的地址。迭代器修改了常规指针的接口，<br>所谓迭代器是一种概念上的抽象：那些行为上像迭代器的东西都可以叫做迭代器。<br>然而迭代器有很多不同的能力，它可以把抽象容器和通用算法有机的统一起来。</p>\n<p>整理:3.29</p>\n<p>回顾: 整型分长短,但在python3中已经没有了<br>bool 是整型的子类<br>math.sqrt 看帮助 官方文档<br>bin() 返回的字符串<br>type isinstance<br>list 是可迭代对象<br>index 匹配 count 匹配的次数<br>extend 魔术方法<br>“{},{}”.format(1.2)</p>\n<ul>\n<li><strong>随机数</strong><br>instantiate 实例<br>fields领域<br>random模块<br>import random<br>random.randint(1.2)<br>random.choice随机取数字 不均匀<br>for i in range(10):<br>sample 取样<br>元组: 不可变<br>命令元组namedtuple attribute属性特性<br>例子:<br>Point = namedtuple(‘Point’,[‘x’,’y’])<br>p = Point(11,y=22)<br>namespace<br>exec 当python语句执行<br>命名元组,返回一个元组的子类,并定义了字段<br>冒泡法 重点<br>map高阶函数 映射<br>aplit 默认使用空白字符分隔<br>maxsplit<br>replace<br>strip 默认去掉字符两端的空白字符<br>find 时间复杂度和index一样遍历<br>format 函数格式字符串语法<br>“{}”.format()<br>参数解构<em><br>“{}”.format(3**0.5)<br>序列都可以用in<br>内置函数 5</em>14 itertor迭代器</li>\n</ul>\n<p>冒泡法:经典排序算法</p>\n<blockquote>\n<p>for i in range(n):<br>   for j in range(n-i):<br>       num[j],num[j+1] = num[j+1],num[j]<br>print()<br>内置函数说明<br>len(s)<br>返回对象的长度（元素个数）。实参可以是序列（如 string、bytes、tuple、list 或 range 等）或集合（如 dictionary、set 或 frozen set 等）<br>zip()<br>创建一个聚合来自每个可迭代对象中元素的迭代器<br>返回一个元组的迭代器,其中<br>我们已经知道,可以直接作用于for循环的数据类型有以下几种:<br>一类是集合数据类型,如list tuple dictionary set str<br>一类是generator ,包括生成器和带yield的generator function<br>这些可以直接作用于for循环的对象统称为可迭代对象:iterable<br>而生成器不但可以作用于for循环,还可以被next()函数不断调用并返回下一个值,直到最后抛出stopiteration错误表示无法继续返回下一个值.</p>\n</blockquote>\n<h1 id=\"pythonnic\"><a href=\"#pythonnic\" class=\"headerlink\" title=\"pythonnic\"></a>pythonnic</h1><p>Python的世界里你会听到这个词”Pythonic”，大概就是指代码符合Python的惯用法，使用的都是Python的语法糖(我觉得可以翻译为『地道』)。比如从其他语言转到Python 的写出来的代码很可能受到以前思维方式的影响(别像 java 一样写一堆 getter/setter)，写出来的代码不够Pythonic: 比如:</p>\n<h1 id=\"不够Pythonic\"><a href=\"#不够Pythonic\" class=\"headerlink\" title=\"不够Pythonic\"></a>不够Pythonic</h1><p>if a &lt; b and a &gt; c:<br>    pass</p>\n<h1 id=\"python里却可以这么写\"><a href=\"#python里却可以这么写\" class=\"headerlink\" title=\"python里却可以这么写\"></a>python里却可以这么写</h1><p>if c &lt; a &lt; b:<br>    pass</p>\n<h1 id=\"bad\"><a href=\"#bad\" class=\"headerlink\" title=\"bad\"></a>bad</h1><p>i = 0<br>while i &lt; mylist_length:<br>    do_something(mylist[i])<br>    i += 1</p>\n<h1 id=\"good\"><a href=\"#good\" class=\"headerlink\" title=\"good\"></a>good</h1><p>for element in mylist:<br>   do_something(element)</p>\n<h1 id=\"bad-不要使用默认可变对象作为默认参数\"><a href=\"#bad-不要使用默认可变对象作为默认参数\" class=\"headerlink\" title=\"bad, 不要使用默认可变对象作为默认参数\"></a>bad, 不要使用默认可变对象作为默认参数</h1><p>def f(a, b=[])<br>    pass</p>\n<h1 id=\"good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题\"><a href=\"#good-可变类型使用-None-作为占位符，因为可变类型可能会被函数修改-副作用-，导致调用代码后边使用它的地方出问题\" class=\"headerlink\" title=\"good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题\"></a>good, 可变类型使用 None 作为占位符，因为可变类型可能会被函数修改(副作用)，导致调用代码后边使用它的地方出问题</h1><p>def f(a, b=None):<br>    if b is None:<br>        b = []<br>Python有一些语法上的坑，比如默认参数只计算一次，不要使用可变类型作为默认参数等，看多了写多了就知道了。尤其是可变类型作为函数参数传入后被改变的情况（函数尽量不要有副作用,这里副作用指的就是修改了传入的可变参数的值），尤其要注意。</p>\n<h1 id=\"列表生成式\"><a href=\"#列表生成式\" class=\"headerlink\" title=\"列表生成式:\"></a>列表生成式:</h1><p>list comprehensions 是python内置的非常简单却强大的可以用来创建list的生成式<br>举个例子 ,要生成list[1,2,3,4,5,6,7,8,9]可以用list(range(1,11))<br>但如果要生成[1x1, 2x2, 3x3, …, 10x10]怎么做？方法一是循环：</p>\n<blockquote>\n<blockquote>\n<blockquote>\n<p>L = []<br>for x in range(1, 11):<br>…    L.append(x * x)<br>…<br>L<br>[1, 4, 9, 16, 25, 36, 49, 64, 81, 100]</p>\n</blockquote>\n</blockquote>\n</blockquote>\n<p>c 程序主要包括以下部分<br>预处理指令<br>函数<br>变量<br>语句<br>注释</p>\n<h1 id=\"include-lt-stdio-h-gt\"><a href=\"#include-lt-stdio-h-gt\" class=\"headerlink\" title=\"include &lt;stdio.h&gt;\"></a>include &lt;stdio.h&gt;</h1><p>int main()<br>{<br>    print(“hello world”);<br>    return 0;<br>}</p>\n<h1 id=\"python-中的对象\"><a href=\"#python-中的对象\" class=\"headerlink\" title=\"python 中的对象\"></a>python 中的对象</h1><p>对象可以说是python最核心的一个概念, 在python的世界里,一切皆对象. 我们知道python是c 编写的,c并不是一个面向对象语言,而c编写的python确实面向对象,在python中,对象就是c中的结构体在堆上申请的一块内存.<br>Python对象的多态性</p>\n<p>　　面向对象中一个重要的特性是多态，那么Python是如何实现多态的呢？<br>　　在Python创建一个对象时，会分配内存，进行初始化，然后Python内部会使用一个PyObject<em>变量来保存和维护这个对象，Python中的所有对象均是如此。比如创建一个PyIntObject对象（整数对象），不是通过PyIntObject </em>变量来保存和维护这个对象，而是通过PyObject <em>，正因为所有对象均如此，所以Python内部各个函数之间传递的都是一种范型指针（Pyobject</em>)，而这个指针所指的对象究竟是什么类型的，我们是不知道的，只能从指针所指对象的ob_type域动态进行判断，而正是这个域，Python实现了多态。</p>\n<h1 id=\"python标准库\"><a href=\"#python标准库\" class=\"headerlink\" title=\"python标准库\"></a>python标准库</h1><p>文本处理服务:string re textwrap<br>二进制数据服务<br>数据类型<br>数字和数学模块<br>函数式编程模块<br>文件和目录访问<br>数据持久化<br>数据压缩和存档<br>文件格式<br>加密服务<br>通用操作系统服务 os io time<br>并发执行 threading<br>网络和进程间通信<br>互联网数据处理 email json<br>结构化标记处理工具 html xml<br>互联网协议和支持 urllib.request http.server<br>多媒体服务 imghdr<br>国际化<br>程序框架 cmd turtle<br>Tk图形用户界面 GUI<br>开发工具 调试和分析<br>软件打包和分发 venv<br>python运行时服务 sysbuiltins   gc垃圾回收器接口<br>自定义python解释器<br>导入模块<br>python语言服务<br>杂项服务<br>windows系统相关模块<br>unix专有服务<br>被取代的模块<br>未创建文档的模块</p>\n<p>none 与NUll的区别<br>表示该值是一个空对象,空值是python里一个特殊的值,用none表示,none不能理解为<br>0,因为0是有意义的,而none是一个特殊的空值<br>判断的时候 均是false<br>属性不同:使用dir()函数返回参数的属性,方法列表,如果参数包含方法dir(),该方法将被<br>调用.如果参数不包含dir(),该方法将最大限度地收集参数信息.</p>\n<p>功能性函数返回都为none<br>None是一个特殊的常量。<br>None和False不同。<br>None不是0。<br>None不是空字符串。<br>None和任何其他的数据类型比较永远返回False。<br>None有自己的数据类型NoneType。<br>你可以将None赋值给任何变量，但是你不能创建其他NoneType对象。<br>L.index(value, [start, [stop]])，这里的中括号表示：start和stop是可选参数。可选参数通常都这么写，用的时候别带中括号。</p>\n<p>单星号(<em>):</em>args 将所以参数以元组(tuple)的形式导入:<br>还有解压参数<br>双星号以字典的形式导入</p>\n<h1 id=\"字典\"><a href=\"#字典\" class=\"headerlink\" title=\"字典\"></a>字典</h1><p>字典是python的半壁江山 要熟练<br>可变的 ,无序的,key不重复<br>d[key]<br>返回key对应的值value<br>key不存在抛出keyerror异常</p>\n<p>get(key[,defalut])<br>返回key对应的值value<br>key不存在返回缺省值,如果没有设置缺省值就返回none</p>\n<p>setdefalut(key[,default])<br>返回key对应的值value<br>key不存在,添加kv对,value设置为default,并返回default</p>\n<p>字典增加和修改</p>\n<p>d[key] = value<br>将key对应的值修改为value<br>key不存在添加新的kv对</p>\n<p>updata([other])<br>使用另一个字典的kv对更新本字典<br>key不存在,就添加<br>key存在,覆盖已经存在的key对应的值<br>就地修改</p>\n<p>字典删除</p>\n<p>pop(key[,default])<br>key不存在,移除他,并返回它的value<br>key不存在,返回给定的default<br>default未设置,key不存在则抛出Keyerror异常<br>popitem()<br>移除并返回一个任意的键值对<br>字典为empty,抛出KEyerror<br>clear()<br>清空字典</p>\n<p>字典删除<br>del语句<br>a = True<br>b = [6]</p>\n<p>字典遍历<br>for …in dict<br>遍历key<br>for k in d:<br>print(k)</p>\n<p>key的要求和set的元素要求一致<br>set的元素可以就是看做key,set可以看做dict的简化版<br>hashable可哈希才可以作为key, 可以使用hash()测试</p>\n<p>defaultdict</p>\n<h1 id=\"解析式\"><a href=\"#解析式\" class=\"headerlink\" title=\"解析式\"></a>解析式</h1><p>列表解析list comprehension</p>\n<p>语法<br>返回值 for 元素 in 可迭代 对象if 条件<br>使用中括号[],内部是for循环,if条件语句可选<br>返回一个新的列表</p>\n<p>列表解析式是一种语法糖<br>编译器会优化,不会因为简写而影响效率,反而因优化提高了效率</p>\n<h1 id=\"生成器\"><a href=\"#生成器\" class=\"headerlink\" title=\"生成器\"></a>生成器</h1><p>python三剑客 生成器 装饰器 描述器<br>熟练运用<br>生成器表达式是按需计算 或惰性求值,延迟计算<br>列表解析式是立即返回值<br>生成器 是可迭代对象 迭代器</p>\n<p>生成器表达式**<br>单从返回值本身来说,生成器表达式省内存,列表解析式返回新的列表<br>生成器没有数据,内存占用极少,他是使用时一个个返回数据如果合起来占用的内存也和列表解析式差不多.但是,它不需要占用这么多内存<br>列表解析式构造新的列表需要立即占用内存,不管你是否立即使用这么多数据</p>\n<p>计算速度<br>单看计算时间看,生成器表达式耗时非常短,列表解析式耗时长<br>但是生成器本身并没有返回任何值,只返回一个生成器对象<br>列表解析式构造并返回了一个新的列表,所以看起来耗时了</p>\n<p>类似:字典,集合解析式</p>\n<h1 id=\"collections-容器数据类型\"><a href=\"#collections-容器数据类型\" class=\"headerlink\" title=\"collections 容器数据类型\"></a>collections 容器数据类型</h1><p>这个模块实现了特定目标的容器<br>nametuple 创建命名元组子类的工厂函数</p>\n<p>counter 字典的子类,提供了可哈希对象的计数功能<br>OrderedDict 字典的子类,保存了他们被添加的顺序<br>defaultdict 字典的子类,提供了一个工厂函数,为字典查询提供一个默认值.</p>\n"},{"title":"网络协议","_content":"\n\n### OSI参考模型\n\n| 模型   | 说明                                                         |\n| ------ | ------------------------------------------------------------ |\n| 应用层 | 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. |\n| 表示层 | 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. |\n| 会话层 | 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. |\n| 传输层 | 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). |\n| 网络层 | 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. |\n| 链路层 | 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . |\n| 物理层 | 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. |\n\n### 网络协议\n\n| 链路层和物理层    | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| ARP(地址解析协议) | IP地址------->MAC地址                                        |\n| RARP              | MAC地址——>IP地址（逆向的）                                   |\n| PPP协议           | 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 |\n| MAC地址           | 48位全球唯一,网络设备的身份识别                              |\n\n| 网络层                       | 描述                                               |\n| ---------------------------- | -------------------------------------------------- |\n| IP协议                       | IP:（分为IPV4（168....）和IPV6（16进制用：隔开）） |\n| ICMP（Internet控制管理协议） | ping命令属于ICMP                                   |\n| IGMP（Internet分组管理协议） | 广播，组播                                         |\n\n| 传输层                | 描述                                                    |\n| --------------------- | ------------------------------------------------------- |\n| TCP（传输控制协议)    | 面向连接，可靠,效率低，一对一的可靠数据传输的协议       |\n| UDP（用户数据报协议） | 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输    |\n| SCTP                  | 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 |\n\n| 应用层                         | 描述                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| 网页访问协议                   | HTTP HTTPS(S是安全)                                          |\n| 邮件发送接收协议               | POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） |\n| FTP                            | 文件传输协议                                                 |\n| Telnet（明文传输）/SSH（安全） | 远程登录                                                     |\n\n| 嵌入式                 | 描述                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| NTP                    | 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） |\n| SNMP(开源（SNMP.NET）) | 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 |\n| RTP/RTSP               | 用传输音视频传输（监控等）                                   |\n\n### 中继系统\n\n中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。\n\n### 中继系统之集线器\n\n光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。\n\n这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。\n\n### 中继系统之交换机\n\n还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：**有记忆功能**。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？\n\n交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。\n\n如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。\n\n### 中继系统之路由器\n\n路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。\n\n \n\n### 端口\n\nIP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF....., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD...都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。\n\n***这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。***\n\n### socket\n\nsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.\n\n### 路由Routing\n\n跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.\n\n路由器上维护着路由表,他知道如何将数据包发往另外的网络.\n\nwindows使用route print, liunx使用route -n可以查看路由表.\n\n路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.\n\n静态路由:有管理员手动配置的固定的路由信息\n\n动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.\n\n","source":"_posts/1 (3).md","raw":"---\ntitle: 网络协议\ncategories: \n- 网络原理\ntags:\n- 网络原理\n---\n\n\n### OSI参考模型\n\n| 模型   | 说明                                                         |\n| ------ | ------------------------------------------------------------ |\n| 应用层 | 访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等. |\n| 表示层 | 提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码. |\n| 会话层 | 建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传. |\n| 传输层 | 提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket). |\n| 网络层 | 为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF. |\n| 链路层 | 在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 . |\n| 物理层 | 为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准. |\n\n### 网络协议\n\n| 链路层和物理层    | 描述                                                         |\n| ----------------- | ------------------------------------------------------------ |\n| ARP(地址解析协议) | IP地址------->MAC地址                                        |\n| RARP              | MAC地址——>IP地址（逆向的）                                   |\n| PPP协议           | 拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样 |\n| MAC地址           | 48位全球唯一,网络设备的身份识别                              |\n\n| 网络层                       | 描述                                               |\n| ---------------------------- | -------------------------------------------------- |\n| IP协议                       | IP:（分为IPV4（168....）和IPV6（16进制用：隔开）） |\n| ICMP（Internet控制管理协议） | ping命令属于ICMP                                   |\n| IGMP（Internet分组管理协议） | 广播，组播                                         |\n\n| 传输层                | 描述                                                    |\n| --------------------- | ------------------------------------------------------- |\n| TCP（传输控制协议)    | 面向连接，可靠,效率低，一对一的可靠数据传输的协议       |\n| UDP（用户数据报协议） | 面向无连接，不可靠，效率高，提供不可靠的数据尽力传输    |\n| SCTP                  | 是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信 |\n\n| 应用层                         | 描述                                                         |\n| ------------------------------ | ------------------------------------------------------------ |\n| 网页访问协议                   | HTTP HTTPS(S是安全)                                          |\n| 邮件发送接收协议               | POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件） |\n| FTP                            | 文件传输协议                                                 |\n| Telnet（明文传输）/SSH（安全） | 远程登录                                                     |\n\n| 嵌入式                 | 描述                                                         |\n| ---------------------- | ------------------------------------------------------------ |\n| NTP                    | 网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的） |\n| SNMP(开源（SNMP.NET）) | 简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置 |\n| RTP/RTSP               | 用传输音视频传输（监控等）                                   |\n\n### 中继系统\n\n中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。\n\n### 中继系统之集线器\n\n光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。\n\n这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。\n\n### 中继系统之交换机\n\n还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：**有记忆功能**。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？\n\n交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。\n\n如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。\n\n### 中继系统之路由器\n\n路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。\n\n \n\n### 端口\n\nIP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF....., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD...都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。\n\n***这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。***\n\n### socket\n\nsocket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.\n\n### 路由Routing\n\n跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.\n\n路由器上维护着路由表,他知道如何将数据包发往另外的网络.\n\nwindows使用route print, liunx使用route -n可以查看路由表.\n\n路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.\n\n静态路由:有管理员手动配置的固定的路由信息\n\n动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.\n\n","slug":"1 (3)","published":1,"date":"2019-06-17T03:39:44.570Z","updated":"2019-06-19T14:49:50.767Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8cc002ajkuff1myxzly","content":"<h3 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h3><table>\n<thead>\n<tr>\n<th>模型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等.</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码.</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传.</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket).</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF.</td>\n</tr>\n<tr>\n<td>链路层</td>\n<td>在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 .</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h3><table>\n<thead>\n<tr>\n<th>链路层和物理层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ARP(地址解析协议)</td>\n<td>IP地址——-&gt;MAC地址</td>\n</tr>\n<tr>\n<td>RARP</td>\n<td>MAC地址——&gt;IP地址（逆向的）</td>\n</tr>\n<tr>\n<td>PPP协议</td>\n<td>拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样</td>\n</tr>\n<tr>\n<td>MAC地址</td>\n<td>48位全球唯一,网络设备的身份识别</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>网络层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IP协议</td>\n<td>IP:（分为IPV4（168….）和IPV6（16进制用：隔开））</td>\n</tr>\n<tr>\n<td>ICMP（Internet控制管理协议）</td>\n<td>ping命令属于ICMP</td>\n</tr>\n<tr>\n<td>IGMP（Internet分组管理协议）</td>\n<td>广播，组播</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>传输层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP（传输控制协议)</td>\n<td>面向连接，可靠,效率低，一对一的可靠数据传输的协议</td>\n</tr>\n<tr>\n<td>UDP（用户数据报协议）</td>\n<td>面向无连接，不可靠，效率高，提供不可靠的数据尽力传输</td>\n</tr>\n<tr>\n<td>SCTP</td>\n<td>是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>应用层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网页访问协议</td>\n<td>HTTP HTTPS(S是安全)</td>\n</tr>\n<tr>\n<td>邮件发送接收协议</td>\n<td>POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件）</td>\n</tr>\n<tr>\n<td>FTP</td>\n<td>文件传输协议</td>\n</tr>\n<tr>\n<td>Telnet（明文传输）/SSH（安全）</td>\n<td>远程登录</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>嵌入式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NTP</td>\n<td>网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的）</td>\n</tr>\n<tr>\n<td>SNMP(开源（SNMP.NET）)</td>\n<td>简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置</td>\n</tr>\n<tr>\n<td>RTP/RTSP</td>\n<td>用传输音视频传输（监控等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"中继系统\"><a href=\"#中继系统\" class=\"headerlink\" title=\"中继系统\"></a>中继系统</h3><p>中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。</p>\n<h3 id=\"中继系统之集线器\"><a href=\"#中继系统之集线器\" class=\"headerlink\" title=\"中继系统之集线器\"></a>中继系统之集线器</h3><p>光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。</p>\n<p>这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。</p>\n<h3 id=\"中继系统之交换机\"><a href=\"#中继系统之交换机\" class=\"headerlink\" title=\"中继系统之交换机\"></a>中继系统之交换机</h3><p>还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：<strong>有记忆功能</strong>。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？</p>\n<p>交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。</p>\n<p>如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。</p>\n<h3 id=\"中继系统之路由器\"><a href=\"#中继系统之路由器\" class=\"headerlink\" title=\"中继系统之路由器\"></a>中继系统之路由器</h3><p>路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。</p>\n<h3 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h3><p>IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。</p>\n<p><strong><em>这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。</em></strong></p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>socket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.</p>\n<h3 id=\"路由Routing\"><a href=\"#路由Routing\" class=\"headerlink\" title=\"路由Routing\"></a>路由Routing</h3><p>跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.</p>\n<p>路由器上维护着路由表,他知道如何将数据包发往另外的网络.</p>\n<p>windows使用route print, liunx使用route -n可以查看路由表.</p>\n<p>路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.</p>\n<p>静态路由:有管理员手动配置的固定的路由信息</p>\n<p>动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.</p>\n","site":{"data":{}},"excerpt":"","more":"<h3 id=\"OSI参考模型\"><a href=\"#OSI参考模型\" class=\"headerlink\" title=\"OSI参考模型\"></a>OSI参考模型</h3><table>\n<thead>\n<tr>\n<th>模型</th>\n<th>说明</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>应用层</td>\n<td>访问网络服务的接口.例如:为操作系统或网络应用程序提供访问网络服务的接口.常见:Telnet, FTP, HTTP,SNMP,DNS等.</td>\n</tr>\n<tr>\n<td>表示层</td>\n<td>提供数据格式转换服务.例如:解密与加密.图片解码和编码,数据的压缩和解压缩.常见:URL加密,口令加密,图片编解码.</td>\n</tr>\n<tr>\n<td>会话层</td>\n<td>建立端连接并提供访问验证和会话管理(SESSION).例如:使用校验点恢复通信.常见:服务器验证用户登录,断点续传.</td>\n</tr>\n<tr>\n<td>传输层</td>\n<td>提供应用进程之间的逻辑通信.例如:建立连接,处理数据包错误,数据包次序.常见:TCP,UDP,SPX,进程, 端口(socket).</td>\n</tr>\n<tr>\n<td>网络层</td>\n<td>为数据在结点之间传输创建逻辑链路,并分组转发数据.例如对子网间的数据包进行路由选择.常见:路由器,多层交换机, 防火墙, IP, IPX, RIP, OSPF.</td>\n</tr>\n<tr>\n<td>链路层</td>\n<td>在通信的实体间建立数据链路连接,例如:将数据分帧, 并处理流控制,物理地址寻址,重发等.常见:网卡(MAC), 网桥,二层交换机等 .</td>\n</tr>\n<tr>\n<td>物理层</td>\n<td>为数据设备提供原始比特流的传输的通路.例如:网络通信的数据传输介质,由电缆与设备共同构成.常见:中继器, 集线器, HUB, RJ-45标准.</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"网络协议\"><a href=\"#网络协议\" class=\"headerlink\" title=\"网络协议\"></a>网络协议</h3><table>\n<thead>\n<tr>\n<th>链路层和物理层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>ARP(地址解析协议)</td>\n<td>IP地址——-&gt;MAC地址</td>\n</tr>\n<tr>\n<td>RARP</td>\n<td>MAC地址——&gt;IP地址（逆向的）</td>\n</tr>\n<tr>\n<td>PPP协议</td>\n<td>拨号协议GPRS/3G/4G之前电话通话电话线上网的时候通过这个协议，现在用手机无线的也是一样</td>\n</tr>\n<tr>\n<td>MAC地址</td>\n<td>48位全球唯一,网络设备的身份识别</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>网络层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>IP协议</td>\n<td>IP:（分为IPV4（168….）和IPV6（16进制用：隔开））</td>\n</tr>\n<tr>\n<td>ICMP（Internet控制管理协议）</td>\n<td>ping命令属于ICMP</td>\n</tr>\n<tr>\n<td>IGMP（Internet分组管理协议）</td>\n<td>广播，组播</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>传输层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>TCP（传输控制协议)</td>\n<td>面向连接，可靠,效率低，一对一的可靠数据传输的协议</td>\n</tr>\n<tr>\n<td>UDP（用户数据报协议）</td>\n<td>面向无连接，不可靠，效率高，提供不可靠的数据尽力传输</td>\n</tr>\n<tr>\n<td>SCTP</td>\n<td>是可靠传输，是TCP的增强版，它能实现多主机，多线路的通信</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>应用层</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>网页访问协议</td>\n<td>HTTP HTTPS(S是安全)</td>\n</tr>\n<tr>\n<td>邮件发送接收协议</td>\n<td>POP3(收)/SMTP(发)，IMAP(可接收邮件的一部分)（QQ或者微信的邮件提醒，没下载整个文件但是能显示邮件的一部分，能处理邮件）</td>\n</tr>\n<tr>\n<td>FTP</td>\n<td>文件传输协议</td>\n</tr>\n<tr>\n<td>Telnet（明文传输）/SSH（安全）</td>\n<td>远程登录</td>\n</tr>\n</tbody>\n</table>\n<table>\n<thead>\n<tr>\n<th>嵌入式</th>\n<th>描述</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td>NTP</td>\n<td>网络时钟协议（以前诺基亚关机一定时间就得重新设置时间，很多嵌入式设备需要加进去的）</td>\n</tr>\n<tr>\n<td>SNMP(开源（SNMP.NET）)</td>\n<td>简单网络管理协议（实现对网络设备集中式管理）比如路由，家里的路由登陆网页可以直接设置，但是如果在一个小区里安装了很多路由，一个一个改很麻烦，利用这个协议可以集中管理设置</td>\n</tr>\n<tr>\n<td>RTP/RTSP</td>\n<td>用传输音视频传输（监控等）</td>\n</tr>\n</tbody>\n</table>\n<h3 id=\"中继系统\"><a href=\"#中继系统\" class=\"headerlink\" title=\"中继系统\"></a>中继系统</h3><p>中继系统（Relay System），Relay 是接力的意思，4* 100米接力比赛，每一位选手在100米的赛程内速度达到峰值，体力开始下降，于是把接力棒交给下一个选手，就这样一个个传下去，在赛程内全程极限速度，冲击人类速度的巅峰。</p>\n<h3 id=\"中继系统之集线器\"><a href=\"#中继系统之集线器\" class=\"headerlink\" title=\"中继系统之集线器\"></a>中继系统之集线器</h3><p>光纤、双绞线随着传输距离的增大，信号会衰减（类似人体体力下降），为了避免信号衰减到不可用，需要有中继系统将信号复原、放大并传输出去，以此方法可以将信号传输得更远。比如北京到上海光传输网络，每隔几十公里需要有中继系统来接力。</p>\n<p>这种中继系统类似Hub（集线器）的功能，从入口接收到信号，做信号复原、放大，然后再将信号从出口发送出去，这种中继系统是物理层设备，或一层设备。</p>\n<h3 id=\"中继系统之交换机\"><a href=\"#中继系统之交换机\" class=\"headerlink\" title=\"中继系统之交换机\"></a>中继系统之交换机</h3><p>还有一种中继系统，网桥，现在称二层交换机，它比Hub、集线器高明的地方是：<strong>有记忆功能</strong>。二层交换机会记忆每个端口连接主机的MAC地址，那怎么记忆呢？</p>\n<p>交换机在某个端口接收到一个以太网帧（二层称帧，Frame)，会读取以太网帧头部的Source MAC，然后把这个Source MAC与端口号联系起来，放在一张表里：MAC Address Table，以此方法交换机可以学习到每个端口所对应的MAC地址，接下来如果交换机接收到一个帧，会检查Destination MAC 与MAC Address Table 进行匹配，如果匹配到某个MAC地址，就从那个MAC地址对应的端口发送出去。</p>\n<p>如果没有匹配到任何一个表相，则从所有的端口（除了接收端口）发送出去，这就是通常所说的泛洪（flooding），流量的流速为10Mbps，如果需要泛洪到47 个端口，一共会产生47* 10= 470 Mbps 的泛洪流量，所以泛洪对交换机的影响是非常大的，尽可能避免泛洪流量。</p>\n<h3 id=\"中继系统之路由器\"><a href=\"#中继系统之路由器\" class=\"headerlink\" title=\"中继系统之路由器\"></a>中继系统之路由器</h3><p>路由器是三层设备（网络层/IP层），顾名思义，它可以读取IP包头（三层称包，Packet）任何信息，读取目的IP地址信息，查询路由表，依据最长匹配原则，将IP包接力到更靠近目的地IP的下一跳路由器。</p>\n<h3 id=\"端口\"><a href=\"#端口\" class=\"headerlink\" title=\"端口\"></a>端口</h3><p>IP能锁定一台物理机器,对应一张网卡,外界发来的数据包网卡都会接受,但是问题来了,网卡给程序提供了接口,你监听一下我,要是问题来了,我就转发给你.这样应用程序就能收到程序了.但是问题来了,程序A和程序B都需要监听网卡接发数据,网卡说那我把接到的数据都发给你两,你们自己看着办吧.好,小A小B都接受了,但是又来了CDEF….., 不行了,每个包都被发到了所有应用程序,每个应用程序都累得不行,最终垮了.好,那网卡说我给你们加个表示吧,我们之间可以用一个号码来作为标识,我和小A之间就用1标识如果外界发给1号标识的数据我就转发给你，你监听我的时候得告诉我你监听的时1，我就转发1的数据包给你。好了其他的BCD…都自己弄一个标识号，只要不重复就行。这样大家都省事了。最后设计到安全，一个标识号只能被一个应用程序监听，因为如果小A程序和小B同时监听一个标识号号，那就坏了，我传的数据都被AB接到，这样数据安全性就没办法保证了。</p>\n<p><strong><em>这个标识号就是端口,其实网卡都是被系统层封装了，端口和进程之间的关系也是系统封装好的。我们只需要用socket就行，给定一个端口号就行了。其他的事都交给操作系统去做。</em></strong></p>\n<h3 id=\"socket\"><a href=\"#socket\" class=\"headerlink\" title=\"socket\"></a>socket</h3><p>socket(套接字)是一种通用的网络编程接口,和网络层没有一一对应的关系.</p>\n<h3 id=\"路由Routing\"><a href=\"#路由Routing\" class=\"headerlink\" title=\"路由Routing\"></a>路由Routing</h3><p>跨网络通信就需要使用路由,通过路由器将数据包从一个网络发往另一个网络.</p>\n<p>路由器上维护着路由表,他知道如何将数据包发往另外的网络.</p>\n<p>windows使用route print, liunx使用route -n可以查看路由表.</p>\n<p>路由器所有端口都有使用自己的IP地址, 这些IP地址往往处在不同的网络, 所以,路由器连接了不同的网络.路由表中记录着路由设备所有端口对应的网络,分为静态, 动态配置.</p>\n<p>静态路由:有管理员手动配置的固定的路由信息</p>\n<p>动态路由:网络中的路由器,根据实时网络拓扑变化,相互通信传递路由信息,利用这些路由信息通过路由选择协议动态计算,并更新路由表.常见的协议有RIP, OSPF等.</p>\n"},{"title":"linux命令整理(2)","_content":"## 文档编辑\n\n### grep\n\nLinux grep命令用于查找文件里符合条件的字符串。\n\ngrep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为\"-\"，则grep指令会从标准输入设备读取数据。\n\n语法\ngrep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]\n参数：\n\n-a 或 --text : 不要忽略二进制的数据。\n-A<显示行数> 或 --after-context=<显示行数> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。\n-B<显示行数> 或 --before-context=<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前的内容。\n-c 或 --count : 计算符合样式的列数。\n-C<显示行数> 或 --context=<显示行数>或-<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。\n-d <动作> 或 --directories=<动作> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。\n-e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。\n-E 或 --extended-regexp : 将样式为延伸的普通表示法来使用。\n-f<规则文件> 或 --file=<规则文件> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。\n-F 或 --fixed-regexp : 将样式视为固定字符串的列表。\n-G 或 --basic-regexp : 将样式视为普通的表示法来使用。\n-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。\n-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。\n-i 或 --ignore-case : 忽略字符大小写的差别。\n-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。\n-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。\n-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。\n-o 或 --only-matching : 只显示匹配PATTERN 部分。\n-q 或 --quiet或--silent : 不显示任何信息。\n-r 或 --recursive : 此参数的效果和指定\"-d recurse\"参数相同。\n-s 或 --no-messages : 不显示错误信息。\n-v 或 --revert-match : 显示不包含匹配文本的所有行。\n-V 或 --version : 显示版本信息。\n-w 或 --word-regexp : 只显示全字符合的列。\n-x --line-regexp : 只显示全列符合的列。\n-y : 此参数的效果和指定\"-i\"参数相同。\n\n### sort\n\nLinux sort命令用于将文本文件内容加以排序。\n\nsort可针对文本文件的内容，以行为单位来排序。\n\n语法\nsort [-bcdfimMnr][-o<输出文件>][-t<分隔字符>][+<起始栏位>-<结束栏位>][--help][--verison][文件]\n参数说明：\n\n-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-o<输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t<分隔字符> 指定排序时所用的栏位分隔字符。\n+<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n\n### tr\n\nLinux tr 命令用于转换或删除文件中的字符。\n\ntr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。\n\n语法\ntr [-cdst][--help][--version][第一字符集][第二字符集]  \ntr [OPTION]…SET1[SET2] \n参数说明：\n\n-c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换\n-d, --delete：删除指令字符\n-s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符\n-t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等\n--help：显示程序用法信息\n--version：显示程序本身的版本信息\n字符集合的范围：\n\n\\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\n\\\\ 反斜杠\n\\a Ctrl-G 铃声\n\\b Ctrl-H 退格符\n\\f Ctrl-L 走行换页\n\\n Ctrl-J 新行\n\\r Ctrl-M 回车\n\\t Ctrl-I tab键\n\\v Ctrl-X 水平制表符\nCHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。\n[CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止\n[CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)\n[:alnum:] ：所有字母字符与数字\n[:alpha:] ：所有字母字符\n[:blank:] ：所有水平空格\n[:cntrl:] ：所有控制字符\n[:digit:] ：所有数字\n[:graph:] ：所有可打印的字符(不包含空格符)\n[:lower:] ：所有小写字母\n[:print:] ：所有可打印的字符(包含空格符)\n[:punct:] ：所有标点字符\n[:space:] ：所有水平与垂直空格符\n[:upper:] ：所有大写字母\n[:xdigit:] ：所有 16 进位制的数字\n[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)\n\n### uniq\n\nLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。\n\nuniq 可检查文本文件中重复出现的行列。\n\n语法\nuniq [-cdu][-f<栏位>][-s<字符位置>][-w<字符位置>][--help][--version][输入文件][输出文件]\n参数：\n\n-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。\n-s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。\n\n### wc\n\nLinux wc命令用于计算字数。\n\n利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为\"-\"，则wc指令会从标准输入设备读取数据。\n\n语法\nwc [-clw][--help][--version][文件...]\n参数：\n\n-c或--bytes或--chars 只显示Bytes数。\n-l或--lines 只显示行数。\n-w或--words 只显示字数。\n--help 在线帮助。\n--version 显示版本信息。\n\n### let\n\nlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。\n\n语法格式\nlet arg [arg ...]\n参数说明：\narg：要执行的表达式\n\n### sed\n\nLinux sed命令是利用script来处理文本文件。\n\nsed可依照script的指令，来处理、编辑文本文件。\n\nSed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。\n\n语法\nsed [-hnV][-e<script>][-f<script文件>][文本文件]\n参数说明：\n\n-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。\n-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。\n-h或--help 显示帮助。\n-n或--quiet或--silent 仅显示script处理后的结果。\n-V或--version 显示版本信息。\n动作说明：\n\na ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～\nc ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！\nd ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；\ni ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；\np ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～\ns ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.","source":"_posts/1 (8).md","raw":"---\ntitle: linux命令整理(2)\n\n\ncategories: \n- linux\ntags:\n- linux基础\n---\n## 文档编辑\n\n### grep\n\nLinux grep命令用于查找文件里符合条件的字符串。\n\ngrep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为\"-\"，则grep指令会从标准输入设备读取数据。\n\n语法\ngrep [-abcEFGhHilLnqrsvVwxy][-A<显示列数>][-B<显示列数>][-C<显示列数>][-d<进行动作>][-e<范本样式>][-f<范本文件>][--help][范本样式][文件或目录...]\n参数：\n\n-a 或 --text : 不要忽略二进制的数据。\n-A<显示行数> 或 --after-context=<显示行数> : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。\n-b 或 --byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。\n-B<显示行数> 或 --before-context=<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前的内容。\n-c 或 --count : 计算符合样式的列数。\n-C<显示行数> 或 --context=<显示行数>或-<显示行数> : 除了显示符合样式的那一行之外，并显示该行之前后的内容。\n-d <动作> 或 --directories=<动作> : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。\n-e<范本样式> 或 --regexp=<范本样式> : 指定字符串做为查找文件内容的样式。\n-E 或 --extended-regexp : 将样式为延伸的普通表示法来使用。\n-f<规则文件> 或 --file=<规则文件> : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。\n-F 或 --fixed-regexp : 将样式视为固定字符串的列表。\n-G 或 --basic-regexp : 将样式视为普通的表示法来使用。\n-h 或 --no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。\n-H 或 --with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。\n-i 或 --ignore-case : 忽略字符大小写的差别。\n-l 或 --file-with-matches : 列出文件内容符合指定的样式的文件名称。\n-L 或 --files-without-match : 列出文件内容不符合指定的样式的文件名称。\n-n 或 --line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。\n-o 或 --only-matching : 只显示匹配PATTERN 部分。\n-q 或 --quiet或--silent : 不显示任何信息。\n-r 或 --recursive : 此参数的效果和指定\"-d recurse\"参数相同。\n-s 或 --no-messages : 不显示错误信息。\n-v 或 --revert-match : 显示不包含匹配文本的所有行。\n-V 或 --version : 显示版本信息。\n-w 或 --word-regexp : 只显示全字符合的列。\n-x --line-regexp : 只显示全列符合的列。\n-y : 此参数的效果和指定\"-i\"参数相同。\n\n### sort\n\nLinux sort命令用于将文本文件内容加以排序。\n\nsort可针对文本文件的内容，以行为单位来排序。\n\n语法\nsort [-bcdfimMnr][-o<输出文件>][-t<分隔字符>][+<起始栏位>-<结束栏位>][--help][--verison][文件]\n参数说明：\n\n-b 忽略每行前面开始出的空格字符。\n-c 检查文件是否已经按照顺序排序。\n-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。\n-f 排序时，将小写字母视为大写字母。\n-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。\n-m 将几个排序好的文件进行合并。\n-M 将前面3个字母依照月份的缩写进行排序。\n-n 依照数值的大小排序。\n-o<输出文件> 将排序后的结果存入指定的文件。\n-r 以相反的顺序来排序。\n-t<分隔字符> 指定排序时所用的栏位分隔字符。\n+<起始栏位>-<结束栏位> 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。\n--help 显示帮助。\n--version 显示版本信息。\n\n### tr\n\nLinux tr 命令用于转换或删除文件中的字符。\n\ntr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。\n\n语法\ntr [-cdst][--help][--version][第一字符集][第二字符集]  \ntr [OPTION]…SET1[SET2] \n参数说明：\n\n-c, --complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换\n-d, --delete：删除指令字符\n-s, --squeeze-repeats：缩减连续重复的字符成指定的单个字符\n-t, --truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等\n--help：显示程序用法信息\n--version：显示程序本身的版本信息\n字符集合的范围：\n\n\\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)\n\\\\ 反斜杠\n\\a Ctrl-G 铃声\n\\b Ctrl-H 退格符\n\\f Ctrl-L 走行换页\n\\n Ctrl-J 新行\n\\r Ctrl-M 回车\n\\t Ctrl-I tab键\n\\v Ctrl-X 水平制表符\nCHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。\n[CHAR*] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止\n[CHAR*REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)\n[:alnum:] ：所有字母字符与数字\n[:alpha:] ：所有字母字符\n[:blank:] ：所有水平空格\n[:cntrl:] ：所有控制字符\n[:digit:] ：所有数字\n[:graph:] ：所有可打印的字符(不包含空格符)\n[:lower:] ：所有小写字母\n[:print:] ：所有可打印的字符(包含空格符)\n[:punct:] ：所有标点字符\n[:space:] ：所有水平与垂直空格符\n[:upper:] ：所有大写字母\n[:xdigit:] ：所有 16 进位制的数字\n[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)\n\n### uniq\n\nLinux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。\n\nuniq 可检查文本文件中重复出现的行列。\n\n语法\nuniq [-cdu][-f<栏位>][-s<字符位置>][-w<字符位置>][--help][--version][输入文件][输出文件]\n参数：\n\n-c或--count 在每列旁边显示该行重复出现的次数。\n-d或--repeated 仅显示重复出现的行列。\n-f<栏位>或--skip-fields=<栏位> 忽略比较指定的栏位。\n-s<字符位置>或--skip-chars=<字符位置> 忽略比较指定的字符。\n-u或--unique 仅显示出一次的行列。\n-w<字符位置>或--check-chars=<字符位置> 指定要比较的字符。\n--help 显示帮助。\n--version 显示版本信息。\n[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；\n[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。\n\n### wc\n\nLinux wc命令用于计算字数。\n\n利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为\"-\"，则wc指令会从标准输入设备读取数据。\n\n语法\nwc [-clw][--help][--version][文件...]\n参数：\n\n-c或--bytes或--chars 只显示Bytes数。\n-l或--lines 只显示行数。\n-w或--words 只显示字数。\n--help 在线帮助。\n--version 显示版本信息。\n\n### let\n\nlet 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。\n\n语法格式\nlet arg [arg ...]\n参数说明：\narg：要执行的表达式\n\n### sed\n\nLinux sed命令是利用script来处理文本文件。\n\nsed可依照script的指令，来处理、编辑文本文件。\n\nSed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。\n\n语法\nsed [-hnV][-e<script>][-f<script文件>][文本文件]\n参数说明：\n\n-e<script>或--expression=<script> 以选项中指定的script来处理输入的文本文件。\n-f<script文件>或--file=<script文件> 以选项中指定的script文件来处理输入的文本文件。\n-h或--help 显示帮助。\n-n或--quiet或--silent 仅显示script处理后的结果。\n-V或--version 显示版本信息。\n动作说明：\n\na ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～\nc ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！\nd ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；\ni ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；\np ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～\ns ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.","slug":"1 (8)","published":1,"date":"2019-04-01T07:22:19.056Z","updated":"2019-06-19T14:47:24.952Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8cg002djkuf66oyk2by","content":"<h2 id=\"文档编辑\"><a href=\"#文档编辑\" class=\"headerlink\" title=\"文档编辑\"></a>文档编辑</h2><h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>Linux grep命令用于查找文件里符合条件的字符串。</p>\n<p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p>\n<p>语法<br>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]<br>参数：</p>\n<p>-a 或 –text : 不要忽略二进制的数据。<br>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br>-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。<br>-c 或 –count : 计算符合样式的列数。<br>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。<br>-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。<br>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。<br>-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。<br>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。<br>-F 或 –fixed-regexp : 将样式视为固定字符串的列表。<br>-G 或 –basic-regexp : 将样式视为普通的表示法来使用。<br>-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。<br>-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。<br>-i 或 –ignore-case : 忽略字符大小写的差别。<br>-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。<br>-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。<br>-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。<br>-o 或 –only-matching : 只显示匹配PATTERN 部分。<br>-q 或 –quiet或–silent : 不显示任何信息。<br>-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。<br>-s 或 –no-messages : 不显示错误信息。<br>-v 或 –revert-match : 显示不包含匹配文本的所有行。<br>-V 或 –version : 显示版本信息。<br>-w 或 –word-regexp : 只显示全字符合的列。<br>-x –line-regexp : 只显示全列符合的列。<br>-y : 此参数的效果和指定”-i”参数相同。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p>Linux sort命令用于将文本文件内容加以排序。</p>\n<p>sort可针对文本文件的内容，以行为单位来排序。</p>\n<p>语法<br>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]<br>参数说明：</p>\n<p>-b 忽略每行前面开始出的空格字符。<br>-c 检查文件是否已经按照顺序排序。<br>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>-f 排序时，将小写字母视为大写字母。<br>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。<br>-m 将几个排序好的文件进行合并。<br>-M 将前面3个字母依照月份的缩写进行排序。<br>-n 依照数值的大小排序。<br>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。<br>-r 以相反的顺序来排序。<br>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。<br>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。<br>–help 显示帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"tr\"><a href=\"#tr\" class=\"headerlink\" title=\"tr\"></a>tr</h3><p>Linux tr 命令用于转换或删除文件中的字符。</p>\n<p>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p>\n<p>语法<br>tr [-cdst][–help][–version][第一字符集][第二字符集]<br>tr [OPTION]…SET1[SET2]<br>参数说明：</p>\n<p>-c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换<br>-d, –delete：删除指令字符<br>-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符<br>-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等<br>–help：显示程序用法信息<br>–version：显示程序本身的版本信息<br>字符集合的范围：</p>\n<p>\\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)<br>\\ 反斜杠<br>\\a Ctrl-G 铃声<br>\\b Ctrl-H 退格符<br>\\f Ctrl-L 走行换页<br>\\n Ctrl-J 新行<br>\\r Ctrl-M 回车<br>\\t Ctrl-I tab键<br>\\v Ctrl-X 水平制表符<br>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>[CHAR<em>] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止<br>[CHAR</em>REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)<br>[:alnum:] ：所有字母字符与数字<br>[:alpha:] ：所有字母字符<br>[:blank:] ：所有水平空格<br>[:cntrl:] ：所有控制字符<br>[:digit:] ：所有数字<br>[:graph:] ：所有可打印的字符(不包含空格符)<br>[:lower:] ：所有小写字母<br>[:print:] ：所有可打印的字符(包含空格符)<br>[:punct:] ：所有标点字符<br>[:space:] ：所有水平与垂直空格符<br>[:upper:] ：所有大写字母<br>[:xdigit:] ：所有 16 进位制的数字<br>[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)</p>\n<h3 id=\"uniq\"><a href=\"#uniq\" class=\"headerlink\" title=\"uniq\"></a>uniq</h3><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p>\n<p>uniq 可检查文本文件中重复出现的行列。</p>\n<p>语法<br>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]<br>参数：</p>\n<p>-c或–count 在每列旁边显示该行重复出现的次数。<br>-d或–repeated 仅显示重复出现的行列。<br>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。<br>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。<br>-u或–unique 仅显示出一次的行列。<br>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。<br>–help 显示帮助。<br>–version 显示版本信息。<br>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；<br>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p>\n<h3 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h3><p>Linux wc命令用于计算字数。</p>\n<p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>\n<p>语法<br>wc [-clw][–help][–version][文件…]<br>参数：</p>\n<p>-c或–bytes或–chars 只显示Bytes数。<br>-l或–lines 只显示行数。<br>-w或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p>\n<p>语法格式<br>let arg [arg …]<br>参数说明：<br>arg：要执行的表达式</p>\n<h3 id=\"sed\"><a href=\"#sed\" class=\"headerlink\" title=\"sed\"></a>sed</h3><p>Linux sed命令是利用script来处理文本文件。</p>\n<p>sed可依照script的指令，来处理、编辑文本文件。</p>\n<p>Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>\n<p>语法<br>sed [-hnV][-e<script>][-f&lt;script文件&gt;][文本文件]<br>参数说明：</p>\n<p>-e<script>或–expression=<script> 以选项中指定的script来处理输入的文本文件。<br>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。<br>-h或–help 显示帮助。<br>-n或–quiet或–silent 仅显示script处理后的结果。<br>-V或–version 显示版本信息。<br>动作说明：</p>\n<p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.</p>\n</script></p>","site":{"data":{}},"excerpt":"","more":"<h2 id=\"文档编辑\"><a href=\"#文档编辑\" class=\"headerlink\" title=\"文档编辑\"></a>文档编辑</h2><h3 id=\"grep\"><a href=\"#grep\" class=\"headerlink\" title=\"grep\"></a>grep</h3><p>Linux grep命令用于查找文件里符合条件的字符串。</p>\n<p>grep指令用于查找内容包含指定的范本样式的文件，如果发现某文件的内容符合所指定的范本样式，预设grep指令会把含有范本样式的那一列显示出来。若不指定任何文件名称，或是所给予的文件名为”-“，则grep指令会从标准输入设备读取数据。</p>\n<p>语法<br>grep [-abcEFGhHilLnqrsvVwxy][-A&lt;显示列数&gt;][-B&lt;显示列数&gt;][-C&lt;显示列数&gt;][-d&lt;进行动作&gt;][-e&lt;范本样式&gt;][-f&lt;范本文件&gt;][–help][范本样式][文件或目录…]<br>参数：</p>\n<p>-a 或 –text : 不要忽略二进制的数据。<br>-A&lt;显示行数&gt; 或 –after-context=&lt;显示行数&gt; : 除了显示符合范本样式的那一列之外，并显示该行之后的内容。<br>-b 或 –byte-offset : 在显示符合样式的那一行之前，标示出该行第一个字符的编号。<br>-B&lt;显示行数&gt; 或 –before-context=&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前的内容。<br>-c 或 –count : 计算符合样式的列数。<br>-C&lt;显示行数&gt; 或 –context=&lt;显示行数&gt;或-&lt;显示行数&gt; : 除了显示符合样式的那一行之外，并显示该行之前后的内容。<br>-d &lt;动作&gt; 或 –directories=&lt;动作&gt; : 当指定要查找的是目录而非文件时，必须使用这项参数，否则grep指令将回报信息并停止动作。<br>-e&lt;范本样式&gt; 或 –regexp=&lt;范本样式&gt; : 指定字符串做为查找文件内容的样式。<br>-E 或 –extended-regexp : 将样式为延伸的普通表示法来使用。<br>-f&lt;规则文件&gt; 或 –file=&lt;规则文件&gt; : 指定规则文件，其内容含有一个或多个规则样式，让grep查找符合规则条件的文件内容，格式为每行一个规则样式。<br>-F 或 –fixed-regexp : 将样式视为固定字符串的列表。<br>-G 或 –basic-regexp : 将样式视为普通的表示法来使用。<br>-h 或 –no-filename : 在显示符合样式的那一行之前，不标示该行所属的文件名称。<br>-H 或 –with-filename : 在显示符合样式的那一行之前，表示该行所属的文件名称。<br>-i 或 –ignore-case : 忽略字符大小写的差别。<br>-l 或 –file-with-matches : 列出文件内容符合指定的样式的文件名称。<br>-L 或 –files-without-match : 列出文件内容不符合指定的样式的文件名称。<br>-n 或 –line-number : 在显示符合样式的那一行之前，标示出该行的列数编号。<br>-o 或 –only-matching : 只显示匹配PATTERN 部分。<br>-q 或 –quiet或–silent : 不显示任何信息。<br>-r 或 –recursive : 此参数的效果和指定”-d recurse”参数相同。<br>-s 或 –no-messages : 不显示错误信息。<br>-v 或 –revert-match : 显示不包含匹配文本的所有行。<br>-V 或 –version : 显示版本信息。<br>-w 或 –word-regexp : 只显示全字符合的列。<br>-x –line-regexp : 只显示全列符合的列。<br>-y : 此参数的效果和指定”-i”参数相同。</p>\n<h3 id=\"sort\"><a href=\"#sort\" class=\"headerlink\" title=\"sort\"></a>sort</h3><p>Linux sort命令用于将文本文件内容加以排序。</p>\n<p>sort可针对文本文件的内容，以行为单位来排序。</p>\n<p>语法<br>sort [-bcdfimMnr][-o&lt;输出文件&gt;][-t&lt;分隔字符&gt;][+&lt;起始栏位&gt;-&lt;结束栏位&gt;][–help][–verison][文件]<br>参数说明：</p>\n<p>-b 忽略每行前面开始出的空格字符。<br>-c 检查文件是否已经按照顺序排序。<br>-d 排序时，处理英文字母、数字及空格字符外，忽略其他的字符。<br>-f 排序时，将小写字母视为大写字母。<br>-i 排序时，除了040至176之间的ASCII字符外，忽略其他的字符。<br>-m 将几个排序好的文件进行合并。<br>-M 将前面3个字母依照月份的缩写进行排序。<br>-n 依照数值的大小排序。<br>-o&lt;输出文件&gt; 将排序后的结果存入指定的文件。<br>-r 以相反的顺序来排序。<br>-t&lt;分隔字符&gt; 指定排序时所用的栏位分隔字符。<br>+&lt;起始栏位&gt;-&lt;结束栏位&gt; 以指定的栏位来排序，范围由起始栏位到结束栏位的前一栏位。<br>–help 显示帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"tr\"><a href=\"#tr\" class=\"headerlink\" title=\"tr\"></a>tr</h3><p>Linux tr 命令用于转换或删除文件中的字符。</p>\n<p>tr 指令从标准输入设备读取数据，经过字符串转译后，将结果输出到标准输出设备。</p>\n<p>语法<br>tr [-cdst][–help][–version][第一字符集][第二字符集]<br>tr [OPTION]…SET1[SET2]<br>参数说明：</p>\n<p>-c, –complement：反选设定字符。也就是符合 SET1 的部份不做处理，不符合的剩余部份才进行转换<br>-d, –delete：删除指令字符<br>-s, –squeeze-repeats：缩减连续重复的字符成指定的单个字符<br>-t, –truncate-set1：削减 SET1 指定范围，使之与 SET2 设定长度相等<br>–help：显示程序用法信息<br>–version：显示程序本身的版本信息<br>字符集合的范围：</p>\n<p>\\NNN 八进制值的字符 NNN (1 to 3 为八进制值的字符)<br>\\ 反斜杠<br>\\a Ctrl-G 铃声<br>\\b Ctrl-H 退格符<br>\\f Ctrl-L 走行换页<br>\\n Ctrl-J 新行<br>\\r Ctrl-M 回车<br>\\t Ctrl-I tab键<br>\\v Ctrl-X 水平制表符<br>CHAR1-CHAR2 ：字符范围从 CHAR1 到 CHAR2 的指定，范围的指定以 ASCII 码的次序为基础，只能由小到大，不能由大到小。<br>[CHAR<em>] ：这是 SET2 专用的设定，功能是重复指定的字符到与 SET1 相同长度为止<br>[CHAR</em>REPEAT] ：这也是 SET2 专用的设定，功能是重复指定的字符到设定的 REPEAT 次数为止(REPEAT 的数字采 8 进位制计算，以 0 为开始)<br>[:alnum:] ：所有字母字符与数字<br>[:alpha:] ：所有字母字符<br>[:blank:] ：所有水平空格<br>[:cntrl:] ：所有控制字符<br>[:digit:] ：所有数字<br>[:graph:] ：所有可打印的字符(不包含空格符)<br>[:lower:] ：所有小写字母<br>[:print:] ：所有可打印的字符(包含空格符)<br>[:punct:] ：所有标点字符<br>[:space:] ：所有水平与垂直空格符<br>[:upper:] ：所有大写字母<br>[:xdigit:] ：所有 16 进位制的数字<br>[=CHAR=] ：所有符合指定的字符(等号里的 CHAR，代表你可自订的字符)</p>\n<h3 id=\"uniq\"><a href=\"#uniq\" class=\"headerlink\" title=\"uniq\"></a>uniq</h3><p>Linux uniq 命令用于检查及删除文本文件中重复出现的行列，一般与 sort 命令结合使用。</p>\n<p>uniq 可检查文本文件中重复出现的行列。</p>\n<p>语法<br>uniq [-cdu][-f&lt;栏位&gt;][-s&lt;字符位置&gt;][-w&lt;字符位置&gt;][–help][–version][输入文件][输出文件]<br>参数：</p>\n<p>-c或–count 在每列旁边显示该行重复出现的次数。<br>-d或–repeated 仅显示重复出现的行列。<br>-f&lt;栏位&gt;或–skip-fields=&lt;栏位&gt; 忽略比较指定的栏位。<br>-s&lt;字符位置&gt;或–skip-chars=&lt;字符位置&gt; 忽略比较指定的字符。<br>-u或–unique 仅显示出一次的行列。<br>-w&lt;字符位置&gt;或–check-chars=&lt;字符位置&gt; 指定要比较的字符。<br>–help 显示帮助。<br>–version 显示版本信息。<br>[输入文件] 指定已排序好的文本文件。如果不指定此项，则从标准读取数据；<br>[输出文件] 指定输出的文件。如果不指定此选项，则将内容显示到标准输出设备（显示终端）。</p>\n<h3 id=\"wc\"><a href=\"#wc\" class=\"headerlink\" title=\"wc\"></a>wc</h3><p>Linux wc命令用于计算字数。</p>\n<p>利用wc指令我们可以计算文件的Byte数、字数、或是列数，若不指定文件名称、或是所给予的文件名为”-“，则wc指令会从标准输入设备读取数据。</p>\n<p>语法<br>wc [-clw][–help][–version][文件…]<br>参数：</p>\n<p>-c或–bytes或–chars 只显示Bytes数。<br>-l或–lines 只显示行数。<br>-w或–words 只显示字数。<br>–help 在线帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"let\"><a href=\"#let\" class=\"headerlink\" title=\"let\"></a>let</h3><p>let 命令是 BASH 中用于计算的工具，用于执行一个或多个表达式，变量计算中不需要加上 $ 来表示变量。如果表达式中包含了空格或其他特殊字符，则必须引起来。</p>\n<p>语法格式<br>let arg [arg …]<br>参数说明：<br>arg：要执行的表达式</p>\n<h3 id=\"sed\"><a href=\"#sed\" class=\"headerlink\" title=\"sed\"></a>sed</h3><p>Linux sed命令是利用script来处理文本文件。</p>\n<p>sed可依照script的指令，来处理、编辑文本文件。</p>\n<p>Sed主要用来自动编辑一个或多个文件；简化对文件的反复操作；编写转换程序等。</p>\n<p>语法<br>sed [-hnV][-e<script>][-f&lt;script文件&gt;][文本文件]<br>参数说明：</p>\n<p>-e<script>或–expression=<script> 以选项中指定的script来处理输入的文本文件。<br>-f&lt;script文件&gt;或–file=&lt;script文件&gt; 以选项中指定的script文件来处理输入的文本文件。<br>-h或–help 显示帮助。<br>-n或–quiet或–silent 仅显示script处理后的结果。<br>-V或–version 显示版本信息。<br>动作说明：</p>\n<p>a ：新增， a 的后面可以接字串，而这些字串会在新的一行出现(目前的下一行)～<br>c ：取代， c 的后面可以接字串，这些字串可以取代 n1,n2 之间的行！<br>d ：删除，因为是删除啊，所以 d 后面通常不接任何咚咚；<br>i ：插入， i 的后面可以接字串，而这些字串会在新的一行出现(目前的上一行)；<br>p ：打印，亦即将某个选择的数据印出。通常 p 会与参数 sed -n 一起运行～<br>s ：取代，可以直接进行取代的工作哩！通常这个 s 的动作可以搭配正规表示法.</p>\n</script></p>"},{"title":"linux命令整理(1)","_content":"\n\n\n1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read\n2 文档编辑:grep sed tr sort uniq wc let\n3 磁盘管理:cd df du mkdir pwd mount stat tree ls\n4 网络通讯:telnet httpd ifconfig netatat ping tty write\n5 系统管理:useradd data adduser exit kill ps  pstree top reboot sudo uname who whoami whois w id free\n6 系统设置:reset clear alias enable rpm set passwd time setup\n7 备份压缩:zip tar\n8 其他命令: bc tail\n\n## 文档命令\n\n### cat\n\n全称: concatenate files and print on the standard output\ncat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者\n语法格式:cat [-AbeEnstTuv] [--help] [--version] fileName\n参数说明：\n-n 或 --number：由 1 开始对所有输出的行数编号。\n-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。\n-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。\n-v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。\n-E 或 --show-ends : 在每行结束处显示 $。\n-T 或 --show-tabs: 将 TAB 字符显示为 ^I。\n-A, --show-all：等价于 -vET。\n-e：等价于\"-vE\"选项；\n-t：等价于\"-vT\"选项；\n\n把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：\ncat -n textfile1 > textfile2\n把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：\ncat -b textfile1 textfile2 >> textfile3\n清空 /etc/test.txt 文档内容：\ncat /dev/null > /etc/test.txt\ncat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：\ncat /dev/fd0 > OUTFILE\n相反的，如果想把 image file 写到软盘，输入：\ncat IMG_FILE > /dev/fd0\n注：\n1. OUTFILE 指输出的镜像文件名.\n2. IMG_FILE 指镜像文件。\n3. 若从镜像文件写回 device 时，device 容量需与相当。\n4. 通常用制作开机磁片\n\n### chgrp\n\nLinux chgrp命令用于变更文件或目录的所属群组。\n\n在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。\n\n语法:\nchgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\n参数说明\n　　-c或--changes 效果类似\"-v\"参数，但仅回报更改的部分。\n\n　　-f或--quiet或--silent 　不显示错误信息。\n\n　　-h或--no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。\n\n　　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。\n\n　　-v或--verbose 　显示指令执行过程。\n\n　　--help 　在线帮助。\n\n　　--reference=<参考文件或目录> 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。\n\n　　--version 　显示版本信息。\n\n### chmod\n\nLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。\n\n使用权限 : 所有使用者\n\n语法\nchmod [-cfvR] [--help] [--version] mode file...\n参数说明\nmode : 权限设定字串，格式如下 :\n\n[ugoa...][[+-=][rwxX]...][,...]\n其中：\n\nu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\n+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。\n其他参数说明：\n\n-c : 若该文件权限确实已经更改，才显示其更改动作\n-f : 若该文件权限无法被更改也不要显示错误讯息\n-v : 显示权限变更的详细资料\n-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n--help : 显示辅助说明\n--version : 显示版本\n实例\n将文件 file1.txt 设为所有人皆可读取 :\n\nchmod ugo+r file1.txt\n将文件 file1.txt 设为所有人皆可读取 :\n\nchmod a+r file1.txt\n将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :\n\nchmod ug+w,o-w file1.txt file2.txt\n将 ex1.py 设定为只有该文件拥有者可以执行 :\n\nchmod u+x ex1.py\n将目前目录下的所有文件与子目录皆设为任何人可读取 :\n\nchmod -R a+r *\n此外chmod也可以用数字来表示权限如 :\n\nchmod 777 file\n语法为：\n\nchmod abc file\n其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。\n\nr=4，w=2，x=1\n若要rwx属性则4+2+1=7；\n若要rw-属性则4+2=6；\n若要r-x属性则4+1=5。\nchmod a=rwx file\n和\n\nchmod 777 file\n效果相同\n\nchmod ug=rwx,o=x file\n和\n\nchmod 771 file\n效果相同\n\n若用chmod 4755 filename可使此程序具有root的权限\n\n### chown\n\nLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。\n一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。\n使用权限 : root\n语法\nchown [-cfhvR] [--help] [--version] user[:group] file...\n参数 :\nuser : 新的文件拥有者的使用者 ID\ngroup : 新的文件拥有者的使用者组(group)\n-c : 显示更改的部分的信息\n-f : 忽略错误信息\n-h :修复符号链接\n-v : 显示详细的处理信息\n-R : 处理指定目录以及其子目录下的所有文件\n--help : 显示辅助说明\n--version : 显示版本\n\n### file\n\nLinux file命令用于辨识文件类型。\n\n通过file指令，我们得以辨识该文件的类型。\n\n语法\nfile [-bcLvz][-f <名称文件>][-m <魔法数字文件>...][文件或目录...]\n参数：\n\n-b 　列出辨识结果时，不显示文件名称。\n-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。\n-f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。\n-L 　直接显示符号连接所指向的文件的类别。\n-m<魔法数字文件> 　指定魔法数字文件。\n-v 　显示版本信息。\n-z 　尝试去解读压缩文件的内容。\n[文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。\n\n### find\n\nLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n\n语法\nfind   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \\;\n参数说明 :\n\nfind 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。\n\nexpression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。\n\n-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件\n\n-amin n : 在过去 n 分钟内被读取过\n\n-anewer file : 比文件 file 更晚被读取过的文件\n\n-atime n : 在过去n天内被读取过的文件\n\n-cmin n : 在过去 n 分钟内被修改过\n\n-cnewer file :比文件 file 更新的文件\n\n-ctime n : 在过去n天内被修改过的文件\n\n-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name\n\n-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写\n\n-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写\n\n-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。\n\nd: 目录\n\nc: 字型装置文件\n\nb: 区块装置文件\n\np: 具名贮列\n\nf: 一般文件\n\nl: 符号连结\n\ns: socket\n\n-pid n : process id 是 n 的文件\n\n你可以使用 ( ) 将运算式分隔，并使用下列运算。\n\nexp1 -and exp2\n\n! expr\n\n-not expr\n\nexp1 -or exp2\n\nexp1, exp2\n\n### cut\n\nLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。\n\n语法\ncut  [-bn] [file]\ncut [-c] [file]\ncut [-df] [file]\n使用说明:\n\ncut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。\n\n如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。\n\n参数:\n\n-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n-c ：以字符为单位进行分割。\n-d ：自定义分隔符，默认为制表符。\n-f ：与-d一起使用，指定显示哪个区域。\n-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的\n范围之内，该字符将被写出；否则，该字符将被排除\n\n### ln\n\nLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。\n\n当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。\n\n语法\n ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为\n[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]\n\n[--help] [--version] [--]\n\n命令功能 : \nLinux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。\n\n不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。\n\n软链接：\n\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n2.软链接可以 跨文件系统 ，硬链接不可以\n3.软链接可以对一个不存在的文件名进行链接\n4.软链接可以对目录进行链接\n硬链接：\n\n1.硬链接，以文件副本的形式存在。但不占用实际空间。\n2.不允许给目录创建硬链接\n3.硬链接只有在同一个文件系统中才能创建\n命令参数\n必要参数：\n\n-b 删除，覆盖以前建立的链接\n-d 允许超级用户制作目录的硬链接\n-f 强制执行\n-i 交互模式，文件存在则提示用户是否覆盖\n-n 把符号链接视为一般目录\n-s 软链接(符号链接)\n-v 显示详细的处理过程\n选择参数：\n\n-S \"-S<字尾备份字符串> \"或 \"--suffix=<字尾备份字符串>\"\n-V \"-V<备份方式>\"或\"--version-control=<备份方式>\"\n--help 显示帮助信息\n--version 显示版本信息\n\n### less\n\nless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n\n语法\nless [参数] 文件 \n参数说明：\n\n-b <缓冲区大小> 设置缓冲区的大小\n-e 当文件显示结束后，自动离开\n-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n-g 只标志最后搜索的关键词\n-i 忽略搜索时的大小写\n-m 显示类似more命令的百分比\n-N 显示每行的行号\n-o <文件名> 将less 输出的内容在指定文件中保存起来\n-Q 不使用警告音\n-s 显示连续空行为一行\n-S 行过长时间将超出部分舍弃\n-x <数字> 将\"tab\"键显示为规定的数字空格\n/字符串：向下搜索\"字符串\"的功能\n?字符串：向上搜索\"字符串\"的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\nb 向后翻一页\nd 向后翻半页\nh 显示帮助界面\nQ 退出less 命令\nu 向前滚动半页\ny 向前滚动一行\n空格键 滚动一页\n回车键 滚动一行\n[pagedown]： 向下翻动一页\n[pageup]： 向上翻动一页\n\n### more\n\nLinux more命令\nLinux 命令大全 Linux 命令大全\n\nLinux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n语法\nmore [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]\n参数：\n\n-num 一次显示的行数\n-d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声\n-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能\n-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）\n-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容\n-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料\n-s 当遇到有连续两行以上的空白行，就代换为一行的空白行\n-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）\n+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示\n+num 从第 num 行开始显示\nfileNames 欲显示内容的文档，可为复数个数\n\n### mv\n\nLinux mv命令\nLinux 命令大全 Linux 命令大全\n\nLinux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。\n\n语法\nmv [options] source dest\nmv [options] source... directory\n参数说明：\n\n-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\n-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;\nmv参数设置与运行结果\n\nmv 文件名 文件名 将源文件名改为目标文件名\nmv 文件名 目录名 将文件移动到目标目录\nmv 目录名 目录名 目标目录已存在，将源目录\n移动到目标目录；目标\n目录不存在则改名\nmv 目录名 文件名 出错\n\n### rm\n\nrm命令用于删除一个文件或者目录。\n\n语法\nrm [options] name...\n参数：\n\n-i 删除前逐一询问确认。\n-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n-r 将目录及以下之档案亦逐一删除。\n\n### tee\n\nLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。\n\ntee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。\n\n语法\ntee [-ai][--help][--version][文件...]\n参数：\n\n-a或--append 　附加到既有文件的后面，而非覆盖它．\n-i或--ignore-interrupts 　忽略中断信号。\n--help 　在线帮助。\n--version 　显示版本信息。\n\n### touch\n\nLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\n\nls -l 可以显示档案的时间记录。\n\n语法\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\n参数说明：\na 改变档案的读取时间记录。\nm 改变档案的修改时间记录。\nc 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\nf 不使用，是为了与其他 unix 系统的相容性而保留。\nr 使用参考档的时间记录，与 --file 的效果一样。\nd 设定时间与日期，可以使用各种不同的格式。\nt 设定档案的时间记录，格式与 date 指令相同。\n--no-create 不会建立新档案。\n--help 列出指令格式。\n--version 列出版本讯息。\n\n### which\n\nLinux which命令用于查找文件。\n\nwhich指令会在环境变量$PATH设置的目录里查找符合条件的文件。\n\n语法\nwhich [文件...]\n参数：\n\n-n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n-p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。\n-w 　指定输出时栏位的宽度。\n-V 　显示版本信息\n\n### cp\n\nLinux cp命令主要用于复制文件或目录。\n\n语法\ncp [options] source dest\n或\n\ncp [options] source... directory\n参数说明：\n\n-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n-f：覆盖已经存在的目标文件而不给出提示。\n-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答\"y\"时目标文件将被覆盖。\n-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n-l：不复制文件，只是生成链接文件。\n\n### read\n\nLinux read命令用于从标准输入读取数值。\n\nread 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\n\n语法\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\n参数说明:\n\n-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。\n-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。\n-p 后面跟提示信息，即在输入前打印提示信息。\n-e 在输入的时候可以使用命令补全功能。\n-n 后跟一个数字，定义输入文本的长度，很实用。\n-r 屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了。\n-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。\n-t 后面跟秒数，定义输入字符的等待时间。\n-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。\n\n","source":"_posts/1 (7).md","raw":"---\ntitle: linux命令整理(1)\n\n\ncategories: \n- linux\ntags:\n- linux基础\n---\n\n\n\n1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read\n2 文档编辑:grep sed tr sort uniq wc let\n3 磁盘管理:cd df du mkdir pwd mount stat tree ls\n4 网络通讯:telnet httpd ifconfig netatat ping tty write\n5 系统管理:useradd data adduser exit kill ps  pstree top reboot sudo uname who whoami whois w id free\n6 系统设置:reset clear alias enable rpm set passwd time setup\n7 备份压缩:zip tar\n8 其他命令: bc tail\n\n## 文档命令\n\n### cat\n\n全称: concatenate files and print on the standard output\ncat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者\n语法格式:cat [-AbeEnstTuv] [--help] [--version] fileName\n参数说明：\n-n 或 --number：由 1 开始对所有输出的行数编号。\n-b 或 --number-nonblank：和 -n 相似，只不过对于空白行不编号。\n-s 或 --squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。\n-v 或 --show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。\n-E 或 --show-ends : 在每行结束处显示 $。\n-T 或 --show-tabs: 将 TAB 字符显示为 ^I。\n-A, --show-all：等价于 -vET。\n-e：等价于\"-vE\"选项；\n-t：等价于\"-vT\"选项；\n\n把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：\ncat -n textfile1 > textfile2\n把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：\ncat -b textfile1 textfile2 >> textfile3\n清空 /etc/test.txt 文档内容：\ncat /dev/null > /etc/test.txt\ncat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：\ncat /dev/fd0 > OUTFILE\n相反的，如果想把 image file 写到软盘，输入：\ncat IMG_FILE > /dev/fd0\n注：\n1. OUTFILE 指输出的镜像文件名.\n2. IMG_FILE 指镜像文件。\n3. 若从镜像文件写回 device 时，device 容量需与相当。\n4. 通常用制作开机磁片\n\n### chgrp\n\nLinux chgrp命令用于变更文件或目录的所属群组。\n\n在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。\n\n语法:\nchgrp [-cfhRv][--help][--version][所属群组][文件或目录...] 或 chgrp [-cfhRv][--help][--reference=<参考文件或目录>][--version][文件或目录...]\n参数说明\n　　-c或--changes 效果类似\"-v\"参数，但仅回报更改的部分。\n\n　　-f或--quiet或--silent 　不显示错误信息。\n\n　　-h或--no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。\n\n　　-R或--recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。\n\n　　-v或--verbose 　显示指令执行过程。\n\n　　--help 　在线帮助。\n\n　　--reference=<参考文件或目录> 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。\n\n　　--version 　显示版本信息。\n\n### chmod\n\nLinux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。\n\n使用权限 : 所有使用者\n\n语法\nchmod [-cfvR] [--help] [--version] mode file...\n参数说明\nmode : 权限设定字串，格式如下 :\n\n[ugoa...][[+-=][rwxX]...][,...]\n其中：\n\nu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\n+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。\n其他参数说明：\n\n-c : 若该文件权限确实已经更改，才显示其更改动作\n-f : 若该文件权限无法被更改也不要显示错误讯息\n-v : 显示权限变更的详细资料\n-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n--help : 显示辅助说明\n--version : 显示版本\n实例\n将文件 file1.txt 设为所有人皆可读取 :\n\nchmod ugo+r file1.txt\n将文件 file1.txt 设为所有人皆可读取 :\n\nchmod a+r file1.txt\n将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :\n\nchmod ug+w,o-w file1.txt file2.txt\n将 ex1.py 设定为只有该文件拥有者可以执行 :\n\nchmod u+x ex1.py\n将目前目录下的所有文件与子目录皆设为任何人可读取 :\n\nchmod -R a+r *\n此外chmod也可以用数字来表示权限如 :\n\nchmod 777 file\n语法为：\n\nchmod abc file\n其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。\n\nr=4，w=2，x=1\n若要rwx属性则4+2+1=7；\n若要rw-属性则4+2=6；\n若要r-x属性则4+1=5。\nchmod a=rwx file\n和\n\nchmod 777 file\n效果相同\n\nchmod ug=rwx,o=x file\n和\n\nchmod 771 file\n效果相同\n\n若用chmod 4755 filename可使此程序具有root的权限\n\n### chown\n\nLinux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。\n一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。\n使用权限 : root\n语法\nchown [-cfhvR] [--help] [--version] user[:group] file...\n参数 :\nuser : 新的文件拥有者的使用者 ID\ngroup : 新的文件拥有者的使用者组(group)\n-c : 显示更改的部分的信息\n-f : 忽略错误信息\n-h :修复符号链接\n-v : 显示详细的处理信息\n-R : 处理指定目录以及其子目录下的所有文件\n--help : 显示辅助说明\n--version : 显示版本\n\n### file\n\nLinux file命令用于辨识文件类型。\n\n通过file指令，我们得以辨识该文件的类型。\n\n语法\nfile [-bcLvz][-f <名称文件>][-m <魔法数字文件>...][文件或目录...]\n参数：\n\n-b 　列出辨识结果时，不显示文件名称。\n-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。\n-f<名称文件> 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。\n-L 　直接显示符号连接所指向的文件的类别。\n-m<魔法数字文件> 　指定魔法数字文件。\n-v 　显示版本信息。\n-z 　尝试去解读压缩文件的内容。\n[文件或目录...] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。\n\n### find\n\nLinux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。\n\n语法\nfind   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \\;\n参数说明 :\n\nfind 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。\n\nexpression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。\n\n-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件\n\n-amin n : 在过去 n 分钟内被读取过\n\n-anewer file : 比文件 file 更晚被读取过的文件\n\n-atime n : 在过去n天内被读取过的文件\n\n-cmin n : 在过去 n 分钟内被修改过\n\n-cnewer file :比文件 file 更新的文件\n\n-ctime n : 在过去n天内被修改过的文件\n\n-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name\n\n-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写\n\n-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写\n\n-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。\n\nd: 目录\n\nc: 字型装置文件\n\nb: 区块装置文件\n\np: 具名贮列\n\nf: 一般文件\n\nl: 符号连结\n\ns: socket\n\n-pid n : process id 是 n 的文件\n\n你可以使用 ( ) 将运算式分隔，并使用下列运算。\n\nexp1 -and exp2\n\n! expr\n\n-not expr\n\nexp1 -or exp2\n\nexp1, exp2\n\n### cut\n\nLinux cut命令用于显示每行从开头算起 num1 到 num2 的文字。\n\n语法\ncut  [-bn] [file]\ncut [-c] [file]\ncut [-df] [file]\n使用说明:\n\ncut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。\n\n如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。\n\n参数:\n\n-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。\n-c ：以字符为单位进行分割。\n-d ：自定义分隔符，默认为制表符。\n-f ：与-d一起使用，指定显示哪个区域。\n-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的\n范围之内，该字符将被写出；否则，该字符将被排除\n\n### ln\n\nLinux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。\n\n当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。\n\n语法\n ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为\n[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]\n\n[--help] [--version] [--]\n\n命令功能 : \nLinux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。\n\n不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。\n\n软链接：\n\n1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式\n2.软链接可以 跨文件系统 ，硬链接不可以\n3.软链接可以对一个不存在的文件名进行链接\n4.软链接可以对目录进行链接\n硬链接：\n\n1.硬链接，以文件副本的形式存在。但不占用实际空间。\n2.不允许给目录创建硬链接\n3.硬链接只有在同一个文件系统中才能创建\n命令参数\n必要参数：\n\n-b 删除，覆盖以前建立的链接\n-d 允许超级用户制作目录的硬链接\n-f 强制执行\n-i 交互模式，文件存在则提示用户是否覆盖\n-n 把符号链接视为一般目录\n-s 软链接(符号链接)\n-v 显示详细的处理过程\n选择参数：\n\n-S \"-S<字尾备份字符串> \"或 \"--suffix=<字尾备份字符串>\"\n-V \"-V<备份方式>\"或\"--version-control=<备份方式>\"\n--help 显示帮助信息\n--version 显示版本信息\n\n### less\n\nless 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。\n\n语法\nless [参数] 文件 \n参数说明：\n\n-b <缓冲区大小> 设置缓冲区的大小\n-e 当文件显示结束后，自动离开\n-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件\n-g 只标志最后搜索的关键词\n-i 忽略搜索时的大小写\n-m 显示类似more命令的百分比\n-N 显示每行的行号\n-o <文件名> 将less 输出的内容在指定文件中保存起来\n-Q 不使用警告音\n-s 显示连续空行为一行\n-S 行过长时间将超出部分舍弃\n-x <数字> 将\"tab\"键显示为规定的数字空格\n/字符串：向下搜索\"字符串\"的功能\n?字符串：向上搜索\"字符串\"的功能\nn：重复前一个搜索（与 / 或 ? 有关）\nN：反向重复前一个搜索（与 / 或 ? 有关）\nb 向后翻一页\nd 向后翻半页\nh 显示帮助界面\nQ 退出less 命令\nu 向前滚动半页\ny 向前滚动一行\n空格键 滚动一页\n回车键 滚动一行\n[pagedown]： 向下翻动一页\n[pageup]： 向上翻动一页\n\n### more\n\nLinux more命令\nLinux 命令大全 Linux 命令大全\n\nLinux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。\n\n语法\nmore [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]\n参数：\n\n-num 一次显示的行数\n-d 提示使用者，在画面下方显示 [Press space to continue, 'q' to quit.] ，如果使用者按错键，则会显示 [Press 'h' for instructions.] 而不是 '哔' 声\n-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能\n-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）\n-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容\n-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料\n-s 当遇到有连续两行以上的空白行，就代换为一行的空白行\n-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）\n+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示\n+num 从第 num 行开始显示\nfileNames 欲显示内容的文档，可为复数个数\n\n### mv\n\nLinux mv命令\nLinux 命令大全 Linux 命令大全\n\nLinux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。\n\n语法\nmv [options] source dest\nmv [options] source... directory\n参数说明：\n\n-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;\n-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;\nmv参数设置与运行结果\n\nmv 文件名 文件名 将源文件名改为目标文件名\nmv 文件名 目录名 将文件移动到目标目录\nmv 目录名 目录名 目标目录已存在，将源目录\n移动到目标目录；目标\n目录不存在则改名\nmv 目录名 文件名 出错\n\n### rm\n\nrm命令用于删除一个文件或者目录。\n\n语法\nrm [options] name...\n参数：\n\n-i 删除前逐一询问确认。\n-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。\n-r 将目录及以下之档案亦逐一删除。\n\n### tee\n\nLinux tee命令用于读取标准输入的数据，并将其内容输出成文件。\n\ntee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。\n\n语法\ntee [-ai][--help][--version][文件...]\n参数：\n\n-a或--append 　附加到既有文件的后面，而非覆盖它．\n-i或--ignore-interrupts 　忽略中断信号。\n--help 　在线帮助。\n--version 　显示版本信息。\n\n### touch\n\nLinux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。\n\nls -l 可以显示档案的时间记录。\n\n语法\ntouch [-acfm][-d<日期时间>][-r<参考文件或目录>] [-t<日期时间>][--help][--version][文件或目录…]\n参数说明：\na 改变档案的读取时间记录。\nm 改变档案的修改时间记录。\nc 假如目的档案不存在，不会建立新的档案。与 --no-create 的效果一样。\nf 不使用，是为了与其他 unix 系统的相容性而保留。\nr 使用参考档的时间记录，与 --file 的效果一样。\nd 设定时间与日期，可以使用各种不同的格式。\nt 设定档案的时间记录，格式与 date 指令相同。\n--no-create 不会建立新档案。\n--help 列出指令格式。\n--version 列出版本讯息。\n\n### which\n\nLinux which命令用于查找文件。\n\nwhich指令会在环境变量$PATH设置的目录里查找符合条件的文件。\n\n语法\nwhich [文件...]\n参数：\n\n-n<文件名长度> 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。\n-p<文件名长度> 　与-n参数相同，但此处的<文件名长度>包括了文件的路径。\n-w 　指定输出时栏位的宽度。\n-V 　显示版本信息\n\n### cp\n\nLinux cp命令主要用于复制文件或目录。\n\n语法\ncp [options] source dest\n或\n\ncp [options] source... directory\n参数说明：\n\n-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。\n-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。\n-f：覆盖已经存在的目标文件而不给出提示。\n-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答\"y\"时目标文件将被覆盖。\n-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。\n-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。\n-l：不复制文件，只是生成链接文件。\n\n### read\n\nLinux read命令用于从标准输入读取数值。\n\nread 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。\n\n语法\nread [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name ...]\n参数说明:\n\n-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。\n-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。\n-p 后面跟提示信息，即在输入前打印提示信息。\n-e 在输入的时候可以使用命令补全功能。\n-n 后跟一个数字，定义输入文本的长度，很实用。\n-r 屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了。\n-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。\n-t 后面跟秒数，定义输入字符的等待时间。\n-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。\n\n","slug":"1 (7)","published":1,"date":"2019-04-01T02:01:12.162Z","updated":"2019-06-19T14:46:07.833Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8fb002ojkufnuwyus90","content":"<p>1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read<br>2 文档编辑:grep sed tr sort uniq wc let<br>3 磁盘管理:cd df du mkdir pwd mount stat tree ls<br>4 网络通讯:telnet httpd ifconfig netatat ping tty write<br>5 系统管理:useradd data adduser exit kill ps  pstree top reboot sudo uname who whoami whois w id free<br>6 系统设置:reset clear alias enable rpm set passwd time setup<br>7 备份压缩:zip tar<br>8 其他命令: bc tail</p>\n<h2 id=\"文档命令\"><a href=\"#文档命令\" class=\"headerlink\" title=\"文档命令\"></a>文档命令</h2><h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><p>全称: concatenate files and print on the standard output<br>cat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者<br>语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName<br>参数说明：<br>-n 或 –number：由 1 开始对所有输出的行数编号。<br>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。<br>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 –show-ends : 在每行结束处显示 $。<br>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。<br>-A, –show-all：等价于 -vET。<br>-e：等价于”-vE”选项；<br>-t：等价于”-vT”选项；</p>\n<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：<br>cat -n textfile1 &gt; textfile2<br>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：<br>cat -b textfile1 textfile2 &gt;&gt; textfile3<br>清空 /etc/test.txt 文档内容：<br>cat /dev/null &gt; /etc/test.txt<br>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：<br>cat /dev/fd0 &gt; OUTFILE<br>相反的，如果想把 image file 写到软盘，输入：<br>cat IMG_FILE &gt; /dev/fd0<br>注：</p>\n<ol>\n<li>OUTFILE 指输出的镜像文件名.</li>\n<li>IMG_FILE 指镜像文件。</li>\n<li>若从镜像文件写回 device 时，device 容量需与相当。</li>\n<li>通常用制作开机磁片</li>\n</ol>\n<h3 id=\"chgrp\"><a href=\"#chgrp\" class=\"headerlink\" title=\"chgrp\"></a>chgrp</h3><p>Linux chgrp命令用于变更文件或目录的所属群组。</p>\n<p>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>\n<p>语法:<br>chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br>参数说明<br>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p>\n<p>　　-f或–quiet或–silent 　不显示错误信息。</p>\n<p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p>\n<p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p>\n<p>　　-v或–verbose 　显示指令执行过程。</p>\n<p>　　–help 　在线帮助。</p>\n<p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p>\n<p>　　–version 　显示版本信息。</p>\n<h3 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>\n<p>使用权限 : 所有使用者</p>\n<p>语法<br>chmod [-cfvR] [–help] [–version] mode file…<br>参数说明<br>mode : 权限设定字串，格式如下 :</p>\n<p>[ugoa…][[+-=][rwxX]…][,…]<br>其中：</p>\n<p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>\n<ul>\n<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li>\n</ul>\n<p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本<br>实例<br>将文件 file1.txt 设为所有人皆可读取 :</p>\n<p>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :</p>\n<p>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>\n<p>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>\n<p>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>\n<p>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :</p>\n<p>chmod 777 file<br>语法为：</p>\n<p>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>\n<p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br>chmod a=rwx file<br>和</p>\n<p>chmod 777 file<br>效果相同</p>\n<p>chmod ug=rwx,o=x file<br>和</p>\n<p>chmod 771 file<br>效果相同</p>\n<p>若用chmod 4755 filename可使此程序具有root的权限</p>\n<h3 id=\"chown\"><a href=\"#chown\" class=\"headerlink\" title=\"chown\"></a>chown</h3><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。<br>使用权限 : root<br>语法<br>chown [-cfhvR] [–help] [–version] user[:group] file…<br>参数 :<br>user : 新的文件拥有者的使用者 ID<br>group : 新的文件拥有者的使用者组(group)<br>-c : 显示更改的部分的信息<br>-f : 忽略错误信息<br>-h :修复符号链接<br>-v : 显示详细的处理信息<br>-R : 处理指定目录以及其子目录下的所有文件<br>–help : 显示辅助说明<br>–version : 显示版本</p>\n<h3 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h3><p>Linux file命令用于辨识文件类型。</p>\n<p>通过file指令，我们得以辨识该文件的类型。</p>\n<p>语法<br>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]<br>参数：</p>\n<p>-b 　列出辨识结果时，不显示文件名称。<br>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。<br>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。<br>-L 　直接显示符号连接所指向的文件的类别。<br>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。<br>-v 　显示版本信息。<br>-z 　尝试去解读压缩文件的内容。<br>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>\n<p>语法<br>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \\;<br>参数说明 :</p>\n<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>\n<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>\n<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>\n<p>-amin n : 在过去 n 分钟内被读取过</p>\n<p>-anewer file : 比文件 file 更晚被读取过的文件</p>\n<p>-atime n : 在过去n天内被读取过的文件</p>\n<p>-cmin n : 在过去 n 分钟内被修改过</p>\n<p>-cnewer file :比文件 file 更新的文件</p>\n<p>-ctime n : 在过去n天内被修改过的文件</p>\n<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>\n<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>\n<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p>\n<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>\n<p>d: 目录</p>\n<p>c: 字型装置文件</p>\n<p>b: 区块装置文件</p>\n<p>p: 具名贮列</p>\n<p>f: 一般文件</p>\n<p>l: 符号连结</p>\n<p>s: socket</p>\n<p>-pid n : process id 是 n 的文件</p>\n<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>\n<p>exp1 -and exp2</p>\n<p>! expr</p>\n<p>-not expr</p>\n<p>exp1 -or exp2</p>\n<p>exp1, exp2</p>\n<h3 id=\"cut\"><a href=\"#cut\" class=\"headerlink\" title=\"cut\"></a>cut</h3><p>Linux cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p>\n<p>语法<br>cut  [-bn] [file]<br>cut [-c] [file]<br>cut [-df] [file]<br>使用说明:</p>\n<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>\n<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p>\n<p>参数:</p>\n<p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<br>-c ：以字符为单位进行分割。<br>-d ：自定义分隔符，默认为制表符。<br>-f ：与-d一起使用，指定显示哪个区域。<br>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</p>\n<h3 id=\"ln\"><a href=\"#ln\" class=\"headerlink\" title=\"ln\"></a>ln</h3><p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>\n<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>\n<p>语法<br> ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为<br>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>\n<p>[–help] [–version] [–]</p>\n<p>命令功能 :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>\n<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>\n<p>软链接：</p>\n<p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>硬链接：</p>\n<p>1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>2.不允许给目录创建硬链接<br>3.硬链接只有在同一个文件系统中才能创建<br>命令参数<br>必要参数：</p>\n<p>-b 删除，覆盖以前建立的链接<br>-d 允许超级用户制作目录的硬链接<br>-f 强制执行<br>-i 交互模式，文件存在则提示用户是否覆盖<br>-n 把符号链接视为一般目录<br>-s 软链接(符号链接)<br>-v 显示详细的处理过程<br>选择参数：</p>\n<p>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”<br>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”<br>–help 显示帮助信息<br>–version 显示版本信息</p>\n<h3 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>\n<p>语法<br>less [参数] 文件<br>参数说明：</p>\n<p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小<br>-e 当文件显示结束后，自动离开<br>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件<br>-g 只标志最后搜索的关键词<br>-i 忽略搜索时的大小写<br>-m 显示类似more命令的百分比<br>-N 显示每行的行号<br>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>-Q 不使用警告音<br>-s 显示连续空行为一行<br>-S 行过长时间将超出部分舍弃<br>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格<br>/字符串：向下搜索”字符串”的功能<br>?字符串：向上搜索”字符串”的功能<br>n：重复前一个搜索（与 / 或 ? 有关）<br>N：反向重复前一个搜索（与 / 或 ? 有关）<br>b 向后翻一页<br>d 向后翻半页<br>h 显示帮助界面<br>Q 退出less 命令<br>u 向前滚动半页<br>y 向前滚动一行<br>空格键 滚动一页<br>回车键 滚动一行<br>[pagedown]： 向下翻动一页<br>[pageup]： 向上翻动一页</p>\n<h3 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more\"></a>more</h3><p>Linux more命令<br>Linux 命令大全 Linux 命令大全</p>\n<p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p>\n<p>语法<br>more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]<br>参数：</p>\n<p>-num 一次显示的行数<br>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声<br>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能<br>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）<br>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容<br>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料<br>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）<br>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示<br>+num 从第 num 行开始显示<br>fileNames 欲显示内容的文档，可为复数个数</p>\n<h3 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h3><p>Linux mv命令<br>Linux 命令大全 Linux 命令大全</p>\n<p>Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>\n<p>语法<br>mv [options] source dest<br>mv [options] source… directory<br>参数说明：</p>\n<p>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;<br>-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;<br>mv参数设置与运行结果</p>\n<p>mv 文件名 文件名 将源文件名改为目标文件名<br>mv 文件名 目录名 将文件移动到目标目录<br>mv 目录名 目录名 目标目录已存在，将源目录<br>移动到目标目录；目标<br>目录不存在则改名<br>mv 目录名 文件名 出错</p>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>rm命令用于删除一个文件或者目录。</p>\n<p>语法<br>rm [options] name…<br>参数：</p>\n<p>-i 删除前逐一询问确认。<br>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r 将目录及以下之档案亦逐一删除。</p>\n<h3 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h3><p>Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。</p>\n<p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p>\n<p>语法<br>tee [-ai][–help][–version][文件…]<br>参数：</p>\n<p>-a或–append 　附加到既有文件的后面，而非覆盖它．<br>-i或–ignore-interrupts 　忽略中断信号。<br>–help 　在线帮助。<br>–version 　显示版本信息。</p>\n<h3 id=\"touch\"><a href=\"#touch\" class=\"headerlink\" title=\"touch\"></a>touch</h3><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>\n<p>ls -l 可以显示档案的时间记录。</p>\n<p>语法<br>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]<br>参数说明：<br>a 改变档案的读取时间记录。<br>m 改变档案的修改时间记录。<br>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。<br>f 不使用，是为了与其他 unix 系统的相容性而保留。<br>r 使用参考档的时间记录，与 –file 的效果一样。<br>d 设定时间与日期，可以使用各种不同的格式。<br>t 设定档案的时间记录，格式与 date 指令相同。<br>–no-create 不会建立新档案。<br>–help 列出指令格式。<br>–version 列出版本讯息。</p>\n<h3 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h3><p>Linux which命令用于查找文件。</p>\n<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>\n<p>语法<br>which [文件…]<br>参数：</p>\n<p>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。<br>-w 　指定输出时栏位的宽度。<br>-V 　显示版本信息</p>\n<h3 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h3><p>Linux cp命令主要用于复制文件或目录。</p>\n<p>语法<br>cp [options] source dest<br>或</p>\n<p>cp [options] source… directory<br>参数说明：</p>\n<p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。<br>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p>\n<h3 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h3><p>Linux read命令用于从标准输入读取数值。</p>\n<p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p>\n<p>语法<br>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]<br>参数说明:</p>\n<p>-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。<br>-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。<br>-p 后面跟提示信息，即在输入前打印提示信息。<br>-e 在输入的时候可以使用命令补全功能。<br>-n 后跟一个数字，定义输入文本的长度，很实用。<br>-r 屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了。<br>-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。<br>-t 后面跟秒数，定义输入字符的等待时间。<br>-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>1 文档管理cat chgrp chmod chown file find  cut in less more mv tee touch which cp read<br>2 文档编辑:grep sed tr sort uniq wc let<br>3 磁盘管理:cd df du mkdir pwd mount stat tree ls<br>4 网络通讯:telnet httpd ifconfig netatat ping tty write<br>5 系统管理:useradd data adduser exit kill ps  pstree top reboot sudo uname who whoami whois w id free<br>6 系统设置:reset clear alias enable rpm set passwd time setup<br>7 备份压缩:zip tar<br>8 其他命令: bc tail</p>\n<h2 id=\"文档命令\"><a href=\"#文档命令\" class=\"headerlink\" title=\"文档命令\"></a>文档命令</h2><h3 id=\"cat\"><a href=\"#cat\" class=\"headerlink\" title=\"cat\"></a>cat</h3><p>全称: concatenate files and print on the standard output<br>cat 命令用于连接文件并打印到标准输出设备上。使用权限:所有使用者<br>语法格式:cat [-AbeEnstTuv] [–help] [–version] fileName<br>参数说明：<br>-n 或 –number：由 1 开始对所有输出的行数编号。<br>-b 或 –number-nonblank：和 -n 相似，只不过对于空白行不编号。<br>-s 或 –squeeze-blank：当遇到有连续两行以上的空白行，就代换为一行的空白行。<br>-v 或 –show-nonprinting：使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外。<br>-E 或 –show-ends : 在每行结束处显示 $。<br>-T 或 –show-tabs: 将 TAB 字符显示为 ^I。<br>-A, –show-all：等价于 -vET。<br>-e：等价于”-vE”选项；<br>-t：等价于”-vT”选项；</p>\n<p>把 textfile1 的文档内容加上行号后输入 textfile2 这个文档里：<br>cat -n textfile1 &gt; textfile2<br>把 textfile1 和 textfile2 的文档内容加上行号（空白行不加）之后将内容附加到 textfile3 文档里：<br>cat -b textfile1 textfile2 &gt;&gt; textfile3<br>清空 /etc/test.txt 文档内容：<br>cat /dev/null &gt; /etc/test.txt<br>cat 也可以用来制作镜像文件。例如要制作软盘的镜像文件，将软盘放好后输入：<br>cat /dev/fd0 &gt; OUTFILE<br>相反的，如果想把 image file 写到软盘，输入：<br>cat IMG_FILE &gt; /dev/fd0<br>注：</p>\n<ol>\n<li>OUTFILE 指输出的镜像文件名.</li>\n<li>IMG_FILE 指镜像文件。</li>\n<li>若从镜像文件写回 device 时，device 容量需与相当。</li>\n<li>通常用制作开机磁片</li>\n</ol>\n<h3 id=\"chgrp\"><a href=\"#chgrp\" class=\"headerlink\" title=\"chgrp\"></a>chgrp</h3><p>Linux chgrp命令用于变更文件或目录的所属群组。</p>\n<p>在UNIX系统家族里，文件或目录权限的掌控以拥有者及所属群组来管理。您可以使用chgrp指令去变更文件与目录的所属群组，设置方式采用群组名称或群组识别码皆可。</p>\n<p>语法:<br>chgrp [-cfhRv][–help][–version][所属群组][文件或目录…] 或 chgrp [-cfhRv][–help][–reference=&lt;参考文件或目录&gt;][–version][文件或目录…]<br>参数说明<br>　　-c或–changes 效果类似”-v”参数，但仅回报更改的部分。</p>\n<p>　　-f或–quiet或–silent 　不显示错误信息。</p>\n<p>　　-h或–no-dereference 　只对符号连接的文件作修改，而不更动其他任何相关文件。</p>\n<p>　　-R或–recursive 　递归处理，将指定目录下的所有文件及子目录一并处理。</p>\n<p>　　-v或–verbose 　显示指令执行过程。</p>\n<p>　　–help 　在线帮助。</p>\n<p>　　–reference=&lt;参考文件或目录&gt; 　把指定文件或目录的所属群组全部设成和参考文件或目录的所属群组相同。</p>\n<p>　　–version 　显示版本信息。</p>\n<h3 id=\"chmod\"><a href=\"#chmod\" class=\"headerlink\" title=\"chmod\"></a>chmod</h3><p>Linux/Unix 的文件调用权限分为三级 : 文件拥有者、群组、其他。利用 chmod 可以藉以控制文件如何被他人所调用。</p>\n<p>使用权限 : 所有使用者</p>\n<p>语法<br>chmod [-cfvR] [–help] [–version] mode file…<br>参数说明<br>mode : 权限设定字串，格式如下 :</p>\n<p>[ugoa…][[+-=][rwxX]…][,…]<br>其中：</p>\n<p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>\n<ul>\n<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li>\n</ul>\n<p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本<br>实例<br>将文件 file1.txt 设为所有人皆可读取 :</p>\n<p>chmod ugo+r file1.txt<br>将文件 file1.txt 设为所有人皆可读取 :</p>\n<p>chmod a+r file1.txt<br>将文件 file1.txt 与 file2.txt 设为该文件拥有者，与其所属同一个群体者可写入，但其他以外的人则不可写入 :</p>\n<p>chmod ug+w,o-w file1.txt file2.txt<br>将 ex1.py 设定为只有该文件拥有者可以执行 :</p>\n<p>chmod u+x ex1.py<br>将目前目录下的所有文件与子目录皆设为任何人可读取 :</p>\n<p>chmod -R a+r *<br>此外chmod也可以用数字来表示权限如 :</p>\n<p>chmod 777 file<br>语法为：</p>\n<p>chmod abc file<br>其中a,b,c各为一个数字，分别表示User、Group、及Other的权限。</p>\n<p>r=4，w=2，x=1<br>若要rwx属性则4+2+1=7；<br>若要rw-属性则4+2=6；<br>若要r-x属性则4+1=5。<br>chmod a=rwx file<br>和</p>\n<p>chmod 777 file<br>效果相同</p>\n<p>chmod ug=rwx,o=x file<br>和</p>\n<p>chmod 771 file<br>效果相同</p>\n<p>若用chmod 4755 filename可使此程序具有root的权限</p>\n<h3 id=\"chown\"><a href=\"#chown\" class=\"headerlink\" title=\"chown\"></a>chown</h3><p>Linux/Unix 是多人多工操作系统，所有的文件皆有拥有者。利用 chown 将指定文件的拥有者改为指定的用户或组，用户可以是用户名或者用户ID；组可以是组名或者组ID；文件是以空格分开的要改变权限的文件列表，支持通配符。 。<br>一般来说，这个指令只有是由系统管理者(root)所使用，一般使用者没有权限可以改变别人的文件拥有者，也没有权限可以自己的文件拥有者改设为别人。只有系统管理者(root)才有这样的权限。<br>使用权限 : root<br>语法<br>chown [-cfhvR] [–help] [–version] user[:group] file…<br>参数 :<br>user : 新的文件拥有者的使用者 ID<br>group : 新的文件拥有者的使用者组(group)<br>-c : 显示更改的部分的信息<br>-f : 忽略错误信息<br>-h :修复符号链接<br>-v : 显示详细的处理信息<br>-R : 处理指定目录以及其子目录下的所有文件<br>–help : 显示辅助说明<br>–version : 显示版本</p>\n<h3 id=\"file\"><a href=\"#file\" class=\"headerlink\" title=\"file\"></a>file</h3><p>Linux file命令用于辨识文件类型。</p>\n<p>通过file指令，我们得以辨识该文件的类型。</p>\n<p>语法<br>file [-bcLvz][-f &lt;名称文件&gt;][-m &lt;魔法数字文件&gt;…][文件或目录…]<br>参数：</p>\n<p>-b 　列出辨识结果时，不显示文件名称。<br>-c 　详细显示指令执行过程，便于排错或分析程序执行的情形。<br>-f&lt;名称文件&gt; 　指定名称文件，其内容有一个或多个文件名称时，让file依序辨识这些文件，格式为每列一个文件名称。<br>-L 　直接显示符号连接所指向的文件的类别。<br>-m&lt;魔法数字文件&gt; 　指定魔法数字文件。<br>-v 　显示版本信息。<br>-z 　尝试去解读压缩文件的内容。<br>[文件或目录…] 要确定类型的文件列表，多个文件之间使用空格分开，可以使用shell通配符匹配多个文件。</p>\n<h3 id=\"find\"><a href=\"#find\" class=\"headerlink\" title=\"find\"></a>find</h3><p>Linux find命令用来在指定目录下查找文件。任何位于参数之前的字符串都将被视为欲查找的目录名。如果使用该命令时，不设置任何参数，则find命令将在当前目录下查找子目录与文件。并且将查找到的子目录和文件全部进行显示。</p>\n<p>语法<br>find   path   -option   [   -print ]   [ -exec   -ok   command ]   {} \\;<br>参数说明 :</p>\n<p>find 根据下列规则判断 path 和 expression，在命令列上第一个 - ( ) , ! 之前的部份为 path，之后的是 expression。如果 path 是空字串则使用目前路径，如果 expression 是空字串则使用 -print 为预设 expression。</p>\n<p>expression 中可使用的选项有二三十个之多，在此只介绍最常用的部份。</p>\n<p>-mount, -xdev : 只检查和指定目录在同一个文件系统下的文件，避免列出其它文件系统中的文件</p>\n<p>-amin n : 在过去 n 分钟内被读取过</p>\n<p>-anewer file : 比文件 file 更晚被读取过的文件</p>\n<p>-atime n : 在过去n天内被读取过的文件</p>\n<p>-cmin n : 在过去 n 分钟内被修改过</p>\n<p>-cnewer file :比文件 file 更新的文件</p>\n<p>-ctime n : 在过去n天内被修改过的文件</p>\n<p>-empty : 空的文件-gid n or -group name : gid 是 n 或是 group 名称是 name</p>\n<p>-ipath p, -path p : 路径名称符合 p 的文件，ipath 会忽略大小写</p>\n<p>-name name, -iname name : 文件名称符合 name 的文件。iname 会忽略大小写</p>\n<p>-size n : 文件大小 是 n 单位，b 代表 512 位元组的区块，c 表示字元数，k 表示 kilo bytes，w 是二个位元组。-type c : 文件类型是 c 的文件。</p>\n<p>d: 目录</p>\n<p>c: 字型装置文件</p>\n<p>b: 区块装置文件</p>\n<p>p: 具名贮列</p>\n<p>f: 一般文件</p>\n<p>l: 符号连结</p>\n<p>s: socket</p>\n<p>-pid n : process id 是 n 的文件</p>\n<p>你可以使用 ( ) 将运算式分隔，并使用下列运算。</p>\n<p>exp1 -and exp2</p>\n<p>! expr</p>\n<p>-not expr</p>\n<p>exp1 -or exp2</p>\n<p>exp1, exp2</p>\n<h3 id=\"cut\"><a href=\"#cut\" class=\"headerlink\" title=\"cut\"></a>cut</h3><p>Linux cut命令用于显示每行从开头算起 num1 到 num2 的文字。</p>\n<p>语法<br>cut  [-bn] [file]<br>cut [-c] [file]<br>cut [-df] [file]<br>使用说明:</p>\n<p>cut 命令从文件的每一行剪切字节、字符和字段并将这些字节、字符和字段写至标准输出。</p>\n<p>如果不指定 File 参数，cut 命令将读取标准输入。必须指定 -b、-c 或 -f 标志之一。</p>\n<p>参数:</p>\n<p>-b ：以字节为单位进行分割。这些字节位置将忽略多字节字符边界，除非也指定了 -n 标志。<br>-c ：以字符为单位进行分割。<br>-d ：自定义分隔符，默认为制表符。<br>-f ：与-d一起使用，指定显示哪个区域。<br>-n ：取消分割多字节字符。仅和 -b 标志一起使用。如果字符的最后一个字节落在由 -b 标志的 List 参数指示的<br>范围之内，该字符将被写出；否则，该字符将被排除</p>\n<h3 id=\"ln\"><a href=\"#ln\" class=\"headerlink\" title=\"ln\"></a>ln</h3><p>Linux ln命令是一个非常重要命令，它的功能是为某一个文件在另外一个位置建立一个同步的链接。</p>\n<p>当我们需要在不同的目录，用到相同的文件时，我们不需要在每一个需要的目录下都放一个必须相同的文件，我们只要在某个固定的目录，放上该文件，然后在 其它的目录下用ln命令链接（link）它就可以，不必重复的占用磁盘空间。</p>\n<p>语法<br> ln [参数][源文件或目录][目标文件或目录] 其中参数的格式为<br>[-bdfinsvF] [-S backup-suffix] [-V {numbered,existing,simple}]</p>\n<p>[–help] [–version] [–]</p>\n<p>命令功能 :<br>Linux文件系统中，有所谓的链接(link)，我们可以将其视为档案的别名，而链接又可分为两种 : 硬链接(hard link)与软链接(symbolic link)，硬链接的意思是一个档案可以有多个名称，而软链接的方式则是产生一个特殊的档案，该档案的内容是指向另一个档案的位置。硬链接是存在同一个文件系统中，而软链接却可以跨越不同的文件系统。</p>\n<p>不论是硬链接或软链接都不会将原本的档案复制一份，只会占用非常少量的磁碟空间。</p>\n<p>软链接：</p>\n<p>1.软链接，以路径的形式存在。类似于Windows操作系统中的快捷方式<br>2.软链接可以 跨文件系统 ，硬链接不可以<br>3.软链接可以对一个不存在的文件名进行链接<br>4.软链接可以对目录进行链接<br>硬链接：</p>\n<p>1.硬链接，以文件副本的形式存在。但不占用实际空间。<br>2.不允许给目录创建硬链接<br>3.硬链接只有在同一个文件系统中才能创建<br>命令参数<br>必要参数：</p>\n<p>-b 删除，覆盖以前建立的链接<br>-d 允许超级用户制作目录的硬链接<br>-f 强制执行<br>-i 交互模式，文件存在则提示用户是否覆盖<br>-n 把符号链接视为一般目录<br>-s 软链接(符号链接)<br>-v 显示详细的处理过程<br>选择参数：</p>\n<p>-S “-S&lt;字尾备份字符串&gt; “或 “–suffix=&lt;字尾备份字符串&gt;”<br>-V “-V&lt;备份方式&gt;”或”–version-control=&lt;备份方式&gt;”<br>–help 显示帮助信息<br>–version 显示版本信息</p>\n<h3 id=\"less\"><a href=\"#less\" class=\"headerlink\" title=\"less\"></a>less</h3><p>less 与 more 类似，但使用 less 可以随意浏览文件，而 more 仅能向前移动，却不能向后移动，而且 less 在查看之前不会加载整个文件。</p>\n<p>语法<br>less [参数] 文件<br>参数说明：</p>\n<p>-b &lt;缓冲区大小&gt; 设置缓冲区的大小<br>-e 当文件显示结束后，自动离开<br>-f 强迫打开特殊文件，例如外围设备代号、目录和二进制文件<br>-g 只标志最后搜索的关键词<br>-i 忽略搜索时的大小写<br>-m 显示类似more命令的百分比<br>-N 显示每行的行号<br>-o &lt;文件名&gt; 将less 输出的内容在指定文件中保存起来<br>-Q 不使用警告音<br>-s 显示连续空行为一行<br>-S 行过长时间将超出部分舍弃<br>-x &lt;数字&gt; 将”tab”键显示为规定的数字空格<br>/字符串：向下搜索”字符串”的功能<br>?字符串：向上搜索”字符串”的功能<br>n：重复前一个搜索（与 / 或 ? 有关）<br>N：反向重复前一个搜索（与 / 或 ? 有关）<br>b 向后翻一页<br>d 向后翻半页<br>h 显示帮助界面<br>Q 退出less 命令<br>u 向前滚动半页<br>y 向前滚动一行<br>空格键 滚动一页<br>回车键 滚动一行<br>[pagedown]： 向下翻动一页<br>[pageup]： 向上翻动一页</p>\n<h3 id=\"more\"><a href=\"#more\" class=\"headerlink\" title=\"more\"></a>more</h3><p>Linux more命令<br>Linux 命令大全 Linux 命令大全</p>\n<p>Linux more 命令类似 cat ，不过会以一页一页的形式显示，更方便使用者逐页阅读，而最基本的指令就是按空白键（space）就往下一页显示，按 b 键就会往回（back）一页显示，而且还有搜寻字串的功能（与 vi 相似），使用中的说明文件，请按 h 。</p>\n<p>语法<br>more [-dlfpcsu] [-num] [+/pattern] [+linenum] [fileNames..]<br>参数：</p>\n<p>-num 一次显示的行数<br>-d 提示使用者，在画面下方显示 [Press space to continue, ‘q’ to quit.] ，如果使用者按错键，则会显示 [Press ‘h’ for instructions.] 而不是 ‘哔’ 声<br>-l 取消遇见特殊字元 ^L（送纸字元）时会暂停的功能<br>-f 计算行数时，以实际上的行数，而非自动换行过后的行数（有些单行字数太长的会被扩展为两行或两行以上）<br>-p 不以卷动的方式显示每一页，而是先清除萤幕后再显示内容<br>-c 跟 -p 相似，不同的是先显示内容再清除其他旧资料<br>-s 当遇到有连续两行以上的空白行，就代换为一行的空白行<br>-u 不显示下引号 （根据环境变数 TERM 指定的 terminal 而有所不同）<br>+/pattern 在每个文档显示前搜寻该字串（pattern），然后从该字串之后开始显示<br>+num 从第 num 行开始显示<br>fileNames 欲显示内容的文档，可为复数个数</p>\n<h3 id=\"mv\"><a href=\"#mv\" class=\"headerlink\" title=\"mv\"></a>mv</h3><p>Linux mv命令<br>Linux 命令大全 Linux 命令大全</p>\n<p>Linux mv命令用来为文件或目录改名、或将文件或目录移入其它位置。</p>\n<p>语法<br>mv [options] source dest<br>mv [options] source… directory<br>参数说明：</p>\n<p>-i: 若指定目录已有同名文件，则先询问是否覆盖旧文件;<br>-f: 在mv操作要覆盖某已有的目标文件时不给任何指示;<br>mv参数设置与运行结果</p>\n<p>mv 文件名 文件名 将源文件名改为目标文件名<br>mv 文件名 目录名 将文件移动到目标目录<br>mv 目录名 目录名 目标目录已存在，将源目录<br>移动到目标目录；目标<br>目录不存在则改名<br>mv 目录名 文件名 出错</p>\n<h3 id=\"rm\"><a href=\"#rm\" class=\"headerlink\" title=\"rm\"></a>rm</h3><p>rm命令用于删除一个文件或者目录。</p>\n<p>语法<br>rm [options] name…<br>参数：</p>\n<p>-i 删除前逐一询问确认。<br>-f 即使原档案属性设为唯读，亦直接删除，无需逐一确认。<br>-r 将目录及以下之档案亦逐一删除。</p>\n<h3 id=\"tee\"><a href=\"#tee\" class=\"headerlink\" title=\"tee\"></a>tee</h3><p>Linux tee命令用于读取标准输入的数据，并将其内容输出成文件。</p>\n<p>tee指令会从标准输入设备读取数据，将其内容输出到标准输出设备，同时保存成文件。</p>\n<p>语法<br>tee [-ai][–help][–version][文件…]<br>参数：</p>\n<p>-a或–append 　附加到既有文件的后面，而非覆盖它．<br>-i或–ignore-interrupts 　忽略中断信号。<br>–help 　在线帮助。<br>–version 　显示版本信息。</p>\n<h3 id=\"touch\"><a href=\"#touch\" class=\"headerlink\" title=\"touch\"></a>touch</h3><p>Linux touch命令用于修改文件或者目录的时间属性，包括存取时间和更改时间。若文件不存在，系统会建立一个新的文件。</p>\n<p>ls -l 可以显示档案的时间记录。</p>\n<p>语法<br>touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]<br>参数说明：<br>a 改变档案的读取时间记录。<br>m 改变档案的修改时间记录。<br>c 假如目的档案不存在，不会建立新的档案。与 –no-create 的效果一样。<br>f 不使用，是为了与其他 unix 系统的相容性而保留。<br>r 使用参考档的时间记录，与 –file 的效果一样。<br>d 设定时间与日期，可以使用各种不同的格式。<br>t 设定档案的时间记录，格式与 date 指令相同。<br>–no-create 不会建立新档案。<br>–help 列出指令格式。<br>–version 列出版本讯息。</p>\n<h3 id=\"which\"><a href=\"#which\" class=\"headerlink\" title=\"which\"></a>which</h3><p>Linux which命令用于查找文件。</p>\n<p>which指令会在环境变量$PATH设置的目录里查找符合条件的文件。</p>\n<p>语法<br>which [文件…]<br>参数：</p>\n<p>-n&lt;文件名长度&gt; 　指定文件名长度，指定的长度必须大于或等于所有文件中最长的文件名。<br>-p&lt;文件名长度&gt; 　与-n参数相同，但此处的&lt;文件名长度&gt;包括了文件的路径。<br>-w 　指定输出时栏位的宽度。<br>-V 　显示版本信息</p>\n<h3 id=\"cp\"><a href=\"#cp\" class=\"headerlink\" title=\"cp\"></a>cp</h3><p>Linux cp命令主要用于复制文件或目录。</p>\n<p>语法<br>cp [options] source dest<br>或</p>\n<p>cp [options] source… directory<br>参数说明：</p>\n<p>-a：此选项通常在复制目录时使用，它保留链接、文件属性，并复制目录下的所有内容。其作用等于dpR参数组合。<br>-d：复制时保留链接。这里所说的链接相当于Windows系统中的快捷方式。<br>-f：覆盖已经存在的目标文件而不给出提示。<br>-i：与-f选项相反，在覆盖目标文件之前给出提示，要求用户确认是否覆盖，回答”y”时目标文件将被覆盖。<br>-p：除复制文件的内容外，还把修改时间和访问权限也复制到新文件中。<br>-r：若给出的源文件是一个目录文件，此时将复制该目录下所有的子目录和文件。<br>-l：不复制文件，只是生成链接文件。</p>\n<h3 id=\"read\"><a href=\"#read\" class=\"headerlink\" title=\"read\"></a>read</h3><p>Linux read命令用于从标准输入读取数值。</p>\n<p>read 内部命令被用来从标准输入读取单行数据。这个命令可以用来读取键盘输入，当使用重定向的时候，可以读取文件中的一行数据。</p>\n<p>语法<br>read [-ers] [-a aname] [-d delim] [-i text] [-n nchars] [-N nchars] [-p prompt] [-t timeout] [-u fd] [name …]<br>参数说明:</p>\n<p>-a 后跟一个变量，该变量会被认为是个数组，然后给其赋值，默认是以空格为分割符。<br>-d 后面跟一个标志符，其实只有其后的第一个字符有用，作为结束的标志。<br>-p 后面跟提示信息，即在输入前打印提示信息。<br>-e 在输入的时候可以使用命令补全功能。<br>-n 后跟一个数字，定义输入文本的长度，很实用。<br>-r 屏蔽\\，如果没有该选项，则\\作为一个转义字符，有的话 \\就是个正常的字符了。<br>-s 安静模式，在输入字符时不再屏幕上显示，例如login时输入密码。<br>-t 后面跟秒数，定义输入字符的等待时间。<br>-u 后面跟fd，从文件描述符中读入，该文件描述符可以是exec新开启的。</p>\n"},{"title":"linux命令整理(3)","_content":"\n\n## 磁盘管理\n\n### cd\n\nLinux cd命令用于切换当前工作目录至 dirName(目录参数)。\n\n其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。\n\n另外，\"~\" 也表示为 home 目录 的意思，\".\" 则是表示目前所在的目录，\"..\" 则表示目前目录位置的上一层目录。\n\n语法\ncd [dirName]\ndirName：要切换的目标目录。\n\n### df\n\nLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。\n\n语法\ndf [选项]... [FILE]...\n文件-a, --all 包含所有的具有 0 Blocks 的文件系统\n文件--block-size={SIZE} 使用 {SIZE} 大小的 Blocks\n文件-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)\n文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024\n文件-i, --inodes 列出 inode 资讯，不列出已使用 block\n文件-k, --kilobytes 就像是 --block-size=1024\n文件-l, --local 限制列出的文件结构\n文件-m, --megabytes 就像 --block-size=1048576\n文件--no-sync 取得资讯前不 sync (预设值)\n文件-P, --portability 使用 POSIX 输出格式\n文件--sync 在取得资讯前 sync\n文件-t, --type=TYPE 限制列出文件系统的 TYPE\n文件-T, --print-type 显示文件系统的形式\n文件-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE\n文件-v (忽略)\n文件--help 显示这个帮手并且离开\n文件--version 输出版本资讯并且离开\n\n### du\n\nLinux du命令用于显示目录或文件的大小。\n\ndu会显示指定的目录或文件所占用的磁盘空间。\n\n语法\ndu [-abcDhHklmsSx][-L <符号连接>][-X <文件>][--block-size][--exclude=<目录或文件>][--max-depth=<目录层数>][--help][--version][目录或文件]\n参数说明：\n\n-a或-all 显示目录中个别文件的大小。\n-b或-bytes 显示目录或文件大小时，以byte为单位。\n-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。\n-D或--dereference-args 显示指定符号连接的源文件大小。\n-h或--human-readable 以K，M，G为单位，提高信息的可读性。\n-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。\n-k或--kilobytes 以1024 bytes为单位。\n-l或--count-links 重复计算硬件连接的文件。\n-L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。\n-m或--megabytes 以1MB为单位。\n-s或--summarize 仅显示总计。\n-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。\n-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。\n-X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。\n--exclude=<目录或文件> 略过指定的目录或文件。\n--max-depth=<目录层数> 超过指定层数的目录后，予以忽略。\n--help 显示帮助。\n--version 显示版本信息。\n\n### mkdir\n\nLinux mkdir命令用于建立名称为 dirName 之子目录。\n\n语法\nmkdir [-p] dirName\n参数说明：\n\n-p 确保目录名称存在，不存在的就建一个。\n\n### pwd\n\nLinux pwd命令用于显示工作目录。\n\n执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。\n\n语法\npwd [--help][--version]\n参数说明:\n\n--help 在线帮助。\n--version 显示版本信息。\n\n### mount\n\nLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\n\n语法\nmount [-hV]\nmount -a [-fFnrsvw] [-t vfstype]\nmount [-fnrsvw] [-o options [,...]] device | dir\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\n参数说明：\n\n-V：显示程序版本\n-h：显示辅助讯息\n-v：显示较讯息，通常和 -f 用来除错。\n-a：将 /etc/fstab 中定义的所有档案系统挂上。\n-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。\n-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。\n-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。\n-s-r：等于 -o ro\n-w：等于 -o rw\n-L：将含有特定标签的硬盘分割挂上。\n-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。\n-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。\n-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。\n-o sync：在同步模式下执行。\n-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。\n-o auto、-o noauto：打开/关闭自动挂上模式。\n-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.\n-o dev、-o nodev-o exec、-o noexec允许执行档被执行。\n-o suid、-o nosuid：\n允许执行档在 root 权限下执行。\n-o user、-o nouser：使用者可以执行 mount/umount 的动作。\n-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。\n-o ro：用唯读模式挂上。\n-o rw：用可读写模式挂上。\n-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。\n\n### ls\n\nLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。\n\n语法\n ls [-alrtAFR] [name...]\n参数 :\n\n-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为\".\"的视为隐藏档，不会列出)\n-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n-r 将文件以相反次序显示(原定依英文字母次序)\n-t 将文件依建立时间之先后次序列出\n-A 同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录)\n-F 在列出的文件名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\"\n-R 若目录下有文件，则以下之文件亦皆依序列出\n\n## 系统管理\n\n### useradd\n\nLinux useradd命令用于建立用户帐号。\n\nuseradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。\n\n语法\nuseradd [-mMnr][-c <备注>][-d <登入目录>][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-s <shell>][-u <uid>][用户帐号]\n或\n\nuseradd -D [-b][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-s <shell>]\n参数说明：\n\n-c<备注> 　加上备注文字。备注文字会保存在passwd的备注栏位中。\n-d<登入目录> 　指定用户登入时的启始目录。\n-D 　变更预设值．\n-e<有效期限> 　指定帐号的有效期限。\n-f<缓冲天数> 　指定在密码过期后多少天即关闭该帐号。\n-g<群组> 　指定用户所属的群组。\n-G<群组> 　指定用户所属的附加群组。\n-m 　自动建立用户的登入目录。\n-M 　不要自动建立用户的登入目录。\n-n 　取消建立以用户名称为名的群组．\n-r 　建立系统帐号。\n-s<shell>　 　指定用户登入后所使用的shell。\n-u<uid> 　指定用户ID\n\n### data\n\nLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：\n\n时间方面：\n\n% : 印出 %\n%n : 下一行\n%t : 跳格\n%H : 小时(00..23)\n%I : 小时(01..12)\n%k : 小时(0..23)\n%l : 小时(1..12)\n%M : 分钟(00..59)\n%p : 显示本地 AM 或 PM\n%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)\n%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数\n%S : 秒(00..61)\n%T : 直接显示时间 (24 小时制)\n%X : 相当于 %H:%M:%S\n%Z : 显示时区\n日期方面：\n\n%a : 星期几 (Sun..Sat)\n%A : 星期几 (Sunday..Saturday)\n%b : 月份 (Jan..Dec)\n%B : 月份 (January..December)\n%c : 直接显示日期与时间\n%d : 日 (01..31)\n%D : 直接显示日期 (mm/dd/yy)\n%h : 同 %b\n%j : 一年中的第几天 (001..366)\n%m : 月份 (01..12)\n%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)\n%w : 一周中的第几天 (0..6)\n%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)\n%x : 直接显示日期 (mm/dd/yy)\n%y : 年份的最后两位数字 (00.99)\n%Y : 完整年份 (0000..9999)\n若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。\n\n使用权限：所有使用者。\n\n当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date '+%-H:%-M:%-S' 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。\n\n当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。\n\n语法\ndate [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]\n参数说明：\n\n-d datestr : 显示 datestr 中所设定的时间 (非系统时间)\n--help : 显示辅助讯息\n-s datestr : 将系统时间设为 datestr 中所设定的时间\n-u : 显示目前的格林威治时间\n--version : 显示版本编号\n\n### ps\n\nLinux ps命令用于显示当前进程 (process) 的状态。\n\n语法\nps [options] [--help]\n参数：\n\nps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义\n-A 列出所有的行程\n-w 显示加宽可以显示较多的资讯\n-au 显示较详细的资讯\n-aux 显示所有包含其他使用者的行程\nau(x) 输出格式 :\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nUSER: 行程拥有者\nPID: pid\n%CPU: 占用的 CPU 使用率\n%MEM: 占用的记忆体使用率\nVSZ: 占用的虚拟记忆体大小\nRSS: 占用的记忆体大小\nTTY: 终端的次要装置号码 (minor device number of tty)\nSTAT: 该行程的状态:\nD: 不可中断的静止 (通悸□□缜b进行 I/O 动作)\nR: 正在执行中\nS: 静止状态\nT: 暂停执行\nZ: 不存在但暂时无法消除\nW: 没有足够的记忆体分页可分配\n<: 高优先序的行程\nN: 低优先序的行程\nL: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\nSTART: 行程开始时间\nTIME: 执行的时间\nCOMMAND:所执行的指令\n\n### top\n\nLinux top命令用于实时显示 process 的动态。\n\n使用权限：所有使用者。\n\n语法\ntop [-] [d delay] [q] [c] [S] [s] [i] [n] [b]\n参数说明：\n\nd : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s\nq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行\nc : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来\ns : 安全模式，将交谈式指令取消, 避免潜在的危机\ni : 不显示任何闲置 (idle) 或无用 (zombie) 的行程\nn : 更新的次数，完成后将会退出 top\nb : 批次档模式，搭配 \"n\" 参数一起使用，可以用来将 top 的结果输出到档案内\n\n### pstree\n\nLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。\n\n使用权限：所有使用者。\n\n语法\npstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]\n或\n\npstree -V\n参数说明：\n\n-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号\n-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）\n\n### reboot\n\nLinux reboot命令用于用来重新启动计算机。\n\n若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代\n\n语法\nreboot [-n] [-w] [-d] [-f] [-i]\n参数：\n\n-n : 在重开机前不做将记忆体资料写回硬盘的动作\n-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里\n-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）\n-f : 强迫重开机，不呼叫 shutdown 这个指令\n-i : 在重开机之前先把所有网络相关的装置先停止\n\n### screen\n\nLinux screen命令用于多重视窗管理程序。\n\nscreen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。\n\n语法\nscreen [-AmRvx -ls -wipe][-d <作业名称>][-h <行数>][-r <作业名称>][-s <shell>][-S <作业名称>]\n参数说明：\n\n-A 　将所有的视窗都调整为目前终端机的大小。\n-d<作业名称> 　将指定的screen作业离线。\n-h<行数> 　指定视窗的缓冲区行数。\n-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。\n-r<作业名称> 　恢复离线的screen作业。\n-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。\n-s<shell> 　指定建立新视窗时，所要执行的shell。\n-S<作业名称> 　指定screen作业的名称。\n-v 　显示版本信息。\n-x 　恢复之前离线的screen作业。\n-ls或--list 　显示目前所有的screen作业。\n-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。\n\n### shutdown\n\nLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。\n\n使用权限：系统管理者。\n\n语法\nshutdown [-t seconds] [-rkhncfF] time [message]\n参数说明：\n\n-t seconds : 设定在几秒钟之后进行关机程序。\n-k : 并不会真的关机，只是将警告讯息传送给所有使用者。\n-r : 关机后重新开机。\n-h : 关机后停机。\n-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\n-c : 取消目前已经进行中的关机动作。\n-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。\n-F : 关机时，强迫进行 fsck 动作。\ntime : 设定关机的时间。\nmessage : 传送给所有使用者的警告讯息。\n\n### swatch\n\nLinux swatch命令用于系统监控程序。\n\nswatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。\n\n语法\nswatch [-A <分隔字符>][-c <设置文件>][-f <记录文件>][-I <分隔字符>][-P <分隔字符>][-r <时间>][-t <记录文件>]\n参数说明：\n\n-A<分隔字符> 　预设配置文件中，动作的分隔字符，预设为逗号。\n-c<设置文件> 　指定配置文件，而不使用预设的配置文件。\n-f<记录文件> 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。\n-I<分隔字符> 　指定输入记录的分隔字符，预设为换行字符。\n-P<分隔字符> 　指定配置文件中，事件的分隔字符，预设为逗号。\n-r<时间> 　在指定的时间重新启动。\n-t<记录文件> 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。\n\n### id\n\nLinux id命令用于显示用户的ID，以及所属群组的ID。\n\nid会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。\n\n语法\nid [-gGnru][--help][--version][用户名称]\n参数说明：\n\n-g或--group 　显示用户所属群组的ID。\n-G或--groups 　显示用户所属附加群组的ID。\n-n或--name 　显示用户，所属群组或附加群组的名称。\n-r或--real 　显示实际ID。\n-u或--user 　显示用户ID。\n-help 　显示帮助。\n-version 　显示版本信息。\n\n### free\n\nLinux free命令用于显示内存状态。\n\nfree指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。\n\n语法\nfree [-bkmotV][-s <间隔秒数>]\n参数说明：\n\n-b 　以Byte为单位显示内存使用情况。\n-k 　以KB为单位显示内存使用情况。\n-m 　以MB为单位显示内存使用情况。\n-o 　不显示缓冲区调节列。\n-s<间隔秒数> 　持续观察内存使用状况。\n-t 　显示内存总和列。\n-V 　显示版本信息。\n\n## 系统设置\n\n### setup\n\nLinux setup命令设置公用程序，是一个启动图形设置系统的命令。\n\nsetup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。\n\n语法\nsetup\nsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：\n\n１.登陆认证方式\n２.键盘组态设置\n３.鼠标组态设置\n４.开机时所要启动的系统服务\n５.声卡组态设置\n６.时区设置\n７.X Windows组态设置","source":"_posts/1 (9).md","raw":"---\ntitle: linux命令整理(3)\n\n\ncategories: \n- linux\ntags:\n- linux基础\n---\n\n\n## 磁盘管理\n\n### cd\n\nLinux cd命令用于切换当前工作目录至 dirName(目录参数)。\n\n其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。\n\n另外，\"~\" 也表示为 home 目录 的意思，\".\" 则是表示目前所在的目录，\"..\" 则表示目前目录位置的上一层目录。\n\n语法\ncd [dirName]\ndirName：要切换的目标目录。\n\n### df\n\nLinux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。\n\n语法\ndf [选项]... [FILE]...\n文件-a, --all 包含所有的具有 0 Blocks 的文件系统\n文件--block-size={SIZE} 使用 {SIZE} 大小的 Blocks\n文件-h, --human-readable 使用人类可读的格式(预设值是不加这个选项的...)\n文件-H, --si 很像 -h, 但是用 1000 为单位而不是用 1024\n文件-i, --inodes 列出 inode 资讯，不列出已使用 block\n文件-k, --kilobytes 就像是 --block-size=1024\n文件-l, --local 限制列出的文件结构\n文件-m, --megabytes 就像 --block-size=1048576\n文件--no-sync 取得资讯前不 sync (预设值)\n文件-P, --portability 使用 POSIX 输出格式\n文件--sync 在取得资讯前 sync\n文件-t, --type=TYPE 限制列出文件系统的 TYPE\n文件-T, --print-type 显示文件系统的形式\n文件-x, --exclude-type=TYPE 限制列出文件系统不要显示 TYPE\n文件-v (忽略)\n文件--help 显示这个帮手并且离开\n文件--version 输出版本资讯并且离开\n\n### du\n\nLinux du命令用于显示目录或文件的大小。\n\ndu会显示指定的目录或文件所占用的磁盘空间。\n\n语法\ndu [-abcDhHklmsSx][-L <符号连接>][-X <文件>][--block-size][--exclude=<目录或文件>][--max-depth=<目录层数>][--help][--version][目录或文件]\n参数说明：\n\n-a或-all 显示目录中个别文件的大小。\n-b或-bytes 显示目录或文件大小时，以byte为单位。\n-c或--total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。\n-D或--dereference-args 显示指定符号连接的源文件大小。\n-h或--human-readable 以K，M，G为单位，提高信息的可读性。\n-H或--si 与-h参数相同，但是K，M，G是以1000为换算单位。\n-k或--kilobytes 以1024 bytes为单位。\n-l或--count-links 重复计算硬件连接的文件。\n-L<符号连接>或--dereference<符号连接> 显示选项中所指定符号连接的源文件大小。\n-m或--megabytes 以1MB为单位。\n-s或--summarize 仅显示总计。\n-S或--separate-dirs 显示个别目录的大小时，并不含其子目录的大小。\n-x或--one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。\n-X<文件>或--exclude-from=<文件> 在<文件>指定目录或文件。\n--exclude=<目录或文件> 略过指定的目录或文件。\n--max-depth=<目录层数> 超过指定层数的目录后，予以忽略。\n--help 显示帮助。\n--version 显示版本信息。\n\n### mkdir\n\nLinux mkdir命令用于建立名称为 dirName 之子目录。\n\n语法\nmkdir [-p] dirName\n参数说明：\n\n-p 确保目录名称存在，不存在的就建一个。\n\n### pwd\n\nLinux pwd命令用于显示工作目录。\n\n执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。\n\n语法\npwd [--help][--version]\n参数说明:\n\n--help 在线帮助。\n--version 显示版本信息。\n\n### mount\n\nLinux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。\n\n语法\nmount [-hV]\nmount -a [-fFnrsvw] [-t vfstype]\nmount [-fnrsvw] [-o options [,...]] device | dir\nmount [-fnrsvw] [-t vfstype] [-o options] device dir\n参数说明：\n\n-V：显示程序版本\n-h：显示辅助讯息\n-v：显示较讯息，通常和 -f 用来除错。\n-a：将 /etc/fstab 中定义的所有档案系统挂上。\n-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。\n-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。\n-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。\n-s-r：等于 -o ro\n-w：等于 -o rw\n-L：将含有特定标签的硬盘分割挂上。\n-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。\n-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。\n-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。\n-o sync：在同步模式下执行。\n-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。\n-o auto、-o noauto：打开/关闭自动挂上模式。\n-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.\n-o dev、-o nodev-o exec、-o noexec允许执行档被执行。\n-o suid、-o nosuid：\n允许执行档在 root 权限下执行。\n-o user、-o nouser：使用者可以执行 mount/umount 的动作。\n-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。\n-o ro：用唯读模式挂上。\n-o rw：用可读写模式挂上。\n-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。\n\n### ls\n\nLinux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。\n\n语法\n ls [-alrtAFR] [name...]\n参数 :\n\n-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为\".\"的视为隐藏档，不会列出)\n-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出\n-r 将文件以相反次序显示(原定依英文字母次序)\n-t 将文件依建立时间之先后次序列出\n-A 同 -a ，但不列出 \".\" (目前目录) 及 \"..\" (父目录)\n-F 在列出的文件名称后加一符号；例如可执行档则加 \"*\", 目录则加 \"/\"\n-R 若目录下有文件，则以下之文件亦皆依序列出\n\n## 系统管理\n\n### useradd\n\nLinux useradd命令用于建立用户帐号。\n\nuseradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。\n\n语法\nuseradd [-mMnr][-c <备注>][-d <登入目录>][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-s <shell>][-u <uid>][用户帐号]\n或\n\nuseradd -D [-b][-e <有效期限>][-f <缓冲天数>][-g <群组>][-G <群组>][-s <shell>]\n参数说明：\n\n-c<备注> 　加上备注文字。备注文字会保存在passwd的备注栏位中。\n-d<登入目录> 　指定用户登入时的启始目录。\n-D 　变更预设值．\n-e<有效期限> 　指定帐号的有效期限。\n-f<缓冲天数> 　指定在密码过期后多少天即关闭该帐号。\n-g<群组> 　指定用户所属的群组。\n-G<群组> 　指定用户所属的附加群组。\n-m 　自动建立用户的登入目录。\n-M 　不要自动建立用户的登入目录。\n-n 　取消建立以用户名称为名的群组．\n-r 　建立系统帐号。\n-s<shell>　 　指定用户登入后所使用的shell。\n-u<uid> 　指定用户ID\n\n### data\n\nLinux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：\n\n时间方面：\n\n% : 印出 %\n%n : 下一行\n%t : 跳格\n%H : 小时(00..23)\n%I : 小时(01..12)\n%k : 小时(0..23)\n%l : 小时(1..12)\n%M : 分钟(00..59)\n%p : 显示本地 AM 或 PM\n%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)\n%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数\n%S : 秒(00..61)\n%T : 直接显示时间 (24 小时制)\n%X : 相当于 %H:%M:%S\n%Z : 显示时区\n日期方面：\n\n%a : 星期几 (Sun..Sat)\n%A : 星期几 (Sunday..Saturday)\n%b : 月份 (Jan..Dec)\n%B : 月份 (January..December)\n%c : 直接显示日期与时间\n%d : 日 (01..31)\n%D : 直接显示日期 (mm/dd/yy)\n%h : 同 %b\n%j : 一年中的第几天 (001..366)\n%m : 月份 (01..12)\n%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)\n%w : 一周中的第几天 (0..6)\n%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)\n%x : 直接显示日期 (mm/dd/yy)\n%y : 年份的最后两位数字 (00.99)\n%Y : 完整年份 (0000..9999)\n若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。\n\n使用权限：所有使用者。\n\n当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date '+%-H:%-M:%-S' 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。\n\n当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。\n\n语法\ndate [-u] [-d datestr] [-s datestr] [--utc] [--universal] [--date=datestr] [--set=datestr] [--help] [--version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]\n参数说明：\n\n-d datestr : 显示 datestr 中所设定的时间 (非系统时间)\n--help : 显示辅助讯息\n-s datestr : 将系统时间设为 datestr 中所设定的时间\n-u : 显示目前的格林威治时间\n--version : 显示版本编号\n\n### ps\n\nLinux ps命令用于显示当前进程 (process) 的状态。\n\n语法\nps [options] [--help]\n参数：\n\nps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义\n-A 列出所有的行程\n-w 显示加宽可以显示较多的资讯\n-au 显示较详细的资讯\n-aux 显示所有包含其他使用者的行程\nau(x) 输出格式 :\nUSER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND\nUSER: 行程拥有者\nPID: pid\n%CPU: 占用的 CPU 使用率\n%MEM: 占用的记忆体使用率\nVSZ: 占用的虚拟记忆体大小\nRSS: 占用的记忆体大小\nTTY: 终端的次要装置号码 (minor device number of tty)\nSTAT: 该行程的状态:\nD: 不可中断的静止 (通悸□□缜b进行 I/O 动作)\nR: 正在执行中\nS: 静止状态\nT: 暂停执行\nZ: 不存在但暂时无法消除\nW: 没有足够的记忆体分页可分配\n<: 高优先序的行程\nN: 低优先序的行程\nL: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)\nSTART: 行程开始时间\nTIME: 执行的时间\nCOMMAND:所执行的指令\n\n### top\n\nLinux top命令用于实时显示 process 的动态。\n\n使用权限：所有使用者。\n\n语法\ntop [-] [d delay] [q] [c] [S] [s] [i] [n] [b]\n参数说明：\n\nd : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s\nq : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行\nc : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来\ns : 安全模式，将交谈式指令取消, 避免潜在的危机\ni : 不显示任何闲置 (idle) 或无用 (zombie) 的行程\nn : 更新的次数，完成后将会退出 top\nb : 批次档模式，搭配 \"n\" 参数一起使用，可以用来将 top 的结果输出到档案内\n\n### pstree\n\nLinux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。\n\n使用权限：所有使用者。\n\n语法\npstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]\n或\n\npstree -V\n参数说明：\n\n-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号\n-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）\n\n### reboot\n\nLinux reboot命令用于用来重新启动计算机。\n\n若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代\n\n语法\nreboot [-n] [-w] [-d] [-f] [-i]\n参数：\n\n-n : 在重开机前不做将记忆体资料写回硬盘的动作\n-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里\n-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）\n-f : 强迫重开机，不呼叫 shutdown 这个指令\n-i : 在重开机之前先把所有网络相关的装置先停止\n\n### screen\n\nLinux screen命令用于多重视窗管理程序。\n\nscreen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。\n\n语法\nscreen [-AmRvx -ls -wipe][-d <作业名称>][-h <行数>][-r <作业名称>][-s <shell>][-S <作业名称>]\n参数说明：\n\n-A 　将所有的视窗都调整为目前终端机的大小。\n-d<作业名称> 　将指定的screen作业离线。\n-h<行数> 　指定视窗的缓冲区行数。\n-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。\n-r<作业名称> 　恢复离线的screen作业。\n-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。\n-s<shell> 　指定建立新视窗时，所要执行的shell。\n-S<作业名称> 　指定screen作业的名称。\n-v 　显示版本信息。\n-x 　恢复之前离线的screen作业。\n-ls或--list 　显示目前所有的screen作业。\n-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。\n\n### shutdown\n\nLinux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。\n\n使用权限：系统管理者。\n\n语法\nshutdown [-t seconds] [-rkhncfF] time [message]\n参数说明：\n\n-t seconds : 设定在几秒钟之后进行关机程序。\n-k : 并不会真的关机，只是将警告讯息传送给所有使用者。\n-r : 关机后重新开机。\n-h : 关机后停机。\n-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。\n-c : 取消目前已经进行中的关机动作。\n-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。\n-F : 关机时，强迫进行 fsck 动作。\ntime : 设定关机的时间。\nmessage : 传送给所有使用者的警告讯息。\n\n### swatch\n\nLinux swatch命令用于系统监控程序。\n\nswatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。\n\n语法\nswatch [-A <分隔字符>][-c <设置文件>][-f <记录文件>][-I <分隔字符>][-P <分隔字符>][-r <时间>][-t <记录文件>]\n参数说明：\n\n-A<分隔字符> 　预设配置文件中，动作的分隔字符，预设为逗号。\n-c<设置文件> 　指定配置文件，而不使用预设的配置文件。\n-f<记录文件> 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。\n-I<分隔字符> 　指定输入记录的分隔字符，预设为换行字符。\n-P<分隔字符> 　指定配置文件中，事件的分隔字符，预设为逗号。\n-r<时间> 　在指定的时间重新启动。\n-t<记录文件> 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。\n\n### id\n\nLinux id命令用于显示用户的ID，以及所属群组的ID。\n\nid会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。\n\n语法\nid [-gGnru][--help][--version][用户名称]\n参数说明：\n\n-g或--group 　显示用户所属群组的ID。\n-G或--groups 　显示用户所属附加群组的ID。\n-n或--name 　显示用户，所属群组或附加群组的名称。\n-r或--real 　显示实际ID。\n-u或--user 　显示用户ID。\n-help 　显示帮助。\n-version 　显示版本信息。\n\n### free\n\nLinux free命令用于显示内存状态。\n\nfree指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。\n\n语法\nfree [-bkmotV][-s <间隔秒数>]\n参数说明：\n\n-b 　以Byte为单位显示内存使用情况。\n-k 　以KB为单位显示内存使用情况。\n-m 　以MB为单位显示内存使用情况。\n-o 　不显示缓冲区调节列。\n-s<间隔秒数> 　持续观察内存使用状况。\n-t 　显示内存总和列。\n-V 　显示版本信息。\n\n## 系统设置\n\n### setup\n\nLinux setup命令设置公用程序，是一个启动图形设置系统的命令。\n\nsetup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。\n\n语法\nsetup\nsetup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：\n\n１.登陆认证方式\n２.键盘组态设置\n３.鼠标组态设置\n４.开机时所要启动的系统服务\n５.声卡组态设置\n６.时区设置\n７.X Windows组态设置","slug":"1 (9)","published":1,"date":"2019-04-01T07:27:36.113Z","updated":"2019-06-19T14:47:31.806Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8fd002pjkufdoon0xsa","content":"<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><h3 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h3><p>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</p>\n<p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>\n<p>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>\n<p>语法<br>cd [dirName]<br>dirName：要切换的目标目录。</p>\n<h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p>\n<p>语法<br>df [选项]… [FILE]…<br>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<br>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks<br>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<br>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<br>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<br>文件-k, –kilobytes 就像是 –block-size=1024<br>文件-l, –local 限制列出的文件结构<br>文件-m, –megabytes 就像 –block-size=1048576<br>文件–no-sync 取得资讯前不 sync (预设值)<br>文件-P, –portability 使用 POSIX 输出格式<br>文件–sync 在取得资讯前 sync<br>文件-t, –type=TYPE 限制列出文件系统的 TYPE<br>文件-T, –print-type 显示文件系统的形式<br>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE<br>文件-v (忽略)<br>文件–help 显示这个帮手并且离开<br>文件–version 输出版本资讯并且离开</p>\n<h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><p>Linux du命令用于显示目录或文件的大小。</p>\n<p>du会显示指定的目录或文件所占用的磁盘空间。</p>\n<p>语法<br>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]<br>参数说明：</p>\n<p>-a或-all 显示目录中个别文件的大小。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计。<br>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h3><p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>\n<p>语法<br>mkdir [-p] dirName<br>参数说明：</p>\n<p>-p 确保目录名称存在，不存在的就建一个。</p>\n<h3 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h3><p>Linux pwd命令用于显示工作目录。</p>\n<p>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p>\n<p>语法<br>pwd [–help][–version]<br>参数说明:</p>\n<p>–help 在线帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p>Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</p>\n<p>语法<br>mount [-hV]<br>mount -a [-fFnrsvw] [-t vfstype]<br>mount [-fnrsvw] [-o options [,…]] device | dir<br>mount [-fnrsvw] [-t vfstype] [-o options] device dir<br>参数说明：</p>\n<p>-V：显示程序版本<br>-h：显示辅助讯息<br>-v：显示较讯息，通常和 -f 用来除错。<br>-a：将 /etc/fstab 中定义的所有档案系统挂上。<br>-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。<br>-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。<br>-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。<br>-s-r：等于 -o ro<br>-w：等于 -o rw<br>-L：将含有特定标签的硬盘分割挂上。<br>-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br>-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。<br>-o sync：在同步模式下执行。<br>-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。<br>-o auto、-o noauto：打开/关闭自动挂上模式。<br>-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.<br>-o dev、-o nodev-o exec、-o noexec允许执行档被执行。<br>-o suid、-o nosuid：<br>允许执行档在 root 权限下执行。<br>-o user、-o nouser：使用者可以执行 mount/umount 的动作。<br>-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。<br>-o ro：用唯读模式挂上。<br>-o rw：用可读写模式挂上。<br>-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</p>\n<h3 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h3><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p>\n<p>语法<br> ls [-alrtAFR] [name…]<br>参数 :</p>\n<p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出</p>\n<h2 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h2><h3 id=\"useradd\"><a href=\"#useradd\" class=\"headerlink\" title=\"useradd\"></a>useradd</h3><p>Linux useradd命令用于建立用户帐号。</p>\n<p>useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>\n<p>语法<br>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>][-u <uid>][用户帐号]<br>或</uid></shell></p>\n<p>useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>]<br>参数说明：</shell></p>\n<p>-c&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。<br>-d&lt;登入目录&gt; 　指定用户登入时的启始目录。<br>-D 　变更预设值．<br>-e&lt;有效期限&gt; 　指定帐号的有效期限。<br>-f&lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。<br>-g&lt;群组&gt; 　指定用户所属的群组。<br>-G&lt;群组&gt; 　指定用户所属的附加群组。<br>-m 　自动建立用户的登入目录。<br>-M 　不要自动建立用户的登入目录。<br>-n 　取消建立以用户名称为名的群组．<br>-r 　建立系统帐号。<br>-s<shell>　 　指定用户登入后所使用的shell。<br>-u<uid> 　指定用户ID</uid></shell></p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：</p>\n<p>时间方面：</p>\n<p>% : 印出 %<br>%n : 下一行<br>%t : 跳格<br>%H : 小时(00..23)<br>%I : 小时(01..12)<br>%k : 小时(0..23)<br>%l : 小时(1..12)<br>%M : 分钟(00..59)<br>%p : 显示本地 AM 或 PM<br>%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)<br>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数<br>%S : 秒(00..61)<br>%T : 直接显示时间 (24 小时制)<br>%X : 相当于 %H:%M:%S<br>%Z : 显示时区<br>日期方面：</p>\n<p>%a : 星期几 (Sun..Sat)<br>%A : 星期几 (Sunday..Saturday)<br>%b : 月份 (Jan..Dec)<br>%B : 月份 (January..December)<br>%c : 直接显示日期与时间<br>%d : 日 (01..31)<br>%D : 直接显示日期 (mm/dd/yy)<br>%h : 同 %b<br>%j : 一年中的第几天 (001..366)<br>%m : 月份 (01..12)<br>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)<br>%w : 一周中的第几天 (0..6)<br>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)<br>%x : 直接显示日期 (mm/dd/yy)<br>%y : 年份的最后两位数字 (00.99)<br>%Y : 完整年份 (0000..9999)<br>若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。</p>\n<p>使用权限：所有使用者。</p>\n<p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。</p>\n<p>当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>\n<p>语法<br>date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]<br>参数说明：</p>\n<p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)<br>–help : 显示辅助讯息<br>-s datestr : 将系统时间设为 datestr 中所设定的时间<br>-u : 显示目前的格林威治时间<br>–version : 显示版本编号</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>\n<p>语法<br>ps [options] [–help]<br>参数：</p>\n<p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p>\n<h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><p>Linux top命令用于实时显示 process 的动态。</p>\n<p>使用权限：所有使用者。</p>\n<p>语法<br>top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]<br>参数说明：</p>\n<p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<br>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<br>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来<br>s : 安全模式，将交谈式指令取消, 避免潜在的危机<br>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程<br>n : 更新的次数，完成后将会退出 top<br>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p>\n<h3 id=\"pstree\"><a href=\"#pstree\" class=\"headerlink\" title=\"pstree\"></a>pstree</h3><p>Linux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</p>\n<p>使用权限：所有使用者。</p>\n<p>语法<br>pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]<br>或</p>\n<p>pstree -V<br>参数说明：</p>\n<p>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号<br>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）</p>\n<h3 id=\"reboot\"><a href=\"#reboot\" class=\"headerlink\" title=\"reboot\"></a>reboot</h3><p>Linux reboot命令用于用来重新启动计算机。</p>\n<p>若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代</p>\n<p>语法<br>reboot [-n] [-w] [-d] [-f] [-i]<br>参数：</p>\n<p>-n : 在重开机前不做将记忆体资料写回硬盘的动作<br>-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里<br>-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）<br>-f : 强迫重开机，不呼叫 shutdown 这个指令<br>-i : 在重开机之前先把所有网络相关的装置先停止</p>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p>Linux screen命令用于多重视窗管理程序。</p>\n<p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p>\n<p>语法<br>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s <shell>][-S &lt;作业名称&gt;]<br>参数说明：</shell></p>\n<p>-A 　将所有的视窗都调整为目前终端机的大小。<br>-d&lt;作业名称&gt; 　将指定的screen作业离线。<br>-h&lt;行数&gt; 　指定视窗的缓冲区行数。<br>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r&lt;作业名称&gt; 　恢复离线的screen作业。<br>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-s<shell> 　指定建立新视窗时，所要执行的shell。<br>-S&lt;作业名称&gt; 　指定screen作业的名称。<br>-v 　显示版本信息。<br>-x 　恢复之前离线的screen作业。<br>-ls或–list 　显示目前所有的screen作业。<br>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</shell></p>\n<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>\n<p>使用权限：系统管理者。</p>\n<p>语法<br>shutdown [-t seconds] [-rkhncfF] time [message]<br>参数说明：</p>\n<p>-t seconds : 设定在几秒钟之后进行关机程序。<br>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。<br>-r : 关机后重新开机。<br>-h : 关机后停机。<br>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。<br>-c : 取消目前已经进行中的关机动作。<br>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。<br>-F : 关机时，强迫进行 fsck 动作。<br>time : 设定关机的时间。<br>message : 传送给所有使用者的警告讯息。</p>\n<h3 id=\"swatch\"><a href=\"#swatch\" class=\"headerlink\" title=\"swatch\"></a>swatch</h3><p>Linux swatch命令用于系统监控程序。</p>\n<p>swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。</p>\n<p>语法<br>swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]<br>参数说明：</p>\n<p>-A&lt;分隔字符&gt; 　预设配置文件中，动作的分隔字符，预设为逗号。<br>-c&lt;设置文件&gt; 　指定配置文件，而不使用预设的配置文件。<br>-f&lt;记录文件&gt; 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。<br>-I&lt;分隔字符&gt; 　指定输入记录的分隔字符，预设为换行字符。<br>-P&lt;分隔字符&gt; 　指定配置文件中，事件的分隔字符，预设为逗号。<br>-r&lt;时间&gt; 　在指定的时间重新启动。<br>-t&lt;记录文件&gt; 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p>\n<p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p>\n<p>语法<br>id [-gGnru][–help][–version][用户名称]<br>参数说明：</p>\n<p>-g或–group 　显示用户所属群组的ID。<br>-G或–groups 　显示用户所属附加群组的ID。<br>-n或–name 　显示用户，所属群组或附加群组的名称。<br>-r或–real 　显示实际ID。<br>-u或–user 　显示用户ID。<br>-help 　显示帮助。<br>-version 　显示版本信息。</p>\n<h3 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h3><p>Linux free命令用于显示内存状态。</p>\n<p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p>\n<p>语法<br>free [-bkmotV][-s &lt;间隔秒数&gt;]<br>参数说明：</p>\n<p>-b 　以Byte为单位显示内存使用情况。<br>-k 　以KB为单位显示内存使用情况。<br>-m 　以MB为单位显示内存使用情况。<br>-o 　不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。<br>-t 　显示内存总和列。<br>-V 　显示版本信息。</p>\n<h2 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h2><h3 id=\"setup\"><a href=\"#setup\" class=\"headerlink\" title=\"setup\"></a>setup</h3><p>Linux setup命令设置公用程序，是一个启动图形设置系统的命令。</p>\n<p>setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。</p>\n<p>语法<br>setup<br>setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：</p>\n<p>１.登陆认证方式<br>２.键盘组态设置<br>３.鼠标组态设置<br>４.开机时所要启动的系统服务<br>５.声卡组态设置<br>６.时区设置<br>７.X Windows组态设置</p>\n","site":{"data":{}},"excerpt":"","more":"<h2 id=\"磁盘管理\"><a href=\"#磁盘管理\" class=\"headerlink\" title=\"磁盘管理\"></a>磁盘管理</h2><h3 id=\"cd\"><a href=\"#cd\" class=\"headerlink\" title=\"cd\"></a>cd</h3><p>Linux cd命令用于切换当前工作目录至 dirName(目录参数)。</p>\n<p>其中 dirName 表示法可为绝对路径或相对路径。若目录名称省略，则变换至使用者的 home 目录 (也就是刚 login 时所在的目录)。</p>\n<p>另外，”~” 也表示为 home 目录 的意思，”.” 则是表示目前所在的目录，”..” 则表示目前目录位置的上一层目录。</p>\n<p>语法<br>cd [dirName]<br>dirName：要切换的目标目录。</p>\n<h3 id=\"df\"><a href=\"#df\" class=\"headerlink\" title=\"df\"></a>df</h3><p>Linux df命令用于显示目前在Linux系统上的文件系统的磁盘使用情况统计。</p>\n<p>语法<br>df [选项]… [FILE]…<br>文件-a, –all 包含所有的具有 0 Blocks 的文件系统<br>文件–block-size={SIZE} 使用 {SIZE} 大小的 Blocks<br>文件-h, –human-readable 使用人类可读的格式(预设值是不加这个选项的…)<br>文件-H, –si 很像 -h, 但是用 1000 为单位而不是用 1024<br>文件-i, –inodes 列出 inode 资讯，不列出已使用 block<br>文件-k, –kilobytes 就像是 –block-size=1024<br>文件-l, –local 限制列出的文件结构<br>文件-m, –megabytes 就像 –block-size=1048576<br>文件–no-sync 取得资讯前不 sync (预设值)<br>文件-P, –portability 使用 POSIX 输出格式<br>文件–sync 在取得资讯前 sync<br>文件-t, –type=TYPE 限制列出文件系统的 TYPE<br>文件-T, –print-type 显示文件系统的形式<br>文件-x, –exclude-type=TYPE 限制列出文件系统不要显示 TYPE<br>文件-v (忽略)<br>文件–help 显示这个帮手并且离开<br>文件–version 输出版本资讯并且离开</p>\n<h3 id=\"du\"><a href=\"#du\" class=\"headerlink\" title=\"du\"></a>du</h3><p>Linux du命令用于显示目录或文件的大小。</p>\n<p>du会显示指定的目录或文件所占用的磁盘空间。</p>\n<p>语法<br>du [-abcDhHklmsSx][-L &lt;符号连接&gt;][-X &lt;文件&gt;][–block-size][–exclude=&lt;目录或文件&gt;][–max-depth=&lt;目录层数&gt;][–help][–version][目录或文件]<br>参数说明：</p>\n<p>-a或-all 显示目录中个别文件的大小。<br>-b或-bytes 显示目录或文件大小时，以byte为单位。<br>-c或–total 除了显示个别目录或文件的大小外，同时也显示所有目录或文件的总和。<br>-D或–dereference-args 显示指定符号连接的源文件大小。<br>-h或–human-readable 以K，M，G为单位，提高信息的可读性。<br>-H或–si 与-h参数相同，但是K，M，G是以1000为换算单位。<br>-k或–kilobytes 以1024 bytes为单位。<br>-l或–count-links 重复计算硬件连接的文件。<br>-L&lt;符号连接&gt;或–dereference&lt;符号连接&gt; 显示选项中所指定符号连接的源文件大小。<br>-m或–megabytes 以1MB为单位。<br>-s或–summarize 仅显示总计。<br>-S或–separate-dirs 显示个别目录的大小时，并不含其子目录的大小。<br>-x或–one-file-xystem 以一开始处理时的文件系统为准，若遇上其它不同的文件系统目录则略过。<br>-X&lt;文件&gt;或–exclude-from=&lt;文件&gt; 在&lt;文件&gt;指定目录或文件。<br>–exclude=&lt;目录或文件&gt; 略过指定的目录或文件。<br>–max-depth=&lt;目录层数&gt; 超过指定层数的目录后，予以忽略。<br>–help 显示帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"mkdir\"><a href=\"#mkdir\" class=\"headerlink\" title=\"mkdir\"></a>mkdir</h3><p>Linux mkdir命令用于建立名称为 dirName 之子目录。</p>\n<p>语法<br>mkdir [-p] dirName<br>参数说明：</p>\n<p>-p 确保目录名称存在，不存在的就建一个。</p>\n<h3 id=\"pwd\"><a href=\"#pwd\" class=\"headerlink\" title=\"pwd\"></a>pwd</h3><p>Linux pwd命令用于显示工作目录。</p>\n<p>执行pwd指令可立刻得知您目前所在的工作目录的绝对路径名称。</p>\n<p>语法<br>pwd [–help][–version]<br>参数说明:</p>\n<p>–help 在线帮助。<br>–version 显示版本信息。</p>\n<h3 id=\"mount\"><a href=\"#mount\" class=\"headerlink\" title=\"mount\"></a>mount</h3><p>Linux mount命令是经常会使用到的命令，它用于挂载Linux系统外的文件。</p>\n<p>语法<br>mount [-hV]<br>mount -a [-fFnrsvw] [-t vfstype]<br>mount [-fnrsvw] [-o options [,…]] device | dir<br>mount [-fnrsvw] [-t vfstype] [-o options] device dir<br>参数说明：</p>\n<p>-V：显示程序版本<br>-h：显示辅助讯息<br>-v：显示较讯息，通常和 -f 用来除错。<br>-a：将 /etc/fstab 中定义的所有档案系统挂上。<br>-F：这个命令通常和 -a 一起使用，它会为每一个 mount 的动作产生一个行程负责执行。在系统需要挂上大量 NFS 档案系统时可以加快挂上的动作。<br>-f：通常用在除错的用途。它会使 mount 并不执行实际挂上的动作，而是模拟整个挂上的过程。通常会和 -v 一起使用。<br>-n：一般而言，mount 在挂上后会在 /etc/mtab 中写入一笔资料。但在系统中没有可写入档案系统存在的情况下可以用这个选项取消这个动作。<br>-s-r：等于 -o ro<br>-w：等于 -o rw<br>-L：将含有特定标签的硬盘分割挂上。<br>-U：将档案分割序号为 的档案系统挂下。-L 和 -U 必须在/proc/partition 这种档案存在时才有意义。<br>-t：指定档案系统的型态，通常不必指定。mount 会自动选择正确的型态。<br>-o async：打开非同步模式，所有的档案读写动作都会用非同步模式执行。<br>-o sync：在同步模式下执行。<br>-o atime、-o noatime：当 atime 打开时，系统会在每次读取档案时更新档案的『上一次调用时间』。当我们使用 flash 档案系统时可能会选项把这个选项关闭以减少写入的次数。<br>-o auto、-o noauto：打开/关闭自动挂上模式。<br>-o defaults:使用预设的选项 rw, suid, dev, exec, auto, nouser, and async.<br>-o dev、-o nodev-o exec、-o noexec允许执行档被执行。<br>-o suid、-o nosuid：<br>允许执行档在 root 权限下执行。<br>-o user、-o nouser：使用者可以执行 mount/umount 的动作。<br>-o remount：将一个已经挂下的档案系统重新用不同的方式挂上。例如原先是唯读的系统，现在用可读写的模式重新挂上。<br>-o ro：用唯读模式挂上。<br>-o rw：用可读写模式挂上。<br>-o loop=：使用 loop 模式用来将一个档案当成硬盘分割挂上系统。</p>\n<h3 id=\"ls\"><a href=\"#ls\" class=\"headerlink\" title=\"ls\"></a>ls</h3><p>Linux ls命令用于显示指定工作目录下之内容（列出目前工作目录所含之文件及子目录)。</p>\n<p>语法<br> ls [-alrtAFR] [name…]<br>参数 :</p>\n<p>-a 显示所有文件及目录 (ls内定将文件名或目录名称开头为”.”的视为隐藏档，不会列出)<br>-l 除文件名称外，亦将文件型态、权限、拥有者、文件大小等资讯详细列出<br>-r 将文件以相反次序显示(原定依英文字母次序)<br>-t 将文件依建立时间之先后次序列出<br>-A 同 -a ，但不列出 “.” (目前目录) 及 “..” (父目录)<br>-F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“<br>-R 若目录下有文件，则以下之文件亦皆依序列出</p>\n<h2 id=\"系统管理\"><a href=\"#系统管理\" class=\"headerlink\" title=\"系统管理\"></a>系统管理</h2><h3 id=\"useradd\"><a href=\"#useradd\" class=\"headerlink\" title=\"useradd\"></a>useradd</h3><p>Linux useradd命令用于建立用户帐号。</p>\n<p>useradd可用来建立用户帐号。帐号建好之后，再用passwd设定帐号的密码．而可用userdel删除帐号。使用useradd指令所建立的帐号，实际上是保存在/etc/passwd文本文件中。</p>\n<p>语法<br>useradd [-mMnr][-c &lt;备注&gt;][-d &lt;登入目录&gt;][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>][-u <uid>][用户帐号]<br>或</uid></shell></p>\n<p>useradd -D [-b][-e &lt;有效期限&gt;][-f &lt;缓冲天数&gt;][-g &lt;群组&gt;][-G &lt;群组&gt;][-s <shell>]<br>参数说明：</shell></p>\n<p>-c&lt;备注&gt; 　加上备注文字。备注文字会保存在passwd的备注栏位中。<br>-d&lt;登入目录&gt; 　指定用户登入时的启始目录。<br>-D 　变更预设值．<br>-e&lt;有效期限&gt; 　指定帐号的有效期限。<br>-f&lt;缓冲天数&gt; 　指定在密码过期后多少天即关闭该帐号。<br>-g&lt;群组&gt; 　指定用户所属的群组。<br>-G&lt;群组&gt; 　指定用户所属的附加群组。<br>-m 　自动建立用户的登入目录。<br>-M 　不要自动建立用户的登入目录。<br>-n 　取消建立以用户名称为名的群组．<br>-r 　建立系统帐号。<br>-s<shell>　 　指定用户登入后所使用的shell。<br>-u<uid> 　指定用户ID</uid></shell></p>\n<h3 id=\"data\"><a href=\"#data\" class=\"headerlink\" title=\"data\"></a>data</h3><p>Linux date命令可以用来显示或设定系统的日期与时间，在显示方面，使用者可以设定欲显示的格式，格式设定为一个加号后接数个标记，其中可用的标记列表如下：</p>\n<p>时间方面：</p>\n<p>% : 印出 %<br>%n : 下一行<br>%t : 跳格<br>%H : 小时(00..23)<br>%I : 小时(01..12)<br>%k : 小时(0..23)<br>%l : 小时(1..12)<br>%M : 分钟(00..59)<br>%p : 显示本地 AM 或 PM<br>%r : 直接显示时间 (12 小时制，格式为 hh:mm:ss [AP]M)<br>%s : 从 1970 年 1 月 1 日 00:00:00 UTC 到目前为止的秒数<br>%S : 秒(00..61)<br>%T : 直接显示时间 (24 小时制)<br>%X : 相当于 %H:%M:%S<br>%Z : 显示时区<br>日期方面：</p>\n<p>%a : 星期几 (Sun..Sat)<br>%A : 星期几 (Sunday..Saturday)<br>%b : 月份 (Jan..Dec)<br>%B : 月份 (January..December)<br>%c : 直接显示日期与时间<br>%d : 日 (01..31)<br>%D : 直接显示日期 (mm/dd/yy)<br>%h : 同 %b<br>%j : 一年中的第几天 (001..366)<br>%m : 月份 (01..12)<br>%U : 一年中的第几周 (00..53) (以 Sunday 为一周的第一天的情形)<br>%w : 一周中的第几天 (0..6)<br>%W : 一年中的第几周 (00..53) (以 Monday 为一周的第一天的情形)<br>%x : 直接显示日期 (mm/dd/yy)<br>%y : 年份的最后两位数字 (00.99)<br>%Y : 完整年份 (0000..9999)<br>若是不以加号作为开头，则表示要设定时间，而时间格式为 MMDDhhmm[[CC]YY][.ss]，其中 MM 为月份，DD 为日，hh 为小时，mm 为分钟，CC 为年份前两位数字，YY 为年份后两位数字，ss 为秒数。</p>\n<p>使用权限：所有使用者。</p>\n<p>当您不希望出现无意义的 0 时(比如说 1999/03/07)，则可以在标记中插入 - 符号，比如说 date ‘+%-H:%-M:%-S’ 会把时分秒中无意义的 0 给去掉，像是原本的 08:09:04 会变为 8:9:4。另外，只有取得权限者(比如说 root)才能设定系统时间。</p>\n<p>当您以 root 身分更改了系统时间之后，请记得以 clock -w 来将系统时间写入 CMOS 中，这样下次重新开机时系统时间才会持续抱持最新的正确值。</p>\n<p>语法<br>date [-u] [-d datestr] [-s datestr] [–utc] [–universal] [–date=datestr] [–set=datestr] [–help] [–version] [+FORMAT] [MMDDhhmm[[CC]YY][.ss]]<br>参数说明：</p>\n<p>-d datestr : 显示 datestr 中所设定的时间 (非系统时间)<br>–help : 显示辅助讯息<br>-s datestr : 将系统时间设为 datestr 中所设定的时间<br>-u : 显示目前的格林威治时间<br>–version : 显示版本编号</p>\n<h3 id=\"ps\"><a href=\"#ps\" class=\"headerlink\" title=\"ps\"></a>ps</h3><p>Linux ps命令用于显示当前进程 (process) 的状态。</p>\n<p>语法<br>ps [options] [–help]<br>参数：</p>\n<p>ps 的参数非常多, 在此仅列出几个常用的参数并大略介绍含义<br>-A 列出所有的行程<br>-w 显示加宽可以显示较多的资讯<br>-au 显示较详细的资讯<br>-aux 显示所有包含其他使用者的行程<br>au(x) 输出格式 :<br>USER PID %CPU %MEM VSZ RSS TTY STAT START TIME COMMAND<br>USER: 行程拥有者<br>PID: pid<br>%CPU: 占用的 CPU 使用率<br>%MEM: 占用的记忆体使用率<br>VSZ: 占用的虚拟记忆体大小<br>RSS: 占用的记忆体大小<br>TTY: 终端的次要装置号码 (minor device number of tty)<br>STAT: 该行程的状态:<br>D: 不可中断的静止 (通悸□□缜b进行 I/O 动作)<br>R: 正在执行中<br>S: 静止状态<br>T: 暂停执行<br>Z: 不存在但暂时无法消除<br>W: 没有足够的记忆体分页可分配<br>&lt;: 高优先序的行程<br>N: 低优先序的行程<br>L: 有记忆体分页分配并锁在记忆体内 (实时系统或捱A I/O)<br>START: 行程开始时间<br>TIME: 执行的时间<br>COMMAND:所执行的指令</p>\n<h3 id=\"top\"><a href=\"#top\" class=\"headerlink\" title=\"top\"></a>top</h3><p>Linux top命令用于实时显示 process 的动态。</p>\n<p>使用权限：所有使用者。</p>\n<p>语法<br>top [-] [d delay] [q] [c] [S] [s] [i] [n] [b]<br>参数说明：</p>\n<p>d : 改变显示的更新速度，或是在交谈式指令列( interactive command)按 s<br>q : 没有任何延迟的显示速度，如果使用者是有 superuser 的权限，则 top 将会以最高的优先序执行<br>c : 切换显示模式，共有两种模式，一是只显示执行档的名称，另一种是显示完整的路径与名称S : 累积模式，会将己完成或消失的子行程 ( dead child process ) 的 CPU time 累积起来<br>s : 安全模式，将交谈式指令取消, 避免潜在的危机<br>i : 不显示任何闲置 (idle) 或无用 (zombie) 的行程<br>n : 更新的次数，完成后将会退出 top<br>b : 批次档模式，搭配 “n” 参数一起使用，可以用来将 top 的结果输出到档案内</p>\n<h3 id=\"pstree\"><a href=\"#pstree\" class=\"headerlink\" title=\"pstree\"></a>pstree</h3><p>Linux pstree命令将所有行程以树状图显示，树状图将会以 pid (如果有指定) 或是以 init 这个基本行程为根 (root)，如果有指定使用者 id，则树状图会只显示该使用者所拥有的行程。</p>\n<p>使用权限：所有使用者。</p>\n<p>语法<br>pstree [-a] [-c] [-h|-Hpid] [-l] [-n] [-p] [-u] [-G|-U] [pid|user]<br>或</p>\n<p>pstree -V<br>参数说明：</p>\n<p>-a 显示该行程的完整指令及参数, 如果是被记忆体置换出去的行程则会加上括号<br>-c 如果有重覆的行程名, 则分开列出（预设值是会在前面加上 *）</p>\n<h3 id=\"reboot\"><a href=\"#reboot\" class=\"headerlink\" title=\"reboot\"></a>reboot</h3><p>Linux reboot命令用于用来重新启动计算机。</p>\n<p>若系统的 runlevel 为 0 或 6 ，则重新开机，否则以 shutdown 指令（加上 -r 参数）来取代</p>\n<p>语法<br>reboot [-n] [-w] [-d] [-f] [-i]<br>参数：</p>\n<p>-n : 在重开机前不做将记忆体资料写回硬盘的动作<br>-w : 并不会真的重开机，只是把记录写到 /var/log/wtmp 档案里<br>-d : 不把记录写到 /var/log/wtmp 档案里（-n 这个参数包含了 -d）<br>-f : 强迫重开机，不呼叫 shutdown 这个指令<br>-i : 在重开机之前先把所有网络相关的装置先停止</p>\n<h3 id=\"screen\"><a href=\"#screen\" class=\"headerlink\" title=\"screen\"></a>screen</h3><p>Linux screen命令用于多重视窗管理程序。</p>\n<p>screen为多重视窗管理程序。此处所谓的视窗，是指一个全屏幕的文字模式画面。通常只有在使用telnet登入主机或是使用老式的终端机时，才有可能用到screen程序。</p>\n<p>语法<br>screen [-AmRvx -ls -wipe][-d &lt;作业名称&gt;][-h &lt;行数&gt;][-r &lt;作业名称&gt;][-s <shell>][-S &lt;作业名称&gt;]<br>参数说明：</shell></p>\n<p>-A 　将所有的视窗都调整为目前终端机的大小。<br>-d&lt;作业名称&gt; 　将指定的screen作业离线。<br>-h&lt;行数&gt; 　指定视窗的缓冲区行数。<br>-m 　即使目前已在作业中的screen作业，仍强制建立新的screen作业。<br>-r&lt;作业名称&gt; 　恢复离线的screen作业。<br>-R 　先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业。<br>-s<shell> 　指定建立新视窗时，所要执行的shell。<br>-S&lt;作业名称&gt; 　指定screen作业的名称。<br>-v 　显示版本信息。<br>-x 　恢复之前离线的screen作业。<br>-ls或–list 　显示目前所有的screen作业。<br>-wipe 　检查目前所有的screen作业，并删除已经无法使用的screen作业。</shell></p>\n<h3 id=\"shutdown\"><a href=\"#shutdown\" class=\"headerlink\" title=\"shutdown\"></a>shutdown</h3><p>Linux shutdown命令可以用来进行关机程序，并且在关机以前传送讯息给所有使用者正在执行的程序，shutdown 也可以用来重开机。</p>\n<p>使用权限：系统管理者。</p>\n<p>语法<br>shutdown [-t seconds] [-rkhncfF] time [message]<br>参数说明：</p>\n<p>-t seconds : 设定在几秒钟之后进行关机程序。<br>-k : 并不会真的关机，只是将警告讯息传送给所有使用者。<br>-r : 关机后重新开机。<br>-h : 关机后停机。<br>-n : 不采用正常程序来关机，用强迫的方式杀掉所有执行中的程序后自行关机。<br>-c : 取消目前已经进行中的关机动作。<br>-f : 关机时，不做 fcsk 动作(检查 Linux 档系统)。<br>-F : 关机时，强迫进行 fsck 动作。<br>time : 设定关机的时间。<br>message : 传送给所有使用者的警告讯息。</p>\n<h3 id=\"swatch\"><a href=\"#swatch\" class=\"headerlink\" title=\"swatch\"></a>swatch</h3><p>Linux swatch命令用于系统监控程序。</p>\n<p>swatch可用来监控系统记录文件，并在发现特定的事件时，执行指定的动作。swatch所监控的事件以及对应事件的动作都存放在swatch的配置文件中。预设的配置文件为拥护根目录下的.swatchrc。然而在Red Hat Linux的预设用户根目录下并没有.swatchrc配置文件，您可将/usr/doc/swatch-2.2/config_files/swatchrc.personal文件复制到用户根目录下的.swatchrc，然后修改.swatchrc所要监控的事件及执行的动作。</p>\n<p>语法<br>swatch [-A &lt;分隔字符&gt;][-c &lt;设置文件&gt;][-f &lt;记录文件&gt;][-I &lt;分隔字符&gt;][-P &lt;分隔字符&gt;][-r &lt;时间&gt;][-t &lt;记录文件&gt;]<br>参数说明：</p>\n<p>-A&lt;分隔字符&gt; 　预设配置文件中，动作的分隔字符，预设为逗号。<br>-c&lt;设置文件&gt; 　指定配置文件，而不使用预设的配置文件。<br>-f&lt;记录文件&gt; 　检查指定的记录文件，检查完毕后不会继续监控该记录文件。<br>-I&lt;分隔字符&gt; 　指定输入记录的分隔字符，预设为换行字符。<br>-P&lt;分隔字符&gt; 　指定配置文件中，事件的分隔字符，预设为逗号。<br>-r&lt;时间&gt; 　在指定的时间重新启动。<br>-t&lt;记录文件&gt; 　检查指定的记录文件，并且会监控加入记录文件中的后继记录。</p>\n<h3 id=\"id\"><a href=\"#id\" class=\"headerlink\" title=\"id\"></a>id</h3><p>Linux id命令用于显示用户的ID，以及所属群组的ID。</p>\n<p>id会显示用户以及所属群组的实际与有效ID。若两个ID相同，则仅显示实际ID。若仅指定用户名称，则显示目前用户的ID。</p>\n<p>语法<br>id [-gGnru][–help][–version][用户名称]<br>参数说明：</p>\n<p>-g或–group 　显示用户所属群组的ID。<br>-G或–groups 　显示用户所属附加群组的ID。<br>-n或–name 　显示用户，所属群组或附加群组的名称。<br>-r或–real 　显示实际ID。<br>-u或–user 　显示用户ID。<br>-help 　显示帮助。<br>-version 　显示版本信息。</p>\n<h3 id=\"free\"><a href=\"#free\" class=\"headerlink\" title=\"free\"></a>free</h3><p>Linux free命令用于显示内存状态。</p>\n<p>free指令会显示内存的使用情况，包括实体内存，虚拟的交换文件内存，共享内存区段，以及系统核心使用的缓冲区等。</p>\n<p>语法<br>free [-bkmotV][-s &lt;间隔秒数&gt;]<br>参数说明：</p>\n<p>-b 　以Byte为单位显示内存使用情况。<br>-k 　以KB为单位显示内存使用情况。<br>-m 　以MB为单位显示内存使用情况。<br>-o 　不显示缓冲区调节列。<br>-s&lt;间隔秒数&gt; 　持续观察内存使用状况。<br>-t 　显示内存总和列。<br>-V 　显示版本信息。</p>\n<h2 id=\"系统设置\"><a href=\"#系统设置\" class=\"headerlink\" title=\"系统设置\"></a>系统设置</h2><h3 id=\"setup\"><a href=\"#setup\" class=\"headerlink\" title=\"setup\"></a>setup</h3><p>Linux setup命令设置公用程序，是一个启动图形设置系统的命令。</p>\n<p>setup 命令：用来配置X，打印设置，时区设置，系统服务，网络配置，配置，防火墙配置，验证配置，鼠标配置。</p>\n<p>语法<br>setup<br>setup是一个设置公用程序，提供图形界面的操作方式。在setup中可设置7类的选项：</p>\n<p>１.登陆认证方式<br>２.键盘组态设置<br>３.鼠标组态设置<br>４.开机时所要启动的系统服务<br>５.声卡组态设置<br>６.时区设置<br>７.X Windows组态设置</p>\n"},{"title":"linux知识框架","_content":"\n# 介绍\n\n\n\n## 操作系统\n\nos(operating system),通用目的的软件程序\n>硬件驱动\n>进程管理\n>内存管理\n>网络管理\n>安全管理\n>文件管理\n\n## 安装linux\n\n>linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的[manjaro](https://www.manjaro.cn/153)或[mint](https://www.linuxmint.com/download.php)\n>分区和启动:\n>硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tb\n>uefi的GPT分区:逐渐代替MBR标准\n>主分区 一块硬盘最多4个,不能划分更小,最小单位\n>扩展分区:一块硬盘最多一个,不能直接创建文件系统\n>安装过程大同小异 [详细步骤](https://blog.csdn.net/python_lqx/article/details/88670425)\n>需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌.\n>/dev/sda 100g\n>/dev/sda1 /boot mountpoint  1g\n>/dev/sda2 /                50g\n>/dev/sda3 /data            20g\n>/dev/sda5 /swap             2g\n\n## 开发接口标准\n\n>ABI:application binary interface ABI描述了程序与os之间的底层接口\n>API:application programming interface\n>开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit\n\n## 用户和内核空间\n\n>username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响  \n>内核空间:kernel space\n\n## linux哲学思想\n\n在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的\n\n\n## 文件操作\n\n文件和目录被组织成单根倒置树结构\n文件系统从根目录下开始,用\"/\"表示\nproc虚拟的,在硬盘上不存在\n文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)\n以.开头的文件为隐藏文件\n元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.\n数据:data(内容在硬盘上)\n文件系统分成结构:LSB\n文件名最长255个字节,文件系统不一样大小不一样\n包括路径在内文件名称最长4095个字节\n蓝色---目录 绿色---可执行文件  红色---压缩文件\n浅蓝色---链接文件 灰色---其他文件 粉色是socket(套接字文件)双向传递\n管道文件 p开头(pipe)单工传输\n\n## 文件系统结构元素\n\n/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录\n/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序\n/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序\n/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)\n/lib64：专用于x86_64系统上的辅助共享库文件存放位置\n/etc：配置文件目录\n/home/USERNAME：普通用户家目录\n/root：管理员的家目录\n/media：便携式移动设备挂载点\n/mnt：临时文件系统挂载点\n/dev：设备文件及特殊文件存储位置  b: block device，随机访问  c: character device，线性访问\n/opt：第三方应用程序的安装位置\n/srv：系统上运行的服务用到的数据\n/tmp：临时文件存储位置\n/proc: 用于输出内核与进程信息相关的虚拟文件系统\n/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统\n/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文\n/usr: universal shared, read-only data  bin: 保证系统拥有完整功能而提供的应用程序  \nsbin:  lib：32位使用  lib64：只存在64位系统\ninclude: C程序的头文件(header files)  \nshare：结构化独立的数据，例如doc, man等\nlocal：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文\n\n/var: variable data files  cache: 应用程序缓存数据目录  \nlib: 应用程序状态信息数据  \nlocal：专用于为/usr/local下的应用程序存储可变数据  \nlock: 锁文件  log: 日志目录及文件  \nopt: 专用于为/opt下的应用程序存储可变数据\nrun: 运行中的进程相关数据,通常用于存储进程pid文件  \nspool: 应用程序数据池\ntmp: 保存系统两次重启之间产生的临时数据\n\n## Linux下的文件类型\n\n-：普通文件\nd: 目录文件\nb: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)\nc: 字符设备(设备主要以字符为单位,键盘为主)\nl: 符号链接文件\np: 管道文件pipe\ns: 套接字文件socket\n\n### 显示当前工作目录\n\n每个shell和系统进程都有一个当前的工作目录  \nCWD:current work directory\n显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认）\n\n### 更改目录\n\ncd  改变目录 使用绝对或相对路径： cd /home/wang/        cd home/wang 切换至父目录：  cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd - \n选项：-P  \n相关的环境变量：  PWD：当前目录路径   OLDPWD：上一次目录路径\n\n### 列出目录内容\n\n列出当前目录的内容或指定目录\n用法：ls [options] [ files_or_dirs ]\n示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R  目录递归通过 ls -ld  目录和符号链接信息 ls -1  文件分行显示 ls –S  按从大到小排序 ls –t   按mtime排序 ls –u   配合-t选项，显示并按atime从新到旧排序 \nls –U  按目录存放顺序显示 ls –X  按文件后缀排序\n>[root@centos7 sysconfig]# ll /etc/motd\n>-rw-r--r--. 1 root root 15 Mar 21 03:19 /etc/motd\n>[root@centos7 sysconfig]# ll ../motd\n>-rw-r--r--. 1 root root 15 Mar 21 03:19 ../motd\n-a 全部\n-r 递归\nll 是别名 (ls -l)\n\n### 查看文件状态\n\nstat\n文件：metadata, data\n三个时间戳: access time：访问时间，atime，读取文件内容\nmodify time: 修改时间,\nmtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变\ndata 时间不会一直更新\n通配符* 任意字符\n二进制查看hexdump -C\n\n### 创建和查看文件\n\ntouch 命令是个外部命令\n[]表示其中一个字母\n[^  ]表示除去其中字符的任意字符\n两个大于号比 touch安全\n\n### 文件统配符\n\nman 7 glob\n\n### 复制和转移删除文件\n\ncp [OPTION]... [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失\n原始命令前加\\\n拷贝文件夹 -r(递归)\ncp 有可能丢失数据不能用rmdir删除\n\ndata是个挂载点\ncp [OPTION]... SOURCE... DIRECTORY cp [OPTION]... -t DIRECTORY SOURCE... cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中      如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中  基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中\ncp SRC... DEST    SRC...：多个文件      \nDEST必须存在，且为目录，其它情形均会出错；cp SRC DEST \nSRC是目录：此时使用选项：-r\n如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；\n如果DEST存在：\n如果DEST是文件：报错 \n如果DEST是目录：\ninode（index node）表中包含文件系统所有文件列表 \n一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括：  文件类型，权限，UID，GID  链接数（指向这个文件名路径名称个数）  该文件的大小和不同的时间戳  指向磁盘上文件的数据块指针  有关文件的其他数据 \n\ninode 唯一标识在元数据里\n删除其实删的元数据.删文件比建文件快多了\n\n### 软和硬链接\n\n硬链接\n创建硬链接会增加额外的记录项以引用文件 \n对应于同一文件系统上一个物理文件 \n每个目录引用相同的inode号 \n创建时链接数递增 \n删除文件时： \nrm命令递减计数的链接 \n文件要存在，至少有一个链接数 \n当链接数为零时，该文件被删除 \n不能跨越驱动器或分区\n语法:  ln filename  [linkname ]\n软连接\n一个符号文件链接指向一个文件\nls -s显示链接的名称和应用的文件\n一个符号链接的内容是他引用文件的名称\n可以对目录进行\n可以跨分区\n指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数\n语法:ln -s 文件 链接名\n\n## i/0 重定向至文件\n\n程序:指令+数据\ninput 和output\n打开的文件都有一个fd:file descrptor(文件描述符)\nlinux 给程序提供三种i/o设备\n标准输入(STDIN)-0 默认接受来自键盘的输入\n标准输出(STDOUT) -1默认输出到终端窗口\n标准错误(STDERR) -2 默认输出到窗口\ni/o重定向:改变默认位置\n语法:命令  操作符号 文件名\n操作符>把STDOUT重定向到文件\n2> 把STDERR重定向到文件\n$> 把所有输出重定向到文件\ntr 转换和删除字符\n\n## 管道\n\n管道用来连接命令\n命令1|命令2|命令3\n将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDIN\nless 一页一页地查看输入\n重定向到多个目标(tee)\n把命令1的STDOUT保存在文件中,作为命令2的输入\n-a追加\n使用:\n保存不同阶段的输入\n复杂管道的故障排除\n同时查看和记录输出\n\n# 用户组权限\n\n## 用户user\n\n令牌token,identity\nlinux用户:username/UID\n管理员:root,0\n普通用户:1-65535\n系统用户:1-499,1-999\n对守护进程获取资源进行权限进行分配\n登录用户:500+,1000\n交互式登录\nnologin 是软件启动没有用户登录\n\n## 组group\n\nlinux:Groupname/GID\n管理员:\n系统 :1-499,1-999\n普通组:500+,1000+\n安全上下文:\n进行中的程序:程序(process)\n以进程发起者的身份运行:\nroot:/bin/cat\nmage:/bin/cat\n组的类别\n用户的主要组:\n用户必须属于一个且只有一个主组\n组名同用户名,且包含一个用户,私有组\n用户和组的配置文件\n/etc/passwd:用户及其属性信息\n/etc/group:组及其属性信息\n/etc/shadow:用户密码及其相关属性\n/etc/gshadow:组密码及其相关属性\npasswd文件格式\nlogin name:登录用名\npasswd:密码\nUID:用户身份编号\nGID:登录默认所在组编号\nGECOS:用户全名或注释\nhome diretory:用户主目录\nshell:用户默认使用shell\nshadow文件格式\nuseradd usermod userdel\n组账号维护命令:groupadd\ngroupmod groupdel\n\n## 用户创建:useradd\n\nuseradd [options]LOGIN\n-u UID\n-o 配合-u选项,不检查UID的唯一性\n-g GID:指明用户所属基本组,可谓组名,也可以GID\n-c \"COMMENT\":用户的注释信息\n默认设置:/etc/default/useradd文件中\n删除用户:userdel -r删除用户目录\n\n## 查看用户相关的ID信息\n\nid [OPTIONS]...[USER]\n-u :显示UID\n-g :显示GID\n-G :显示用户所属的组的ID\n-n :显示名称,需配合ugG使用\n\n## 切换用户或以其他用户身份执行命令\n\nsu[options] [-] [user[args...]]\n切换用户的方式\nssh root@ip\ncurl ww\nservice network restat\n\n## 设置密码\n\npasswd\n常用选项：\n -d:删除指定用户密码\n -l:锁定指定用户\n -u:解锁指定用户\n -e:强制用户下次登录修改密码\n -f: 强制操作\n -n mindays: 指定最短使用期限\n -x maxdays：最大使用期限\n -w warndays：提前多少天开始警告\n -i inactivedays：非活动期限\n --stdin：从标准输入接收用户密码\n echo \"PASSWORD\" | passwd --stdin USERNAME\n\n## 创建组\n\ngroupadd[option]...group_name\n-g GID:指明GID号:\n-r:创建系统组\n修改和删除组:\n组属性修改:groupmod\n组删除:groupdel\n组密码:gpasswd\nnewgrp命令:临时切换主组\nchown设置文件的所有者\nchgrp设置文件的属组信息\n修改文件的属主和属组chown\n修改文件的属组:chgrp\n\n## 文件权限\n\n文件的权限主要针对三类对象进行定义\nowner: 属主, u\ngroup: 属组, g\nother: 其他, o\n每个文件针对每类访问者都定义了三种权限\nr: Readable\nw: Writable\nx: eXcutable\n\n### 修改文件权限\n\nchmod [OPTION]... OCTAL-MODE FILE...\n -R: 递归修改权限\nchmod [OPTION]... MODE[,MODE]... FILE...\n MODE：\n 修改一类用户的所有权限：\n u= g= o= ug= a= u=,g=\n 修改一类用户某位或某些位权限\n u+ u- g+ g- o+ o- a+ a- + -\nchmod [OPTION]... --reference=RFILE FILE...\n参考RFILE文件的权限，将FILE的修改为同RFILE\n数字权限法:chmod数字 file\nrwx r-x r-- file\n其中：\n\nu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\n+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。\n其他参数说明：\n\n-c : 若该文件权限确实已经更改，才显示其更改动作\n-f : 若该文件权限无法被更改也不要显示错误讯息\n-v : 显示权限变更的详细资料\n-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n--help : 显示辅助说明\n--version : 显示版本\n\n# 文本工具\n\n## 基础\n\n文件内容:less和cat\n文件截取:head和tail\n按列抽取:cut\n按关键字抽取:grep\n文件查看:cat tac rev\n分页查看:more\n一页一页的查看:less\nless 命令是man命令使用的分页器\n\n### 显示文本前后或后行内容\n\nhead[option]...[FILE]默认看文本前10行,配合管道可以看命令前两行\ntail[option]...[FILE]看文本尾\ntail-f 跟踪看日志\ncut命令取字段\npast 横着合并文件\nwc 收集文本\n\n### 文本排序sort\n\n把整理过的文本显示在STDOUT,不改变原始文件\nsort[opiton]file(s)\nuniq:从输入中删除前后相接的重复的行,处理日志\nliunx:文本处理三剑客\ngrep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红\nsed:stream editor, 文本编辑工具\nawk:liunx上的实现gawk,文本报告生成器\ngrep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行\n\n## 正则表达式\n\n匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数\n位置锚定:定位\n正则字符特殊 元字符\n.单个任意字符\n[abc]表示其中一个字符\n[^abc]除去abc任意字母\n[:lower:]小写\n[:upper:]大写\n分组方式\nabc\\{3}\\\n搜索替代工具\ngrep过滤特定行,sed也可以并且编辑修改文件\n\n## vim编辑器\n\nvi:visual interface 文本编辑器\n文本:asscii ,unicode\n文本编辑种类:\n行编辑器:sed\n全屏编辑器:nano,vi\nvim -viimproved\n其他编辑器\ngedit 一个简单的图形编辑器\ngvim 一个vim编辑器的图形版本\nvi一开始是vim的别名\nvim有三种模式:normal(普通) insert(插入) extendcommand(命令)\nnormal :默认模式,移动光标,剪切/粘贴文本\ninsert :修改文本\nextend command:保存,退出\n\n### 搜索替代\n\n/ :从当前光标所在处向文件尾部查找\n? :从当前光标所在处向文件首部查找\nn :与命令同方向\nN :与命令反方向\n处理文本的工具sed\nstream editor 行编辑器\nsed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为\"模式空间\",接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如'D'的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.\nvim不适合修改大批量文件,sed可以\nsed 配合管道可以使用\nawk 语言\nsed '' passwd\n'地址命令'地址不写代表全部文件 命令不写代表输出\n\n# 软件管理\n\n## 包管理器\n\nrpm 打包文件 不需要考虑部署 安装路径都定义好\n二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件\n程序包管理器：\ndebian：deb文件, dpkg包管理器  \nredhat: rpm文件, rpm包管理器  \nrpm: Redhat Package Manager   RPM  Package Manager\n源代码：name-VERSION.tar.gz|bz2|xz  VERSION: major.minor.release\nrpm包命名方式:name-VERSION-release.arch.rpm  \n例：bash-4.2.46-19.el7.x86_64.rpm  VERSION: major.minor.release  release：release.OS  \n常见的arch：  x86: i386, i486, i586, i686  x86_64: x64, x86_64, amd64  powerpc: ppc  跟平台无关：noarch\n\n包：分类和拆包  \nApplication-VERSION-ARCH.rpm: 主包\nApplication-devel-VERSION-ARCH.rpm 开发子包  Application-utils-VERSION-ARHC.rpm 其它子包  Application-libs-VERSION-ARHC.rpm 其它子包\n包之间：可能存在依赖关系，甚至循环依赖\n解决依赖包管理\n工具:yum：rpm包管理器的前端工具  apt-get：deb包管理器前端工具  zypper: suse上的rpm前端管理工具  dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具\n\n查看二进制程序所依赖的库文件  ldd /PATH/TO/BINARY_FILE\n管理及查看本机装载的库文件  ldconfig 加载库文件  /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系  配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf  缓存文件：/etc/ld.so.cache\n\n### 程序包管理器\n\n功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.\n包文件组成 (每个包独有)\nRPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.  \n安装或卸载时运行的脚本\n数据库(公共)：/var/lib/rpm 程序包名称及版本  依赖关系  功能说明  包安装后生成的各文件路径及校验码信息\n管理程序包的方式:使用包管理器：rpm  使用前端工具：yum, dnf\n获取程序包的途径：  \n(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/   http://mirrors.aliyun.com   http://mirrors.sohu.com   http://mirrors.163.com  \n(2) 项目官方站点程序包的来源 \n(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux  Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net   http://rpm.pbone.net https://sourceforge.net/ \n(4) 自己制作 注意：第三方包建议要检查其合法性  来源合法性,程序包的完整性\n\n* rpm包管理 \nCentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护  安装：  \nrpm {-i|--install} [install-options] PACKAGE_FILE… \n   -v: verbose  \n   -h: 以#显示程序包管理执行进度  rpm -ivh PACKAGE_FILE ...\n\n* rpm包安装\n[install-options]  \n--test: 测试安装，但不真正执行安装，即dry run模式  \n--nodeps：忽略依赖关系  \n--replacepkgs | replacefiles  \n--nosignature: 不检查来源合法性  \n--nodigest：不检查包完整性  \n--noscripts：不执行程序包脚本   %pre: 安装前脚本；\n--nopre   %post: 安装后脚本；\n--nopost   %preun: 卸载前脚本；\n--nopreun   %postun: 卸载后脚本；  --nopostun\n* rpm包升级\n升级：rpm {-U|--upgrade} [install-options] PACKAGE_FILE...\nrpm {-F|--freshen} [install-options] PACKAGE_FILE...  \nupgrade：安装有旧版程序包，则“升级”\n如果不存在旧版程序包，则“安装”  \nfreshen：安装有旧版程序包，则“升级”\n如果不存在旧版程序包，则不执行升级操作  rpm -Uvh PACKAGE_FILE ...  rpm -Fvh PACKAGE_FILE ...  \n--oldpackage：降级  \n--force: 强制安装\n\n* 升级注意项\n注意：\n(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留\n* 包查询\nrpm {-q|--query} [select-options] [query-options] [select-options]  \n-a: 所有包  \n-f: 查看指定的文件由哪个程序包安装生成  \n-p rpmfile：针对尚未安装的程序包文件做查询操作  \n--whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供  --whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖\nrpm2cpio 包文件|cpio –itv  预览包内文件 rpm2cpio 包文件|cpio –id  “*.conf” 释放包内文件\n\n* 常用查询用法：  -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE  -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, ...  -qa \n包卸载：  rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ...\n\n包校验\nrpm {-V|--verify} [select-options] [verify-options]  S file Size differs  M Mode differs (includes permissions and file type)  5 digest (formerly MD5 sum) differs  D Device major/minor number mismatch  L readLink(2) path mismatch  U User ownership differs  G Group ownership differs  T mTime differs  P capabilities differ\n包校验\n包来源合法性验正及完整性验正  \n完整性验正：SHA256  \n来源合法性验正：RSA 公钥加密  \n对称加密：加密、解密使用同一密钥  \n非对称加密：密钥是成对儿的\npublic key: 公钥，公开所有人\n\n* rpm数据库\n数据库重建：  /var/lib/rpm rpm {--initdb|--rebuilddb}  initdb: 初始化   如果事先不存在数据库，则新建之   否则，不执行任何操作  rebuilddb：重建已安装的包头的数据库索引目录\n\n## yum\n\nCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具  yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下）  文件服务器: http:// https://   ftp://   file:// \n\n* yum配置文件 \nyum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置  /etc/yum.repos.d/*.repo：为仓库的指向提供配置  \n仓库指向的定义：   [repositoryID]   name=Some name for this repository   baseurl=url://path/to/repository/   enabled={1|0}   gpgcheck={1|0}   gpgkey=URL   enablegroups={1|0}   failovermethod={roundrobin|priority}    roundrobin：意为随机挑选，默认值    priority:按顺序访问   cost=   默认为1000\n* yum仓库\nyum的repo配置文件中可用的变量：  $releasever: 当前OS的发行版的主版本号  $arch: 平台，i386,i486,i586,x86_64等  $basearch：基础平台；i386, x86_64  $YUM0-$YUM9:自定义变量 实例:  http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64  http://server/centos/6/i384 \nyum源\n阿里云repo文件:http://mirrors.aliyun.com/repo/ \nCentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/ \nEPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 \n\n### yum命令\n\nyum命令的用法：  yum [options] [command] [package ...] \n显示仓库列表：  yum repolist [all|enabled|disabled] \n显示程序包：  yum list  yum list [all | glob_exp1] [glob_exp2] [...]  yum list {available|installed|updates} [glob_exp1] [...] 安装程序包：  yum install package1 [package2] [...]  yum reinstall package1 [package2] [...]  (重新安装) \nyum命令 \n升级程序包：  yum update [package1] [package2] [...]  yum downgrade package1 [package2] [...] (降级) \n检查可用升级：  yum check-update \n卸载程序包：  yum remove | erase package1 [package2] [...] \nyum命令 \n查看程序包information：  yum info [...] \n查看指定的特性(可以是某文件)是由哪个程序包所提供：  yum provides | whatprovides feature1 [feature2] [...] \n清理本地缓存：  清除/var/cache/yum/$basearch/$releasever缓存  yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] \n构建缓存：  yum makecache \nyum命令 \n搜索：yum search string1 [string2] [...]  以指定的关键字搜索程序包名及summary信息 \n查看指定包所依赖的capabilities：  yum deplist package1 [package2] [...] \n查看yum事务历史：  yum history [info|list|packages-list|packages-info|  summary|addon-info|redo|undo|  rollback|new|sync|stats]  yum history  yum history info 6  yum history undo 6  \n日志 ：/var/log/yum.log\n安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] [...](用install替代)  \nyum localupdate rpmfile1 [rpmfile2] [...] (用update替代)\n包组管理的相关命令：  yum groupinstall group1 [group2] [...]   groupupdate group1 [group2] [...]   yum grouplist [hidden] [groupwildcard] [...]   yum groupremove group1 [group2] [...]   yum groupinfo group1 [...] \nyum命令 \nyum的命令行选项：  --nogpgcheck：禁止进行gpg check  -y: 自动回答为“yes”  -q：静默模式  --disablerepo=repoidglob：临时禁用此处指定的repo  --enablerepo=repoidglob：临时启用此处指定的repo  --noplugins：禁用所有插件 \n系统光盘yum仓库\n系统安装光盘作为本地yum仓库：\n(1) 挂载光盘至某目录，例如/mnt/cdrom   mount /dev/cdrom /mnt/cdrom \n(2) 创建配置文件   [CentOS7]   name=   baseurl=   gpgcheck=   enabled= 创建yum仓库：  createrepo [options] <directory>\n\n### 程序包编译\n\n程序包编译安装： Application-VERSION-release.src.rpm --> 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码-->预处理-->编译-->汇编-->链接-->执行 \n源代码组织格式：  多文件：文件中的代码之间，很可能存在跨文件依赖关系  C、C++：make 项目管理器   configure脚本 --> Makefile.in --> Makefile  java: maven\n\n## C语言源代码编译安装三步骤:\n1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make  根据Makefile文件，构建应用程序\n3、make install  复制文件到相应路径\n开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in \n注意：安装前查看INSTALL，README\n\n开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software    Foundation) mariadb.org 代码托管:SourceForge.net  Github.com      code.google.com\nc/c++编译器: gcc (GNU C Complier)\n\n编译C源代码：  准备：提供开发工具及开发环境   开发工具：make, gcc等   开发环境：开发库，头文件    glibc：标准库  实现：通过“包组”提供开发组件   Development Tools   Server Platform Development\n\n第一步：configure脚本 选项：指定安装位置、指定启用的特性 --help: 获取其支持使用的选项  选项分类：安装路径设定:--prefix=/PATH: 指定默认安装位置,默认为/usr/local/--sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译\n\nOptional Features: 可选特性 --disable-FEATURE  --enable-FEATURE[=ARG] Optional Packages: 可选包 --with-PACKAGE[=ARG],依赖包    --without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION\n\n第二步：make 第三步：make install\n\n安装后的配置：\n(1) 二进制程序目录导入至PATH环境变量中   编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH\n(2) 导入帮助手册  编辑/etc/man.config|man_db.conf文件 添加一个MANPATH\n\n# shell编程\n\n## 基础\n\n程序：指令+数据\n程序编程风格：\n        过程式：以指令为中心，数据服务于指令\n        对象式：以数据为中心，指令服务于数据\n        shell程序：提供了编程能力，解释执行\n\n### 编程基本概念\n\n编程逻辑处理方式：\n顺序执行\n循环执行\n选择执行\n\n### shell编程：过程式、解释执行\n\n编程语言的基本结构：\n各种系统命令的组合\n数据存储：变量、数组\n表达式: a + b\n语句:if\nshell脚本基础\nshell脚本:\n包含一些命令或声明，并符合一定格式的文本文件\n格式要求:首行shebang机制\n>#!/bin/bash\n>#!/usr/bin/python\n>#!/usr/bin/perl\nshell脚本的用途有：\n自动化常用命令\n\n执行系统管理和故障排除\n\n创建简单的应用程序\n\n处理文本或文件\n\n### 添加注释\n\n注释以#开头\n第二步：运行脚本\n给予执行权限，在命令行上指定脚本的绝对或相对路径\n直接运行解释器，将脚本作为解释器程序的参数运行\n\n### 脚本规范\n\n脚本代码开头约定\n1、第一行一般为调用使用的语言\n2、程序名，避免更改文件名为无法找到正确的文件\n3、版本号\n4、更改后的时间\n5、作者相关信息\n6、该程序的作用，及注意事项\n7、最后是各版本的更新简要说明\n\n脚本调试\n检测脚本中的语法错误\nbash -n /path/to/some_script\n调试执行\nbash -x /path/to/some_script\n\n## 变量\n\n变量：命名的内存空间\n数据存储方式：\n字符：\n数值：整型，浮点型\n变量：变量类型\n作用：\n1、数据存储格式\n2、参与的运算\n3、表示的数据范围\n类型：\n字符\n数值：整型、浮点型\n变量命名法则：\n1、不能使程序中的保留字：例如 if, for\n2、只能使用数字、字母及下划线，且不能以数字开头\n3、见名知义\n4、统一命名规则：驼峰命名法，建议大写\n\n* bash中变量的种类\n根据变量的生效范围等标准划分下面变量类型：\n        局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，\n包括当前shell的子shell进程均无效\n        环境（全局）变量：生效范围为当前shell进程及其子进程\n        本地变量：生效范围为当前shell进程中某代码片断，通常指函数\n        位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传\n递给它的参数\n        特殊变量：$?, $0, $*, $@, $#,$$\n* 局部变量\n变量赋值：name=‘value’\n可以使用引用value:\n(1) 可以是直接字串; name=“root\"\n(2) 变量引用：name=\"$USER\"\n(3) 命令引用：name=`COMMAND` name=$(COMMAND)\n变量引用：${name} $name\n\"\"：弱引用，其中的变量引用会被替换为变量值\n''：强引用，其中的变量引用不会被替换为变量值，而保持原字符串\n显示已定义的所有变量：set\n删除变量：unset name\n\n* 环境变量\nbash内建的环境变量：\nPATH\nSHELL\nUSER\nUID\nHOME\nPWD\nSHLVL\nLANG\n MAIL\nHOSTNAME\nHISTSIZE\n—\n\n### 只读和位置变量\n\n只读变量：只能声明，但不能修改和删除\n声明只读变量：\n        readonly name\n        declare -r name\n查看只读变量：\n        readonly –p\n位置变量：在脚本代码中调用通过命令行传递给脚本的参数\n$1, $2, ...：对应第1、第2等参数，shift [n]换位置\n$0: 命令本身\n$*: 传递给脚本的所有参数，全部参数合为一个字符串\n$@: 传递给脚本的所有参数，每个参数为独立字符串\n$#: 传递给脚本的参数的个数\n$@ $* 只在被双引号包起来的时候才会有差异\nset -- 清空所有位置变量\n* 退出状态\n进程使用退出状态来报告成功或失败\n• 0 代表成功，1－255代表失败\n• $? 变量保存最近的命令退出状态\n例如：\nping -c1 -W1 hostdown &> /dev/null\necho $?\n退出状态码\nbash自定义退出状态码\nexit [n]：自定义退出状态码\n注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命\n令后面的数字\n注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执\n行的最后一条命令的状态码\n\n## 运算\n\nbash中的算术运算:help let\n+, -, *, /, %取模（取余）, **（乘方）\n实现算术运算：\n(1) let var=算术表达式\n(2) var=$[算术表达式]\n(3) var=$((算术表达式))\n(4) var=$(expr arg1 arg2 arg3 ...)\n(5) declare –i var = 数值\n(6) echo ‘算术表达式’ | bc\n乘法符号有些场景中需要转义，如*\nbash有内建的随机数生成器：RANDOM（0-32767）\necho $[$RANDOM%50] ：0-49之间随机数\n赋值\n* 增强型赋值：\n+=, -=, *=, /=, %=\nlet varOPERvalue\n例如:let count+=3\n自加3后自赋值\n自增，自减：\n        let var+=1\n        let var++\n        let var-=1\n        let var--\n* 逻辑运算\ntrue, false\n1, 0\n        与：\n        1 与 1 = 1\n        1 与 0 = 0\n        0 与 1 = 0\n        0 与 0 = 0\n        或:\n        1 或 1 = 1\n        1 或 0 = 1\n        0 或 1 = 1\n        0 或 0 = 0\n        非：！\n        ! 1 = 0\n        ! 0 = 1\n\n* 短路运算\n\n* 短路与\n第一个为0，结果必定为0\n第一个为1，第二个必须要参与运算\n* 短路或\n第一个为1，结果必定为1\n第一个为0，第二个必须要参与运算\n* 异或：^\n异或的两个值,相同为假，不同为真\n* 条件测试\n判断某需求是否满足，需要由测试机制来实现\n专用的测试表达式需要由测试命令辅助完成测试过程\n评估布尔声明，以便用在条件性执行中\n• 若真，则返回0\n• 若假，则返回1\n* 测试命令：\n• test EXPRESSION\n• [ EXPRESSION ]\n• [[ EXPRESSION ]]\n注意：EXPRESSION前后必须有空白字符\nbash的数值测试\n-v VAR\n变量VAR是否设置\n* 数值测试：\n-gt 是否大于\n-ge 是否大于等于\n-eq 是否等于\n-ne 是否不等于\n-lt 是否小于\n-le 是否小于等于\nbash的字符串测试\n\n* 字符串测试:\n\n>== 是否等于\n> ascii码是否大于ascii码\n< 是否小于\n!= 是否不等于\n=~ 左侧字符串是否能够被右侧的PATTERN所匹配\n注意: 此表达式一般用于[[ ]]中；扩展的正则表达式\n>-z \"STRING“ 字符串是否为空，空为真，不空为假\n>-n \"STRING“ 字符串是否不空，不空为真，空为假\n注意：用于字符串比较时的用到的操作数都应该使用引号\nBash的文件测试\n\n* 存在性测试\n\n-a FILE：同-e\n-e FILE: 文件存在性测试，存在为真，否则为假\n存在性及类别测试\n-b FILE：是否存在且为块设备文件\n-c FILE：是否存在且为字符设备文件\n-d FILE：是否存在且为目录文件\n-f FILE：是否存在且为普通文件\n-h FILE 或 -L FILE：存在且为符号链接文件\n-p FILE：是否存在且为命名管道文件\n-S FILE：是否存在且为套接字文件\nBash的文件权限测试\n\n* 文件权限测试：\n-r FILE：是否存在且可读\n-w FILE: 是否存在且可写\n-x FILE: 是否存在且可执行\n* 文件特殊权限测试：\n-u FILE：是否存在且拥有suid权限\n-g FILE：是否存在且拥有sgid权限\n-k FILE：是否存在且拥有sticky权限\nBash的文件属性测试\n* 文件大小测试：\n-s FILE: 是否存在且非空\n文件是否打开：\n-t fd: fd 文件描述符是否在某终端已经打开\n-N FILE：文件自从上一次被读取之后是否被修改过\n-O FILE：当前有效用户是否为文件属主\n-G FILE：当前有效用户是否为文件属组\nBash的文件属性测试\n* 双目测试：\nFILE1 -ef FILE2: FILE1是否是FILE2的硬链接\nFILE1 -nt FILE2: FILE1是否新于FILE2（mtime）\nFILE1 -ot FILE2: FILE1是否旧于FILE2\n\n使用read命令来接受输入\n使用read来把输入值分配给一个或多个shell变量\n-p 指定要显示的提示\n-s 静默输入，一般用于密码\n-n N 指定输入的字符长度N\n-d ‘字符’ 输入结束符\n-t N TIMEOUT为N秒\nread 从标准输入中读取值，给每个单词分配一个变量\n所有剩余单词都被分配给最后一个变量\nread -p “Enter a filename: “ FILE\n\n## 流程控制\n\n过程式编程语言：\n        顺序执行\n        选择执行\n        循环执行\n条件选择if语句\n\n* 选择执行:\n\n注意：if语句可嵌套\n单分支\n        if 判断条件;then\n        条件为真的分支代码\n        fi\n双分支\n        if 判断条件; then\n        条件为真的分支代码\n        else\n条件为假的分支代码\nfi\n\n* \n多分支\n        if 判断条件1; then\n        条件为真的分支代码\n        elif 判断条件2; then\n        条件为真的分支代码\n        elif 判断条件3; then\n        条件为真的分支代码\n        else\n        以上条件都为假的分支代码\n        fi\n逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句\n\n* 条件判断：case语句\n        case 变量引用 in\n        PAT1)\n        分支1\n        ;;\n        PAT2)\n        分支2\n        ;;\n        ...\n        *)\n        默认分支\n        ;;\n        esac\n\ncase支持glob风格的通配符：\n        *: 任意长度任意字符\n        ?: 任意单个字符\n        []：指定范围内的任意单个字符\n        a|b: a或b\n\n* 循环\n  \n\n循环执行\n将某代码段重复运行多次\n重复运行多少次：\n循环次数事先已知\n循环次数事先未知\n有进入条件和退出条件\nfor, while, until\nfor循环\nfor 变量名 in 列表;do\n循环体\ndone\n执行机制：\n依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直\n到列表中的元素耗尽，循环结束\n\n* for循环\n列表生成方式：\n(1) 直接给出列表\n(2) 整数列表：\n(a) {start..end}\n(b) $(seq [start [step]] end)\n(3) 返回列表的命令\n$(COMMAND)\n(4) 使用glob，如：*.sh\n(5) 变量引用；\n$@, $*\nwhile循环\nwhile CONDITION; do\n循环体\ndone\nCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后\n会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为\n“false”终止循环\n因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地\n被修正\n进入条件：CONDITION为true\n退出条件：CONDITION为false\nuntil循环\nuntil CONDITION; do\n循环体\ndone\n进入条件： CONDITION 为false\n退出条件： CONDITION 为true\n循环控制语句continue\n用于循环体中\nontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为\n第1层\nwhile CONDTIITON1; do\nCMD1\n...\nif CONDITION2; then\ncontinue\nfi\nCMDn\n...\ndone\n循环控制语句break\n用于循环体中\nbreak [N]：提前结束第N层循环，最内层为第1层\nwhile CONDTIITON1; do\nCMD1\n...\nif CONDITION2; then\nbreak\nfi\nCMDn\n...\ndone\n特殊用法\n双小括号方法，即((…))格式，也可以用于算术运算\n双小括号方法也可以使bash Shell实现C语言风格的变量操作\nI=10\n((I++))\nfor循环的特殊格式：\n for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))\n do\n* 循环体\n done\n控制变量初始化：仅在运行到循环代码段时执行一次\n控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做\n条件判断\n\n## 函数介绍\n\n函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程\n它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运\n行，而是shell程序的一部分\n函数和shell程序比较相似，区别在于：\nShell程序在子Shell中运行\n而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变\n量进行修改\n定义函数\n函数由两部分组成：函数名和函数体\nhelp function\n语法一：\nf_name （）{\n...函数体...\n}\n 语法二：\nfunction f_name {\n...函数体...\n}\n 语法三：\nfunction f_name （） {\n...函数体...\n}\n\n* 函数使用\n函数的定义和使用：\n可在交互式环境下定义函数\n可将函数放在脚本文件中作为它的一部分\n可放在只包含函数的单独文件中\n调用：函数只有被调用才会执行\n调用：给定函数名\n函数名出现的地方，会被自动替换为函数代码\n函数的生命周期：被调用时创建，返回时终止函数返回值\n函数有两种返回值：\n函数的执行结果返回值：\n(1) 使用echo等命令进行输出\n(2) 函数体中调用命令的输出结果\n函数的退出状态码：\n(1) 默认取决于函数中执行的最后一条命令的退出状态码\n(2) 自定义退出状态码，其格式为：\nreturn 从函数中返回，用最后状态命令决定返回值\nreturn 0 无错误返回。\nreturn 1-255 有错误返回\n交互式环境下定义和使用函数\n\n>示例:\n >dir() {\n > ls -l\n > }\n定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同\ndir\n该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令\nunset dir\n在脚本中定义及使用函数\n函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它\n后才能使用\n调用函数仅使用其函数名即可\n>示例：\n>cat func1\n>!/bin/bash\n>func1\n>hello()\n>{\n> echo \"Hello there today's date is `date +%F`\"\n>}\n>echo \"now going to the function hello\"\n>hello\n>echo \"back from the function\"\n使用函数文件\n可以将经常使用的函数存入函数文件，然后将函数文件载入shell\n文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main\n一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set\n命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数\n若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新\n载入此文件\n\n* 创建函数文件\n\n函数文件示例：\n>cat functions.main\n>#!/bin/bash\n>#functions.main\n>findit()\n>{\n> if [ $# -lt 1 ] ; then\n> echo \"Usage:findit file\"\n> return 1\n>fi\n>find / -name $1 –print\n>}\n\n* 载入函数\n函数文件已创建好后，要将它载入shell\n定位函数文件并载入shell的格式：\n. filename 或 source filename\n注意：此即<点> <空格> <文件名>\n这里的文件名要带正确路径\n\n* 检查载入函数\n使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数\n\n>示例：\n>set\n> findit=( )\n> {\n> if [ $# -lt 1 ]; then\n> echo \"usage :findit file\";\n> return 1\n> fi\n> find / -name $1 -print\n> }\n\n* 执行shell函数\n要执行函数，简单地键入函数名即可\n示例：\nfindit groups\n/usr/bin/groups\n/usr/local/backups/groups.bak\n* 删除shell函数\n现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命\n令完成删除函数\n命令格式为：\nunset function_name\n示例：\nunset findit\n再键入set命令，函数将不再显示\n* 函数参数\n函数可以接受参数：\n传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；\n例如“testfunc arg1 arg2 ...”\n在函数体中当中，可使用$1, $2, ...调用这些参数；还可以使用$@, $*, $#\n等特殊变量\n函数变量\n变量作用域：\n环境变量：当前shell和子shell有效\n本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；\n因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数\n局部变量：函数的生命周期；函数结束时变量被自动销毁\n注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量\n在函数中定义局部变量的方法\nlocal NAME=VALUE\n函数递归示例\n* 函数递归：\n函数直接或间接调用自身\n注意递归层数\n递归实例：\n阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语\n一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的\n阶乘为1，自然数n的阶乘写作n!\nn!=1×2×3×...×n\n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n\nn!=n(n-1)(n-2)...1\nn(n-1)! = n(n-1)(n-2)!\n函数递归示例:\n\n>        示例：fact.sh\n>\n>        fact() {\n>        if [ $1 -eq 0 -o $1 -eq 1 ]; then\n>        echo 1\n>        else\n>        echo $[$1*$(fact $[$1-1])]\n>        fi\n>        }\n>        fact $1\n\n* fork炸弹\n\nfork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是\n一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个\n简单的程序迅速耗尽系统里面的所有资源\n函数实现\n:(){ :|:& };:\nbomb() { bomb | bomb & }; bomb  实际上: 代表bomb\n脚本实现\n>cat Bomb.sh\n>./$0|./$0&\n","source":"_posts/1 (10).md","raw":"---\ntitle: linux知识框架\n\ncategories:\n- linux\ntags:\n- linux基础\n\n---\n\n# 介绍\n\n\n\n## 操作系统\n\nos(operating system),通用目的的软件程序\n>硬件驱动\n>进程管理\n>内存管理\n>网络管理\n>安全管理\n>文件管理\n\n## 安装linux\n\n>linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的[manjaro](https://www.manjaro.cn/153)或[mint](https://www.linuxmint.com/download.php)\n>分区和启动:\n>硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tb\n>uefi的GPT分区:逐渐代替MBR标准\n>主分区 一块硬盘最多4个,不能划分更小,最小单位\n>扩展分区:一块硬盘最多一个,不能直接创建文件系统\n>安装过程大同小异 [详细步骤](https://blog.csdn.net/python_lqx/article/details/88670425)\n>需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌.\n>/dev/sda 100g\n>/dev/sda1 /boot mountpoint  1g\n>/dev/sda2 /                50g\n>/dev/sda3 /data            20g\n>/dev/sda5 /swap             2g\n\n## 开发接口标准\n\n>ABI:application binary interface ABI描述了程序与os之间的底层接口\n>API:application programming interface\n>开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit\n\n## 用户和内核空间\n\n>username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响  \n>内核空间:kernel space\n\n## linux哲学思想\n\n在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的\n\n\n## 文件操作\n\n文件和目录被组织成单根倒置树结构\n文件系统从根目录下开始,用\"/\"表示\nproc虚拟的,在硬盘上不存在\n文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)\n以.开头的文件为隐藏文件\n元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.\n数据:data(内容在硬盘上)\n文件系统分成结构:LSB\n文件名最长255个字节,文件系统不一样大小不一样\n包括路径在内文件名称最长4095个字节\n蓝色---目录 绿色---可执行文件  红色---压缩文件\n浅蓝色---链接文件 灰色---其他文件 粉色是socket(套接字文件)双向传递\n管道文件 p开头(pipe)单工传输\n\n## 文件系统结构元素\n\n/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录\n/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序\n/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序\n/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)\n/lib64：专用于x86_64系统上的辅助共享库文件存放位置\n/etc：配置文件目录\n/home/USERNAME：普通用户家目录\n/root：管理员的家目录\n/media：便携式移动设备挂载点\n/mnt：临时文件系统挂载点\n/dev：设备文件及特殊文件存储位置  b: block device，随机访问  c: character device，线性访问\n/opt：第三方应用程序的安装位置\n/srv：系统上运行的服务用到的数据\n/tmp：临时文件存储位置\n/proc: 用于输出内核与进程信息相关的虚拟文件系统\n/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统\n/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文\n/usr: universal shared, read-only data  bin: 保证系统拥有完整功能而提供的应用程序  \nsbin:  lib：32位使用  lib64：只存在64位系统\ninclude: C程序的头文件(header files)  \nshare：结构化独立的数据，例如doc, man等\nlocal：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文\n\n/var: variable data files  cache: 应用程序缓存数据目录  \nlib: 应用程序状态信息数据  \nlocal：专用于为/usr/local下的应用程序存储可变数据  \nlock: 锁文件  log: 日志目录及文件  \nopt: 专用于为/opt下的应用程序存储可变数据\nrun: 运行中的进程相关数据,通常用于存储进程pid文件  \nspool: 应用程序数据池\ntmp: 保存系统两次重启之间产生的临时数据\n\n## Linux下的文件类型\n\n-：普通文件\nd: 目录文件\nb: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)\nc: 字符设备(设备主要以字符为单位,键盘为主)\nl: 符号链接文件\np: 管道文件pipe\ns: 套接字文件socket\n\n### 显示当前工作目录\n\n每个shell和系统进程都有一个当前的工作目录  \nCWD:current work directory\n显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认）\n\n### 更改目录\n\ncd  改变目录 使用绝对或相对路径： cd /home/wang/        cd home/wang 切换至父目录：  cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd - \n选项：-P  \n相关的环境变量：  PWD：当前目录路径   OLDPWD：上一次目录路径\n\n### 列出目录内容\n\n列出当前目录的内容或指定目录\n用法：ls [options] [ files_or_dirs ]\n示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R  目录递归通过 ls -ld  目录和符号链接信息 ls -1  文件分行显示 ls –S  按从大到小排序 ls –t   按mtime排序 ls –u   配合-t选项，显示并按atime从新到旧排序 \nls –U  按目录存放顺序显示 ls –X  按文件后缀排序\n>[root@centos7 sysconfig]# ll /etc/motd\n>-rw-r--r--. 1 root root 15 Mar 21 03:19 /etc/motd\n>[root@centos7 sysconfig]# ll ../motd\n>-rw-r--r--. 1 root root 15 Mar 21 03:19 ../motd\n-a 全部\n-r 递归\nll 是别名 (ls -l)\n\n### 查看文件状态\n\nstat\n文件：metadata, data\n三个时间戳: access time：访问时间，atime，读取文件内容\nmodify time: 修改时间,\nmtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变\ndata 时间不会一直更新\n通配符* 任意字符\n二进制查看hexdump -C\n\n### 创建和查看文件\n\ntouch 命令是个外部命令\n[]表示其中一个字母\n[^  ]表示除去其中字符的任意字符\n两个大于号比 touch安全\n\n### 文件统配符\n\nman 7 glob\n\n### 复制和转移删除文件\n\ncp [OPTION]... [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失\n原始命令前加\\\n拷贝文件夹 -r(递归)\ncp 有可能丢失数据不能用rmdir删除\n\ndata是个挂载点\ncp [OPTION]... SOURCE... DIRECTORY cp [OPTION]... -t DIRECTORY SOURCE... cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中      如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中  基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中\ncp SRC... DEST    SRC...：多个文件      \nDEST必须存在，且为目录，其它情形均会出错；cp SRC DEST \nSRC是目录：此时使用选项：-r\n如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；\n如果DEST存在：\n如果DEST是文件：报错 \n如果DEST是目录：\ninode（index node）表中包含文件系统所有文件列表 \n一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括：  文件类型，权限，UID，GID  链接数（指向这个文件名路径名称个数）  该文件的大小和不同的时间戳  指向磁盘上文件的数据块指针  有关文件的其他数据 \n\ninode 唯一标识在元数据里\n删除其实删的元数据.删文件比建文件快多了\n\n### 软和硬链接\n\n硬链接\n创建硬链接会增加额外的记录项以引用文件 \n对应于同一文件系统上一个物理文件 \n每个目录引用相同的inode号 \n创建时链接数递增 \n删除文件时： \nrm命令递减计数的链接 \n文件要存在，至少有一个链接数 \n当链接数为零时，该文件被删除 \n不能跨越驱动器或分区\n语法:  ln filename  [linkname ]\n软连接\n一个符号文件链接指向一个文件\nls -s显示链接的名称和应用的文件\n一个符号链接的内容是他引用文件的名称\n可以对目录进行\n可以跨分区\n指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数\n语法:ln -s 文件 链接名\n\n## i/0 重定向至文件\n\n程序:指令+数据\ninput 和output\n打开的文件都有一个fd:file descrptor(文件描述符)\nlinux 给程序提供三种i/o设备\n标准输入(STDIN)-0 默认接受来自键盘的输入\n标准输出(STDOUT) -1默认输出到终端窗口\n标准错误(STDERR) -2 默认输出到窗口\ni/o重定向:改变默认位置\n语法:命令  操作符号 文件名\n操作符>把STDOUT重定向到文件\n2> 把STDERR重定向到文件\n$> 把所有输出重定向到文件\ntr 转换和删除字符\n\n## 管道\n\n管道用来连接命令\n命令1|命令2|命令3\n将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDIN\nless 一页一页地查看输入\n重定向到多个目标(tee)\n把命令1的STDOUT保存在文件中,作为命令2的输入\n-a追加\n使用:\n保存不同阶段的输入\n复杂管道的故障排除\n同时查看和记录输出\n\n# 用户组权限\n\n## 用户user\n\n令牌token,identity\nlinux用户:username/UID\n管理员:root,0\n普通用户:1-65535\n系统用户:1-499,1-999\n对守护进程获取资源进行权限进行分配\n登录用户:500+,1000\n交互式登录\nnologin 是软件启动没有用户登录\n\n## 组group\n\nlinux:Groupname/GID\n管理员:\n系统 :1-499,1-999\n普通组:500+,1000+\n安全上下文:\n进行中的程序:程序(process)\n以进程发起者的身份运行:\nroot:/bin/cat\nmage:/bin/cat\n组的类别\n用户的主要组:\n用户必须属于一个且只有一个主组\n组名同用户名,且包含一个用户,私有组\n用户和组的配置文件\n/etc/passwd:用户及其属性信息\n/etc/group:组及其属性信息\n/etc/shadow:用户密码及其相关属性\n/etc/gshadow:组密码及其相关属性\npasswd文件格式\nlogin name:登录用名\npasswd:密码\nUID:用户身份编号\nGID:登录默认所在组编号\nGECOS:用户全名或注释\nhome diretory:用户主目录\nshell:用户默认使用shell\nshadow文件格式\nuseradd usermod userdel\n组账号维护命令:groupadd\ngroupmod groupdel\n\n## 用户创建:useradd\n\nuseradd [options]LOGIN\n-u UID\n-o 配合-u选项,不检查UID的唯一性\n-g GID:指明用户所属基本组,可谓组名,也可以GID\n-c \"COMMENT\":用户的注释信息\n默认设置:/etc/default/useradd文件中\n删除用户:userdel -r删除用户目录\n\n## 查看用户相关的ID信息\n\nid [OPTIONS]...[USER]\n-u :显示UID\n-g :显示GID\n-G :显示用户所属的组的ID\n-n :显示名称,需配合ugG使用\n\n## 切换用户或以其他用户身份执行命令\n\nsu[options] [-] [user[args...]]\n切换用户的方式\nssh root@ip\ncurl ww\nservice network restat\n\n## 设置密码\n\npasswd\n常用选项：\n -d:删除指定用户密码\n -l:锁定指定用户\n -u:解锁指定用户\n -e:强制用户下次登录修改密码\n -f: 强制操作\n -n mindays: 指定最短使用期限\n -x maxdays：最大使用期限\n -w warndays：提前多少天开始警告\n -i inactivedays：非活动期限\n --stdin：从标准输入接收用户密码\n echo \"PASSWORD\" | passwd --stdin USERNAME\n\n## 创建组\n\ngroupadd[option]...group_name\n-g GID:指明GID号:\n-r:创建系统组\n修改和删除组:\n组属性修改:groupmod\n组删除:groupdel\n组密码:gpasswd\nnewgrp命令:临时切换主组\nchown设置文件的所有者\nchgrp设置文件的属组信息\n修改文件的属主和属组chown\n修改文件的属组:chgrp\n\n## 文件权限\n\n文件的权限主要针对三类对象进行定义\nowner: 属主, u\ngroup: 属组, g\nother: 其他, o\n每个文件针对每类访问者都定义了三种权限\nr: Readable\nw: Writable\nx: eXcutable\n\n### 修改文件权限\n\nchmod [OPTION]... OCTAL-MODE FILE...\n -R: 递归修改权限\nchmod [OPTION]... MODE[,MODE]... FILE...\n MODE：\n 修改一类用户的所有权限：\n u= g= o= ug= a= u=,g=\n 修改一类用户某位或某些位权限\n u+ u- g+ g- o+ o- a+ a- + -\nchmod [OPTION]... --reference=RFILE FILE...\n参考RFILE文件的权限，将FILE的修改为同RFILE\n数字权限法:chmod数字 file\nrwx r-x r-- file\n其中：\n\nu 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。\n+ 表示增加权限、- 表示取消权限、= 表示唯一设定权限。\nr 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。\n其他参数说明：\n\n-c : 若该文件权限确实已经更改，才显示其更改动作\n-f : 若该文件权限无法被更改也不要显示错误讯息\n-v : 显示权限变更的详细资料\n-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)\n--help : 显示辅助说明\n--version : 显示版本\n\n# 文本工具\n\n## 基础\n\n文件内容:less和cat\n文件截取:head和tail\n按列抽取:cut\n按关键字抽取:grep\n文件查看:cat tac rev\n分页查看:more\n一页一页的查看:less\nless 命令是man命令使用的分页器\n\n### 显示文本前后或后行内容\n\nhead[option]...[FILE]默认看文本前10行,配合管道可以看命令前两行\ntail[option]...[FILE]看文本尾\ntail-f 跟踪看日志\ncut命令取字段\npast 横着合并文件\nwc 收集文本\n\n### 文本排序sort\n\n把整理过的文本显示在STDOUT,不改变原始文件\nsort[opiton]file(s)\nuniq:从输入中删除前后相接的重复的行,处理日志\nliunx:文本处理三剑客\ngrep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红\nsed:stream editor, 文本编辑工具\nawk:liunx上的实现gawk,文本报告生成器\ngrep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行\n\n## 正则表达式\n\n匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数\n位置锚定:定位\n正则字符特殊 元字符\n.单个任意字符\n[abc]表示其中一个字符\n[^abc]除去abc任意字母\n[:lower:]小写\n[:upper:]大写\n分组方式\nabc\\{3}\\\n搜索替代工具\ngrep过滤特定行,sed也可以并且编辑修改文件\n\n## vim编辑器\n\nvi:visual interface 文本编辑器\n文本:asscii ,unicode\n文本编辑种类:\n行编辑器:sed\n全屏编辑器:nano,vi\nvim -viimproved\n其他编辑器\ngedit 一个简单的图形编辑器\ngvim 一个vim编辑器的图形版本\nvi一开始是vim的别名\nvim有三种模式:normal(普通) insert(插入) extendcommand(命令)\nnormal :默认模式,移动光标,剪切/粘贴文本\ninsert :修改文本\nextend command:保存,退出\n\n### 搜索替代\n\n/ :从当前光标所在处向文件尾部查找\n? :从当前光标所在处向文件首部查找\nn :与命令同方向\nN :与命令反方向\n处理文本的工具sed\nstream editor 行编辑器\nsed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为\"模式空间\",接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如'D'的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.\nvim不适合修改大批量文件,sed可以\nsed 配合管道可以使用\nawk 语言\nsed '' passwd\n'地址命令'地址不写代表全部文件 命令不写代表输出\n\n# 软件管理\n\n## 包管理器\n\nrpm 打包文件 不需要考虑部署 安装路径都定义好\n二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件\n程序包管理器：\ndebian：deb文件, dpkg包管理器  \nredhat: rpm文件, rpm包管理器  \nrpm: Redhat Package Manager   RPM  Package Manager\n源代码：name-VERSION.tar.gz|bz2|xz  VERSION: major.minor.release\nrpm包命名方式:name-VERSION-release.arch.rpm  \n例：bash-4.2.46-19.el7.x86_64.rpm  VERSION: major.minor.release  release：release.OS  \n常见的arch：  x86: i386, i486, i586, i686  x86_64: x64, x86_64, amd64  powerpc: ppc  跟平台无关：noarch\n\n包：分类和拆包  \nApplication-VERSION-ARCH.rpm: 主包\nApplication-devel-VERSION-ARCH.rpm 开发子包  Application-utils-VERSION-ARHC.rpm 其它子包  Application-libs-VERSION-ARHC.rpm 其它子包\n包之间：可能存在依赖关系，甚至循环依赖\n解决依赖包管理\n工具:yum：rpm包管理器的前端工具  apt-get：deb包管理器前端工具  zypper: suse上的rpm前端管理工具  dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具\n\n查看二进制程序所依赖的库文件  ldd /PATH/TO/BINARY_FILE\n管理及查看本机装载的库文件  ldconfig 加载库文件  /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系  配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf  缓存文件：/etc/ld.so.cache\n\n### 程序包管理器\n\n功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.\n包文件组成 (每个包独有)\nRPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.  \n安装或卸载时运行的脚本\n数据库(公共)：/var/lib/rpm 程序包名称及版本  依赖关系  功能说明  包安装后生成的各文件路径及校验码信息\n管理程序包的方式:使用包管理器：rpm  使用前端工具：yum, dnf\n获取程序包的途径：  \n(1) 系统发版的光盘或官方的服务器;CentOS镜像:https://www.centos.org/download/   http://mirrors.aliyun.com   http://mirrors.sohu.com   http://mirrors.163.com  \n(2) 项目官方站点程序包的来源 \n(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux  Rpmforge:RHEL推荐，包很全 搜索引擎:http://pkgs.org http://rpmfind.net   http://rpm.pbone.net https://sourceforge.net/ \n(4) 自己制作 注意：第三方包建议要检查其合法性  来源合法性,程序包的完整性\n\n* rpm包管理 \nCentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护  安装：  \nrpm {-i|--install} [install-options] PACKAGE_FILE… \n   -v: verbose  \n   -h: 以#显示程序包管理执行进度  rpm -ivh PACKAGE_FILE ...\n\n* rpm包安装\n[install-options]  \n--test: 测试安装，但不真正执行安装，即dry run模式  \n--nodeps：忽略依赖关系  \n--replacepkgs | replacefiles  \n--nosignature: 不检查来源合法性  \n--nodigest：不检查包完整性  \n--noscripts：不执行程序包脚本   %pre: 安装前脚本；\n--nopre   %post: 安装后脚本；\n--nopost   %preun: 卸载前脚本；\n--nopreun   %postun: 卸载后脚本；  --nopostun\n* rpm包升级\n升级：rpm {-U|--upgrade} [install-options] PACKAGE_FILE...\nrpm {-F|--freshen} [install-options] PACKAGE_FILE...  \nupgrade：安装有旧版程序包，则“升级”\n如果不存在旧版程序包，则“安装”  \nfreshen：安装有旧版程序包，则“升级”\n如果不存在旧版程序包，则不执行升级操作  rpm -Uvh PACKAGE_FILE ...  rpm -Fvh PACKAGE_FILE ...  \n--oldpackage：降级  \n--force: 强制安装\n\n* 升级注意项\n注意：\n(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留\n* 包查询\nrpm {-q|--query} [select-options] [query-options] [select-options]  \n-a: 所有包  \n-f: 查看指定的文件由哪个程序包安装生成  \n-p rpmfile：针对尚未安装的程序包文件做查询操作  \n--whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供  --whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖\nrpm2cpio 包文件|cpio –itv  预览包内文件 rpm2cpio 包文件|cpio –id  “*.conf” 释放包内文件\n\n* 常用查询用法：  -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE  -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, ...  -qa \n包卸载：  rpm {-e|--erase} [--allmatches] [--nodeps] [--noscripts] [--notriggers] [--test] PACKAGE_NAME ...\n\n包校验\nrpm {-V|--verify} [select-options] [verify-options]  S file Size differs  M Mode differs (includes permissions and file type)  5 digest (formerly MD5 sum) differs  D Device major/minor number mismatch  L readLink(2) path mismatch  U User ownership differs  G Group ownership differs  T mTime differs  P capabilities differ\n包校验\n包来源合法性验正及完整性验正  \n完整性验正：SHA256  \n来源合法性验正：RSA 公钥加密  \n对称加密：加密、解密使用同一密钥  \n非对称加密：密钥是成对儿的\npublic key: 公钥，公开所有人\n\n* rpm数据库\n数据库重建：  /var/lib/rpm rpm {--initdb|--rebuilddb}  initdb: 初始化   如果事先不存在数据库，则新建之   否则，不执行任何操作  rebuilddb：重建已安装的包头的数据库索引目录\n\n## yum\n\nCentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具  yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下）  文件服务器: http:// https://   ftp://   file:// \n\n* yum配置文件 \nyum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置  /etc/yum.repos.d/*.repo：为仓库的指向提供配置  \n仓库指向的定义：   [repositoryID]   name=Some name for this repository   baseurl=url://path/to/repository/   enabled={1|0}   gpgcheck={1|0}   gpgkey=URL   enablegroups={1|0}   failovermethod={roundrobin|priority}    roundrobin：意为随机挑选，默认值    priority:按顺序访问   cost=   默认为1000\n* yum仓库\nyum的repo配置文件中可用的变量：  $releasever: 当前OS的发行版的主版本号  $arch: 平台，i386,i486,i586,x86_64等  $basearch：基础平台；i386, x86_64  $YUM0-$YUM9:自定义变量 实例:  http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64  http://server/centos/6/i384 \nyum源\n阿里云repo文件:http://mirrors.aliyun.com/repo/ \nCentOS系统的yum源 阿里云：https://mirrors.aliyun.com/centos/$releasever/os/x86_64/ \nEPEL的yum源:阿里云：https://mirrors.aliyun.com/epel/$releasever/x86_64 \n\n### yum命令\n\nyum命令的用法：  yum [options] [command] [package ...] \n显示仓库列表：  yum repolist [all|enabled|disabled] \n显示程序包：  yum list  yum list [all | glob_exp1] [glob_exp2] [...]  yum list {available|installed|updates} [glob_exp1] [...] 安装程序包：  yum install package1 [package2] [...]  yum reinstall package1 [package2] [...]  (重新安装) \nyum命令 \n升级程序包：  yum update [package1] [package2] [...]  yum downgrade package1 [package2] [...] (降级) \n检查可用升级：  yum check-update \n卸载程序包：  yum remove | erase package1 [package2] [...] \nyum命令 \n查看程序包information：  yum info [...] \n查看指定的特性(可以是某文件)是由哪个程序包所提供：  yum provides | whatprovides feature1 [feature2] [...] \n清理本地缓存：  清除/var/cache/yum/$basearch/$releasever缓存  yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ] \n构建缓存：  yum makecache \nyum命令 \n搜索：yum search string1 [string2] [...]  以指定的关键字搜索程序包名及summary信息 \n查看指定包所依赖的capabilities：  yum deplist package1 [package2] [...] \n查看yum事务历史：  yum history [info|list|packages-list|packages-info|  summary|addon-info|redo|undo|  rollback|new|sync|stats]  yum history  yum history info 6  yum history undo 6  \n日志 ：/var/log/yum.log\n安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] [...](用install替代)  \nyum localupdate rpmfile1 [rpmfile2] [...] (用update替代)\n包组管理的相关命令：  yum groupinstall group1 [group2] [...]   groupupdate group1 [group2] [...]   yum grouplist [hidden] [groupwildcard] [...]   yum groupremove group1 [group2] [...]   yum groupinfo group1 [...] \nyum命令 \nyum的命令行选项：  --nogpgcheck：禁止进行gpg check  -y: 自动回答为“yes”  -q：静默模式  --disablerepo=repoidglob：临时禁用此处指定的repo  --enablerepo=repoidglob：临时启用此处指定的repo  --noplugins：禁用所有插件 \n系统光盘yum仓库\n系统安装光盘作为本地yum仓库：\n(1) 挂载光盘至某目录，例如/mnt/cdrom   mount /dev/cdrom /mnt/cdrom \n(2) 创建配置文件   [CentOS7]   name=   baseurl=   gpgcheck=   enabled= 创建yum仓库：  createrepo [options] <directory>\n\n### 程序包编译\n\n程序包编译安装： Application-VERSION-release.src.rpm --> 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码-->预处理-->编译-->汇编-->链接-->执行 \n源代码组织格式：  多文件：文件中的代码之间，很可能存在跨文件依赖关系  C、C++：make 项目管理器   configure脚本 --> Makefile.in --> Makefile  java: maven\n\n## C语言源代码编译安装三步骤:\n1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make  根据Makefile文件，构建应用程序\n3、make install  复制文件到相应路径\n开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in \n注意：安装前查看INSTALL，README\n\n开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software    Foundation) mariadb.org 代码托管:SourceForge.net  Github.com      code.google.com\nc/c++编译器: gcc (GNU C Complier)\n\n编译C源代码：  准备：提供开发工具及开发环境   开发工具：make, gcc等   开发环境：开发库，头文件    glibc：标准库  实现：通过“包组”提供开发组件   Development Tools   Server Platform Development\n\n第一步：configure脚本 选项：指定安装位置、指定启用的特性 --help: 获取其支持使用的选项  选项分类：安装路径设定:--prefix=/PATH: 指定默认安装位置,默认为/usr/local/--sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译\n\nOptional Features: 可选特性 --disable-FEATURE  --enable-FEATURE[=ARG] Optional Packages: 可选包 --with-PACKAGE[=ARG],依赖包    --without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION\n\n第二步：make 第三步：make install\n\n安装后的配置：\n(1) 二进制程序目录导入至PATH环境变量中   编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH\n(2) 导入帮助手册  编辑/etc/man.config|man_db.conf文件 添加一个MANPATH\n\n# shell编程\n\n## 基础\n\n程序：指令+数据\n程序编程风格：\n        过程式：以指令为中心，数据服务于指令\n        对象式：以数据为中心，指令服务于数据\n        shell程序：提供了编程能力，解释执行\n\n### 编程基本概念\n\n编程逻辑处理方式：\n顺序执行\n循环执行\n选择执行\n\n### shell编程：过程式、解释执行\n\n编程语言的基本结构：\n各种系统命令的组合\n数据存储：变量、数组\n表达式: a + b\n语句:if\nshell脚本基础\nshell脚本:\n包含一些命令或声明，并符合一定格式的文本文件\n格式要求:首行shebang机制\n>#!/bin/bash\n>#!/usr/bin/python\n>#!/usr/bin/perl\nshell脚本的用途有：\n自动化常用命令\n\n执行系统管理和故障排除\n\n创建简单的应用程序\n\n处理文本或文件\n\n### 添加注释\n\n注释以#开头\n第二步：运行脚本\n给予执行权限，在命令行上指定脚本的绝对或相对路径\n直接运行解释器，将脚本作为解释器程序的参数运行\n\n### 脚本规范\n\n脚本代码开头约定\n1、第一行一般为调用使用的语言\n2、程序名，避免更改文件名为无法找到正确的文件\n3、版本号\n4、更改后的时间\n5、作者相关信息\n6、该程序的作用，及注意事项\n7、最后是各版本的更新简要说明\n\n脚本调试\n检测脚本中的语法错误\nbash -n /path/to/some_script\n调试执行\nbash -x /path/to/some_script\n\n## 变量\n\n变量：命名的内存空间\n数据存储方式：\n字符：\n数值：整型，浮点型\n变量：变量类型\n作用：\n1、数据存储格式\n2、参与的运算\n3、表示的数据范围\n类型：\n字符\n数值：整型、浮点型\n变量命名法则：\n1、不能使程序中的保留字：例如 if, for\n2、只能使用数字、字母及下划线，且不能以数字开头\n3、见名知义\n4、统一命名规则：驼峰命名法，建议大写\n\n* bash中变量的种类\n根据变量的生效范围等标准划分下面变量类型：\n        局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，\n包括当前shell的子shell进程均无效\n        环境（全局）变量：生效范围为当前shell进程及其子进程\n        本地变量：生效范围为当前shell进程中某代码片断，通常指函数\n        位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传\n递给它的参数\n        特殊变量：$?, $0, $*, $@, $#,$$\n* 局部变量\n变量赋值：name=‘value’\n可以使用引用value:\n(1) 可以是直接字串; name=“root\"\n(2) 变量引用：name=\"$USER\"\n(3) 命令引用：name=`COMMAND` name=$(COMMAND)\n变量引用：${name} $name\n\"\"：弱引用，其中的变量引用会被替换为变量值\n''：强引用，其中的变量引用不会被替换为变量值，而保持原字符串\n显示已定义的所有变量：set\n删除变量：unset name\n\n* 环境变量\nbash内建的环境变量：\nPATH\nSHELL\nUSER\nUID\nHOME\nPWD\nSHLVL\nLANG\n MAIL\nHOSTNAME\nHISTSIZE\n—\n\n### 只读和位置变量\n\n只读变量：只能声明，但不能修改和删除\n声明只读变量：\n        readonly name\n        declare -r name\n查看只读变量：\n        readonly –p\n位置变量：在脚本代码中调用通过命令行传递给脚本的参数\n$1, $2, ...：对应第1、第2等参数，shift [n]换位置\n$0: 命令本身\n$*: 传递给脚本的所有参数，全部参数合为一个字符串\n$@: 传递给脚本的所有参数，每个参数为独立字符串\n$#: 传递给脚本的参数的个数\n$@ $* 只在被双引号包起来的时候才会有差异\nset -- 清空所有位置变量\n* 退出状态\n进程使用退出状态来报告成功或失败\n• 0 代表成功，1－255代表失败\n• $? 变量保存最近的命令退出状态\n例如：\nping -c1 -W1 hostdown &> /dev/null\necho $?\n退出状态码\nbash自定义退出状态码\nexit [n]：自定义退出状态码\n注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命\n令后面的数字\n注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执\n行的最后一条命令的状态码\n\n## 运算\n\nbash中的算术运算:help let\n+, -, *, /, %取模（取余）, **（乘方）\n实现算术运算：\n(1) let var=算术表达式\n(2) var=$[算术表达式]\n(3) var=$((算术表达式))\n(4) var=$(expr arg1 arg2 arg3 ...)\n(5) declare –i var = 数值\n(6) echo ‘算术表达式’ | bc\n乘法符号有些场景中需要转义，如*\nbash有内建的随机数生成器：RANDOM（0-32767）\necho $[$RANDOM%50] ：0-49之间随机数\n赋值\n* 增强型赋值：\n+=, -=, *=, /=, %=\nlet varOPERvalue\n例如:let count+=3\n自加3后自赋值\n自增，自减：\n        let var+=1\n        let var++\n        let var-=1\n        let var--\n* 逻辑运算\ntrue, false\n1, 0\n        与：\n        1 与 1 = 1\n        1 与 0 = 0\n        0 与 1 = 0\n        0 与 0 = 0\n        或:\n        1 或 1 = 1\n        1 或 0 = 1\n        0 或 1 = 1\n        0 或 0 = 0\n        非：！\n        ! 1 = 0\n        ! 0 = 1\n\n* 短路运算\n\n* 短路与\n第一个为0，结果必定为0\n第一个为1，第二个必须要参与运算\n* 短路或\n第一个为1，结果必定为1\n第一个为0，第二个必须要参与运算\n* 异或：^\n异或的两个值,相同为假，不同为真\n* 条件测试\n判断某需求是否满足，需要由测试机制来实现\n专用的测试表达式需要由测试命令辅助完成测试过程\n评估布尔声明，以便用在条件性执行中\n• 若真，则返回0\n• 若假，则返回1\n* 测试命令：\n• test EXPRESSION\n• [ EXPRESSION ]\n• [[ EXPRESSION ]]\n注意：EXPRESSION前后必须有空白字符\nbash的数值测试\n-v VAR\n变量VAR是否设置\n* 数值测试：\n-gt 是否大于\n-ge 是否大于等于\n-eq 是否等于\n-ne 是否不等于\n-lt 是否小于\n-le 是否小于等于\nbash的字符串测试\n\n* 字符串测试:\n\n>== 是否等于\n> ascii码是否大于ascii码\n< 是否小于\n!= 是否不等于\n=~ 左侧字符串是否能够被右侧的PATTERN所匹配\n注意: 此表达式一般用于[[ ]]中；扩展的正则表达式\n>-z \"STRING“ 字符串是否为空，空为真，不空为假\n>-n \"STRING“ 字符串是否不空，不空为真，空为假\n注意：用于字符串比较时的用到的操作数都应该使用引号\nBash的文件测试\n\n* 存在性测试\n\n-a FILE：同-e\n-e FILE: 文件存在性测试，存在为真，否则为假\n存在性及类别测试\n-b FILE：是否存在且为块设备文件\n-c FILE：是否存在且为字符设备文件\n-d FILE：是否存在且为目录文件\n-f FILE：是否存在且为普通文件\n-h FILE 或 -L FILE：存在且为符号链接文件\n-p FILE：是否存在且为命名管道文件\n-S FILE：是否存在且为套接字文件\nBash的文件权限测试\n\n* 文件权限测试：\n-r FILE：是否存在且可读\n-w FILE: 是否存在且可写\n-x FILE: 是否存在且可执行\n* 文件特殊权限测试：\n-u FILE：是否存在且拥有suid权限\n-g FILE：是否存在且拥有sgid权限\n-k FILE：是否存在且拥有sticky权限\nBash的文件属性测试\n* 文件大小测试：\n-s FILE: 是否存在且非空\n文件是否打开：\n-t fd: fd 文件描述符是否在某终端已经打开\n-N FILE：文件自从上一次被读取之后是否被修改过\n-O FILE：当前有效用户是否为文件属主\n-G FILE：当前有效用户是否为文件属组\nBash的文件属性测试\n* 双目测试：\nFILE1 -ef FILE2: FILE1是否是FILE2的硬链接\nFILE1 -nt FILE2: FILE1是否新于FILE2（mtime）\nFILE1 -ot FILE2: FILE1是否旧于FILE2\n\n使用read命令来接受输入\n使用read来把输入值分配给一个或多个shell变量\n-p 指定要显示的提示\n-s 静默输入，一般用于密码\n-n N 指定输入的字符长度N\n-d ‘字符’ 输入结束符\n-t N TIMEOUT为N秒\nread 从标准输入中读取值，给每个单词分配一个变量\n所有剩余单词都被分配给最后一个变量\nread -p “Enter a filename: “ FILE\n\n## 流程控制\n\n过程式编程语言：\n        顺序执行\n        选择执行\n        循环执行\n条件选择if语句\n\n* 选择执行:\n\n注意：if语句可嵌套\n单分支\n        if 判断条件;then\n        条件为真的分支代码\n        fi\n双分支\n        if 判断条件; then\n        条件为真的分支代码\n        else\n条件为假的分支代码\nfi\n\n* \n多分支\n        if 判断条件1; then\n        条件为真的分支代码\n        elif 判断条件2; then\n        条件为真的分支代码\n        elif 判断条件3; then\n        条件为真的分支代码\n        else\n        以上条件都为假的分支代码\n        fi\n逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句\n\n* 条件判断：case语句\n        case 变量引用 in\n        PAT1)\n        分支1\n        ;;\n        PAT2)\n        分支2\n        ;;\n        ...\n        *)\n        默认分支\n        ;;\n        esac\n\ncase支持glob风格的通配符：\n        *: 任意长度任意字符\n        ?: 任意单个字符\n        []：指定范围内的任意单个字符\n        a|b: a或b\n\n* 循环\n  \n\n循环执行\n将某代码段重复运行多次\n重复运行多少次：\n循环次数事先已知\n循环次数事先未知\n有进入条件和退出条件\nfor, while, until\nfor循环\nfor 变量名 in 列表;do\n循环体\ndone\n执行机制：\n依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直\n到列表中的元素耗尽，循环结束\n\n* for循环\n列表生成方式：\n(1) 直接给出列表\n(2) 整数列表：\n(a) {start..end}\n(b) $(seq [start [step]] end)\n(3) 返回列表的命令\n$(COMMAND)\n(4) 使用glob，如：*.sh\n(5) 变量引用；\n$@, $*\nwhile循环\nwhile CONDITION; do\n循环体\ndone\nCONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后\n会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为\n“false”终止循环\n因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地\n被修正\n进入条件：CONDITION为true\n退出条件：CONDITION为false\nuntil循环\nuntil CONDITION; do\n循环体\ndone\n进入条件： CONDITION 为false\n退出条件： CONDITION 为true\n循环控制语句continue\n用于循环体中\nontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为\n第1层\nwhile CONDTIITON1; do\nCMD1\n...\nif CONDITION2; then\ncontinue\nfi\nCMDn\n...\ndone\n循环控制语句break\n用于循环体中\nbreak [N]：提前结束第N层循环，最内层为第1层\nwhile CONDTIITON1; do\nCMD1\n...\nif CONDITION2; then\nbreak\nfi\nCMDn\n...\ndone\n特殊用法\n双小括号方法，即((…))格式，也可以用于算术运算\n双小括号方法也可以使bash Shell实现C语言风格的变量操作\nI=10\n((I++))\nfor循环的特殊格式：\n for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))\n do\n* 循环体\n done\n控制变量初始化：仅在运行到循环代码段时执行一次\n控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做\n条件判断\n\n## 函数介绍\n\n函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程\n它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运\n行，而是shell程序的一部分\n函数和shell程序比较相似，区别在于：\nShell程序在子Shell中运行\n而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变\n量进行修改\n定义函数\n函数由两部分组成：函数名和函数体\nhelp function\n语法一：\nf_name （）{\n...函数体...\n}\n 语法二：\nfunction f_name {\n...函数体...\n}\n 语法三：\nfunction f_name （） {\n...函数体...\n}\n\n* 函数使用\n函数的定义和使用：\n可在交互式环境下定义函数\n可将函数放在脚本文件中作为它的一部分\n可放在只包含函数的单独文件中\n调用：函数只有被调用才会执行\n调用：给定函数名\n函数名出现的地方，会被自动替换为函数代码\n函数的生命周期：被调用时创建，返回时终止函数返回值\n函数有两种返回值：\n函数的执行结果返回值：\n(1) 使用echo等命令进行输出\n(2) 函数体中调用命令的输出结果\n函数的退出状态码：\n(1) 默认取决于函数中执行的最后一条命令的退出状态码\n(2) 自定义退出状态码，其格式为：\nreturn 从函数中返回，用最后状态命令决定返回值\nreturn 0 无错误返回。\nreturn 1-255 有错误返回\n交互式环境下定义和使用函数\n\n>示例:\n >dir() {\n > ls -l\n > }\n定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同\ndir\n该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令\nunset dir\n在脚本中定义及使用函数\n函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它\n后才能使用\n调用函数仅使用其函数名即可\n>示例：\n>cat func1\n>!/bin/bash\n>func1\n>hello()\n>{\n> echo \"Hello there today's date is `date +%F`\"\n>}\n>echo \"now going to the function hello\"\n>hello\n>echo \"back from the function\"\n使用函数文件\n可以将经常使用的函数存入函数文件，然后将函数文件载入shell\n文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main\n一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set\n命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数\n若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新\n载入此文件\n\n* 创建函数文件\n\n函数文件示例：\n>cat functions.main\n>#!/bin/bash\n>#functions.main\n>findit()\n>{\n> if [ $# -lt 1 ] ; then\n> echo \"Usage:findit file\"\n> return 1\n>fi\n>find / -name $1 –print\n>}\n\n* 载入函数\n函数文件已创建好后，要将它载入shell\n定位函数文件并载入shell的格式：\n. filename 或 source filename\n注意：此即<点> <空格> <文件名>\n这里的文件名要带正确路径\n\n* 检查载入函数\n使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数\n\n>示例：\n>set\n> findit=( )\n> {\n> if [ $# -lt 1 ]; then\n> echo \"usage :findit file\";\n> return 1\n> fi\n> find / -name $1 -print\n> }\n\n* 执行shell函数\n要执行函数，简单地键入函数名即可\n示例：\nfindit groups\n/usr/bin/groups\n/usr/local/backups/groups.bak\n* 删除shell函数\n现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命\n令完成删除函数\n命令格式为：\nunset function_name\n示例：\nunset findit\n再键入set命令，函数将不再显示\n* 函数参数\n函数可以接受参数：\n传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；\n例如“testfunc arg1 arg2 ...”\n在函数体中当中，可使用$1, $2, ...调用这些参数；还可以使用$@, $*, $#\n等特殊变量\n函数变量\n变量作用域：\n环境变量：当前shell和子shell有效\n本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；\n因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数\n局部变量：函数的生命周期；函数结束时变量被自动销毁\n注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量\n在函数中定义局部变量的方法\nlocal NAME=VALUE\n函数递归示例\n* 函数递归：\n函数直接或间接调用自身\n注意递归层数\n递归实例：\n阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语\n一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的\n阶乘为1，自然数n的阶乘写作n!\nn!=1×2×3×...×n\n阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n\nn!=n(n-1)(n-2)...1\nn(n-1)! = n(n-1)(n-2)!\n函数递归示例:\n\n>        示例：fact.sh\n>\n>        fact() {\n>        if [ $1 -eq 0 -o $1 -eq 1 ]; then\n>        echo 1\n>        else\n>        echo $[$1*$(fact $[$1-1])]\n>        fi\n>        }\n>        fact $1\n\n* fork炸弹\n\nfork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是\n一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个\n简单的程序迅速耗尽系统里面的所有资源\n函数实现\n:(){ :|:& };:\nbomb() { bomb | bomb & }; bomb  实际上: 代表bomb\n脚本实现\n>cat Bomb.sh\n>./$0|./$0&\n","slug":"1 (10)","published":1,"date":"2019-04-01T02:01:12.152Z","updated":"2019-06-19T14:44:59.257Z","comments":1,"layout":"post","photos":[],"link":"","_id":"cjx90h8nd002ujkufimpwwvpr","content":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><p>os(operating system),通用目的的软件程序</p>\n<blockquote>\n<p>硬件驱动<br>进程管理<br>内存管理<br>网络管理<br>安全管理<br>文件管理</p>\n</blockquote>\n<h2 id=\"安装linux\"><a href=\"#安装linux\" class=\"headerlink\" title=\"安装linux\"></a>安装linux</h2><blockquote>\n<p>linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的<a href=\"https://www.manjaro.cn/153\" target=\"_blank\" rel=\"noopener\">manjaro</a>或<a href=\"https://www.linuxmint.com/download.php\" target=\"_blank\" rel=\"noopener\">mint</a><br>分区和启动:<br>硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tb<br>uefi的GPT分区:逐渐代替MBR标准<br>主分区 一块硬盘最多4个,不能划分更小,最小单位<br>扩展分区:一块硬盘最多一个,不能直接创建文件系统<br>安装过程大同小异 <a href=\"https://blog.csdn.net/python_lqx/article/details/88670425\" target=\"_blank\" rel=\"noopener\">详细步骤</a><br>需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌.<br>/dev/sda 100g<br>/dev/sda1 /boot mountpoint  1g<br>/dev/sda2 /                50g<br>/dev/sda3 /data            20g<br>/dev/sda5 /swap             2g</p>\n</blockquote>\n<h2 id=\"开发接口标准\"><a href=\"#开发接口标准\" class=\"headerlink\" title=\"开发接口标准\"></a>开发接口标准</h2><blockquote>\n<p>ABI:application binary interface ABI描述了程序与os之间的底层接口<br>API:application programming interface<br>开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit</p>\n</blockquote>\n<h2 id=\"用户和内核空间\"><a href=\"#用户和内核空间\" class=\"headerlink\" title=\"用户和内核空间\"></a>用户和内核空间</h2><blockquote>\n<p>username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响<br>内核空间:kernel space</p>\n</blockquote>\n<h2 id=\"linux哲学思想\"><a href=\"#linux哲学思想\" class=\"headerlink\" title=\"linux哲学思想\"></a>linux哲学思想</h2><p>在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件和目录被组织成单根倒置树结构<br>文件系统从根目录下开始,用”/“表示<br>proc虚拟的,在硬盘上不存在<br>文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)<br>以.开头的文件为隐藏文件<br>元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.<br>数据:data(内容在硬盘上)<br>文件系统分成结构:LSB<br>文件名最长255个字节,文件系统不一样大小不一样<br>包括路径在内文件名称最长4095个字节<br>蓝色—目录 绿色—可执行文件  红色—压缩文件<br>浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递<br>管道文件 p开头(pipe)单工传输</p>\n<h2 id=\"文件系统结构元素\"><a href=\"#文件系统结构元素\" class=\"headerlink\" title=\"文件系统结构元素\"></a>文件系统结构元素</h2><p>/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录<br>/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序<br>/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序<br>/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)<br>/lib64：专用于x86_64系统上的辅助共享库文件存放位置<br>/etc：配置文件目录<br>/home/USERNAME：普通用户家目录<br>/root：管理员的家目录<br>/media：便携式移动设备挂载点<br>/mnt：临时文件系统挂载点<br>/dev：设备文件及特殊文件存储位置  b: block device，随机访问  c: character device，线性访问<br>/opt：第三方应用程序的安装位置<br>/srv：系统上运行的服务用到的数据<br>/tmp：临时文件存储位置<br>/proc: 用于输出内核与进程信息相关的虚拟文件系统<br>/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统<br>/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文<br>/usr: universal shared, read-only data  bin: 保证系统拥有完整功能而提供的应用程序<br>sbin:  lib：32位使用  lib64：只存在64位系统<br>include: C程序的头文件(header files)<br>share：结构化独立的数据，例如doc, man等<br>local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文</p>\n<p>/var: variable data files  cache: 应用程序缓存数据目录<br>lib: 应用程序状态信息数据<br>local：专用于为/usr/local下的应用程序存储可变数据<br>lock: 锁文件  log: 日志目录及文件<br>opt: 专用于为/opt下的应用程序存储可变数据<br>run: 运行中的进程相关数据,通常用于存储进程pid文件<br>spool: 应用程序数据池<br>tmp: 保存系统两次重启之间产生的临时数据</p>\n<h2 id=\"Linux下的文件类型\"><a href=\"#Linux下的文件类型\" class=\"headerlink\" title=\"Linux下的文件类型\"></a>Linux下的文件类型</h2><p>-：普通文件<br>d: 目录文件<br>b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)<br>c: 字符设备(设备主要以字符为单位,键盘为主)<br>l: 符号链接文件<br>p: 管道文件pipe<br>s: 套接字文件socket</p>\n<h3 id=\"显示当前工作目录\"><a href=\"#显示当前工作目录\" class=\"headerlink\" title=\"显示当前工作目录\"></a>显示当前工作目录</h3><p>每个shell和系统进程都有一个当前的工作目录<br>CWD:current work directory<br>显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认）</p>\n<h3 id=\"更改目录\"><a href=\"#更改目录\" class=\"headerlink\" title=\"更改目录\"></a>更改目录</h3><p>cd  改变目录 使用绝对或相对路径： cd /home/wang/        cd home/wang 切换至父目录：  cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -<br>选项：-P<br>相关的环境变量：  PWD：当前目录路径   OLDPWD：上一次目录路径</p>\n<h3 id=\"列出目录内容\"><a href=\"#列出目录内容\" class=\"headerlink\" title=\"列出目录内容\"></a>列出目录内容</h3><p>列出当前目录的内容或指定目录<br>用法：ls [options] [ files_or_dirs ]<br>示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R  目录递归通过 ls -ld  目录和符号链接信息 ls -1  文件分行显示 ls –S  按从大到小排序 ls –t   按mtime排序 ls –u   配合-t选项，显示并按atime从新到旧排序<br>ls –U  按目录存放顺序显示 ls –X  按文件后缀排序</p>\n<blockquote>\n<p>[root@centos7 sysconfig]# ll /etc/motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd<br>[root@centos7 sysconfig]# ll ../motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd<br>-a 全部<br>-r 递归<br>ll 是别名 (ls -l)</p>\n</blockquote>\n<h3 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h3><p>stat<br>文件：metadata, data<br>三个时间戳: access time：访问时间，atime，读取文件内容<br>modify time: 修改时间,<br>mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变<br>data 时间不会一直更新<br>通配符* 任意字符<br>二进制查看hexdump -C</p>\n<h3 id=\"创建和查看文件\"><a href=\"#创建和查看文件\" class=\"headerlink\" title=\"创建和查看文件\"></a>创建和查看文件</h3><p>touch 命令是个外部命令<br>[]表示其中一个字母<br>[^  ]表示除去其中字符的任意字符<br>两个大于号比 touch安全</p>\n<h3 id=\"文件统配符\"><a href=\"#文件统配符\" class=\"headerlink\" title=\"文件统配符\"></a>文件统配符</h3><p>man 7 glob</p>\n<h3 id=\"复制和转移删除文件\"><a href=\"#复制和转移删除文件\" class=\"headerlink\" title=\"复制和转移删除文件\"></a>复制和转移删除文件</h3><p>cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失<br>原始命令前加\\<br>拷贝文件夹 -r(递归)<br>cp 有可能丢失数据不能用rmdir删除</p>\n<p>data是个挂载点<br>cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中      如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中  基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中<br>cp SRC… DEST    SRC…：多个文件<br>DEST必须存在，且为目录，其它情形均会出错；cp SRC DEST<br>SRC是目录：此时使用选项：-r<br>如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；<br>如果DEST存在：<br>如果DEST是文件：报错<br>如果DEST是目录：<br>inode（index node）表中包含文件系统所有文件列表<br>一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括：  文件类型，权限，UID，GID  链接数（指向这个文件名路径名称个数）  该文件的大小和不同的时间戳  指向磁盘上文件的数据块指针  有关文件的其他数据 </p>\n<p>inode 唯一标识在元数据里<br>删除其实删的元数据.删文件比建文件快多了</p>\n<h3 id=\"软和硬链接\"><a href=\"#软和硬链接\" class=\"headerlink\" title=\"软和硬链接\"></a>软和硬链接</h3><p>硬链接<br>创建硬链接会增加额外的记录项以引用文件<br>对应于同一文件系统上一个物理文件<br>每个目录引用相同的inode号<br>创建时链接数递增<br>删除文件时：<br>rm命令递减计数的链接<br>文件要存在，至少有一个链接数<br>当链接数为零时，该文件被删除<br>不能跨越驱动器或分区<br>语法:  ln filename  [linkname ]<br>软连接<br>一个符号文件链接指向一个文件<br>ls -s显示链接的名称和应用的文件<br>一个符号链接的内容是他引用文件的名称<br>可以对目录进行<br>可以跨分区<br>指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数<br>语法:ln -s 文件 链接名</p>\n<h2 id=\"i-0-重定向至文件\"><a href=\"#i-0-重定向至文件\" class=\"headerlink\" title=\"i/0 重定向至文件\"></a>i/0 重定向至文件</h2><p>程序:指令+数据<br>input 和output<br>打开的文件都有一个fd:file descrptor(文件描述符)<br>linux 给程序提供三种i/o设备<br>标准输入(STDIN)-0 默认接受来自键盘的输入<br>标准输出(STDOUT) -1默认输出到终端窗口<br>标准错误(STDERR) -2 默认输出到窗口<br>i/o重定向:改变默认位置<br>语法:命令  操作符号 文件名<br>操作符&gt;把STDOUT重定向到文件<br>2&gt; 把STDERR重定向到文件<br>$&gt; 把所有输出重定向到文件<br>tr 转换和删除字符</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>管道用来连接命令<br>命令1|命令2|命令3<br>将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDIN<br>less 一页一页地查看输入<br>重定向到多个目标(tee)<br>把命令1的STDOUT保存在文件中,作为命令2的输入<br>-a追加<br>使用:<br>保存不同阶段的输入<br>复杂管道的故障排除<br>同时查看和记录输出</p>\n<h1 id=\"用户组权限\"><a href=\"#用户组权限\" class=\"headerlink\" title=\"用户组权限\"></a>用户组权限</h1><h2 id=\"用户user\"><a href=\"#用户user\" class=\"headerlink\" title=\"用户user\"></a>用户user</h2><p>令牌token,identity<br>linux用户:username/UID<br>管理员:root,0<br>普通用户:1-65535<br>系统用户:1-499,1-999<br>对守护进程获取资源进行权限进行分配<br>登录用户:500+,1000<br>交互式登录<br>nologin 是软件启动没有用户登录</p>\n<h2 id=\"组group\"><a href=\"#组group\" class=\"headerlink\" title=\"组group\"></a>组group</h2><p>linux:Groupname/GID<br>管理员:<br>系统 :1-499,1-999<br>普通组:500+,1000+<br>安全上下文:<br>进行中的程序:程序(process)<br>以进程发起者的身份运行:<br>root:/bin/cat<br>mage:/bin/cat<br>组的类别<br>用户的主要组:<br>用户必须属于一个且只有一个主组<br>组名同用户名,且包含一个用户,私有组<br>用户和组的配置文件<br>/etc/passwd:用户及其属性信息<br>/etc/group:组及其属性信息<br>/etc/shadow:用户密码及其相关属性<br>/etc/gshadow:组密码及其相关属性<br>passwd文件格式<br>login name:登录用名<br>passwd:密码<br>UID:用户身份编号<br>GID:登录默认所在组编号<br>GECOS:用户全名或注释<br>home diretory:用户主目录<br>shell:用户默认使用shell<br>shadow文件格式<br>useradd usermod userdel<br>组账号维护命令:groupadd<br>groupmod groupdel</p>\n<h2 id=\"用户创建-useradd\"><a href=\"#用户创建-useradd\" class=\"headerlink\" title=\"用户创建:useradd\"></a>用户创建:useradd</h2><p>useradd [options]LOGIN<br>-u UID<br>-o 配合-u选项,不检查UID的唯一性<br>-g GID:指明用户所属基本组,可谓组名,也可以GID<br>-c “COMMENT”:用户的注释信息<br>默认设置:/etc/default/useradd文件中<br>删除用户:userdel -r删除用户目录</p>\n<h2 id=\"查看用户相关的ID信息\"><a href=\"#查看用户相关的ID信息\" class=\"headerlink\" title=\"查看用户相关的ID信息\"></a>查看用户相关的ID信息</h2><p>id [OPTIONS]…[USER]<br>-u :显示UID<br>-g :显示GID<br>-G :显示用户所属的组的ID<br>-n :显示名称,需配合ugG使用</p>\n<h2 id=\"切换用户或以其他用户身份执行命令\"><a href=\"#切换用户或以其他用户身份执行命令\" class=\"headerlink\" title=\"切换用户或以其他用户身份执行命令\"></a>切换用户或以其他用户身份执行命令</h2><p>su[options] [-] [user[args…]]<br>切换用户的方式<br>ssh root@ip<br>curl ww<br>service network restat</p>\n<h2 id=\"设置密码\"><a href=\"#设置密码\" class=\"headerlink\" title=\"设置密码\"></a>设置密码</h2><p>passwd<br>常用选项：<br> -d:删除指定用户密码<br> -l:锁定指定用户<br> -u:解锁指定用户<br> -e:强制用户下次登录修改密码<br> -f: 强制操作<br> -n mindays: 指定最短使用期限<br> -x maxdays：最大使用期限<br> -w warndays：提前多少天开始警告<br> -i inactivedays：非活动期限<br> –stdin：从标准输入接收用户密码<br> echo “PASSWORD” | passwd –stdin USERNAME</p>\n<h2 id=\"创建组\"><a href=\"#创建组\" class=\"headerlink\" title=\"创建组\"></a>创建组</h2><p>groupadd[option]…group_name<br>-g GID:指明GID号:<br>-r:创建系统组<br>修改和删除组:<br>组属性修改:groupmod<br>组删除:groupdel<br>组密码:gpasswd<br>newgrp命令:临时切换主组<br>chown设置文件的所有者<br>chgrp设置文件的属组信息<br>修改文件的属主和属组chown<br>修改文件的属组:chgrp</p>\n<h2 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h2><p>文件的权限主要针对三类对象进行定义<br>owner: 属主, u<br>group: 属组, g<br>other: 其他, o<br>每个文件针对每类访问者都定义了三种权限<br>r: Readable<br>w: Writable<br>x: eXcutable</p>\n<h3 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h3><p>chmod [OPTION]… OCTAL-MODE FILE…<br> -R: 递归修改权限<br>chmod [OPTION]… MODE[,MODE]… FILE…<br> MODE：<br> 修改一类用户的所有权限：<br> u= g= o= ug= a= u=,g=<br> 修改一类用户某位或某些位权限<br> u+ u- g+ g- o+ o- a+ a- + -<br>chmod [OPTION]… –reference=RFILE FILE…<br>参考RFILE文件的权限，将FILE的修改为同RFILE<br>数字权限法:chmod数字 file<br>rwx r-x r– file<br>其中：</p>\n<p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>\n<ul>\n<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li>\n</ul>\n<p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本</p>\n<h1 id=\"文本工具\"><a href=\"#文本工具\" class=\"headerlink\" title=\"文本工具\"></a>文本工具</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>文件内容:less和cat<br>文件截取:head和tail<br>按列抽取:cut<br>按关键字抽取:grep<br>文件查看:cat tac rev<br>分页查看:more<br>一页一页的查看:less<br>less 命令是man命令使用的分页器</p>\n<h3 id=\"显示文本前后或后行内容\"><a href=\"#显示文本前后或后行内容\" class=\"headerlink\" title=\"显示文本前后或后行内容\"></a>显示文本前后或后行内容</h3><p>head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行<br>tail[option]…[FILE]看文本尾<br>tail-f 跟踪看日志<br>cut命令取字段<br>past 横着合并文件<br>wc 收集文本</p>\n<h3 id=\"文本排序sort\"><a href=\"#文本排序sort\" class=\"headerlink\" title=\"文本排序sort\"></a>文本排序sort</h3><p>把整理过的文本显示在STDOUT,不改变原始文件<br>sort[opiton]file(s)<br>uniq:从输入中删除前后相接的重复的行,处理日志<br>liunx:文本处理三剑客<br>grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红<br>sed:stream editor, 文本编辑工具<br>awk:liunx上的实现gawk,文本报告生成器<br>grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数<br>位置锚定:定位<br>正则字符特殊 元字符<br>.单个任意字符<br>[abc]表示其中一个字符<br>[^abc]除去abc任意字母<br>[:lower:]小写<br>[:upper:]大写<br>分组方式<br>abc{3}\\<br>搜索替代工具<br>grep过滤特定行,sed也可以并且编辑修改文件</p>\n<h2 id=\"vim编辑器\"><a href=\"#vim编辑器\" class=\"headerlink\" title=\"vim编辑器\"></a>vim编辑器</h2><p>vi:visual interface 文本编辑器<br>文本:asscii ,unicode<br>文本编辑种类:<br>行编辑器:sed<br>全屏编辑器:nano,vi<br>vim -viimproved<br>其他编辑器<br>gedit 一个简单的图形编辑器<br>gvim 一个vim编辑器的图形版本<br>vi一开始是vim的别名<br>vim有三种模式:normal(普通) insert(插入) extendcommand(命令)<br>normal :默认模式,移动光标,剪切/粘贴文本<br>insert :修改文本<br>extend command:保存,退出</p>\n<h3 id=\"搜索替代\"><a href=\"#搜索替代\" class=\"headerlink\" title=\"搜索替代\"></a>搜索替代</h3><p>/ :从当前光标所在处向文件尾部查找<br>? :从当前光标所在处向文件首部查找<br>n :与命令同方向<br>N :与命令反方向<br>处理文本的工具sed<br>stream editor 行编辑器<br>sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.<br>vim不适合修改大批量文件,sed可以<br>sed 配合管道可以使用<br>awk 语言<br>sed ‘’ passwd<br>‘地址命令’地址不写代表全部文件 命令不写代表输出</p>\n<h1 id=\"软件管理\"><a href=\"#软件管理\" class=\"headerlink\" title=\"软件管理\"></a>软件管理</h1><h2 id=\"包管理器\"><a href=\"#包管理器\" class=\"headerlink\" title=\"包管理器\"></a>包管理器</h2><p>rpm 打包文件 不需要考虑部署 安装路径都定义好<br>二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件<br>程序包管理器：<br>debian：deb文件, dpkg包管理器<br>redhat: rpm文件, rpm包管理器<br>rpm: Redhat Package Manager   RPM  Package Manager<br>源代码：name-VERSION.tar.gz|bz2|xz  VERSION: major.minor.release<br>rpm包命名方式:name-VERSION-release.arch.rpm<br>例：bash-4.2.46-19.el7.x86_64.rpm  VERSION: major.minor.release  release：release.OS<br>常见的arch：  x86: i386, i486, i586, i686  x86_64: x64, x86_64, amd64  powerpc: ppc  跟平台无关：noarch</p>\n<p>包：分类和拆包<br>Application-VERSION-ARCH.rpm: 主包<br>Application-devel-VERSION-ARCH.rpm 开发子包  Application-utils-VERSION-ARHC.rpm 其它子包  Application-libs-VERSION-ARHC.rpm 其它子包<br>包之间：可能存在依赖关系，甚至循环依赖<br>解决依赖包管理<br>工具:yum：rpm包管理器的前端工具  apt-get：deb包管理器前端工具  zypper: suse上的rpm前端管理工具  dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具</p>\n<p>查看二进制程序所依赖的库文件  ldd /PATH/TO/BINARY_FILE<br>管理及查看本机装载的库文件  ldconfig 加载库文件  /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系  配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf  缓存文件：/etc/ld.so.cache</p>\n<h3 id=\"程序包管理器\"><a href=\"#程序包管理器\" class=\"headerlink\" title=\"程序包管理器\"></a>程序包管理器</h3><p>功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.<br>包文件组成 (每个包独有)<br>RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.<br>安装或卸载时运行的脚本<br>数据库(公共)：/var/lib/rpm 程序包名称及版本  依赖关系  功能说明  包安装后生成的各文件路径及校验码信息<br>管理程序包的方式:使用包管理器：rpm  使用前端工具：yum, dnf<br>获取程序包的途径：<br>(1) 系统发版的光盘或官方的服务器;CentOS镜像:<a href=\"https://www.centos.org/download/\" target=\"_blank\" rel=\"noopener\">https://www.centos.org/download/</a>   <a href=\"http://mirrors.aliyun.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com</a>   <a href=\"http://mirrors.sohu.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.sohu.com</a>   <a href=\"http://mirrors.163.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com</a><br>(2) 项目官方站点程序包的来源<br>(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux  Rpmforge:RHEL推荐，包很全 搜索引擎:<a href=\"http://pkgs.org\" target=\"_blank\" rel=\"noopener\">http://pkgs.org</a> <a href=\"http://rpmfind.net\" target=\"_blank\" rel=\"noopener\">http://rpmfind.net</a>   <a href=\"http://rpm.pbone.net\" target=\"_blank\" rel=\"noopener\">http://rpm.pbone.net</a> <a href=\"https://sourceforge.net/\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/</a><br>(4) 自己制作 注意：第三方包建议要检查其合法性  来源合法性,程序包的完整性</p>\n<ul>\n<li><p>rpm包管理<br>CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护  安装：<br>rpm {-i|–install} [install-options] PACKAGE_FILE…<br> -v: verbose<br> -h: 以#显示程序包管理执行进度  rpm -ivh PACKAGE_FILE …</p>\n</li>\n<li><p>rpm包安装<br>[install-options]<br>–test: 测试安装，但不真正执行安装，即dry run模式<br>–nodeps：忽略依赖关系<br>–replacepkgs | replacefiles<br>–nosignature: 不检查来源合法性<br>–nodigest：不检查包完整性<br>–noscripts：不执行程序包脚本   %pre: 安装前脚本；<br>–nopre   %post: 安装后脚本；<br>–nopost   %preun: 卸载前脚本；<br>–nopreun   %postun: 卸载后脚本；  –nopostun</p>\n</li>\n<li><p>rpm包升级<br>升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…<br>rpm {-F|–freshen} [install-options] PACKAGE_FILE…<br>upgrade：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则“安装”<br>freshen：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则不执行升级操作  rpm -Uvh PACKAGE_FILE …  rpm -Fvh PACKAGE_FILE …<br>–oldpackage：降级<br>–force: 强制安装</p>\n</li>\n<li><p>升级注意项<br>注意：<br>(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留</p>\n</li>\n<li><p>包查询<br>rpm {-q|–query} [select-options] [query-options] [select-options]<br>-a: 所有包<br>-f: 查看指定的文件由哪个程序包安装生成<br>-p rpmfile：针对尚未安装的程序包文件做查询操作<br>–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供  –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖<br>rpm2cpio 包文件|cpio –itv  预览包内文件 rpm2cpio 包文件|cpio –id  “*.conf” 释放包内文件</p>\n</li>\n<li><p>常用查询用法：  -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE  -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, …  -qa<br>包卸载：  rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME …</p>\n</li>\n</ul>\n<p>包校验<br>rpm {-V|–verify} [select-options] [verify-options]  S file Size differs  M Mode differs (includes permissions and file type)  5 digest (formerly MD5 sum) differs  D Device major/minor number mismatch  L readLink(2) path mismatch  U User ownership differs  G Group ownership differs  T mTime differs  P capabilities differ<br>包校验<br>包来源合法性验正及完整性验正<br>完整性验正：SHA256<br>来源合法性验正：RSA 公钥加密<br>对称加密：加密、解密使用同一密钥<br>非对称加密：密钥是成对儿的<br>public key: 公钥，公开所有人</p>\n<ul>\n<li>rpm数据库<br>数据库重建：  /var/lib/rpm rpm {–initdb|–rebuilddb}  initdb: 初始化   如果事先不存在数据库，则新建之   否则，不执行任何操作  rebuilddb：重建已安装的包头的数据库索引目录</li>\n</ul>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>CentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具  yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下）  文件服务器: http:// https://   ftp://   file:// </p>\n<ul>\n<li>yum配置文件<br>yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置  /etc/yum.repos.d/*.repo：为仓库的指向提供配置<br>仓库指向的定义：   [repositoryID]   name=Some name for this repository   baseurl=url://path/to/repository/   enabled={1|0}   gpgcheck={1|0}   gpgkey=URL   enablegroups={1|0}   failovermethod={roundrobin|priority}    roundrobin：意为随机挑选，默认值    priority:按顺序访问   cost=   默认为1000</li>\n<li>yum仓库<br>yum的repo配置文件中可用的变量：  $releasever: 当前OS的发行版的主版本号  $arch: 平台，i386,i486,i586,x86_64等  $basearch：基础平台；i386, x86_64  $YUM0-$YUM9:自定义变量 实例:  <a href=\"http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64\" target=\"_blank\" rel=\"noopener\">http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64</a>  <a href=\"http://server/centos/6/i384\" target=\"_blank\" rel=\"noopener\">http://server/centos/6/i384</a><br>yum源<br>阿里云repo文件:<a href=\"http://mirrors.aliyun.com/repo/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/repo/</a><br>CentOS系统的yum源 阿里云：<a href=\"https://mirrors.aliyun.com/centos/$releasever/os/x86_64/\" target=\"_blank\" rel=\"noopener\">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a><br>EPEL的yum源:阿里云：<a href=\"https://mirrors.aliyun.com/epel/$releasever/x86_64\" target=\"_blank\" rel=\"noopener\">https://mirrors.aliyun.com/epel/$releasever/x86_64</a> </li>\n</ul>\n<h3 id=\"yum命令\"><a href=\"#yum命令\" class=\"headerlink\" title=\"yum命令\"></a>yum命令</h3><p>yum命令的用法：  yum [options] [command] [package …]<br>显示仓库列表：  yum repolist [all|enabled|disabled]<br>显示程序包：  yum list  yum list [all | glob_exp1] [glob_exp2] […]  yum list {available|installed|updates} [glob_exp1] […] 安装程序包：  yum install package1 [package2] […]  yum reinstall package1 [package2] […]  (重新安装)<br>yum命令<br>升级程序包：  yum update [package1] [package2] […]  yum downgrade package1 [package2] […] (降级)<br>检查可用升级：  yum check-update<br>卸载程序包：  yum remove | erase package1 [package2] […]<br>yum命令<br>查看程序包information：  yum info […]<br>查看指定的特性(可以是某文件)是由哪个程序包所提供：  yum provides | whatprovides feature1 [feature2] […]<br>清理本地缓存：  清除/var/cache/yum/$basearch/$releasever缓存  yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]<br>构建缓存：  yum makecache<br>yum命令<br>搜索：yum search string1 [string2] […]  以指定的关键字搜索程序包名及summary信息<br>查看指定包所依赖的capabilities：  yum deplist package1 [package2] […]<br>查看yum事务历史：  yum history [info|list|packages-list|packages-info|  summary|addon-info|redo|undo|  rollback|new|sync|stats]  yum history  yum history info 6  yum history undo 6<br>日志 ：/var/log/yum.log<br>安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] <a href=\"用install替代\">…</a><br>yum localupdate rpmfile1 [rpmfile2] […] (用update替代)<br>包组管理的相关命令：  yum groupinstall group1 [group2] […]   groupupdate group1 [group2] […]   yum grouplist [hidden] [groupwildcard] […]   yum groupremove group1 [group2] […]   yum groupinfo group1 […]<br>yum命令<br>yum的命令行选项：  –nogpgcheck：禁止进行gpg check  -y: 自动回答为“yes”  -q：静默模式  –disablerepo=repoidglob：临时禁用此处指定的repo  –enablerepo=repoidglob：临时启用此处指定的repo  –noplugins：禁用所有插件<br>系统光盘yum仓库<br>系统安装光盘作为本地yum仓库：<br>(1) 挂载光盘至某目录，例如/mnt/cdrom   mount /dev/cdrom /mnt/cdrom<br>(2) 创建配置文件   [CentOS7]   name=   baseurl=   gpgcheck=   enabled= 创建yum仓库：  createrepo [options] <directory></directory></p>\n<h3 id=\"程序包编译\"><a href=\"#程序包编译\" class=\"headerlink\" title=\"程序包编译\"></a>程序包编译</h3><p>程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行<br>源代码组织格式：  多文件：文件中的代码之间，很可能存在跨文件依赖关系  C、C++：make 项目管理器   configure脚本 –&gt; Makefile.in –&gt; Makefile  java: maven</p>\n<h2 id=\"C语言源代码编译安装三步骤\"><a href=\"#C语言源代码编译安装三步骤\" class=\"headerlink\" title=\"C语言源代码编译安装三步骤:\"></a>C语言源代码编译安装三步骤:</h2><p>1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make  根据Makefile文件，构建应用程序<br>3、make install  复制文件到相应路径<br>开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in<br>注意：安装前查看INSTALL，README</p>\n<p>开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software    Foundation) mariadb.org 代码托管:SourceForge.net  Github.com      code.google.com<br>c/c++编译器: gcc (GNU C Complier)</p>\n<p>编译C源代码：  准备：提供开发工具及开发环境   开发工具：make, gcc等   开发环境：开发库，头文件    glibc：标准库  实现：通过“包组”提供开发组件   Development Tools   Server Platform Development</p>\n<p>第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项  选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译</p>\n<p>Optional Features: 可选特性 –disable-FEATURE  –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包    –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION</p>\n<p>第二步：make 第三步：make install</p>\n<p>安装后的配置：<br>(1) 二进制程序目录导入至PATH环境变量中   编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH<br>(2) 导入帮助手册  编辑/etc/man.config|man_db.conf文件 添加一个MANPATH</p>\n<h1 id=\"shell编程\"><a href=\"#shell编程\" class=\"headerlink\" title=\"shell编程\"></a>shell编程</h1><h2 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>程序：指令+数据<br>程序编程风格：<br>        过程式：以指令为中心，数据服务于指令<br>        对象式：以数据为中心，指令服务于数据<br>        shell程序：提供了编程能力，解释执行</p>\n<h3 id=\"编程基本概念\"><a href=\"#编程基本概念\" class=\"headerlink\" title=\"编程基本概念\"></a>编程基本概念</h3><p>编程逻辑处理方式：<br>顺序执行<br>循环执行<br>选择执行</p>\n<h3 id=\"shell编程：过程式、解释执行\"><a href=\"#shell编程：过程式、解释执行\" class=\"headerlink\" title=\"shell编程：过程式、解释执行\"></a>shell编程：过程式、解释执行</h3><p>编程语言的基本结构：<br>各种系统命令的组合<br>数据存储：变量、数组<br>表达式: a + b<br>语句:if<br>shell脚本基础<br>shell脚本:<br>包含一些命令或声明，并符合一定格式的文本文件<br>格式要求:首行shebang机制</p>\n<blockquote>\n<p>#!/bin/bash</p>\n<p>#!/usr/bin/python</p>\n<p>#!/usr/bin/perl<br>shell脚本的用途有：<br>自动化常用命令</p>\n</blockquote>\n<p>执行系统管理和故障排除</p>\n<p>创建简单的应用程序</p>\n<p>处理文本或文件</p>\n<h3 id=\"添加注释\"><a href=\"#添加注释\" class=\"headerlink\" title=\"添加注释\"></a>添加注释</h3><p>注释以#开头<br>第二步：运行脚本<br>给予执行权限，在命令行上指定脚本的绝对或相对路径<br>直接运行解释器，将脚本作为解释器程序的参数运行</p>\n<h3 id=\"脚本规范\"><a href=\"#脚本规范\" class=\"headerlink\" title=\"脚本规范\"></a>脚本规范</h3><p>脚本代码开头约定<br>1、第一行一般为调用使用的语言<br>2、程序名，避免更改文件名为无法找到正确的文件<br>3、版本号<br>4、更改后的时间<br>5、作者相关信息<br>6、该程序的作用，及注意事项<br>7、最后是各版本的更新简要说明</p>\n<p>脚本调试<br>检测脚本中的语法错误<br>bash -n /path/to/some_script<br>调试执行<br>bash -x /path/to/some_script</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量：命名的内存空间<br>数据存储方式：<br>字符：<br>数值：整型，浮点型<br>变量：变量类型<br>作用：<br>1、数据存储格式<br>2、参与的运算<br>3、表示的数据范围<br>类型：<br>字符<br>数值：整型、浮点型<br>变量命名法则：<br>1、不能使程序中的保留字：例如 if, for<br>2、只能使用数字、字母及下划线，且不能以数字开头<br>3、见名知义<br>4、统一命名规则：驼峰命名法，建议大写</p>\n<ul>\n<li>bash中变量的种类<br>根据变量的生效范围等标准划分下面变量类型：<pre><code>局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，\n</code></pre>包括当前shell的子shell进程均无效<pre><code>环境（全局）变量：生效范围为当前shell进程及其子进程\n本地变量：生效范围为当前shell进程中某代码片断，通常指函数\n位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传\n</code></pre>递给它的参数<pre><code>特殊变量：$?, $0, $*, $@, $#,$$\n</code></pre></li>\n<li><p>局部变量<br>变量赋值：name=‘value’<br>可以使用引用value:<br>(1) 可以是直接字串; name=“root”<br>(2) 变量引用：name=”$USER”<br>(3) 命令引用：name=<code>COMMAND</code> name=$(COMMAND)<br>变量引用：${name} $name<br>“”：弱引用，其中的变量引用会被替换为变量值<br>‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br>显示已定义的所有变量：set<br>删除变量：unset name</p>\n</li>\n<li><p>环境变量<br>bash内建的环境变量：<br>PATH<br>SHELL<br>USER<br>UID<br>HOME<br>PWD<br>SHLVL<br>LANG<br>MAIL<br>HOSTNAME<br>HISTSIZE<br>—</p>\n</li>\n</ul>\n<h3 id=\"只读和位置变量\"><a href=\"#只读和位置变量\" class=\"headerlink\" title=\"只读和位置变量\"></a>只读和位置变量</h3><p>只读变量：只能声明，但不能修改和删除<br>声明只读变量：<br>        readonly name<br>        declare -r name<br>查看只读变量：<br>        readonly –p<br>位置变量：在脚本代码中调用通过命令行传递给脚本的参数<br>$1, $2, …：对应第1、第2等参数，shift [n]换位置<br>$0: 命令本身<br>$<em>: 传递给脚本的所有参数，全部参数合为一个字符串<br>$@: 传递给脚本的所有参数，每个参数为独立字符串<br>$#: 传递给脚本的参数的个数<br>$@ $</em> 只在被双引号包起来的时候才会有差异<br>set – 清空所有位置变量</p>\n<ul>\n<li>退出状态<br>进程使用退出状态来报告成功或失败<br>• 0 代表成功，1－255代表失败<br>• $? 变量保存最近的命令退出状态<br>例如：<br>ping -c1 -W1 hostdown &amp;&gt; /dev/null<br>echo $?<br>退出状态码<br>bash自定义退出状态码<br>exit [n]：自定义退出状态码<br>注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命<br>令后面的数字<br>注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执<br>行的最后一条命令的状态码</li>\n</ul>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>bash中的算术运算:help let<br>+, -, <em>, /, %取模（取余）, **（乘方）<br>实现算术运算：<br>(1) let var=算术表达式<br>(2) var=$[算术表达式]<br>(3) var=$((算术表达式))<br>(4) var=$(expr arg1 arg2 arg3 …)<br>(5) declare –i var = 数值<br>(6) echo ‘算术表达式’ | bc<br>乘法符号有些场景中需要转义，如</em><br>bash有内建的随机数生成器：RANDOM（0-32767）<br>echo $[$RANDOM%50] ：0-49之间随机数<br>赋值</p>\n<ul>\n<li>增强型赋值：<br>+=, -=, *=, /=, %=<br>let varOPERvalue<br>例如:let count+=3<br>自加3后自赋值<br>自增，自减：<pre><code>let var+=1\nlet var++\nlet var-=1\nlet var--\n</code></pre></li>\n<li><p>逻辑运算<br>true, false<br>1, 0</p>\n<pre><code>与：\n1 与 1 = 1\n1 与 0 = 0\n0 与 1 = 0\n0 与 0 = 0\n或:\n1 或 1 = 1\n1 或 0 = 1\n0 或 1 = 1\n0 或 0 = 0\n非：！\n! 1 = 0\n! 0 = 1\n</code></pre></li>\n<li><p>短路运算</p>\n</li>\n<li><p>短路与<br>第一个为0，结果必定为0<br>第一个为1，第二个必须要参与运算</p>\n</li>\n<li>短路或<br>第一个为1，结果必定为1<br>第一个为0，第二个必须要参与运算</li>\n<li>异或：^<br>异或的两个值,相同为假，不同为真</li>\n<li>条件测试<br>判断某需求是否满足，需要由测试机制来实现<br>专用的测试表达式需要由测试命令辅助完成测试过程<br>评估布尔声明，以便用在条件性执行中<br>• 若真，则返回0<br>• 若假，则返回1</li>\n<li>测试命令：<br>• test EXPRESSION<br>• [ EXPRESSION ]<br>• [[ EXPRESSION ]]<br>注意：EXPRESSION前后必须有空白字符<br>bash的数值测试<br>-v VAR<br>变量VAR是否设置</li>\n<li><p>数值测试：<br>-gt 是否大于<br>-ge 是否大于等于<br>-eq 是否等于<br>-ne 是否不等于<br>-lt 是否小于<br>-le 是否小于等于<br>bash的字符串测试</p>\n</li>\n<li><p>字符串测试:</p>\n</li>\n</ul>\n<blockquote>\n<p>== 是否等于<br>ascii码是否大于ascii码<br>&lt; 是否小于<br>!= 是否不等于<br>=~ 左侧字符串是否能够被右侧的PATTERN所匹配<br>注意: 此表达式一般用于[[ ]]中；扩展的正则表达式<br>-z “STRING“ 字符串是否为空，空为真，不空为假<br>-n “STRING“ 字符串是否不空，不空为真，空为假<br>注意：用于字符串比较时的用到的操作数都应该使用引号<br>Bash的文件测试</p>\n</blockquote>\n<ul>\n<li>存在性测试</li>\n</ul>\n<p>-a FILE：同-e<br>-e FILE: 文件存在性测试，存在为真，否则为假<br>存在性及类别测试<br>-b FILE：是否存在且为块设备文件<br>-c FILE：是否存在且为字符设备文件<br>-d FILE：是否存在且为目录文件<br>-f FILE：是否存在且为普通文件<br>-h FILE 或 -L FILE：存在且为符号链接文件<br>-p FILE：是否存在且为命名管道文件<br>-S FILE：是否存在且为套接字文件<br>Bash的文件权限测试</p>\n<ul>\n<li>文件权限测试：<br>-r FILE：是否存在且可读<br>-w FILE: 是否存在且可写<br>-x FILE: 是否存在且可执行</li>\n<li>文件特殊权限测试：<br>-u FILE：是否存在且拥有suid权限<br>-g FILE：是否存在且拥有sgid权限<br>-k FILE：是否存在且拥有sticky权限<br>Bash的文件属性测试</li>\n<li>文件大小测试：<br>-s FILE: 是否存在且非空<br>文件是否打开：<br>-t fd: fd 文件描述符是否在某终端已经打开<br>-N FILE：文件自从上一次被读取之后是否被修改过<br>-O FILE：当前有效用户是否为文件属主<br>-G FILE：当前有效用户是否为文件属组<br>Bash的文件属性测试</li>\n<li>双目测试：<br>FILE1 -ef FILE2: FILE1是否是FILE2的硬链接<br>FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）<br>FILE1 -ot FILE2: FILE1是否旧于FILE2</li>\n</ul>\n<p>使用read命令来接受输入<br>使用read来把输入值分配给一个或多个shell变量<br>-p 指定要显示的提示<br>-s 静默输入，一般用于密码<br>-n N 指定输入的字符长度N<br>-d ‘字符’ 输入结束符<br>-t N TIMEOUT为N秒<br>read 从标准输入中读取值，给每个单词分配一个变量<br>所有剩余单词都被分配给最后一个变量<br>read -p “Enter a filename: “ FILE</p>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><p>过程式编程语言：<br>        顺序执行<br>        选择执行<br>        循环执行<br>条件选择if语句</p>\n<ul>\n<li>选择执行:</li>\n</ul>\n<p>注意：if语句可嵌套<br>单分支<br>        if 判断条件;then<br>        条件为真的分支代码<br>        fi<br>双分支<br>        if 判断条件; then<br>        条件为真的分支代码<br>        else<br>条件为假的分支代码<br>fi</p>\n<ul>\n<li><p>多分支</p>\n<pre><code>if 判断条件1; then\n条件为真的分支代码\nelif 判断条件2; then\n条件为真的分支代码\nelif 判断条件3; then\n条件为真的分支代码\nelse\n以上条件都为假的分支代码\nfi\n</code></pre><p>逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句</p>\n</li>\n<li><p>条件判断：case语句</p>\n<pre><code>case 变量引用 in\nPAT1)\n分支1\n;;\nPAT2)\n分支2\n;;\n...\n*)\n默认分支\n;;\nesac\n</code></pre></li>\n</ul>\n<p>case支持glob风格的通配符：<br>        *: 任意长度任意字符<br>        ?: 任意单个字符<br>        []：指定范围内的任意单个字符<br>        a|b: a或b</p>\n<ul>\n<li>循环</li>\n</ul>\n<p>循环执行<br>将某代码段重复运行多次<br>重复运行多少次：<br>循环次数事先已知<br>循环次数事先未知<br>有进入条件和退出条件<br>for, while, until<br>for循环<br>for 变量名 in 列表;do<br>循环体<br>done<br>执行机制：<br>依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直<br>到列表中的元素耗尽，循环结束</p>\n<ul>\n<li>for循环<br>列表生成方式：<br>(1) 直接给出列表<br>(2) 整数列表：<br>(a) {start..end}<br>(b) $(seq [start [step]] end)<br>(3) 返回列表的命令<br>$(COMMAND)<br>(4) 使用glob，如：<em>.sh<br>(5) 变量引用；<br>$@, $</em><br>while循环<br>while CONDITION; do<br>循环体<br>done<br>CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后<br>会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为<br>“false”终止循环<br>因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地<br>被修正<br>进入条件：CONDITION为true<br>退出条件：CONDITION为false<br>until循环<br>until CONDITION; do<br>循环体<br>done<br>进入条件： CONDITION 为false<br>退出条件： CONDITION 为true<br>循环控制语句continue<br>用于循环体中<br>ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为<br>第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>continue<br>fi<br>CMDn<br>…<br>done<br>循环控制语句break<br>用于循环体中<br>break [N]：提前结束第N层循环，最内层为第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>break<br>fi<br>CMDn<br>…<br>done<br>特殊用法<br>双小括号方法，即((…))格式，也可以用于算术运算<br>双小括号方法也可以使bash Shell实现C语言风格的变量操作<br>I=10<br>((I++))<br>for循环的特殊格式：<br>for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))<br>do</li>\n<li>循环体<br>done<br>控制变量初始化：仅在运行到循环代码段时执行一次<br>控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做<br>条件判断</li>\n</ul>\n<h2 id=\"函数介绍\"><a href=\"#函数介绍\" class=\"headerlink\" title=\"函数介绍\"></a>函数介绍</h2><p>函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程<br>它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运<br>行，而是shell程序的一部分<br>函数和shell程序比较相似，区别在于：<br>Shell程序在子Shell中运行<br>而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变<br>量进行修改<br>定义函数<br>函数由两部分组成：函数名和函数体<br>help function<br>语法一：<br>f_name （）{<br>…函数体…<br>}<br> 语法二：<br>function f_name {<br>…函数体…<br>}<br> 语法三：<br>function f_name （） {<br>…函数体…<br>}</p>\n<ul>\n<li>函数使用<br>函数的定义和使用：<br>可在交互式环境下定义函数<br>可将函数放在脚本文件中作为它的一部分<br>可放在只包含函数的单独文件中<br>调用：函数只有被调用才会执行<br>调用：给定函数名<br>函数名出现的地方，会被自动替换为函数代码<br>函数的生命周期：被调用时创建，返回时终止函数返回值<br>函数有两种返回值：<br>函数的执行结果返回值：<br>(1) 使用echo等命令进行输出<br>(2) 函数体中调用命令的输出结果<br>函数的退出状态码：<br>(1) 默认取决于函数中执行的最后一条命令的退出状态码<br>(2) 自定义退出状态码，其格式为：<br>return 从函数中返回，用最后状态命令决定返回值<br>return 0 无错误返回。<br>return 1-255 有错误返回<br>交互式环境下定义和使用函数</li>\n</ul>\n<blockquote>\n<p>示例:<br>dir() {<br>ls -l<br>}<br>定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同<br>dir<br>该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令<br>unset dir<br>在脚本中定义及使用函数<br>函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它<br>后才能使用<br>调用函数仅使用其函数名即可<br>示例：<br>cat func1<br>!/bin/bash<br>func1<br>hello()<br>{<br>echo “Hello there today’s date is <code>date +%F</code>“<br>}<br>echo “now going to the function hello”<br>hello<br>echo “back from the function”<br>使用函数文件<br>可以将经常使用的函数存入函数文件，然后将函数文件载入shell<br>文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main<br>一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set<br>命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数<br>若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新<br>载入此文件</p>\n</blockquote>\n<ul>\n<li>创建函数文件</li>\n</ul>\n<p>函数文件示例：</p>\n<blockquote>\n<p>cat functions.main</p>\n<p>#!/bin/bash</p>\n<p>#functions.main<br>findit()<br>{<br>if [ $# -lt 1 ] ; then<br>echo “Usage:findit file”<br>return 1<br>fi<br>find / -name $1 –print<br>}</p>\n</blockquote>\n<ul>\n<li><p>载入函数<br>函数文件已创建好后，要将它载入shell<br>定位函数文件并载入shell的格式：<br>. filename 或 source filename<br>注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;<br>这里的文件名要带正确路径</p>\n</li>\n<li><p>检查载入函数<br>使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数</p>\n</li>\n</ul>\n<blockquote>\n<p>示例：<br>set<br>findit=( )<br>{<br>if [ $# -lt 1 ]; then<br>echo “usage :findit file”;<br>return 1<br>fi<br>find / -name $1 -print<br>}</p>\n</blockquote>\n<ul>\n<li>执行shell函数<br>要执行函数，简单地键入函数名即可<br>示例：<br>findit groups<br>/usr/bin/groups<br>/usr/local/backups/groups.bak</li>\n<li>删除shell函数<br>现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命<br>令完成删除函数<br>命令格式为：<br>unset function_name<br>示例：<br>unset findit<br>再键入set命令，函数将不再显示</li>\n<li>函数参数<br>函数可以接受参数：<br>传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；<br>例如“testfunc arg1 arg2 …”<br>在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#<br>等特殊变量<br>函数变量<br>变量作用域：<br>环境变量：当前shell和子shell有效<br>本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；<br>因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数<br>局部变量：函数的生命周期；函数结束时变量被自动销毁<br>注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量<br>在函数中定义局部变量的方法<br>local NAME=VALUE<br>函数递归示例</li>\n<li>函数递归：<br>函数直接或间接调用自身<br>注意递归层数<br>递归实例：<br>阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的<br>阶乘为1，自然数n的阶乘写作n!<br>n!=1×2×3×…×n<br>阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n<br>n!=n(n-1)(n-2)…1<br>n(n-1)! = n(n-1)(n-2)!<br>函数递归示例:</li>\n</ul>\n<blockquote>\n<pre><code>示例：fact.sh\n\nfact() {\nif [ $1 -eq 0 -o $1 -eq 1 ]; then\necho 1\nelse\necho $[$1*$(fact $[$1-1])]\nfi\n}\nfact $1\n</code></pre></blockquote>\n<ul>\n<li>fork炸弹</li>\n</ul>\n<p>fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是<br>一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个<br>简单的程序迅速耗尽系统里面的所有资源<br>函数实现<br>:(){ :|:&amp; };:<br>bomb() { bomb | bomb &amp; }; bomb  实际上: 代表bomb<br>脚本实现</p>\n<blockquote>\n<p>cat Bomb.sh<br>./$0|./$0&amp;</p>\n</blockquote>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"介绍\"><a href=\"#介绍\" class=\"headerlink\" title=\"介绍\"></a>介绍</h1><h2 id=\"操作系统\"><a href=\"#操作系统\" class=\"headerlink\" title=\"操作系统\"></a>操作系统</h2><p>os(operating system),通用目的的软件程序</p>\n<blockquote>\n<p>硬件驱动<br>进程管理<br>内存管理<br>网络管理<br>安全管理<br>文件管理</p>\n</blockquote>\n<h2 id=\"安装linux\"><a href=\"#安装linux\" class=\"headerlink\" title=\"安装linux\"></a>安装linux</h2><blockquote>\n<p>linux发行版企业多用红帽(redhat)的centos 个人电脑推荐kde桌面的<a href=\"https://www.manjaro.cn/153\" target=\"_blank\" rel=\"noopener\">manjaro</a>或<a href=\"https://www.linuxmint.com/download.php\" target=\"_blank\" rel=\"noopener\">mint</a><br>分区和启动:<br>硬盘MBR分区(主引导记录)他有自己的启动器最大支持2tb<br>uefi的GPT分区:逐渐代替MBR标准<br>主分区 一块硬盘最多4个,不能划分更小,最小单位<br>扩展分区:一块硬盘最多一个,不能直接创建文件系统<br>安装过程大同小异 <a href=\"https://blog.csdn.net/python_lqx/article/details/88670425\" target=\"_blank\" rel=\"noopener\">详细步骤</a><br>需要注意的是如何分区:这里的分区在虚拟机上只是虚拟的,分100g不影响物理硬盘实际占用.实际情况要自己斟酌.<br>/dev/sda 100g<br>/dev/sda1 /boot mountpoint  1g<br>/dev/sda2 /                50g<br>/dev/sda3 /data            20g<br>/dev/sda5 /swap             2g</p>\n</blockquote>\n<h2 id=\"开发接口标准\"><a href=\"#开发接口标准\" class=\"headerlink\" title=\"开发接口标准\"></a>开发接口标准</h2><blockquote>\n<p>ABI:application binary interface ABI描述了程序与os之间的底层接口<br>API:application programming interface<br>开源协议: GPLv2,GPLv3 Apache BSD Mozilla Mit</p>\n</blockquote>\n<h2 id=\"用户和内核空间\"><a href=\"#用户和内核空间\" class=\"headerlink\" title=\"用户和内核空间\"></a>用户和内核空间</h2><blockquote>\n<p>username 用户程序的运行空间 为了安全,他们是隔离的即使用户的程序崩溃,内核也不受影响<br>内核空间:kernel space</p>\n</blockquote>\n<h2 id=\"linux哲学思想\"><a href=\"#linux哲学思想\" class=\"headerlink\" title=\"linux哲学思想\"></a>linux哲学思想</h2><p>在linux上一切皆文件,其实就是硬盘也是以文件格式展示出来的</p>\n<h2 id=\"文件操作\"><a href=\"#文件操作\" class=\"headerlink\" title=\"文件操作\"></a>文件操作</h2><p>文件和目录被组织成单根倒置树结构<br>文件系统从根目录下开始,用”/“表示<br>proc虚拟的,在硬盘上不存在<br>文件 区别大小写( 这是文件系统决定,微软的ntfs不存在,而linux的ext4大小写敏感)<br>以.开头的文件为隐藏文件<br>元数据:metadata(包含属性,权限,大小)每个文件都有自己的元数据,有指针指向到数据的真实内容.<br>数据:data(内容在硬盘上)<br>文件系统分成结构:LSB<br>文件名最长255个字节,文件系统不一样大小不一样<br>包括路径在内文件名称最长4095个字节<br>蓝色—目录 绿色—可执行文件  红色—压缩文件<br>浅蓝色—链接文件 灰色—其他文件 粉色是socket(套接字文件)双向传递<br>管道文件 p开头(pipe)单工传输</p>\n<h2 id=\"文件系统结构元素\"><a href=\"#文件系统结构元素\" class=\"headerlink\" title=\"文件系统结构元素\"></a>文件系统结构元素</h2><p>/boot：引导文件存放目录，内核文件(vmlinuz)、引导加载器(bootloader, grub)都存放于此目录<br>/bin：供所有用户使用的基本命令；不能关联至独立分区，OS启动即会用到的 程序<br>/sbin：管理类的基本命令；不能关联至独立分区，OS启动即会用到的程序<br>/lib：启动时程序依赖的基本共享库文件以及内核模块文件(/lib/modules)<br>/lib64：专用于x86_64系统上的辅助共享库文件存放位置<br>/etc：配置文件目录<br>/home/USERNAME：普通用户家目录<br>/root：管理员的家目录<br>/media：便携式移动设备挂载点<br>/mnt：临时文件系统挂载点<br>/dev：设备文件及特殊文件存储位置  b: block device，随机访问  c: character device，线性访问<br>/opt：第三方应用程序的安装位置<br>/srv：系统上运行的服务用到的数据<br>/tmp：临时文件存储位置<br>/proc: 用于输出内核与进程信息相关的虚拟文件系统<br>/sys：用于输出当前系统上硬件设备相关信息虚拟文件系统<br>/selinux: security enhanced Linux，selinux相关的安全策略等信息的存储位置文<br>/usr: universal shared, read-only data  bin: 保证系统拥有完整功能而提供的应用程序<br>sbin:  lib：32位使用  lib64：只存在64位系统<br>include: C程序的头文件(header files)<br>share：结构化独立的数据，例如doc, man等<br>local：第三方应用程序的安装位置 bin, sbin, lib, lib64, etc, share 文</p>\n<p>/var: variable data files  cache: 应用程序缓存数据目录<br>lib: 应用程序状态信息数据<br>local：专用于为/usr/local下的应用程序存储可变数据<br>lock: 锁文件  log: 日志目录及文件<br>opt: 专用于为/opt下的应用程序存储可变数据<br>run: 运行中的进程相关数据,通常用于存储进程pid文件<br>spool: 应用程序数据池<br>tmp: 保存系统两次重启之间产生的临时数据</p>\n<h2 id=\"Linux下的文件类型\"><a href=\"#Linux下的文件类型\" class=\"headerlink\" title=\"Linux下的文件类型\"></a>Linux下的文件类型</h2><p>-：普通文件<br>d: 目录文件<br>b: 块设备(硬盘,以块为单位,有缓存,一块一块写,有缓存区)<br>c: 字符设备(设备主要以字符为单位,键盘为主)<br>l: 符号链接文件<br>p: 管道文件pipe<br>s: 套接字文件socket</p>\n<h3 id=\"显示当前工作目录\"><a href=\"#显示当前工作目录\" class=\"headerlink\" title=\"显示当前工作目录\"></a>显示当前工作目录</h3><p>每个shell和系统进程都有一个当前的工作目录<br>CWD:current work directory<br>显示当前shell CWD的绝对路径 pwd: printing working directory -P 显示真实物理路径 -L 显示链接路径（默认）</p>\n<h3 id=\"更改目录\"><a href=\"#更改目录\" class=\"headerlink\" title=\"更改目录\"></a>更改目录</h3><p>cd  改变目录 使用绝对或相对路径： cd /home/wang/        cd home/wang 切换至父目录：  cd .. 切换至当前用户主目录： cd 切换至以前的工作目录： cd -<br>选项：-P<br>相关的环境变量：  PWD：当前目录路径   OLDPWD：上一次目录路径</p>\n<h3 id=\"列出目录内容\"><a href=\"#列出目录内容\" class=\"headerlink\" title=\"列出目录内容\"></a>列出目录内容</h3><p>列出当前目录的内容或指定目录<br>用法：ls [options] [ files_or_dirs ]<br>示例: ls -a 包含隐藏文件 ls -l 显示额外的信息 ls -R  目录递归通过 ls -ld  目录和符号链接信息 ls -1  文件分行显示 ls –S  按从大到小排序 ls –t   按mtime排序 ls –u   配合-t选项，显示并按atime从新到旧排序<br>ls –U  按目录存放顺序显示 ls –X  按文件后缀排序</p>\n<blockquote>\n<p>[root@centos7 sysconfig]# ll /etc/motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 /etc/motd<br>[root@centos7 sysconfig]# ll ../motd<br>-rw-r–r–. 1 root root 15 Mar 21 03:19 ../motd<br>-a 全部<br>-r 递归<br>ll 是别名 (ls -l)</p>\n</blockquote>\n<h3 id=\"查看文件状态\"><a href=\"#查看文件状态\" class=\"headerlink\" title=\"查看文件状态\"></a>查看文件状态</h3><p>stat<br>文件：metadata, data<br>三个时间戳: access time：访问时间，atime，读取文件内容<br>modify time: 修改时间,<br>mtime，改变文件内容（数据） change time: 改变时间, ctime，元数据发生改变<br>data 时间不会一直更新<br>通配符* 任意字符<br>二进制查看hexdump -C</p>\n<h3 id=\"创建和查看文件\"><a href=\"#创建和查看文件\" class=\"headerlink\" title=\"创建和查看文件\"></a>创建和查看文件</h3><p>touch 命令是个外部命令<br>[]表示其中一个字母<br>[^  ]表示除去其中字符的任意字符<br>两个大于号比 touch安全</p>\n<h3 id=\"文件统配符\"><a href=\"#文件统配符\" class=\"headerlink\" title=\"文件统配符\"></a>文件统配符</h3><p>man 7 glob</p>\n<h3 id=\"复制和转移删除文件\"><a href=\"#复制和转移删除文件\" class=\"headerlink\" title=\"复制和转移删除文件\"></a>复制和转移删除文件</h3><p>cp [OPTION]… [-T] SOURCE DEST外部命令 现在的cp是别名 元数据会丢失<br>原始命令前加\\<br>拷贝文件夹 -r(递归)<br>cp 有可能丢失数据不能用rmdir删除</p>\n<p>data是个挂载点<br>cp [OPTION]… SOURCE… DIRECTORY cp [OPTION]… -t DIRECTORY SOURCE… cp SRC DEST SRC是文件：如果目标不存在：新建DEST，并将SRC中内容填充至DEST中      如果目标存在： 如果DEST是文件：将SRC中的内容覆盖至DEST中  基于安全，建议为cp命令使用-i选项 如果DEST是目录：在DEST下新建与原文件同名的文件，并将SRC中内容填 充至新文件中<br>cp SRC… DEST    SRC…：多个文件<br>DEST必须存在，且为目录，其它情形均会出错；cp SRC DEST<br>SRC是目录：此时使用选项：-r<br>如果DEST不存在：则创建指定目录，复制SRC目录中所有文件至DEST中；<br>如果DEST存在：<br>如果DEST是文件：报错<br>如果DEST是目录：<br>inode（index node）表中包含文件系统所有文件列表<br>一个节点 （索引节点）是在一个表项，包含有关文件的信息（ 元数据 ），包 括：  文件类型，权限，UID，GID  链接数（指向这个文件名路径名称个数）  该文件的大小和不同的时间戳  指向磁盘上文件的数据块指针  有关文件的其他数据 </p>\n<p>inode 唯一标识在元数据里<br>删除其实删的元数据.删文件比建文件快多了</p>\n<h3 id=\"软和硬链接\"><a href=\"#软和硬链接\" class=\"headerlink\" title=\"软和硬链接\"></a>软和硬链接</h3><p>硬链接<br>创建硬链接会增加额外的记录项以引用文件<br>对应于同一文件系统上一个物理文件<br>每个目录引用相同的inode号<br>创建时链接数递增<br>删除文件时：<br>rm命令递减计数的链接<br>文件要存在，至少有一个链接数<br>当链接数为零时，该文件被删除<br>不能跨越驱动器或分区<br>语法:  ln filename  [linkname ]<br>软连接<br>一个符号文件链接指向一个文件<br>ls -s显示链接的名称和应用的文件<br>一个符号链接的内容是他引用文件的名称<br>可以对目录进行<br>可以跨分区<br>指向的是另一个文件的路径;其大小为指向的路径字符串的长度;不增加或减少目标文件inode的引用计数<br>语法:ln -s 文件 链接名</p>\n<h2 id=\"i-0-重定向至文件\"><a href=\"#i-0-重定向至文件\" class=\"headerlink\" title=\"i/0 重定向至文件\"></a>i/0 重定向至文件</h2><p>程序:指令+数据<br>input 和output<br>打开的文件都有一个fd:file descrptor(文件描述符)<br>linux 给程序提供三种i/o设备<br>标准输入(STDIN)-0 默认接受来自键盘的输入<br>标准输出(STDOUT) -1默认输出到终端窗口<br>标准错误(STDERR) -2 默认输出到窗口<br>i/o重定向:改变默认位置<br>语法:命令  操作符号 文件名<br>操作符&gt;把STDOUT重定向到文件<br>2&gt; 把STDERR重定向到文件<br>$&gt; 把所有输出重定向到文件<br>tr 转换和删除字符</p>\n<h2 id=\"管道\"><a href=\"#管道\" class=\"headerlink\" title=\"管道\"></a>管道</h2><p>管道用来连接命令<br>命令1|命令2|命令3<br>将命令1的STDOUT发送给命令2的STDIN,命令2的STDOUT发送给命令3的STDIN<br>less 一页一页地查看输入<br>重定向到多个目标(tee)<br>把命令1的STDOUT保存在文件中,作为命令2的输入<br>-a追加<br>使用:<br>保存不同阶段的输入<br>复杂管道的故障排除<br>同时查看和记录输出</p>\n<h1 id=\"用户组权限\"><a href=\"#用户组权限\" class=\"headerlink\" title=\"用户组权限\"></a>用户组权限</h1><h2 id=\"用户user\"><a href=\"#用户user\" class=\"headerlink\" title=\"用户user\"></a>用户user</h2><p>令牌token,identity<br>linux用户:username/UID<br>管理员:root,0<br>普通用户:1-65535<br>系统用户:1-499,1-999<br>对守护进程获取资源进行权限进行分配<br>登录用户:500+,1000<br>交互式登录<br>nologin 是软件启动没有用户登录</p>\n<h2 id=\"组group\"><a href=\"#组group\" class=\"headerlink\" title=\"组group\"></a>组group</h2><p>linux:Groupname/GID<br>管理员:<br>系统 :1-499,1-999<br>普通组:500+,1000+<br>安全上下文:<br>进行中的程序:程序(process)<br>以进程发起者的身份运行:<br>root:/bin/cat<br>mage:/bin/cat<br>组的类别<br>用户的主要组:<br>用户必须属于一个且只有一个主组<br>组名同用户名,且包含一个用户,私有组<br>用户和组的配置文件<br>/etc/passwd:用户及其属性信息<br>/etc/group:组及其属性信息<br>/etc/shadow:用户密码及其相关属性<br>/etc/gshadow:组密码及其相关属性<br>passwd文件格式<br>login name:登录用名<br>passwd:密码<br>UID:用户身份编号<br>GID:登录默认所在组编号<br>GECOS:用户全名或注释<br>home diretory:用户主目录<br>shell:用户默认使用shell<br>shadow文件格式<br>useradd usermod userdel<br>组账号维护命令:groupadd<br>groupmod groupdel</p>\n<h2 id=\"用户创建-useradd\"><a href=\"#用户创建-useradd\" class=\"headerlink\" title=\"用户创建:useradd\"></a>用户创建:useradd</h2><p>useradd [options]LOGIN<br>-u UID<br>-o 配合-u选项,不检查UID的唯一性<br>-g GID:指明用户所属基本组,可谓组名,也可以GID<br>-c “COMMENT”:用户的注释信息<br>默认设置:/etc/default/useradd文件中<br>删除用户:userdel -r删除用户目录</p>\n<h2 id=\"查看用户相关的ID信息\"><a href=\"#查看用户相关的ID信息\" class=\"headerlink\" title=\"查看用户相关的ID信息\"></a>查看用户相关的ID信息</h2><p>id [OPTIONS]…[USER]<br>-u :显示UID<br>-g :显示GID<br>-G :显示用户所属的组的ID<br>-n :显示名称,需配合ugG使用</p>\n<h2 id=\"切换用户或以其他用户身份执行命令\"><a href=\"#切换用户或以其他用户身份执行命令\" class=\"headerlink\" title=\"切换用户或以其他用户身份执行命令\"></a>切换用户或以其他用户身份执行命令</h2><p>su[options] [-] [user[args…]]<br>切换用户的方式<br>ssh root@ip<br>curl ww<br>service network restat</p>\n<h2 id=\"设置密码\"><a href=\"#设置密码\" class=\"headerlink\" title=\"设置密码\"></a>设置密码</h2><p>passwd<br>常用选项：<br> -d:删除指定用户密码<br> -l:锁定指定用户<br> -u:解锁指定用户<br> -e:强制用户下次登录修改密码<br> -f: 强制操作<br> -n mindays: 指定最短使用期限<br> -x maxdays：最大使用期限<br> -w warndays：提前多少天开始警告<br> -i inactivedays：非活动期限<br> –stdin：从标准输入接收用户密码<br> echo “PASSWORD” | passwd –stdin USERNAME</p>\n<h2 id=\"创建组\"><a href=\"#创建组\" class=\"headerlink\" title=\"创建组\"></a>创建组</h2><p>groupadd[option]…group_name<br>-g GID:指明GID号:<br>-r:创建系统组<br>修改和删除组:<br>组属性修改:groupmod<br>组删除:groupdel<br>组密码:gpasswd<br>newgrp命令:临时切换主组<br>chown设置文件的所有者<br>chgrp设置文件的属组信息<br>修改文件的属主和属组chown<br>修改文件的属组:chgrp</p>\n<h2 id=\"文件权限\"><a href=\"#文件权限\" class=\"headerlink\" title=\"文件权限\"></a>文件权限</h2><p>文件的权限主要针对三类对象进行定义<br>owner: 属主, u<br>group: 属组, g<br>other: 其他, o<br>每个文件针对每类访问者都定义了三种权限<br>r: Readable<br>w: Writable<br>x: eXcutable</p>\n<h3 id=\"修改文件权限\"><a href=\"#修改文件权限\" class=\"headerlink\" title=\"修改文件权限\"></a>修改文件权限</h3><p>chmod [OPTION]… OCTAL-MODE FILE…<br> -R: 递归修改权限<br>chmod [OPTION]… MODE[,MODE]… FILE…<br> MODE：<br> 修改一类用户的所有权限：<br> u= g= o= ug= a= u=,g=<br> 修改一类用户某位或某些位权限<br> u+ u- g+ g- o+ o- a+ a- + -<br>chmod [OPTION]… –reference=RFILE FILE…<br>参考RFILE文件的权限，将FILE的修改为同RFILE<br>数字权限法:chmod数字 file<br>rwx r-x r– file<br>其中：</p>\n<p>u 表示该文件的拥有者，g 表示与该文件的拥有者属于同一个群体(group)者，o 表示其他以外的人，a 表示这三者皆是。</p>\n<ul>\n<li>表示增加权限、- 表示取消权限、= 表示唯一设定权限。<br>r 表示可读取，w 表示可写入，x 表示可执行，X 表示只有当该文件是个子目录或者该文件已经被设定过为可执行。<br>其他参数说明：</li>\n</ul>\n<p>-c : 若该文件权限确实已经更改，才显示其更改动作<br>-f : 若该文件权限无法被更改也不要显示错误讯息<br>-v : 显示权限变更的详细资料<br>-R : 对目前目录下的所有文件与子目录进行相同的权限变更(即以递回的方式逐个变更)<br>–help : 显示辅助说明<br>–version : 显示版本</p>\n<h1 id=\"文本工具\"><a href=\"#文本工具\" class=\"headerlink\" title=\"文本工具\"></a>文本工具</h1><h2 id=\"基础\"><a href=\"#基础\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>文件内容:less和cat<br>文件截取:head和tail<br>按列抽取:cut<br>按关键字抽取:grep<br>文件查看:cat tac rev<br>分页查看:more<br>一页一页的查看:less<br>less 命令是man命令使用的分页器</p>\n<h3 id=\"显示文本前后或后行内容\"><a href=\"#显示文本前后或后行内容\" class=\"headerlink\" title=\"显示文本前后或后行内容\"></a>显示文本前后或后行内容</h3><p>head[option]…[FILE]默认看文本前10行,配合管道可以看命令前两行<br>tail[option]…[FILE]看文本尾<br>tail-f 跟踪看日志<br>cut命令取字段<br>past 横着合并文件<br>wc 收集文本</p>\n<h3 id=\"文本排序sort\"><a href=\"#文本排序sort\" class=\"headerlink\" title=\"文本排序sort\"></a>文本排序sort</h3><p>把整理过的文本显示在STDOUT,不改变原始文件<br>sort[opiton]file(s)<br>uniq:从输入中删除前后相接的重复的行,处理日志<br>liunx:文本处理三剑客<br>grep:文本过滤,文本搜索 逐行匹配符合条件的字符 现在用的grep是个别名 输出变红<br>sed:stream editor, 文本编辑工具<br>awk:liunx上的实现gawk,文本报告生成器<br>grep作用:文本搜索工具,根据用户指定的模式对目标文本逐行进行匹配检查;打印匹配到行</p>\n<h2 id=\"正则表达式\"><a href=\"#正则表达式\" class=\"headerlink\" title=\"正则表达式\"></a>正则表达式</h2><p>匹配次数:用在要指定次数的字符后面,用于指定前面字符的次数<br>位置锚定:定位<br>正则字符特殊 元字符<br>.单个任意字符<br>[abc]表示其中一个字符<br>[^abc]除去abc任意字母<br>[:lower:]小写<br>[:upper:]大写<br>分组方式<br>abc{3}\\<br>搜索替代工具<br>grep过滤特定行,sed也可以并且编辑修改文件</p>\n<h2 id=\"vim编辑器\"><a href=\"#vim编辑器\" class=\"headerlink\" title=\"vim编辑器\"></a>vim编辑器</h2><p>vi:visual interface 文本编辑器<br>文本:asscii ,unicode<br>文本编辑种类:<br>行编辑器:sed<br>全屏编辑器:nano,vi<br>vim -viimproved<br>其他编辑器<br>gedit 一个简单的图形编辑器<br>gvim 一个vim编辑器的图形版本<br>vi一开始是vim的别名<br>vim有三种模式:normal(普通) insert(插入) extendcommand(命令)<br>normal :默认模式,移动光标,剪切/粘贴文本<br>insert :修改文本<br>extend command:保存,退出</p>\n<h3 id=\"搜索替代\"><a href=\"#搜索替代\" class=\"headerlink\" title=\"搜索替代\"></a>搜索替代</h3><p>/ :从当前光标所在处向文件尾部查找<br>? :从当前光标所在处向文件首部查找<br>n :与命令同方向<br>N :与命令反方向<br>处理文本的工具sed<br>stream editor 行编辑器<br>sed是一种编辑器,他一次处理一行内容.处理时,把当前处理的行存储在临时缓冲区中,称为”模式空间”,接着用sed命令处理缓冲区的内容,处理完成后,把缓冲区的内容送往屏幕.然后读入下行,执行下一个循环.如果没有使诸如’D’的特殊命令,那会在两个循环之间清空模式空间,但不会清空保留空间.这样不断重复,直到文件末尾.文件内容并没有改变,除非你使用重定向存储输出.<br>vim不适合修改大批量文件,sed可以<br>sed 配合管道可以使用<br>awk 语言<br>sed ‘’ passwd<br>‘地址命令’地址不写代表全部文件 命令不写代表输出</p>\n<h1 id=\"软件管理\"><a href=\"#软件管理\" class=\"headerlink\" title=\"软件管理\"></a>软件管理</h1><h2 id=\"包管理器\"><a href=\"#包管理器\" class=\"headerlink\" title=\"包管理器\"></a>包管理器</h2><p>rpm 打包文件 不需要考虑部署 安装路径都定义好<br>二进制应用程序的组成部分:二进制文件、库文件、配置文件、帮助文件<br>程序包管理器：<br>debian：deb文件, dpkg包管理器<br>redhat: rpm文件, rpm包管理器<br>rpm: Redhat Package Manager   RPM  Package Manager<br>源代码：name-VERSION.tar.gz|bz2|xz  VERSION: major.minor.release<br>rpm包命名方式:name-VERSION-release.arch.rpm<br>例：bash-4.2.46-19.el7.x86_64.rpm  VERSION: major.minor.release  release：release.OS<br>常见的arch：  x86: i386, i486, i586, i686  x86_64: x64, x86_64, amd64  powerpc: ppc  跟平台无关：noarch</p>\n<p>包：分类和拆包<br>Application-VERSION-ARCH.rpm: 主包<br>Application-devel-VERSION-ARCH.rpm 开发子包  Application-utils-VERSION-ARHC.rpm 其它子包  Application-libs-VERSION-ARHC.rpm 其它子包<br>包之间：可能存在依赖关系，甚至循环依赖<br>解决依赖包管理<br>工具:yum：rpm包管理器的前端工具  apt-get：deb包管理器前端工具  zypper: suse上的rpm前端管理工具  dnf: Fedora 18+ rpm包管理器前端管理工具 npm:nodejs包管理工具</p>\n<p>查看二进制程序所依赖的库文件  ldd /PATH/TO/BINARY_FILE<br>管理及查看本机装载的库文件  ldconfig 加载库文件  /sbin/ldconfig -p: 显示本机已经缓存的所有可用库文件名及文件 路径映射关系  配置文件：/etc/ld.so.conf, /etc/ld.so.conf.d/*.conf  缓存文件：/etc/ld.so.cache</p>\n<h3 id=\"程序包管理器\"><a href=\"#程序包管理器\" class=\"headerlink\" title=\"程序包管理器\"></a>程序包管理器</h3><p>功能：将编译好的应用程序的各组成文件打包一个或几个程序包文件,从而方便快捷地实现程序包的安装、卸载、查询、升级和校验等管理操作.<br>包文件组成 (每个包独有)<br>RPM包内的文件 RPM的元数据，如名称，版本，依赖性，描述等.<br>安装或卸载时运行的脚本<br>数据库(公共)：/var/lib/rpm 程序包名称及版本  依赖关系  功能说明  包安装后生成的各文件路径及校验码信息<br>管理程序包的方式:使用包管理器：rpm  使用前端工具：yum, dnf<br>获取程序包的途径：<br>(1) 系统发版的光盘或官方的服务器;CentOS镜像:<a href=\"https://www.centos.org/download/\" target=\"_blank\" rel=\"noopener\">https://www.centos.org/download/</a>   <a href=\"http://mirrors.aliyun.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com</a>   <a href=\"http://mirrors.sohu.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.sohu.com</a>   <a href=\"http://mirrors.163.com\" target=\"_blank\" rel=\"noopener\">http://mirrors.163.com</a><br>(2) 项目官方站点程序包的来源<br>(3) 第三方组织:Fedora-EPEL:Extra Packages for Enterprise Linux  Rpmforge:RHEL推荐，包很全 搜索引擎:<a href=\"http://pkgs.org\" target=\"_blank\" rel=\"noopener\">http://pkgs.org</a> <a href=\"http://rpmfind.net\" target=\"_blank\" rel=\"noopener\">http://rpmfind.net</a>   <a href=\"http://rpm.pbone.net\" target=\"_blank\" rel=\"noopener\">http://rpm.pbone.net</a> <a href=\"https://sourceforge.net/\" target=\"_blank\" rel=\"noopener\">https://sourceforge.net/</a><br>(4) 自己制作 注意：第三方包建议要检查其合法性  来源合法性,程序包的完整性</p>\n<ul>\n<li><p>rpm包管理<br>CentOS系统上使用rpm命令管理程序包:安装、卸载、升级、查询、校验、数据库维护  安装：<br>rpm {-i|–install} [install-options] PACKAGE_FILE…<br> -v: verbose<br> -h: 以#显示程序包管理执行进度  rpm -ivh PACKAGE_FILE …</p>\n</li>\n<li><p>rpm包安装<br>[install-options]<br>–test: 测试安装，但不真正执行安装，即dry run模式<br>–nodeps：忽略依赖关系<br>–replacepkgs | replacefiles<br>–nosignature: 不检查来源合法性<br>–nodigest：不检查包完整性<br>–noscripts：不执行程序包脚本   %pre: 安装前脚本；<br>–nopre   %post: 安装后脚本；<br>–nopost   %preun: 卸载前脚本；<br>–nopreun   %postun: 卸载后脚本；  –nopostun</p>\n</li>\n<li><p>rpm包升级<br>升级：rpm {-U|–upgrade} [install-options] PACKAGE_FILE…<br>rpm {-F|–freshen} [install-options] PACKAGE_FILE…<br>upgrade：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则“安装”<br>freshen：安装有旧版程序包，则“升级”<br>如果不存在旧版程序包，则不执行升级操作  rpm -Uvh PACKAGE_FILE …  rpm -Fvh PACKAGE_FILE …<br>–oldpackage：降级<br>–force: 强制安装</p>\n</li>\n<li><p>升级注意项<br>注意：<br>(1) 不要对内核做升级操作；Linux支持多内核版本并存，因此，对直接安装新版 本内核 (2) 如果原程序包的配置文件安装后曾被修改，升级时，新版本的提供的同一个配 置文件并不会直接覆盖老版本的配置文件，而把新版本的文件重命名 (FILENAME.rpmnew)后保留</p>\n</li>\n<li><p>包查询<br>rpm {-q|–query} [select-options] [query-options] [select-options]<br>-a: 所有包<br>-f: 查看指定的文件由哪个程序包安装生成<br>-p rpmfile：针对尚未安装的程序包文件做查询操作<br>–whatprovides CAPABILITY：查询指定的CAPABILITY由哪个包所提供  –whatrequires CAPABILITY：查询指定的CAPABILITY被哪个包所依赖<br>rpm2cpio 包文件|cpio –itv  预览包内文件 rpm2cpio 包文件|cpio –id  “*.conf” 释放包内文件</p>\n</li>\n<li><p>常用查询用法：  -qi PACKAGE, -qf FILE, -qc PACKAGE, -ql PACKAGE, -qd PACKAGE  -qpi PACKAGE_FILE, -qpl PACKAGE_FILE, …  -qa<br>包卸载：  rpm {-e|–erase} [–allmatches] [–nodeps] [–noscripts] [–notriggers] [–test] PACKAGE_NAME …</p>\n</li>\n</ul>\n<p>包校验<br>rpm {-V|–verify} [select-options] [verify-options]  S file Size differs  M Mode differs (includes permissions and file type)  5 digest (formerly MD5 sum) differs  D Device major/minor number mismatch  L readLink(2) path mismatch  U User ownership differs  G Group ownership differs  T mTime differs  P capabilities differ<br>包校验<br>包来源合法性验正及完整性验正<br>完整性验正：SHA256<br>来源合法性验正：RSA 公钥加密<br>对称加密：加密、解密使用同一密钥<br>非对称加密：密钥是成对儿的<br>public key: 公钥，公开所有人</p>\n<ul>\n<li>rpm数据库<br>数据库重建：  /var/lib/rpm rpm {–initdb|–rebuilddb}  initdb: 初始化   如果事先不存在数据库，则新建之   否则，不执行任何操作  rebuilddb：重建已安装的包头的数据库索引目录</li>\n</ul>\n<h2 id=\"yum\"><a href=\"#yum\" class=\"headerlink\" title=\"yum\"></a>yum</h2><p>CentOS: yum, dnf YUM: Yellowdog Update Modifier，rpm的前端程序，可解决软件包相关依 赖性，可在多个库之间定位软件包，up2date的替代工具  yum repository: yum repo，存储了众多rpm包，以及包的相关的元数据 文件（放置于特定目录repodata下）  文件服务器: http:// https://   ftp://   file:// </p>\n<ul>\n<li>yum配置文件<br>yum客户端配置文件:/etc/yum.conf：为所有仓库提供公共配置  /etc/yum.repos.d/*.repo：为仓库的指向提供配置<br>仓库指向的定义：   [repositoryID]   name=Some name for this repository   baseurl=url://path/to/repository/   enabled={1|0}   gpgcheck={1|0}   gpgkey=URL   enablegroups={1|0}   failovermethod={roundrobin|priority}    roundrobin：意为随机挑选，默认值    priority:按顺序访问   cost=   默认为1000</li>\n<li>yum仓库<br>yum的repo配置文件中可用的变量：  $releasever: 当前OS的发行版的主版本号  $arch: 平台，i386,i486,i586,x86_64等  $basearch：基础平台；i386, x86_64  $YUM0-$YUM9:自定义变量 实例:  <a href=\"http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64\" target=\"_blank\" rel=\"noopener\">http://server/centos/$releasever/$basearch/http://server/centos/7/x86_64</a>  <a href=\"http://server/centos/6/i384\" target=\"_blank\" rel=\"noopener\">http://server/centos/6/i384</a><br>yum源<br>阿里云repo文件:<a href=\"http://mirrors.aliyun.com/repo/\" target=\"_blank\" rel=\"noopener\">http://mirrors.aliyun.com/repo/</a><br>CentOS系统的yum源 阿里云：<a href=\"https://mirrors.aliyun.com/centos/$releasever/os/x86_64/\" target=\"_blank\" rel=\"noopener\">https://mirrors.aliyun.com/centos/$releasever/os/x86_64/</a><br>EPEL的yum源:阿里云：<a href=\"https://mirrors.aliyun.com/epel/$releasever/x86_64\" target=\"_blank\" rel=\"noopener\">https://mirrors.aliyun.com/epel/$releasever/x86_64</a> </li>\n</ul>\n<h3 id=\"yum命令\"><a href=\"#yum命令\" class=\"headerlink\" title=\"yum命令\"></a>yum命令</h3><p>yum命令的用法：  yum [options] [command] [package …]<br>显示仓库列表：  yum repolist [all|enabled|disabled]<br>显示程序包：  yum list  yum list [all | glob_exp1] [glob_exp2] […]  yum list {available|installed|updates} [glob_exp1] […] 安装程序包：  yum install package1 [package2] […]  yum reinstall package1 [package2] […]  (重新安装)<br>yum命令<br>升级程序包：  yum update [package1] [package2] […]  yum downgrade package1 [package2] […] (降级)<br>检查可用升级：  yum check-update<br>卸载程序包：  yum remove | erase package1 [package2] […]<br>yum命令<br>查看程序包information：  yum info […]<br>查看指定的特性(可以是某文件)是由哪个程序包所提供：  yum provides | whatprovides feature1 [feature2] […]<br>清理本地缓存：  清除/var/cache/yum/$basearch/$releasever缓存  yum clean [ packages | metadata | expire-cache | rpmdb | plugins | all ]<br>构建缓存：  yum makecache<br>yum命令<br>搜索：yum search string1 [string2] […]  以指定的关键字搜索程序包名及summary信息<br>查看指定包所依赖的capabilities：  yum deplist package1 [package2] […]<br>查看yum事务历史：  yum history [info|list|packages-list|packages-info|  summary|addon-info|redo|undo|  rollback|new|sync|stats]  yum history  yum history info 6  yum history undo 6<br>日志 ：/var/log/yum.log<br>安装及升级本地程序包:yum localinstall rpmfile1 [rpmfile2] <a href=\"用install替代\">…</a><br>yum localupdate rpmfile1 [rpmfile2] […] (用update替代)<br>包组管理的相关命令：  yum groupinstall group1 [group2] […]   groupupdate group1 [group2] […]   yum grouplist [hidden] [groupwildcard] […]   yum groupremove group1 [group2] […]   yum groupinfo group1 […]<br>yum命令<br>yum的命令行选项：  –nogpgcheck：禁止进行gpg check  -y: 自动回答为“yes”  -q：静默模式  –disablerepo=repoidglob：临时禁用此处指定的repo  –enablerepo=repoidglob：临时启用此处指定的repo  –noplugins：禁用所有插件<br>系统光盘yum仓库<br>系统安装光盘作为本地yum仓库：<br>(1) 挂载光盘至某目录，例如/mnt/cdrom   mount /dev/cdrom /mnt/cdrom<br>(2) 创建配置文件   [CentOS7]   name=   baseurl=   gpgcheck=   enabled= 创建yum仓库：  createrepo [options] <directory></directory></p>\n<h3 id=\"程序包编译\"><a href=\"#程序包编译\" class=\"headerlink\" title=\"程序包编译\"></a>程序包编译</h3><p>程序包编译安装： Application-VERSION-release.src.rpm –&gt; 安装后，使用rpmbuild命令制作 成二进制格式的rpm包，而后再安装 源代码–&gt;预处理–&gt;编译–&gt;汇编–&gt;链接–&gt;执行<br>源代码组织格式：  多文件：文件中的代码之间，很可能存在跨文件依赖关系  C、C++：make 项目管理器   configure脚本 –&gt; Makefile.in –&gt; Makefile  java: maven</p>\n<h2 id=\"C语言源代码编译安装三步骤\"><a href=\"#C语言源代码编译安装三步骤\" class=\"headerlink\" title=\"C语言源代码编译安装三步骤:\"></a>C语言源代码编译安装三步骤:</h2><p>1、./configure(1)通过选项传递参数，指定启用特性、安装路径等；执行时会参考用户的 指定以及Makefile.in文件生成Makefile(2)检查依赖到的外部环境，如依赖的软包 2、make  根据Makefile文件，构建应用程序<br>3、make install  复制文件到相应路径<br>开发工具:autoconf: 生成configure脚本 automake：生成Makefile.in<br>注意：安装前查看INSTALL，README</p>\n<p>开源程序源代码的获取:官方自建站点:apache.org (ASF：Apache Software    Foundation) mariadb.org 代码托管:SourceForge.net  Github.com      code.google.com<br>c/c++编译器: gcc (GNU C Complier)</p>\n<p>编译C源代码：  准备：提供开发工具及开发环境   开发工具：make, gcc等   开发环境：开发库，头文件    glibc：标准库  实现：通过“包组”提供开发组件   Development Tools   Server Platform Development</p>\n<p>第一步：configure脚本 选项：指定安装位置、指定启用的特性 –help: 获取其支持使用的选项  选项分类：安装路径设定:–prefix=/PATH: 指定默认安装位置,默认为/usr/local/–sysconfdir=/PATH：配置文件安装位置System types:支持交叉编译</p>\n<p>Optional Features: 可选特性 –disable-FEATURE  –enable-FEATURE[=ARG] Optional Packages: 可选包 –with-PACKAGE[=ARG],依赖包    –without-PACKAGE,禁用依赖关系 注意：通常被编译操作依赖的程序包，需要安装此程序包的“开发”组件， 其包名一般类似于name-devel-VERSION</p>\n<p>第二步：make 第三步：make install</p>\n<p>安装后的配置：<br>(1) 二进制程序目录导入至PATH环境变量中   编辑文件/etc/profile.d/NAME.sh export PATH=/PATH/TO/BIN:$PATH<br>(2) 导入帮助手册  编辑/etc/man.config|man_db.conf文件 添加一个MANPATH</p>\n<h1 id=\"shell编程\"><a href=\"#shell编程\" class=\"headerlink\" title=\"shell编程\"></a>shell编程</h1><h2 id=\"基础-1\"><a href=\"#基础-1\" class=\"headerlink\" title=\"基础\"></a>基础</h2><p>程序：指令+数据<br>程序编程风格：<br>        过程式：以指令为中心，数据服务于指令<br>        对象式：以数据为中心，指令服务于数据<br>        shell程序：提供了编程能力，解释执行</p>\n<h3 id=\"编程基本概念\"><a href=\"#编程基本概念\" class=\"headerlink\" title=\"编程基本概念\"></a>编程基本概念</h3><p>编程逻辑处理方式：<br>顺序执行<br>循环执行<br>选择执行</p>\n<h3 id=\"shell编程：过程式、解释执行\"><a href=\"#shell编程：过程式、解释执行\" class=\"headerlink\" title=\"shell编程：过程式、解释执行\"></a>shell编程：过程式、解释执行</h3><p>编程语言的基本结构：<br>各种系统命令的组合<br>数据存储：变量、数组<br>表达式: a + b<br>语句:if<br>shell脚本基础<br>shell脚本:<br>包含一些命令或声明，并符合一定格式的文本文件<br>格式要求:首行shebang机制</p>\n<blockquote>\n<p>#!/bin/bash</p>\n<p>#!/usr/bin/python</p>\n<p>#!/usr/bin/perl<br>shell脚本的用途有：<br>自动化常用命令</p>\n</blockquote>\n<p>执行系统管理和故障排除</p>\n<p>创建简单的应用程序</p>\n<p>处理文本或文件</p>\n<h3 id=\"添加注释\"><a href=\"#添加注释\" class=\"headerlink\" title=\"添加注释\"></a>添加注释</h3><p>注释以#开头<br>第二步：运行脚本<br>给予执行权限，在命令行上指定脚本的绝对或相对路径<br>直接运行解释器，将脚本作为解释器程序的参数运行</p>\n<h3 id=\"脚本规范\"><a href=\"#脚本规范\" class=\"headerlink\" title=\"脚本规范\"></a>脚本规范</h3><p>脚本代码开头约定<br>1、第一行一般为调用使用的语言<br>2、程序名，避免更改文件名为无法找到正确的文件<br>3、版本号<br>4、更改后的时间<br>5、作者相关信息<br>6、该程序的作用，及注意事项<br>7、最后是各版本的更新简要说明</p>\n<p>脚本调试<br>检测脚本中的语法错误<br>bash -n /path/to/some_script<br>调试执行<br>bash -x /path/to/some_script</p>\n<h2 id=\"变量\"><a href=\"#变量\" class=\"headerlink\" title=\"变量\"></a>变量</h2><p>变量：命名的内存空间<br>数据存储方式：<br>字符：<br>数值：整型，浮点型<br>变量：变量类型<br>作用：<br>1、数据存储格式<br>2、参与的运算<br>3、表示的数据范围<br>类型：<br>字符<br>数值：整型、浮点型<br>变量命名法则：<br>1、不能使程序中的保留字：例如 if, for<br>2、只能使用数字、字母及下划线，且不能以数字开头<br>3、见名知义<br>4、统一命名规则：驼峰命名法，建议大写</p>\n<ul>\n<li>bash中变量的种类<br>根据变量的生效范围等标准划分下面变量类型：<pre><code>局部变量：生效范围为当前shell进程；对当前shell之外的其它shell进程，\n</code></pre>包括当前shell的子shell进程均无效<pre><code>环境（全局）变量：生效范围为当前shell进程及其子进程\n本地变量：生效范围为当前shell进程中某代码片断，通常指函数\n位置变量：$1, $2, ...来表示，用于让脚本在脚本代码中调用通过命令行传\n</code></pre>递给它的参数<pre><code>特殊变量：$?, $0, $*, $@, $#,$$\n</code></pre></li>\n<li><p>局部变量<br>变量赋值：name=‘value’<br>可以使用引用value:<br>(1) 可以是直接字串; name=“root”<br>(2) 变量引用：name=”$USER”<br>(3) 命令引用：name=<code>COMMAND</code> name=$(COMMAND)<br>变量引用：${name} $name<br>“”：弱引用，其中的变量引用会被替换为变量值<br>‘’：强引用，其中的变量引用不会被替换为变量值，而保持原字符串<br>显示已定义的所有变量：set<br>删除变量：unset name</p>\n</li>\n<li><p>环境变量<br>bash内建的环境变量：<br>PATH<br>SHELL<br>USER<br>UID<br>HOME<br>PWD<br>SHLVL<br>LANG<br>MAIL<br>HOSTNAME<br>HISTSIZE<br>—</p>\n</li>\n</ul>\n<h3 id=\"只读和位置变量\"><a href=\"#只读和位置变量\" class=\"headerlink\" title=\"只读和位置变量\"></a>只读和位置变量</h3><p>只读变量：只能声明，但不能修改和删除<br>声明只读变量：<br>        readonly name<br>        declare -r name<br>查看只读变量：<br>        readonly –p<br>位置变量：在脚本代码中调用通过命令行传递给脚本的参数<br>$1, $2, …：对应第1、第2等参数，shift [n]换位置<br>$0: 命令本身<br>$<em>: 传递给脚本的所有参数，全部参数合为一个字符串<br>$@: 传递给脚本的所有参数，每个参数为独立字符串<br>$#: 传递给脚本的参数的个数<br>$@ $</em> 只在被双引号包起来的时候才会有差异<br>set – 清空所有位置变量</p>\n<ul>\n<li>退出状态<br>进程使用退出状态来报告成功或失败<br>• 0 代表成功，1－255代表失败<br>• $? 变量保存最近的命令退出状态<br>例如：<br>ping -c1 -W1 hostdown &amp;&gt; /dev/null<br>echo $?<br>退出状态码<br>bash自定义退出状态码<br>exit [n]：自定义退出状态码<br>注意：脚本中一旦遇到exit命令，脚本会立即终止；终止退出状态取决于exit命<br>令后面的数字<br>注意：如果未给脚本指定退出状态码，整个脚本的退出状态码取决于脚本中执<br>行的最后一条命令的状态码</li>\n</ul>\n<h2 id=\"运算\"><a href=\"#运算\" class=\"headerlink\" title=\"运算\"></a>运算</h2><p>bash中的算术运算:help let<br>+, -, <em>, /, %取模（取余）, **（乘方）<br>实现算术运算：<br>(1) let var=算术表达式<br>(2) var=$[算术表达式]<br>(3) var=$((算术表达式))<br>(4) var=$(expr arg1 arg2 arg3 …)<br>(5) declare –i var = 数值<br>(6) echo ‘算术表达式’ | bc<br>乘法符号有些场景中需要转义，如</em><br>bash有内建的随机数生成器：RANDOM（0-32767）<br>echo $[$RANDOM%50] ：0-49之间随机数<br>赋值</p>\n<ul>\n<li>增强型赋值：<br>+=, -=, *=, /=, %=<br>let varOPERvalue<br>例如:let count+=3<br>自加3后自赋值<br>自增，自减：<pre><code>let var+=1\nlet var++\nlet var-=1\nlet var--\n</code></pre></li>\n<li><p>逻辑运算<br>true, false<br>1, 0</p>\n<pre><code>与：\n1 与 1 = 1\n1 与 0 = 0\n0 与 1 = 0\n0 与 0 = 0\n或:\n1 或 1 = 1\n1 或 0 = 1\n0 或 1 = 1\n0 或 0 = 0\n非：！\n! 1 = 0\n! 0 = 1\n</code></pre></li>\n<li><p>短路运算</p>\n</li>\n<li><p>短路与<br>第一个为0，结果必定为0<br>第一个为1，第二个必须要参与运算</p>\n</li>\n<li>短路或<br>第一个为1，结果必定为1<br>第一个为0，第二个必须要参与运算</li>\n<li>异或：^<br>异或的两个值,相同为假，不同为真</li>\n<li>条件测试<br>判断某需求是否满足，需要由测试机制来实现<br>专用的测试表达式需要由测试命令辅助完成测试过程<br>评估布尔声明，以便用在条件性执行中<br>• 若真，则返回0<br>• 若假，则返回1</li>\n<li>测试命令：<br>• test EXPRESSION<br>• [ EXPRESSION ]<br>• [[ EXPRESSION ]]<br>注意：EXPRESSION前后必须有空白字符<br>bash的数值测试<br>-v VAR<br>变量VAR是否设置</li>\n<li><p>数值测试：<br>-gt 是否大于<br>-ge 是否大于等于<br>-eq 是否等于<br>-ne 是否不等于<br>-lt 是否小于<br>-le 是否小于等于<br>bash的字符串测试</p>\n</li>\n<li><p>字符串测试:</p>\n</li>\n</ul>\n<blockquote>\n<p>== 是否等于<br>ascii码是否大于ascii码<br>&lt; 是否小于<br>!= 是否不等于<br>=~ 左侧字符串是否能够被右侧的PATTERN所匹配<br>注意: 此表达式一般用于[[ ]]中；扩展的正则表达式<br>-z “STRING“ 字符串是否为空，空为真，不空为假<br>-n “STRING“ 字符串是否不空，不空为真，空为假<br>注意：用于字符串比较时的用到的操作数都应该使用引号<br>Bash的文件测试</p>\n</blockquote>\n<ul>\n<li>存在性测试</li>\n</ul>\n<p>-a FILE：同-e<br>-e FILE: 文件存在性测试，存在为真，否则为假<br>存在性及类别测试<br>-b FILE：是否存在且为块设备文件<br>-c FILE：是否存在且为字符设备文件<br>-d FILE：是否存在且为目录文件<br>-f FILE：是否存在且为普通文件<br>-h FILE 或 -L FILE：存在且为符号链接文件<br>-p FILE：是否存在且为命名管道文件<br>-S FILE：是否存在且为套接字文件<br>Bash的文件权限测试</p>\n<ul>\n<li>文件权限测试：<br>-r FILE：是否存在且可读<br>-w FILE: 是否存在且可写<br>-x FILE: 是否存在且可执行</li>\n<li>文件特殊权限测试：<br>-u FILE：是否存在且拥有suid权限<br>-g FILE：是否存在且拥有sgid权限<br>-k FILE：是否存在且拥有sticky权限<br>Bash的文件属性测试</li>\n<li>文件大小测试：<br>-s FILE: 是否存在且非空<br>文件是否打开：<br>-t fd: fd 文件描述符是否在某终端已经打开<br>-N FILE：文件自从上一次被读取之后是否被修改过<br>-O FILE：当前有效用户是否为文件属主<br>-G FILE：当前有效用户是否为文件属组<br>Bash的文件属性测试</li>\n<li>双目测试：<br>FILE1 -ef FILE2: FILE1是否是FILE2的硬链接<br>FILE1 -nt FILE2: FILE1是否新于FILE2（mtime）<br>FILE1 -ot FILE2: FILE1是否旧于FILE2</li>\n</ul>\n<p>使用read命令来接受输入<br>使用read来把输入值分配给一个或多个shell变量<br>-p 指定要显示的提示<br>-s 静默输入，一般用于密码<br>-n N 指定输入的字符长度N<br>-d ‘字符’ 输入结束符<br>-t N TIMEOUT为N秒<br>read 从标准输入中读取值，给每个单词分配一个变量<br>所有剩余单词都被分配给最后一个变量<br>read -p “Enter a filename: “ FILE</p>\n<h2 id=\"流程控制\"><a href=\"#流程控制\" class=\"headerlink\" title=\"流程控制\"></a>流程控制</h2><p>过程式编程语言：<br>        顺序执行<br>        选择执行<br>        循环执行<br>条件选择if语句</p>\n<ul>\n<li>选择执行:</li>\n</ul>\n<p>注意：if语句可嵌套<br>单分支<br>        if 判断条件;then<br>        条件为真的分支代码<br>        fi<br>双分支<br>        if 判断条件; then<br>        条件为真的分支代码<br>        else<br>条件为假的分支代码<br>fi</p>\n<ul>\n<li><p>多分支</p>\n<pre><code>if 判断条件1; then\n条件为真的分支代码\nelif 判断条件2; then\n条件为真的分支代码\nelif 判断条件3; then\n条件为真的分支代码\nelse\n以上条件都为假的分支代码\nfi\n</code></pre><p>逐条件进行判断，第一次遇为“真”条件时，执行其分支，而后结束整个if语句</p>\n</li>\n<li><p>条件判断：case语句</p>\n<pre><code>case 变量引用 in\nPAT1)\n分支1\n;;\nPAT2)\n分支2\n;;\n...\n*)\n默认分支\n;;\nesac\n</code></pre></li>\n</ul>\n<p>case支持glob风格的通配符：<br>        *: 任意长度任意字符<br>        ?: 任意单个字符<br>        []：指定范围内的任意单个字符<br>        a|b: a或b</p>\n<ul>\n<li>循环</li>\n</ul>\n<p>循环执行<br>将某代码段重复运行多次<br>重复运行多少次：<br>循环次数事先已知<br>循环次数事先未知<br>有进入条件和退出条件<br>for, while, until<br>for循环<br>for 变量名 in 列表;do<br>循环体<br>done<br>执行机制：<br>依次将列表中的元素赋值给“变量名”; 每次赋值后即执行一次循环体; 直<br>到列表中的元素耗尽，循环结束</p>\n<ul>\n<li>for循环<br>列表生成方式：<br>(1) 直接给出列表<br>(2) 整数列表：<br>(a) {start..end}<br>(b) $(seq [start [step]] end)<br>(3) 返回列表的命令<br>$(COMMAND)<br>(4) 使用glob，如：<em>.sh<br>(5) 变量引用；<br>$@, $</em><br>while循环<br>while CONDITION; do<br>循环体<br>done<br>CONDITION：循环控制条件；进入循环之前，先做一次判断；每一次循环之后<br>会再次做判断；条件为“true”，则执行一次循环；直到条件测试状态为<br>“false”终止循环<br>因此：CONDTION一般应该有循环控制变量；而此变量的值会在循环体不断地<br>被修正<br>进入条件：CONDITION为true<br>退出条件：CONDITION为false<br>until循环<br>until CONDITION; do<br>循环体<br>done<br>进入条件： CONDITION 为false<br>退出条件： CONDITION 为true<br>循环控制语句continue<br>用于循环体中<br>ontinue [N]：提前结束第N层的本轮循环，而直接进入下一轮判断；最内层为<br>第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>continue<br>fi<br>CMDn<br>…<br>done<br>循环控制语句break<br>用于循环体中<br>break [N]：提前结束第N层循环，最内层为第1层<br>while CONDTIITON1; do<br>CMD1<br>…<br>if CONDITION2; then<br>break<br>fi<br>CMDn<br>…<br>done<br>特殊用法<br>双小括号方法，即((…))格式，也可以用于算术运算<br>双小括号方法也可以使bash Shell实现C语言风格的变量操作<br>I=10<br>((I++))<br>for循环的特殊格式：<br>for ((控制变量初始化;条件判断表达式;控制变量的修正表达式))<br>do</li>\n<li>循环体<br>done<br>控制变量初始化：仅在运行到循环代码段时执行一次<br>控制变量的修正表达式：每轮循环结束会先进行控制变量修正运算，而后再做<br>条件判断</li>\n</ul>\n<h2 id=\"函数介绍\"><a href=\"#函数介绍\" class=\"headerlink\" title=\"函数介绍\"></a>函数介绍</h2><p>函数function是由若干条shell命令组成的语句块，实现代码重用和模块化编程<br>它与shell程序形式上是相似的，不同的是它不是一个单独的进程，不能独立运<br>行，而是shell程序的一部分<br>函数和shell程序比较相似，区别在于：<br>Shell程序在子Shell中运行<br>而Shell函数在当前Shell中运行。因此在当前Shell中，函数可以对shell中变<br>量进行修改<br>定义函数<br>函数由两部分组成：函数名和函数体<br>help function<br>语法一：<br>f_name （）{<br>…函数体…<br>}<br> 语法二：<br>function f_name {<br>…函数体…<br>}<br> 语法三：<br>function f_name （） {<br>…函数体…<br>}</p>\n<ul>\n<li>函数使用<br>函数的定义和使用：<br>可在交互式环境下定义函数<br>可将函数放在脚本文件中作为它的一部分<br>可放在只包含函数的单独文件中<br>调用：函数只有被调用才会执行<br>调用：给定函数名<br>函数名出现的地方，会被自动替换为函数代码<br>函数的生命周期：被调用时创建，返回时终止函数返回值<br>函数有两种返回值：<br>函数的执行结果返回值：<br>(1) 使用echo等命令进行输出<br>(2) 函数体中调用命令的输出结果<br>函数的退出状态码：<br>(1) 默认取决于函数中执行的最后一条命令的退出状态码<br>(2) 自定义退出状态码，其格式为：<br>return 从函数中返回，用最后状态命令决定返回值<br>return 0 无错误返回。<br>return 1-255 有错误返回<br>交互式环境下定义和使用函数</li>\n</ul>\n<blockquote>\n<p>示例:<br>dir() {<br>ls -l<br>}<br>定义该函数后，若在$后面键入dir，其显示结果同ls -l的作用相同<br>dir<br>该dir函数将一直保留到用户从系统退出，或执行了如下所示的unset命令<br>unset dir<br>在脚本中定义及使用函数<br>函数在使用前必须定义，因此应将函数定义放在脚本开始部分，直至shell首次发现它<br>后才能使用<br>调用函数仅使用其函数名即可<br>示例：<br>cat func1<br>!/bin/bash<br>func1<br>hello()<br>{<br>echo “Hello there today’s date is <code>date +%F</code>“<br>}<br>echo “now going to the function hello”<br>hello<br>echo “back from the function”<br>使用函数文件<br>可以将经常使用的函数存入函数文件，然后将函数文件载入shell<br>文件名可任意选取，但最好与相关任务有某种联系。例如：functions.main<br>一旦函数文件载入shell，就可以在命令行或脚本中调用函数。可以使用set<br>命令查看所有定义的函数，其输出列表包括已经载入shell的所有函数<br>若要改动函数，首先用unset命令从shell中删除函数。改动完毕后，再重新<br>载入此文件</p>\n</blockquote>\n<ul>\n<li>创建函数文件</li>\n</ul>\n<p>函数文件示例：</p>\n<blockquote>\n<p>cat functions.main</p>\n<p>#!/bin/bash</p>\n<p>#functions.main<br>findit()<br>{<br>if [ $# -lt 1 ] ; then<br>echo “Usage:findit file”<br>return 1<br>fi<br>find / -name $1 –print<br>}</p>\n</blockquote>\n<ul>\n<li><p>载入函数<br>函数文件已创建好后，要将它载入shell<br>定位函数文件并载入shell的格式：<br>. filename 或 source filename<br>注意：此即&lt;点&gt; &lt;空格&gt; &lt;文件名&gt;<br>这里的文件名要带正确路径</p>\n</li>\n<li><p>检查载入函数<br>使用set命令检查函数是否已载入。set命令将在shell中显示所有的载入函数</p>\n</li>\n</ul>\n<blockquote>\n<p>示例：<br>set<br>findit=( )<br>{<br>if [ $# -lt 1 ]; then<br>echo “usage :findit file”;<br>return 1<br>fi<br>find / -name $1 -print<br>}</p>\n</blockquote>\n<ul>\n<li>执行shell函数<br>要执行函数，简单地键入函数名即可<br>示例：<br>findit groups<br>/usr/bin/groups<br>/usr/local/backups/groups.bak</li>\n<li>删除shell函数<br>现在对函数做一些改动后，需要先删除函数，使其对shell不可用。使用unset命<br>令完成删除函数<br>命令格式为：<br>unset function_name<br>示例：<br>unset findit<br>再键入set命令，函数将不再显示</li>\n<li>函数参数<br>函数可以接受参数：<br>传递参数给函数：调用函数时，在函数名后面以空白分隔给定参数列表即可；<br>例如“testfunc arg1 arg2 …”<br>在函数体中当中，可使用$1, $2, …调用这些参数；还可以使用$@, $*, $#<br>等特殊变量<br>函数变量<br>变量作用域：<br>环境变量：当前shell和子shell有效<br>本地变量：只在当前shell进程有效，为执行脚本会启动专用子shell进程；<br>因此，本地变量的作用范围是当前shell脚本程序文件，包括脚本中的函数<br>局部变量：函数的生命周期；函数结束时变量被自动销毁<br>注意：如果函数中有局部变量，如果其名称同本地变量，使用局部变量<br>在函数中定义局部变量的方法<br>local NAME=VALUE<br>函数递归示例</li>\n<li>函数递归：<br>函数直接或间接调用自身<br>注意递归层数<br>递归实例：<br>阶乘是基斯顿·卡曼于 1808 年发明的运算符号，是数学术语<br>一个正整数的阶乘（factorial）是所有小于及等于该数的正整数的积，并且有0的<br>阶乘为1，自然数n的阶乘写作n!<br>n!=1×2×3×…×n<br>阶乘亦可以递归方式定义：0!=1，n!=(n-1)!×n<br>n!=n(n-1)(n-2)…1<br>n(n-1)! = n(n-1)(n-2)!<br>函数递归示例:</li>\n</ul>\n<blockquote>\n<pre><code>示例：fact.sh\n\nfact() {\nif [ $1 -eq 0 -o $1 -eq 1 ]; then\necho 1\nelse\necho $[$1*$(fact $[$1-1])]\nfi\n}\nfact $1\n</code></pre></blockquote>\n<ul>\n<li>fork炸弹</li>\n</ul>\n<p>fork炸弹是一种恶意程序，它的内部是一个不断在fork进程的无限循环，实质是<br>一个简单的递归程序。由于程序是递归的，如果没有任何限制，这会导致这个<br>简单的程序迅速耗尽系统里面的所有资源<br>函数实现<br>:(){ :|:&amp; };:<br>bomb() { bomb | bomb &amp; }; bomb  实际上: 代表bomb<br>脚本实现</p>\n<blockquote>\n<p>cat Bomb.sh<br>./$0|./$0&amp;</p>\n</blockquote>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"cjx90h7zz0000jkufynn8cds4","category_id":"cjx90h80j0004jkufkb1v3uk6","_id":"cjx90h816000gjkufm6mnstyp"},{"post_id":"cjx90h810000ejkufi8jmd5zm","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h81f000njkuf4sq367fp"},{"post_id":"cjx90h80c0002jkuf1mri4n2u","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h81k000sjkufd1yilvvb"},{"post_id":"cjx90h814000fjkufyk76ff55","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h81n000vjkuf2fhbtppc"},{"post_id":"cjx90h81b000kjkufz89rpr2n","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h81t0010jkuf6b7ealx0"},{"post_id":"cjx90h80n0006jkufi78kr5o5","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h81w0013jkuf5ibxpref"},{"post_id":"cjx90h81j000rjkufs8pzy4gk","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h8200018jkufkyne9ztd"},{"post_id":"cjx90h80r0008jkufnlwkdpm2","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h824001bjkufipfxlcdg"},{"post_id":"cjx90h81r000zjkufboyrzrwa","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h828001gjkufif3cmycb"},{"post_id":"cjx90h80u000ajkufa6f1n6sb","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h82b001jjkuf8zc694mt"},{"post_id":"cjx90h81u0012jkuf3j0nkc96","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h82c001ljkufn06dzhju"},{"post_id":"cjx90h81y0017jkuftiirld7j","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h82e001pjkufe1r2zaki"},{"post_id":"cjx90h81e000mjkufobsn21uw","category_id":"cjx90h81x0014jkufxxk58i25","_id":"cjx90h82f001rjkufrlzkhvpa"},{"post_id":"cjx90h823001ajkufr6umdjq0","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h82g001tjkufbxydg0pb"},{"post_id":"cjx90h827001fjkuffqcsl67u","category_id":"cjx90h81x0014jkufxxk58i25","_id":"cjx90h82h001vjkufcmfrlk7v"},{"post_id":"cjx90h81l000ujkuf03tm139l","category_id":"cjx90h825001cjkufwbcrwmci","_id":"cjx90h82i001xjkufxz5p18ip"},{"post_id":"cjx90h829001ijkufyrze76hl","category_id":"cjx90h82d001mjkuf0r23wx6g","_id":"cjx90h82i001yjkufwq98ckxq"},{"post_id":"cjx90h8bq001zjkufe3d4v0yl","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h8c60026jkuf5or1ugp3"},{"post_id":"cjx90h8bz0022jkufiqcf4myk","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h8ce002bjkufu3eb224e"},{"post_id":"cjx90h8c40025jkufktmc3o5m","category_id":"cjx90h80y000bjkufujbdfmts","_id":"cjx90h8cj002ejkuf9bp7dd8n"},{"post_id":"cjx90h8bv0020jkuf810rl45s","category_id":"cjx90h8c20023jkuf8p4ld7l3","_id":"cjx90h8cm002hjkufehxn1knd"},{"post_id":"cjx90h8cc002ajkuff1myxzly","category_id":"cjx90h8ck002fjkuffhrh97ty","_id":"cjx90h8cp002ljkufqii88ovc"},{"post_id":"cjx90h8cg002djkuf66oyk2by","category_id":"cjx90h8cn002ijkufl7dkmb5r","_id":"cjx90h8cr002njkufxl68rve4"},{"post_id":"cjx90h8fb002ojkufnuwyus90","category_id":"cjx90h8cn002ijkufl7dkmb5r","_id":"cjx90h8fi002sjkuf4tu51vt5"},{"post_id":"cjx90h8fd002pjkufdoon0xsa","category_id":"cjx90h8cn002ijkufl7dkmb5r","_id":"cjx90h8fj002tjkufat3mp2th"},{"post_id":"cjx90h8nd002ujkufimpwwvpr","category_id":"cjx90h8cn002ijkufl7dkmb5r","_id":"cjx90h8ng002wjkufdgfnypyr"}],"PostTag":[{"post_id":"cjx90h7zz0000jkufynn8cds4","tag_id":"cjx90h80m0005jkufvawt73qt","_id":"cjx90h810000djkufv19kn1js"},{"post_id":"cjx90h810000ejkufi8jmd5zm","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81b000jjkuftkekid76"},{"post_id":"cjx90h80c0002jkuf1mri4n2u","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81d000ljkuf7nk8m16r"},{"post_id":"cjx90h814000fjkufyk76ff55","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81i000qjkuf40xpymns"},{"post_id":"cjx90h81b000kjkufz89rpr2n","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81l000tjkufst536hvg"},{"post_id":"cjx90h80n0006jkufi78kr5o5","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81q000yjkufshvup5ug"},{"post_id":"cjx90h81j000rjkufs8pzy4gk","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81u0011jkufvyl9hkmh"},{"post_id":"cjx90h80r0008jkufnlwkdpm2","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h81y0016jkuf1eyh67t3"},{"post_id":"cjx90h81r000zjkufboyrzrwa","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h8220019jkuf0o18ioz7"},{"post_id":"cjx90h80u000ajkufa6f1n6sb","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h826001ejkufdwxt5rij"},{"post_id":"cjx90h81u0012jkuf3j0nkc96","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h829001hjkufzbqojmgl"},{"post_id":"cjx90h81y0017jkuftiirld7j","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h82c001kjkuf2eduia5s"},{"post_id":"cjx90h81e000mjkufobsn21uw","tag_id":"cjx90h81x0015jkufr8d9dwk0","_id":"cjx90h82e001ojkuf9ylfniti"},{"post_id":"cjx90h823001ajkufr6umdjq0","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h82f001qjkufauleheby"},{"post_id":"cjx90h827001fjkuffqcsl67u","tag_id":"cjx90h81x0015jkufr8d9dwk0","_id":"cjx90h82g001sjkuf0chtcnrh"},{"post_id":"cjx90h81l000ujkuf03tm139l","tag_id":"cjx90h825001djkufbukwt8i2","_id":"cjx90h82h001ujkufrikiwj9d"},{"post_id":"cjx90h829001ijkufyrze76hl","tag_id":"cjx90h82e001njkuftb3r6ikw","_id":"cjx90h82i001wjkuf5rezobhp"},{"post_id":"cjx90h8bq001zjkufe3d4v0yl","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h8by0021jkufowg5hhyn"},{"post_id":"cjx90h8bz0022jkufiqcf4myk","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h8c70027jkufnh4wh21a"},{"post_id":"cjx90h8c40025jkufktmc3o5m","tag_id":"cjx90h80z000cjkufazl5nkk0","_id":"cjx90h8cb0029jkuff2x6wcyb"},{"post_id":"cjx90h8bv0020jkuf810rl45s","tag_id":"cjx90h8c30024jkufyfy4k2yn","_id":"cjx90h8cg002cjkufvziie33a"},{"post_id":"cjx90h8cc002ajkuff1myxzly","tag_id":"cjx90h8cl002gjkuf87neyogh","_id":"cjx90h8co002kjkufuoem6nqy"},{"post_id":"cjx90h8cg002djkuf66oyk2by","tag_id":"cjx90h8cn002jjkuf5tldfmid","_id":"cjx90h8cq002mjkufggexyi6m"},{"post_id":"cjx90h8fb002ojkufnuwyus90","tag_id":"cjx90h8cn002jjkuf5tldfmid","_id":"cjx90h8fg002qjkuflwykywu1"},{"post_id":"cjx90h8fd002pjkufdoon0xsa","tag_id":"cjx90h8cn002jjkuf5tldfmid","_id":"cjx90h8fh002rjkufxeoqakyx"},{"post_id":"cjx90h8nd002ujkufimpwwvpr","tag_id":"cjx90h8cn002jjkuf5tldfmid","_id":"cjx90h8nf002vjkufxgsfhj9f"}],"Tag":[{"name":"c语言","_id":"cjx90h80m0005jkufvawt73qt"},{"name":"python","_id":"cjx90h80z000cjkufazl5nkk0"},{"name":"算法习题","_id":"cjx90h81x0015jkufr8d9dwk0"},{"name":"系统","_id":"cjx90h825001djkufbukwt8i2"},{"name":"算法","_id":"cjx90h82e001njkuftb3r6ikw"},{"name":"数据结构","_id":"cjx90h8c30024jkufyfy4k2yn"},{"name":"网络原理","_id":"cjx90h8cl002gjkuf87neyogh"},{"name":"linux基础","_id":"cjx90h8cn002jjkuf5tldfmid"}]}}